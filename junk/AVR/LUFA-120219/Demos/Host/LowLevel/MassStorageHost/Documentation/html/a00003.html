<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA Library - Mass Storage Host Demo: Lib/MassStoreCommands.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA Library - Mass Storage Host Demo&#160;<span id="projectnumber">0.0.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00003.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>MassStoreCommands.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="a00004.html">MassStoreCommands.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#acd524e155d5014a0b2a4f6dcba34ddb5">MassStore_SendCommand</a> (MS_CommandBlockWrapper_t *const SCSICommandBlock, void *BufferPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a0c13e34b17c949e38edd360284deeac0">MassStore_WaitForDataReceived</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a239e3651797865b4f3e2cce8eeb35de7">MassStore_SendReceiveData</a> (MS_CommandBlockWrapper_t *const SCSICommandBlock, void *BufferPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a7f811765cf7a70ba5dbe447724ddca58">MassStore_GetReturnedStatus</a> (MS_CommandStatusWrapper_t *const SCSICommandStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ac6b179eea18f5d947233a95bb5d85483">MassStore_MassStorageReset</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ad80d5405f03c08f662de9db05163f82b">MassStore_GetMaxLUN</a> (uint8_t *const MaxLUNIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a4392f4ea50411d0918711ae6dc935c16">MassStore_Inquiry</a> (const uint8_t LUNIndex, SCSI_Inquiry_Response_t *const InquiryPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a5640cbec94f4320ae1bd4b2dfa62b475">MassStore_RequestSense</a> (const uint8_t LUNIndex, SCSI_Request_Sense_Response_t *const SensePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a5d22ef9933e52861549688342804ddaf">MassStore_ReadDeviceBlock</a> (const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, void *BufferPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a5726b87e98539242273e112acec239d6">MassStore_WriteDeviceBlock</a> (const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, void *BufferPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ad8e1a76103edb7da05f5c28d805ad985">MassStore_TestUnitReady</a> (const uint8_t LUNIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a7d950ea34c6a5d68f6d35dc9b1bb5b9a">MassStore_ReadCapacity</a> (const uint8_t LUNIndex, SCSI_Capacity_t *const CapacityPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a2886bf820904f36ca464ba357219e649">MassStore_PreventAllowMediumRemoval</a> (const uint8_t LUNIndex, const bool PreventRemoval)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a976546b67de109f645714ba6085fc1bf">MassStore_Tag</a> = 1</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Mass Storage Device commands, to issue MSD commands to the device for reading device status, capacity, and other characteristics. This file also contains block read and write functions, so that device blocks can be read and written. In general, these functions would be chained to a FAT library to give file-level access to an attached device's contents.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Many Mass Storage devices on the market are non-compliant to the specifications and thus can prove difficult to interface with. It may be necessary to retry the functions in the module several times after they have returned and error to successfully send the command to the device. Some devices may also need to have the stream function timeout period extended beyond 100ms (some badly designed devices exceeding 1.5 seconds occasionally) by defining USB_STREAM_TIMEOUT_MS to a larger value in the project makefile and passing it to the compiler via the -D switch. </dd></dl>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad80d5405f03c08f662de9db05163f82b"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_GetMaxLUN" ref="ad80d5405f03c08f662de9db05163f82b" args="(uint8_t *const MaxLUNIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_GetMaxLUN </td>
          <td>(</td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>MaxLUNIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Some devices do not support this request, and will STALL it when issued. To get around this, on unsupported devices the max LUN index will be reported as zero and no error will be returned if the device STALLs the request.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">MaxLUNIndex</td><td>Pointer to the location that the maximum LUN index value should be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the USB_Host_SendControlErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a7f811765cf7a70ba5dbe447724ddca58"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_GetReturnedStatus" ref="a7f811765cf7a70ba5dbe447724ddca58" args="(MS_CommandStatusWrapper_t *const SCSICommandStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t MassStore_GetReturnedStatus </td>
          <td>(</td>
          <td class="paramtype">MS_CommandStatusWrapper_t *const&#160;</td>
          <td class="paramname"><em>SCSICommandStatus</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Routine to receive the current CSW from the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">SCSICommandStatus</td><td>Pointer to a destination where the returned status data should be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a4392f4ea50411d0918711ae6dc935c16"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_Inquiry" ref="a4392f4ea50411d0918711ae6dc935c16" args="(const uint8_t LUNIndex, SCSI_Inquiry_Response_t *const InquiryPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_Inquiry </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCSI_Inquiry_Response_t *const&#160;</td>
          <td class="paramname"><em>InquiryPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Inquiry command to the attached device, to determine the device's information. This gives information on the device's capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">InquiryPtr</td><td>Pointer to the inquiry data structure where the inquiry data from the device is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b179eea18f5d947233a95bb5d85483"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_MassStorageReset" ref="ac6b179eea18f5d947233a95bb5d85483" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_MassStorageReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a Mass Storage class specific request to reset the attached device's Mass Storage interface, readying the device for the next CBW. The Data endpoints are cleared of any STALL condition once this command completes sucessfuly.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the USB_Host_SendControlErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a2886bf820904f36ca464ba357219e649"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_PreventAllowMediumRemoval" ref="a2886bf820904f36ca464ba357219e649" args="(const uint8_t LUNIndex, const bool PreventRemoval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_PreventAllowMediumRemoval </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>PreventRemoval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Device Prevent/Allow Medium Removal command to the attached device, to lock the physical media from being removed. This is a legacy command for SCSI disks with removable storage (such as ZIP disks), but should still be issued before the first read or write command is sent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PreventRemoval</td><td>Whether or not the LUN media should be locked to prevent removal or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a7d950ea34c6a5d68f6d35dc9b1bb5b9a"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_ReadCapacity" ref="a7d950ea34c6a5d68f6d35dc9b1bb5b9a" args="(const uint8_t LUNIndex, SCSI_Capacity_t *const CapacityPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_ReadCapacity </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCSI_Capacity_t *const&#160;</td>
          <td class="paramname"><em>CapacityPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Device Read Capacity command to the attached device, to determine the capacity of the given Logical Unit within the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CapacityPtr</td><td>Device capacity structure where the capacity data is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a5d22ef9933e52861549688342804ddaf"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_ReadDeviceBlock" ref="a5d22ef9933e52861549688342804ddaf" args="(const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, void *BufferPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_ReadDeviceBlock </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>BlockAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>BlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockAddress</td><td>Start block address to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blocks</td><td>Number of blocks to read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockSize</td><td>Size in bytes of each block to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BufferPtr</td><td>Pointer to the buffer where the read data is to be written to</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a5640cbec94f4320ae1bd4b2dfa62b475"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_RequestSense" ref="a5640cbec94f4320ae1bd4b2dfa62b475" args="(const uint8_t LUNIndex, SCSI_Request_Sense_Response_t *const SensePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_RequestSense </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCSI_Request_Sense_Response_t *const&#160;</td>
          <td class="paramname"><em>SensePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Request Sense command to the attached device, to determine the current SCSI sense information. This gives error codes for the last issued SCSI command to the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SensePtr</td><td>Pointer to the sense data structure where the sense data from the device is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="acd524e155d5014a0b2a4f6dcba34ddb5"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_SendCommand" ref="acd524e155d5014a0b2a4f6dcba34ddb5" args="(MS_CommandBlockWrapper_t *const SCSICommandBlock, void *BufferPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t MassStore_SendCommand </td>
          <td>(</td>
          <td class="paramtype">MS_CommandBlockWrapper_t *const&#160;</td>
          <td class="paramname"><em>SCSICommandBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Routine to send the current CBW to the device, and increment the Tag value as needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SCSICommandBlock</td><td>Pointer to a SCSI command block structure to send to the attached device </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferPtr</td><td>Pointer to a buffer for the data to send or receive to/from the device, or NULL if no data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum </dd></dl>

</div>
</div>
<a class="anchor" id="a239e3651797865b4f3e2cce8eeb35de7"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_SendReceiveData" ref="a239e3651797865b4f3e2cce8eeb35de7" args="(MS_CommandBlockWrapper_t *const SCSICommandBlock, void *BufferPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t MassStore_SendReceiveData </td>
          <td>(</td>
          <td class="paramtype">MS_CommandBlockWrapper_t *const&#160;</td>
          <td class="paramname"><em>SCSICommandBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends or receives the transaction's data stage to or from the attached device, reading or writing to the nominated buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SCSICommandBlock</td><td>Pointer to a SCSI command block structure being sent to the attached device </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferPtr</td><td>Pointer to the data buffer to read from or write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e1a76103edb7da05f5c28d805ad985"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_TestUnitReady" ref="ad8e1a76103edb7da05f5c28d805ad985" args="(const uint8_t LUNIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_TestUnitReady </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Device Test Unit Ready command to the attached device, to determine if the device is ready to accept other commands.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<a class="anchor" id="a0c13e34b17c949e38edd360284deeac0"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_WaitForDataReceived" ref="a0c13e34b17c949e38edd360284deeac0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t MassStore_WaitForDataReceived </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Waits until the attached device is ready to accept data following a CBW, checking to ensure that the device has not stalled the transaction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum </dd></dl>

</div>
</div>
<a class="anchor" id="a5726b87e98539242273e112acec239d6"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_WriteDeviceBlock" ref="a5726b87e98539242273e112acec239d6" args="(const uint8_t LUNIndex, const uint32_t BlockAddress, const uint8_t Blocks, const uint16_t BlockSize, void *BufferPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MassStore_WriteDeviceBlock </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>LUNIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>BlockAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>BlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issues a SCSI Device Block Write command to the attached device, to write one or more data blocks to the storage medium from a buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LUNIndex</td><td>Index of the LUN inside the device the command is being addressed to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockAddress</td><td>Start block address to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blocks</td><td>Number of blocks to write to in the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BlockSize</td><td>Size in bytes of each block to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferPtr</td><td>Pointer to the buffer where the write data is to be sourced from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if the SCSI command fails </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a976546b67de109f645714ba6085fc1bf"></a><!-- doxytag: member="MassStoreCommands.c::MassStore_Tag" ref="a976546b67de109f645714ba6085fc1bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00003.html#a976546b67de109f645714ba6085fc1bf">MassStore_Tag</a> = 1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current Tag value used in issued CBWs to the device. This is automatically incremented each time a command is sent, and is not externally accessible. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00003.html">MassStoreCommands.c</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
