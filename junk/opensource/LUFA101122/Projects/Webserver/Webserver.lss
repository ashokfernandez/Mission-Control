
Webserver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000019c  00800100  000073c6  0000745a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000073c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a43  0080029c  0080029c  000075f6  2**0
                  ALLOC
  3 .stab         000017d0  00000000  00000000  000075f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000071d  00000000  00000000  00008dc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000d48  00000000  00000000  000094e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00001f49  00000000  00000000  0000a22d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000193d3  00000000  00000000  0000c176  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000058e9  00000000  00000000  00025549  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000122f6  00000000  00000000  0002ae32  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001490  00000000  00000000  0003d128  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00006e69  00000000  00000000  0003e5b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000bd74  00000000  00000000  00045421  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000010e0  00000000  00000000  00051195  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *  \param[in] BufferPtr     Pointer to the data source RAM buffer
 */
void DataflashManager_WriteBlocks_RAM(const uint32_t BlockAddress,
                                      uint16_t TotalBlocks,
                                      const uint8_t* BufferPtr)
{
       0:	b0 c1       	rjmp	.+864    	; 0x362 <__ctors_end>

static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
       2:	00 00       	nop
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
       4:	cc c1       	rjmp	.+920    	; 0x39e <__bad_interrupt>
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address (LBA) */
	BYTE count			/* Number of sectors to write (1..255) */
)
{
       6:	00 00       	nop

	return Endpoint_IsConfigured();
}

void Endpoint_ClearEndpoints(void)
{
       8:	ca c1       	rjmp	.+916    	; 0x39e <__bad_interrupt>

	return USB_Host_SendControlRequest(Buffer);
}

uint8_t USB_Host_ClearPipeStall(const uint8_t EndpointNum)
{
       a:	00 00       	nop
{
	USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, AfterType);

	if (*BytesRem)
	  USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, Type);
}
       c:	c8 c1       	rjmp	.+912    	; 0x39e <__bad_interrupt>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
       e:	00 00       	nop
			Length--;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
      10:	c6 c1       	rjmp	.+908    	; 0x39e <__bad_interrupt>
	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	return USB_Host_SendControlRequest(Buffer);
}

uint8_t RNDIS_Host_SendKeepAlive(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
      12:	00 00       	nop
      14:	c4 c1       	rjmp	.+904    	; 0x39e <__bad_interrupt>
      16:	00 00       	nop
      18:	c2 c1       	rjmp	.+900    	; 0x39e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c0 c1       	rjmp	.+896    	; 0x39e <__bad_interrupt>
      1e:	00 00       	nop
      20:	be c1       	rjmp	.+892    	; 0x39e <__bad_interrupt>
      22:	00 00       	nop
      24:	bc c1       	rjmp	.+888    	; 0x39e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 d6 27 	jmp	0x4fac	; 0x4fac <__vector_10>
      2c:	0c 94 98 27 	jmp	0x4f30	; 0x4f30 <__vector_11>
      30:	b6 c1       	rjmp	.+876    	; 0x39e <__bad_interrupt>
      32:	00 00       	nop
      34:	b4 c1       	rjmp	.+872    	; 0x39e <__bad_interrupt>
      36:	00 00       	nop
      38:	b2 c1       	rjmp	.+868    	; 0x39e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b0 c1       	rjmp	.+864    	; 0x39e <__bad_interrupt>
      3e:	00 00       	nop
      40:	ae c1       	rjmp	.+860    	; 0x39e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 c0 19 	jmp	0x3380	; 0x3380 <__vector_17>
      48:	aa c1       	rjmp	.+852    	; 0x39e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	a8 c1       	rjmp	.+848    	; 0x39e <__bad_interrupt>
      4e:	00 00       	nop
      50:	a6 c1       	rjmp	.+844    	; 0x39e <__bad_interrupt>
      52:	00 00       	nop
      54:	a4 c1       	rjmp	.+840    	; 0x39e <__bad_interrupt>
      56:	00 00       	nop
      58:	a2 c1       	rjmp	.+836    	; 0x39e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a0 c1       	rjmp	.+832    	; 0x39e <__bad_interrupt>
      5e:	00 00       	nop
      60:	9e c1       	rjmp	.+828    	; 0x39e <__bad_interrupt>
      62:	00 00       	nop
      64:	9c c1       	rjmp	.+824    	; 0x39e <__bad_interrupt>
      66:	00 00       	nop
      68:	9a c1       	rjmp	.+820    	; 0x39e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	98 c1       	rjmp	.+816    	; 0x39e <__bad_interrupt>
      6e:	00 00       	nop
      70:	96 c1       	rjmp	.+812    	; 0x39e <__bad_interrupt>
      72:	00 00       	nop
      74:	94 c1       	rjmp	.+808    	; 0x39e <__bad_interrupt>
      76:	00 00       	nop
      78:	92 c1       	rjmp	.+804    	; 0x39e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	90 c1       	rjmp	.+800    	; 0x39e <__bad_interrupt>
      7e:	00 00       	nop
      80:	8e c1       	rjmp	.+796    	; 0x39e <__bad_interrupt>
      82:	00 00       	nop
      84:	8c c1       	rjmp	.+792    	; 0x39e <__bad_interrupt>
      86:	00 00       	nop
      88:	8a c1       	rjmp	.+788    	; 0x39e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	88 c1       	rjmp	.+784    	; 0x39e <__bad_interrupt>
      8e:	00 00       	nop
      90:	86 c1       	rjmp	.+780    	; 0x39e <__bad_interrupt>
      92:	00 00       	nop
      94:	84 c1       	rjmp	.+776    	; 0x39e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 00 00 00 08 eb 03 45 20 01 00 01 02     ..........E ....
      a8:	dc 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 20 00 01 01 00 80 32 09 04 00 00 02 08 06     .. .....2.......
      ba:	50 00 07 05 83 02 40 00 01 07 05 04 02 40 00 01     P.....@......@..

000000ca <LanguageString>:
      ca:	04 03 09 04                                         ....

000000ce <ManufacturerString>:
      ce:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      de:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000e8 <ProductString>:
      e8:	1e 03 4c 00 55 00 46 00 41 00 20 00 57 00 65 00     ..L.U.F.A. .W.e.
      f8:	62 00 73 00 65 00 72 00 76 00 65 00 72 00 00 00     b.s.e.r.v.e.r...

00000108 <HTTP200Header>:
     108:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     118:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 31 30     .Server: LUFA 10
     128:	31 31 32 32 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     1122..Connection
     138:	3a 20 63 6c 6f 73 65 0d 0a 4d 49 4d 45 2d 76 65     : close..MIME-ve
     148:	72 73 69 6f 6e 3a 20 31 2e 30 0d 0a 43 6f 6e 74     rsion: 1.0..Cont
     158:	65 6e 74 2d 54 79 70 65 3a 20 00                    ent-Type: .

00000163 <HTTP404Header>:
     163:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     173:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     183:	4c 55 46 41 20 31 30 31 31 32 32 0d 0a 43 6f 6e     LUFA 101122..Con
     193:	6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a     nection: close..
     1a3:	4d 49 4d 45 2d 76 65 72 73 69 6f 6e 3a 20 31 2e     MIME-version: 1.
     1b3:	30 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     0..Content-Type:
     1c3:	20 74 65 78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 45      text/plain....E
     1d3:	72 72 6f 72 20 34 30 34 3a 20 46 69 6c 65 20 4e     rror 404: File N
     1e3:	6f 74 20 46 6f 75 6e 64 3a 20 2f 00                 ot Found: /.

000001ef <DefaultDirFileName>:
     1ef:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

000001f9 <DefaultMIMEType>:
     1f9:	74 65 78 74 2f 70 6c 61 69 6e 00                    text/plain.

00000204 <__c.1813>:
     204:	47 45 54 00                                         GET.

00000208 <__c.1848>:
     208:	0d 0a 0d 0a 00                                      .....

0000020d <WelcomeHeader>:
     20d:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     21d:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     22d:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 2a 20     ************..* 
     23d:	20 20 20 20 20 20 4c 55 46 41 20 75 49 50 20 57           LUFA uIP W
     24d:	65 62 73 65 72 76 65 72 20 28 54 45 4c 4e 45 54     ebserver (TELNET
     25d:	29 20 20 20 20 20 20 20 20 2a 0d 0a 2a 2a 2a 2a     )        *..****
     26d:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     27d:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     28d:	2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 00                    ********...

00000298 <TELNETMenu>:
     298:	0d 0a 20 20 3d 3d 20 41 76 61 69 6c 61 62 6c 65     ..  == Available
     2a8:	20 43 6f 6d 6d 61 6e 64 73 3a 20 3d 3d 0d 0a 20      Commands: ==.. 
     2b8:	20 20 20 20 63 29 20 4c 69 73 74 20 41 63 74 69         c) List Acti
     2c8:	76 65 20 54 43 50 20 43 6f 6e 6e 65 63 74 69 6f     ve TCP Connectio
     2d8:	6e 73 0d 0a 20 20 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ns..  ==========
     2e8:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d     ===============.
     2f8:	0a 0d 0a 3e 00                                      ...>.

000002fd <CurrentConnectionsHeader>:
     2fd:	0d 0a 2a 20 43 75 72 72 65 6e 74 20 54 43 50 20     ..* Current TCP 
     30d:	43 6f 6e 6e 65 63 74 69 6f 6e 73 3a 20 2a 0d 0a     Connections: *..
     31d:	00                                                  .

0000031e <__c.1930>:
     31e:	49 6e 76 61 6c 69 64 20 43 6f 6d 6d 61 6e 64 2e     Invalid Command.
     32e:	0d 0a 00                                            ...

00000331 <__c.1965>:
     331:	25 75 29 20 25 30 32 64 2e 25 30 32 64 2e 25 30     %u) %02d.%02d.%0
     341:	32 64 2e 25 30 32 64 20 28 4c 6f 63 61 6c 20 25     2d.%02d (Local %
     351:	75 2c 20 52 65 6d 6f 74 65 20 25 75 29 0d 0a 00     u, Remote %u)...
     361:	00                                                  .

00000362 <__ctors_end>:
     362:	11 24       	eor	r1, r1
     364:	1f be       	out	0x3f, r1	; 63
     366:	cf ef       	ldi	r28, 0xFF	; 255
     368:	d0 e2       	ldi	r29, 0x20	; 32
     36a:	de bf       	out	0x3e, r29	; 62
     36c:	cd bf       	out	0x3d, r28	; 61

0000036e <__do_copy_data>:
     36e:	12 e0       	ldi	r17, 0x02	; 2
     370:	a0 e0       	ldi	r26, 0x00	; 0
     372:	b1 e0       	ldi	r27, 0x01	; 1
     374:	e6 ec       	ldi	r30, 0xC6	; 198
     376:	f3 e7       	ldi	r31, 0x73	; 115
     378:	00 e0       	ldi	r16, 0x00	; 0
     37a:	0b bf       	out	0x3b, r16	; 59
     37c:	02 c0       	rjmp	.+4      	; 0x382 <__do_copy_data+0x14>
     37e:	07 90       	elpm	r0, Z+
     380:	0d 92       	st	X+, r0
     382:	ac 39       	cpi	r26, 0x9C	; 156
     384:	b1 07       	cpc	r27, r17
     386:	d9 f7       	brne	.-10     	; 0x37e <__do_copy_data+0x10>

00000388 <__do_clear_bss>:
     388:	1c e0       	ldi	r17, 0x0C	; 12
     38a:	ac e9       	ldi	r26, 0x9C	; 156
     38c:	b2 e0       	ldi	r27, 0x02	; 2
     38e:	01 c0       	rjmp	.+2      	; 0x392 <.do_clear_bss_start>

00000390 <.do_clear_bss_loop>:
     390:	1d 92       	st	X+, r1

00000392 <.do_clear_bss_start>:
     392:	af 3d       	cpi	r26, 0xDF	; 223
     394:	b1 07       	cpc	r27, r17
     396:	e1 f7       	brne	.-8      	; 0x390 <.do_clear_bss_loop>
     398:	35 d0       	rcall	.+106    	; 0x404 <main>
     39a:	0c 94 e1 39 	jmp	0x73c2	; 0x73c2 <_exit>

0000039e <__bad_interrupt>:
     39e:	30 ce       	rjmp	.-928    	; 0x0 <__vectors>

000003a0 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     3a0:	84 b7       	in	r24, 0x34	; 52
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     3a6:	88 e1       	ldi	r24, 0x18	; 24
     3a8:	0f b6       	in	r0, 0x3f	; 63
     3aa:	f8 94       	cli
     3ac:	80 93 60 00 	sts	0x0060, r24
     3b0:	10 92 60 00 	sts	0x0060, r1
     3b4:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	20 e8       	ldi	r18, 0x80	; 128
     3bc:	0f b6       	in	r0, 0x3f	; 63
     3be:	f8 94       	cli
     3c0:	20 93 61 00 	sts	0x0061, r18
     3c4:	80 93 61 00 	sts	0x0061, r24
     3c8:	0f be       	out	0x3f, r0	; 63
			 *  \param[in] SPIOptions  SPI Options, a mask consisting of one of each of the SPI_SPEED_*,
			 *                         SPI_SCK_*, SPI_SAMPLE_*, SPI_ORDER_* and SPI_MODE_* masks.
			 */
			static inline void SPI_Init(const uint8_t SPIOptions)
			{
				DDRB  |=  ((1 << 1) | (1 << 2));
     3ca:	84 b1       	in	r24, 0x04	; 4
     3cc:	86 60       	ori	r24, 0x06	; 6
     3ce:	84 b9       	out	0x04, r24	; 4
				DDRB  &= ~((1 << 0) | (1 << 3));
     3d0:	84 b1       	in	r24, 0x04	; 4
     3d2:	86 7f       	andi	r24, 0xF6	; 246
     3d4:	84 b9       	out	0x04, r24	; 4
				PORTB |=  ((1 << 0) | (1 << 3));
     3d6:	85 b1       	in	r24, 0x05	; 5
     3d8:	89 60       	ori	r24, 0x09	; 9
     3da:	85 b9       	out	0x05, r24	; 5

				SPCR   = ((1 << SPE) | SPIOptions);
     3dc:	8c e5       	ldi	r24, 0x5C	; 92
     3de:	8c bd       	out	0x2c, r24	; 44

				if (SPIOptions & SPI_USE_DOUBLESPEED)
				  SPSR |= (1 << SPI2X);
     3e0:	8d b5       	in	r24, 0x2d	; 45
     3e2:	81 60       	ori	r24, 0x01	; 1
     3e4:	8d bd       	out	0x2d, r24	; 45
			/** Initialises the dataflash driver so that commands and data may be sent to an attached dataflash IC.
			 *  The AVR's SPI driver MUST be initialized before any of the dataflash commands are used.
			 */
			static inline void Dataflash_Init(void)
			{
				DATAFLASH_CHIPCS_DDR  |= DATAFLASH_CHIPCS_MASK;
     3e6:	8d b1       	in	r24, 0x0d	; 13
     3e8:	83 60       	ori	r24, 0x03	; 3
     3ea:	8d b9       	out	0x0d, r24	; 13
				DATAFLASH_CHIPCS_PORT |= DATAFLASH_CHIPCS_MASK;
     3ec:	8e b1       	in	r24, 0x0e	; 14
     3ee:	83 60       	ori	r24, 0x03	; 3
     3f0:	8e b9       	out	0x0e, r24	; 14

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     3f2:	8a b1       	in	r24, 0x0a	; 10
     3f4:	80 6f       	ori	r24, 0xF0	; 240
     3f6:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     3f8:	8b b1       	in	r24, 0x0b	; 11
     3fa:	8f 70       	andi	r24, 0x0F	; 15
     3fc:	8b b9       	out	0x0b, r24	; 11

	/* Hardware Initialization */
	SPI_Init(SPI_SPEED_FCPU_DIV_2 | SPI_SCK_LEAD_FALLING | SPI_SAMPLE_TRAILING | SPI_MODE_MASTER);
	Dataflash_Init();
	LEDs_Init();
	USB_Init(USB_MODE_UID);
     3fe:	83 e0       	ldi	r24, 0x03	; 3
     400:	0c 94 61 27 	jmp	0x4ec2	; 0x4ec2 <USB_Init>

00000404 <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     404:	cd df       	rcall	.-102    	; 0x3a0 <SetupHardware>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     406:	8b b1       	in	r24, 0x0b	; 11
     408:	8f 70       	andi	r24, 0x0F	; 15
     40a:	80 61       	ori	r24, 0x10	; 16
     40c:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     40e:	78 94       	sei

	for (;;)
	{
		if (USB_CurrentMode == USB_MODE_Host)
     410:	80 91 17 03 	lds	r24, 0x0317
     414:	82 30       	cpi	r24, 0x02	; 2
     416:	11 f4       	brne	.+4      	; 0x41c <main+0x18>
		  USBHostMode_USBTask();
     418:	7d d0       	rcall	.+250    	; 0x514 <USBHostMode_USBTask>
     41a:	01 c0       	rjmp	.+2      	; 0x41e <main+0x1a>
		else
		  USBDeviceMode_USBTask();
     41c:	57 d0       	rcall	.+174    	; 0x4cc <USBDeviceMode_USBTask>

		USB_USBTask();
     41e:	0e 94 8f 30 	call	0x611e	; 0x611e <USB_USBTask>
     422:	f6 cf       	rjmp	.-20     	; 0x410 <main+0xc>

00000424 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     424:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     426:	92 30       	cpi	r25, 0x02	; 2
     428:	49 f0       	breq	.+18     	; 0x43c <CALLBACK_USB_GetDescriptor+0x18>
     42a:	93 30       	cpi	r25, 0x03	; 3
     42c:	61 f0       	breq	.+24     	; 0x446 <CALLBACK_USB_GetDescriptor+0x22>
     42e:	91 30       	cpi	r25, 0x01	; 1
     430:	f9 f4       	brne	.+62     	; 0x470 <CALLBACK_USB_GetDescriptor+0x4c>
     432:	e8 e9       	ldi	r30, 0x98	; 152
     434:	f0 e0       	ldi	r31, 0x00	; 0
     436:	22 e1       	ldi	r18, 0x12	; 18
     438:	30 e0       	ldi	r19, 0x00	; 0
     43a:	1e c0       	rjmp	.+60     	; 0x478 <CALLBACK_USB_GetDescriptor+0x54>
     43c:	ea ea       	ldi	r30, 0xAA	; 170
     43e:	f0 e0       	ldi	r31, 0x00	; 0
     440:	20 e2       	ldi	r18, 0x20	; 32
     442:	30 e0       	ldi	r19, 0x00	; 0
     444:	19 c0       	rjmp	.+50     	; 0x478 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     446:	81 30       	cpi	r24, 0x01	; 1
     448:	49 f0       	breq	.+18     	; 0x45c <CALLBACK_USB_GetDescriptor+0x38>
     44a:	81 30       	cpi	r24, 0x01	; 1
     44c:	18 f0       	brcs	.+6      	; 0x454 <CALLBACK_USB_GetDescriptor+0x30>
     44e:	82 30       	cpi	r24, 0x02	; 2
     450:	79 f4       	brne	.+30     	; 0x470 <CALLBACK_USB_GetDescriptor+0x4c>
     452:	08 c0       	rjmp	.+16     	; 0x464 <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     454:	ea ec       	ldi	r30, 0xCA	; 202
     456:	f0 e0       	ldi	r31, 0x00	; 0
     458:	84 91       	lpm	r24, Z+
     45a:	07 c0       	rjmp	.+14     	; 0x46a <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     45c:	ee ec       	ldi	r30, 0xCE	; 206
     45e:	f0 e0       	ldi	r31, 0x00	; 0
     460:	84 91       	lpm	r24, Z+
     462:	03 c0       	rjmp	.+6      	; 0x46a <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     464:	e8 ee       	ldi	r30, 0xE8	; 232
     466:	f0 e0       	ldi	r31, 0x00	; 0
     468:	84 91       	lpm	r24, Z+
     46a:	28 2f       	mov	r18, r24
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	04 c0       	rjmp	.+8      	; 0x478 <CALLBACK_USB_GetDescriptor+0x54>
     470:	e0 e0       	ldi	r30, 0x00	; 0
     472:	f0 e0       	ldi	r31, 0x00	; 0
     474:	20 e0       	ldi	r18, 0x00	; 0
     476:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     478:	ed 93       	st	X+, r30
     47a:	fc 93       	st	X, r31
	return Size;
}
     47c:	c9 01       	movw	r24, r18
     47e:	08 95       	ret

00000480 <EVENT_USB_Device_Connect>:
     480:	8b b1       	in	r24, 0x0b	; 11
     482:	8f 70       	andi	r24, 0x0F	; 15
     484:	80 63       	ori	r24, 0x30	; 48
     486:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     488:	08 95       	ret

0000048a <EVENT_USB_Device_Disconnect>:
     48a:	8b b1       	in	r24, 0x0b	; 11
     48c:	8f 70       	andi	r24, 0x0F	; 15
     48e:	80 61       	ori	r24, 0x10	; 16
     490:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     492:	08 95       	ret

00000494 <CALLBACK_MS_Device_SCSICommandReceived>:
     494:	2b b1       	in	r18, 0x0b	; 11
     496:	2f 70       	andi	r18, 0x0F	; 15
     498:	20 6d       	ori	r18, 0xD0	; 208
     49a:	2b b9       	out	0x0b, r18	; 11
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
     49c:	cc d1       	rcall	.+920    	; 0x836 <SCSI_DecodeSCSICommand>
     49e:	9b b1       	in	r25, 0x0b	; 11
     4a0:	9f 70       	andi	r25, 0x0F	; 15
     4a2:	90 62       	ori	r25, 0x20	; 32
     4a4:	9b b9       	out	0x0b, r25	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_READY);

	return CommandSuccess;
}
     4a6:	08 95       	ret

000004a8 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
     4a8:	80 e0       	ldi	r24, 0x00	; 0
     4aa:	91 e0       	ldi	r25, 0x01	; 1
     4ac:	0c 94 e6 31 	jmp	0x63cc	; 0x63cc <MS_Device_ProcessControlRequest>

000004b0 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     4b0:	80 e0       	ldi	r24, 0x00	; 0
     4b2:	91 e0       	ldi	r25, 0x01	; 1
     4b4:	0e 94 aa 31 	call	0x6354	; 0x6354 <MS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     4b8:	80 fd       	sbrc	r24, 0
     4ba:	02 c0       	rjmp	.+4      	; 0x4c0 <EVENT_USB_Device_ConfigurationChanged+0x10>
     4bc:	90 e9       	ldi	r25, 0x90	; 144
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <EVENT_USB_Device_ConfigurationChanged+0x12>
     4c0:	90 e2       	ldi	r25, 0x20	; 32
     4c2:	8b b1       	in	r24, 0x0b	; 11
     4c4:	8f 70       	andi	r24, 0x0F	; 15
     4c6:	98 2b       	or	r25, r24
     4c8:	9b b9       	out	0x0b, r25	; 11
}
     4ca:	08 95       	ret

000004cc <USBDeviceMode_USBTask>:
/** USB device mode management task. This function manages the Mass Storage Device class driver when the device is
 *  initialized in USB device mode.
 */
void USBDeviceMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Device)
     4cc:	80 91 17 03 	lds	r24, 0x0317
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	21 f4       	brne	.+8      	; 0x4dc <USBDeviceMode_USBTask+0x10>
	  return;

	MS_Device_USBTask(&Disk_MS_Interface);
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	91 e0       	ldi	r25, 0x01	; 1
     4d8:	0c 94 ba 30 	jmp	0x6174	; 0x6174 <MS_Device_USBTask>
     4dc:	08 95       	ret

000004de <EVENT_USB_Host_DeviceAttached>:
     4de:	8b b1       	in	r24, 0x0b	; 11
     4e0:	8f 70       	andi	r24, 0x0F	; 15
     4e2:	80 63       	ori	r24, 0x30	; 48
     4e4:	8b b9       	out	0x0b, r24	; 11
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Host_DeviceAttached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     4e6:	08 95       	ret

000004e8 <EVENT_USB_Host_DeviceUnattached>:
     4e8:	8b b1       	in	r24, 0x0b	; 11
     4ea:	8f 70       	andi	r24, 0x0F	; 15
     4ec:	80 61       	ori	r24, 0x10	; 16
     4ee:	8b b9       	out	0x0b, r24	; 11
 *  stops the library USB task management process.
 */
void EVENT_USB_Host_DeviceUnattached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     4f0:	08 95       	ret

000004f2 <EVENT_USB_Host_DeviceEnumerationComplete>:
     4f2:	8b b1       	in	r24, 0x0b	; 11
     4f4:	8f 70       	andi	r24, 0x0F	; 15
     4f6:	80 62       	ori	r24, 0x20	; 32
     4f8:	8b b9       	out	0x0b, r24	; 11
 *  enumerated by the host and is now ready to be used by the application.
 */
void EVENT_USB_Host_DeviceEnumerationComplete(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
}
     4fa:	08 95       	ret

000004fc <EVENT_USB_Host_DeviceEnumerationFailed>:
     4fc:	8b b1       	in	r24, 0x0b	; 11
     4fe:	8f 70       	andi	r24, 0x0F	; 15
     500:	80 69       	ori	r24, 0x90	; 144
     502:	8b b9       	out	0x0b, r24	; 11
 *  enumerating an attached USB device.
 */
void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode, const uint8_t SubErrorCode)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
}
     504:	08 95       	ret

00000506 <EVENT_USB_Host_HostError>:
}

/** Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */
void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
{
	USB_ShutDown();
     506:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <USB_ShutDown>
     50a:	8b b1       	in	r24, 0x0b	; 11
     50c:	8f 70       	andi	r24, 0x0F	; 15
     50e:	80 69       	ori	r24, 0x90	; 144
     510:	8b b9       	out	0x0b, r24	; 11
     512:	ff cf       	rjmp	.-2      	; 0x512 <EVENT_USB_Host_HostError+0xc>

00000514 <USBHostMode_USBTask>:

/** USB host mode management task. This function manages the RNDIS Host class driver and uIP stack when the device is
 *  initialized in USB host mode.
 */
void USBHostMode_USBTask(void)
{
     514:	0f 93       	push	r16
     516:	1f 93       	push	r17
     518:	df 93       	push	r29
     51a:	cf 93       	push	r28
     51c:	cd b7       	in	r28, 0x3d	; 61
     51e:	de b7       	in	r29, 0x3e	; 62
     520:	c6 50       	subi	r28, 0x06	; 6
     522:	d2 40       	sbci	r29, 0x02	; 2
     524:	0f b6       	in	r0, 0x3f	; 63
     526:	f8 94       	cli
     528:	de bf       	out	0x3e, r29	; 62
     52a:	0f be       	out	0x3f, r0	; 63
     52c:	cd bf       	out	0x3d, r28	; 61
	if (USB_CurrentMode != USB_MODE_Host)
     52e:	80 91 17 03 	lds	r24, 0x0317
     532:	82 30       	cpi	r24, 0x02	; 2
     534:	09 f0       	breq	.+2      	; 0x538 <USBHostMode_USBTask+0x24>
     536:	64 c0       	rjmp	.+200    	; 0x600 <USBHostMode_USBTask+0xec>
	  return;

	switch (USB_HostState)
     538:	80 91 de 0c 	lds	r24, 0x0CDE
     53c:	8b 30       	cpi	r24, 0x0B	; 11
     53e:	21 f0       	breq	.+8      	; 0x548 <USBHostMode_USBTask+0x34>
     540:	8c 30       	cpi	r24, 0x0C	; 12
     542:	09 f0       	breq	.+2      	; 0x546 <USBHostMode_USBTask+0x32>
     544:	5d c0       	rjmp	.+186    	; 0x600 <USBHostMode_USBTask+0xec>
     546:	5b c0       	rjmp	.+182    	; 0x5fe <USBHostMode_USBTask+0xea>
     548:	8b b1       	in	r24, 0x0b	; 11
     54a:	8f 70       	andi	r24, 0x0F	; 15
     54c:	80 63       	ori	r24, 0x30	; 48
     54e:	8b b9       	out	0x0b, r24	; 11
			LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);

			uint16_t ConfigDescriptorSize;
			uint8_t  ConfigDescriptorData[512];

			if (USB_Host_GetDeviceConfigDescriptor(1, &ConfigDescriptorSize, ConfigDescriptorData,
     550:	8e 01       	movw	r16, r28
     552:	09 5f       	subi	r16, 0xF9	; 249
     554:	1f 4f       	sbci	r17, 0xFF	; 255
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	be 01       	movw	r22, r28
     55a:	6f 5f       	subi	r22, 0xFF	; 255
     55c:	7f 4f       	sbci	r23, 0xFF	; 255
     55e:	a8 01       	movw	r20, r16
     560:	20 e0       	ldi	r18, 0x00	; 0
     562:	32 e0       	ldi	r19, 0x02	; 2
     564:	0e 94 7b 29 	call	0x52f6	; 0x52f6 <USB_Host_GetDeviceConfigDescriptor>
     568:	88 23       	and	r24, r24
     56a:	c9 f5       	brne	.+114    	; 0x5de <USBHostMode_USBTask+0xca>
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
				break;
			}

			if (RNDIS_Host_ConfigurePipes(&Ethernet_RNDIS_Interface,
     56c:	69 81       	ldd	r22, Y+1	; 0x01
     56e:	7a 81       	ldd	r23, Y+2	; 0x02
     570:	87 e3       	ldi	r24, 0x37	; 55
     572:	91 e0       	ldi	r25, 0x01	; 1
     574:	a8 01       	movw	r20, r16
     576:	0e 94 3d 35 	call	0x6a7a	; 0x6a7a <RNDIS_Host_ConfigurePipes>
     57a:	88 23       	and	r24, r24
     57c:	81 f5       	brne	.+96     	; 0x5de <USBHostMode_USBTask+0xca>
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
				break;
			}

			if (USB_Host_SetDeviceConfiguration(1) != HOST_SENDCONTROL_Successful)
     57e:	81 e0       	ldi	r24, 0x01	; 1
     580:	0e 94 c8 24 	call	0x4990	; 0x4990 <USB_Host_SetDeviceConfiguration>
     584:	88 23       	and	r24, r24
     586:	59 f5       	brne	.+86     	; 0x5de <USBHostMode_USBTask+0xca>
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
				break;
			}

			if (RNDIS_Host_InitializeDevice(&Ethernet_RNDIS_Interface) != HOST_SENDCONTROL_Successful)
     588:	87 e3       	ldi	r24, 0x37	; 55
     58a:	91 e0       	ldi	r25, 0x01	; 1
     58c:	0e 94 c5 34 	call	0x698a	; 0x698a <RNDIS_Host_InitializeDevice>
     590:	88 23       	and	r24, r24
     592:	29 f5       	brne	.+74     	; 0x5de <USBHostMode_USBTask+0xca>
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
				break;
			}

			uint32_t PacketFilter = (REMOTE_NDIS_PACKET_DIRECTED | REMOTE_NDIS_PACKET_BROADCAST);
     594:	89 e0       	ldi	r24, 0x09	; 9
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	a0 e0       	ldi	r26, 0x00	; 0
     59a:	b0 e0       	ldi	r27, 0x00	; 0
     59c:	8b 83       	std	Y+3, r24	; 0x03
     59e:	9c 83       	std	Y+4, r25	; 0x04
     5a0:	ad 83       	std	Y+5, r26	; 0x05
     5a2:	be 83       	std	Y+6, r27	; 0x06
			if (RNDIS_Host_SetRNDISProperty(&Ethernet_RNDIS_Interface, OID_GEN_CURRENT_PACKET_FILTER,
     5a4:	87 e3       	ldi	r24, 0x37	; 55
     5a6:	91 e0       	ldi	r25, 0x01	; 1
     5a8:	4e e0       	ldi	r20, 0x0E	; 14
     5aa:	51 e0       	ldi	r21, 0x01	; 1
     5ac:	61 e0       	ldi	r22, 0x01	; 1
     5ae:	70 e0       	ldi	r23, 0x00	; 0
     5b0:	9e 01       	movw	r18, r28
     5b2:	2d 5f       	subi	r18, 0xFD	; 253
     5b4:	3f 4f       	sbci	r19, 0xFF	; 255
     5b6:	04 e0       	ldi	r16, 0x04	; 4
     5b8:	10 e0       	ldi	r17, 0x00	; 0
     5ba:	0e 94 1f 34 	call	0x683e	; 0x683e <RNDIS_Host_SetRNDISProperty>
     5be:	88 23       	and	r24, r24
     5c0:	71 f4       	brne	.+28     	; 0x5de <USBHostMode_USBTask+0xca>
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
				break;
			}

			if (RNDIS_Host_QueryRNDISProperty(&Ethernet_RNDIS_Interface, OID_802_3_CURRENT_ADDRESS,
     5c2:	87 e3       	ldi	r24, 0x37	; 55
     5c4:	91 e0       	ldi	r25, 0x01	; 1
     5c6:	42 e0       	ldi	r20, 0x02	; 2
     5c8:	51 e0       	ldi	r21, 0x01	; 1
     5ca:	61 e0       	ldi	r22, 0x01	; 1
     5cc:	71 e0       	ldi	r23, 0x01	; 1
     5ce:	21 e2       	ldi	r18, 0x21	; 33
     5d0:	33 e0       	ldi	r19, 0x03	; 3
     5d2:	06 e0       	ldi	r16, 0x06	; 6
     5d4:	10 e0       	ldi	r17, 0x00	; 0
     5d6:	0e 94 7d 33 	call	0x66fa	; 0x66fa <RNDIS_Host_QueryRNDISProperty>
     5da:	88 23       	and	r24, r24
     5dc:	39 f0       	breq	.+14     	; 0x5ec <USBHostMode_USBTask+0xd8>
     5de:	8b b1       	in	r24, 0x0b	; 11
     5e0:	8f 70       	andi	r24, 0x0F	; 15
     5e2:	80 69       	ori	r24, 0x90	; 144
     5e4:	8b b9       	out	0x0b, r24	; 11
											  &MACAddress, sizeof(MACAddress)) != HOST_SENDCONTROL_Successful)
			{
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
     5e6:	10 92 de 0c 	sts	0x0CDE, r1
     5ea:	0a c0       	rjmp	.+20     	; 0x600 <USBHostMode_USBTask+0xec>
				break;
			}

			/* Initialize uIP stack */
			uIPManagement_Init();
     5ec:	f6 d5       	rcall	.+3052   	; 0x11da <uIPManagement_Init>
     5ee:	8b b1       	in	r24, 0x0b	; 11
     5f0:	8f 70       	andi	r24, 0x0F	; 15
     5f2:	80 62       	ori	r24, 0x20	; 32
     5f4:	8b b9       	out	0x0b, r24	; 11

			LEDs_SetAllLEDs(LEDMASK_USB_READY);
			USB_HostState = HOST_STATE_Configured;
     5f6:	8c e0       	ldi	r24, 0x0C	; 12
     5f8:	80 93 de 0c 	sts	0x0CDE, r24
     5fc:	01 c0       	rjmp	.+2      	; 0x600 <USBHostMode_USBTask+0xec>
			break;
		case HOST_STATE_Configured:
			uIPManagement_ManageNetwork();
     5fe:	37 d5       	rcall	.+2670   	; 0x106e <uIPManagement_ManageNetwork>

			break;
	}

	RNDIS_Host_USBTask(&Ethernet_RNDIS_Interface);
}
     600:	ca 5f       	subi	r28, 0xFA	; 250
     602:	dd 4f       	sbci	r29, 0xFD	; 253
     604:	0f b6       	in	r0, 0x3f	; 63
     606:	f8 94       	cli
     608:	de bf       	out	0x3e, r29	; 62
     60a:	0f be       	out	0x3f, r0	; 63
     60c:	cd bf       	out	0x3d, r28	; 61
     60e:	cf 91       	pop	r28
     610:	df 91       	pop	r29
     612:	1f 91       	pop	r17
     614:	0f 91       	pop	r16
     616:	08 95       	ret

00000618 <SCSI_Command_Inquiry>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     618:	af 92       	push	r10
     61a:	bf 92       	push	r11
     61c:	cf 92       	push	r12
     61e:	df 92       	push	r13
     620:	ef 92       	push	r14
     622:	ff 92       	push	r15
     624:	0f 93       	push	r16
     626:	1f 93       	push	r17
     628:	df 93       	push	r29
     62a:	cf 93       	push	r28
     62c:	cd b7       	in	r28, 0x3d	; 61
     62e:	de b7       	in	r29, 0x3e	; 62
     630:	6c 01       	movw	r12, r24

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;

	return true;
}
     632:	ad b6       	in	r10, 0x3d	; 61
     634:	be b6       	in	r11, 0x3e	; 62

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     636:	fc 01       	movw	r30, r24
     638:	05 8d       	ldd	r16, Z+29	; 0x1d
     63a:	14 8d       	ldd	r17, Z+28	; 0x1c
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = (AllocationLength < sizeof(InquiryData))? AllocationLength :
	                                                                       sizeof(InquiryData);

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
     63c:	82 8d       	ldd	r24, Z+26	; 0x1a
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	83 70       	andi	r24, 0x03	; 3
     642:	90 70       	andi	r25, 0x00	; 0
     644:	89 2b       	or	r24, r25
     646:	19 f4       	brne	.+6      	; 0x64e <SCSI_Command_Inquiry+0x36>
     648:	83 8d       	ldd	r24, Z+27	; 0x1b
     64a:	88 23       	and	r24, r24
     64c:	69 f0       	breq	.+26     	; 0x668 <SCSI_Command_Inquiry+0x50>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     64e:	80 91 77 01 	lds	r24, 0x0177
     652:	80 7f       	andi	r24, 0xF0	; 240
     654:	85 60       	ori	r24, 0x05	; 5
     656:	80 93 77 01 	sts	0x0177, r24
     65a:	84 e2       	ldi	r24, 0x24	; 36
     65c:	80 93 81 01 	sts	0x0181, r24
     660:	10 92 82 01 	sts	0x0182, r1
     664:	80 e0       	ldi	r24, 0x00	; 0
     666:	35 c0       	rjmp	.+106    	; 0x6d2 <SCSI_Command_Inquiry+0xba>
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = (AllocationLength < sizeof(InquiryData))? AllocationLength :
	                                                                       sizeof(InquiryData);
     668:	78 01       	movw	r14, r16
     66a:	05 32       	cpi	r16, 0x25	; 37
     66c:	11 05       	cpc	r17, r1
     66e:	18 f0       	brcs	.+6      	; 0x676 <SCSI_Command_Inquiry+0x5e>
     670:	84 e2       	ldi	r24, 0x24	; 36
     672:	e8 2e       	mov	r14, r24
     674:	f1 2c       	mov	r15, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NO_STREAM_CALLBACK);
     676:	81 e5       	ldi	r24, 0x51	; 81
     678:	91 e0       	ldi	r25, 0x01	; 1
     67a:	b7 01       	movw	r22, r14
     67c:	40 e0       	ldi	r20, 0x00	; 0
     67e:	50 e0       	ldi	r21, 0x00	; 0
     680:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <Endpoint_Write_Stream_LE>

	uint8_t PadBytes[AllocationLength - BytesTransferred];
     684:	b8 01       	movw	r22, r16
     686:	6e 19       	sub	r22, r14
     688:	7f 09       	sbc	r23, r15
     68a:	8d b7       	in	r24, 0x3d	; 61
     68c:	9e b7       	in	r25, 0x3e	; 62
     68e:	86 1b       	sub	r24, r22
     690:	97 0b       	sbc	r25, r23
     692:	0f b6       	in	r0, 0x3f	; 63
     694:	f8 94       	cli
     696:	9e bf       	out	0x3e, r25	; 62
     698:	0f be       	out	0x3f, r0	; 63
     69a:	8d bf       	out	0x3d, r24	; 61

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Write_Stream_LE(&PadBytes, sizeof(PadBytes), NO_STREAM_CALLBACK);
     69c:	01 96       	adiw	r24, 0x01	; 1
     69e:	40 e0       	ldi	r20, 0x00	; 0
     6a0:	50 e0       	ldi	r21, 0x00	; 0
     6a2:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     6a6:	80 91 e8 00 	lds	r24, 0x00E8
     6aa:	8e 77       	andi	r24, 0x7E	; 126
     6ac:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     6b0:	97 01       	movw	r18, r14
     6b2:	40 e0       	ldi	r20, 0x00	; 0
     6b4:	50 e0       	ldi	r21, 0x00	; 0
     6b6:	f6 01       	movw	r30, r12
     6b8:	82 89       	ldd	r24, Z+18	; 0x12
     6ba:	93 89       	ldd	r25, Z+19	; 0x13
     6bc:	a4 89       	ldd	r26, Z+20	; 0x14
     6be:	b5 89       	ldd	r27, Z+21	; 0x15
     6c0:	82 1b       	sub	r24, r18
     6c2:	93 0b       	sbc	r25, r19
     6c4:	a4 0b       	sbc	r26, r20
     6c6:	b5 0b       	sbc	r27, r21
     6c8:	82 8b       	std	Z+18, r24	; 0x12
     6ca:	93 8b       	std	Z+19, r25	; 0x13
     6cc:	a4 8b       	std	Z+20, r26	; 0x14
     6ce:	b5 8b       	std	Z+21, r27	; 0x15
     6d0:	81 e0       	ldi	r24, 0x01	; 1

	return true;
}
     6d2:	0f b6       	in	r0, 0x3f	; 63
     6d4:	f8 94       	cli
     6d6:	be be       	out	0x3e, r11	; 62
     6d8:	0f be       	out	0x3f, r0	; 63
     6da:	ad be       	out	0x3d, r10	; 61
     6dc:	cf 91       	pop	r28
     6de:	df 91       	pop	r29
     6e0:	1f 91       	pop	r17
     6e2:	0f 91       	pop	r16
     6e4:	ff 90       	pop	r15
     6e6:	ef 90       	pop	r14
     6e8:	df 90       	pop	r13
     6ea:	cf 90       	pop	r12
     6ec:	bf 90       	pop	r11
     6ee:	af 90       	pop	r10
     6f0:	08 95       	ret

000006f2 <SCSI_Command_Request_Sense>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     6f2:	8f 92       	push	r8
     6f4:	9f 92       	push	r9
     6f6:	bf 92       	push	r11
     6f8:	cf 92       	push	r12
     6fa:	df 92       	push	r13
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	df 93       	push	r29
     706:	cf 93       	push	r28
     708:	cd b7       	in	r28, 0x3d	; 61
     70a:	de b7       	in	r29, 0x3e	; 62
     70c:	6c 01       	movw	r12, r24

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;

	return true;
}
     70e:	8d b6       	in	r8, 0x3d	; 61
     710:	9e b6       	in	r9, 0x3e	; 62
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
     712:	fc 01       	movw	r30, r24
     714:	05 8d       	ldd	r16, Z+29	; 0x1d
	uint8_t  BytesTransferred = (AllocationLength < sizeof(SenseData))? AllocationLength : sizeof(SenseData);
     716:	b0 2e       	mov	r11, r16
     718:	03 31       	cpi	r16, 0x13	; 19
     71a:	10 f0       	brcs	.+4      	; 0x720 <SCSI_Command_Request_Sense+0x2e>
     71c:	92 e1       	ldi	r25, 0x12	; 18
     71e:	b9 2e       	mov	r11, r25

	uint8_t PadBytes[AllocationLength - BytesTransferred];
     720:	10 e0       	ldi	r17, 0x00	; 0
     722:	0b 19       	sub	r16, r11
     724:	11 09       	sbc	r17, r1
     726:	8d b7       	in	r24, 0x3d	; 61
     728:	9e b7       	in	r25, 0x3e	; 62
     72a:	80 1b       	sub	r24, r16
     72c:	91 0b       	sbc	r25, r17
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	f8 94       	cli
     732:	9e bf       	out	0x3e, r25	; 62
     734:	0f be       	out	0x3f, r0	; 63
     736:	8d bf       	out	0x3d, r24	; 61
     738:	ed b6       	in	r14, 0x3d	; 61
     73a:	fe b6       	in	r15, 0x3e	; 62
     73c:	08 94       	sec
     73e:	e1 1c       	adc	r14, r1
     740:	f1 1c       	adc	r15, r1

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NO_STREAM_CALLBACK);
     742:	85 e7       	ldi	r24, 0x75	; 117
     744:	91 e0       	ldi	r25, 0x01	; 1
     746:	6b 2d       	mov	r22, r11
     748:	70 e0       	ldi	r23, 0x00	; 0
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(&PadBytes, sizeof(PadBytes), NO_STREAM_CALLBACK);
     752:	c7 01       	movw	r24, r14
     754:	b8 01       	movw	r22, r16
     756:	40 e0       	ldi	r20, 0x00	; 0
     758:	50 e0       	ldi	r21, 0x00	; 0
     75a:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <Endpoint_Write_Stream_LE>
     75e:	80 91 e8 00 	lds	r24, 0x00E8
     762:	8e 77       	andi	r24, 0x7E	; 126
     764:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     768:	f6 01       	movw	r30, r12
     76a:	82 89       	ldd	r24, Z+18	; 0x12
     76c:	93 89       	ldd	r25, Z+19	; 0x13
     76e:	a4 89       	ldd	r26, Z+20	; 0x14
     770:	b5 89       	ldd	r27, Z+21	; 0x15
     772:	8b 19       	sub	r24, r11
     774:	91 09       	sbc	r25, r1
     776:	a1 09       	sbc	r26, r1
     778:	b1 09       	sbc	r27, r1
     77a:	82 8b       	std	Z+18, r24	; 0x12
     77c:	93 8b       	std	Z+19, r25	; 0x13
     77e:	a4 8b       	std	Z+20, r26	; 0x14
     780:	b5 8b       	std	Z+21, r27	; 0x15

	return true;
}
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	0f b6       	in	r0, 0x3f	; 63
     786:	f8 94       	cli
     788:	9e be       	out	0x3e, r9	; 62
     78a:	0f be       	out	0x3f, r0	; 63
     78c:	8d be       	out	0x3d, r8	; 61
     78e:	cf 91       	pop	r28
     790:	df 91       	pop	r29
     792:	1f 91       	pop	r17
     794:	0f 91       	pop	r16
     796:	ff 90       	pop	r15
     798:	ef 90       	pop	r14
     79a:	df 90       	pop	r13
     79c:	cf 90       	pop	r12
     79e:	bf 90       	pop	r11
     7a0:	9f 90       	pop	r9
     7a2:	8f 90       	pop	r8
     7a4:	08 95       	ret

000007a6 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	8c 01       	movw	r16, r24
     7b0:	86 2f       	mov	r24, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
     7b2:	f8 01       	movw	r30, r16
     7b4:	46 8d       	ldd	r20, Z+30	; 0x1e
     7b6:	55 8d       	ldd	r21, Z+29	; 0x1d
     7b8:	64 8d       	ldd	r22, Z+28	; 0x1c
     7ba:	73 8d       	ldd	r23, Z+27	; 0x1b

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     7bc:	c1 a1       	ldd	r28, Z+33	; 0x21
     7be:	d0 a1       	ldd	r29, Z+32	; 0x20

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)
     7c0:	40 30       	cpi	r20, 0x00	; 0
     7c2:	f0 e8       	ldi	r31, 0x80	; 128
     7c4:	5f 07       	cpc	r21, r31
     7c6:	f0 e0       	ldi	r31, 0x00	; 0
     7c8:	6f 07       	cpc	r22, r31
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
     7cc:	7f 07       	cpc	r23, r31
     7ce:	68 f0       	brcs	.+26     	; 0x7ea <SCSI_Command_ReadWrite_10+0x44>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     7d0:	80 91 77 01 	lds	r24, 0x0177
     7d4:	80 7f       	andi	r24, 0xF0	; 240
     7d6:	85 60       	ori	r24, 0x05	; 5
     7d8:	80 93 77 01 	sts	0x0177, r24
     7dc:	81 e2       	ldi	r24, 0x21	; 33
     7de:	80 93 81 01 	sts	0x0181, r24
     7e2:	10 92 82 01 	sts	0x0182, r1
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	21 c0       	rjmp	.+66     	; 0x82c <SCSI_Command_ReadWrite_10+0x86>

		return false;
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
     7ea:	88 23       	and	r24, r24
     7ec:	21 f0       	breq	.+8      	; 0x7f6 <SCSI_Command_ReadWrite_10+0x50>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     7ee:	c8 01       	movw	r24, r16
     7f0:	9e 01       	movw	r18, r28
     7f2:	d2 d1       	rcall	.+932    	; 0xb98 <DataflashManager_ReadBlocks>
     7f4:	03 c0       	rjmp	.+6      	; 0x7fc <SCSI_Command_ReadWrite_10+0x56>
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     7f6:	c8 01       	movw	r24, r16
     7f8:	9e 01       	movw	r18, r28
     7fa:	e4 d2       	rcall	.+1480   	; 0xdc4 <DataflashManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
     7fc:	9e 01       	movw	r18, r28
     7fe:	40 e0       	ldi	r20, 0x00	; 0
     800:	50 e0       	ldi	r21, 0x00	; 0
     802:	69 e0       	ldi	r22, 0x09	; 9
     804:	22 0f       	add	r18, r18
     806:	33 1f       	adc	r19, r19
     808:	44 1f       	adc	r20, r20
     80a:	55 1f       	adc	r21, r21
     80c:	6a 95       	dec	r22
     80e:	d1 f7       	brne	.-12     	; 0x804 <SCSI_Command_ReadWrite_10+0x5e>
     810:	f8 01       	movw	r30, r16
     812:	82 89       	ldd	r24, Z+18	; 0x12
     814:	93 89       	ldd	r25, Z+19	; 0x13
     816:	a4 89       	ldd	r26, Z+20	; 0x14
     818:	b5 89       	ldd	r27, Z+21	; 0x15
     81a:	82 1b       	sub	r24, r18
     81c:	93 0b       	sbc	r25, r19
     81e:	a4 0b       	sbc	r26, r20
     820:	b5 0b       	sbc	r27, r21
     822:	82 8b       	std	Z+18, r24	; 0x12
     824:	93 8b       	std	Z+19, r25	; 0x13
     826:	a4 8b       	std	Z+20, r26	; 0x14
     828:	b5 8b       	std	Z+21, r27	; 0x15
     82a:	81 e0       	ldi	r24, 0x01	; 1

	return true;
}
     82c:	df 91       	pop	r29
     82e:	cf 91       	pop	r28
     830:	1f 91       	pop	r17
     832:	0f 91       	pop	r16
     834:	08 95       	ret

00000836 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	df 93       	push	r29
     83c:	cf 93       	push	r28
     83e:	cd b7       	in	r28, 0x3d	; 61
     840:	de b7       	in	r29, 0x3e	; 62
     842:	28 97       	sbiw	r28, 0x08	; 8
     844:	0f b6       	in	r0, 0x3f	; 63
     846:	f8 94       	cli
     848:	de bf       	out	0x3e, r29	; 62
     84a:	0f be       	out	0x3f, r0	; 63
     84c:	cd bf       	out	0x3d, r28	; 61
     84e:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     850:	fc 01       	movw	r30, r24
     852:	81 8d       	ldd	r24, Z+25	; 0x19
     854:	8e 31       	cpi	r24, 0x1E	; 30
     856:	09 f4       	brne	.+2      	; 0x85a <SCSI_DecodeSCSICommand+0x24>
     858:	79 c0       	rjmp	.+242    	; 0x94c <SCSI_DecodeSCSICommand+0x116>
     85a:	8f 31       	cpi	r24, 0x1F	; 31
     85c:	70 f4       	brcc	.+28     	; 0x87a <SCSI_DecodeSCSICommand+0x44>
     85e:	83 30       	cpi	r24, 0x03	; 3
     860:	f9 f0       	breq	.+62     	; 0x8a0 <SCSI_DecodeSCSICommand+0x6a>
     862:	84 30       	cpi	r24, 0x04	; 4
     864:	20 f4       	brcc	.+8      	; 0x86e <SCSI_DecodeSCSICommand+0x38>
     866:	88 23       	and	r24, r24
     868:	09 f4       	brne	.+2      	; 0x86c <SCSI_DecodeSCSICommand+0x36>
     86a:	70 c0       	rjmp	.+224    	; 0x94c <SCSI_DecodeSCSICommand+0x116>
     86c:	75 c0       	rjmp	.+234    	; 0x958 <SCSI_DecodeSCSICommand+0x122>
     86e:	82 31       	cpi	r24, 0x12	; 18
     870:	a1 f0       	breq	.+40     	; 0x89a <SCSI_DecodeSCSICommand+0x64>
     872:	8d 31       	cpi	r24, 0x1D	; 29
     874:	09 f0       	breq	.+2      	; 0x878 <SCSI_DecodeSCSICommand+0x42>
     876:	70 c0       	rjmp	.+224    	; 0x958 <SCSI_DecodeSCSICommand+0x122>
     878:	48 c0       	rjmp	.+144    	; 0x90a <SCSI_DecodeSCSICommand+0xd4>
     87a:	88 32       	cpi	r24, 0x28	; 40
     87c:	09 f4       	brne	.+2      	; 0x880 <SCSI_DecodeSCSICommand+0x4a>
     87e:	62 c0       	rjmp	.+196    	; 0x944 <SCSI_DecodeSCSICommand+0x10e>
     880:	89 32       	cpi	r24, 0x29	; 41
     882:	20 f4       	brcc	.+8      	; 0x88c <SCSI_DecodeSCSICommand+0x56>
     884:	85 32       	cpi	r24, 0x25	; 37
     886:	09 f0       	breq	.+2      	; 0x88a <SCSI_DecodeSCSICommand+0x54>
     888:	67 c0       	rjmp	.+206    	; 0x958 <SCSI_DecodeSCSICommand+0x122>
     88a:	0d c0       	rjmp	.+26     	; 0x8a6 <SCSI_DecodeSCSICommand+0x70>
     88c:	8a 32       	cpi	r24, 0x2A	; 42
     88e:	09 f4       	brne	.+2      	; 0x892 <SCSI_DecodeSCSICommand+0x5c>
     890:	56 c0       	rjmp	.+172    	; 0x93e <SCSI_DecodeSCSICommand+0x108>
     892:	8f 32       	cpi	r24, 0x2F	; 47
     894:	09 f0       	breq	.+2      	; 0x898 <SCSI_DecodeSCSICommand+0x62>
     896:	60 c0       	rjmp	.+192    	; 0x958 <SCSI_DecodeSCSICommand+0x122>
     898:	59 c0       	rjmp	.+178    	; 0x94c <SCSI_DecodeSCSICommand+0x116>
	{
		case SCSI_CMD_INQUIRY:
			CommandSuccess = SCSI_Command_Inquiry(MSInterfaceInfo);
     89a:	c8 01       	movw	r24, r16
     89c:	bd de       	rcall	.-646    	; 0x618 <SCSI_Command_Inquiry>
     89e:	66 c0       	rjmp	.+204    	; 0x96c <SCSI_DecodeSCSICommand+0x136>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
     8a0:	c8 01       	movw	r24, r16
     8a2:	27 df       	rcall	.-434    	; 0x6f2 <SCSI_Command_Request_Sense>
     8a4:	63 c0       	rjmp	.+198    	; 0x96c <SCSI_DecodeSCSICommand+0x136>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
     8a6:	8f ef       	ldi	r24, 0xFF	; 255
     8a8:	9f e7       	ldi	r25, 0x7F	; 127
     8aa:	a0 e0       	ldi	r26, 0x00	; 0
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	89 83       	std	Y+1, r24	; 0x01
     8b0:	9a 83       	std	Y+2, r25	; 0x02
     8b2:	ab 83       	std	Y+3, r26	; 0x03
     8b4:	bc 83       	std	Y+4, r27	; 0x04
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
     8b6:	80 e0       	ldi	r24, 0x00	; 0
     8b8:	92 e0       	ldi	r25, 0x02	; 2
     8ba:	a0 e0       	ldi	r26, 0x00	; 0
     8bc:	b0 e0       	ldi	r27, 0x00	; 0
     8be:	8d 83       	std	Y+5, r24	; 0x05
     8c0:	9e 83       	std	Y+6, r25	; 0x06
     8c2:	af 83       	std	Y+7, r26	; 0x07
     8c4:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NO_STREAM_CALLBACK);
     8c6:	ce 01       	movw	r24, r28
     8c8:	01 96       	adiw	r24, 0x01	; 1
     8ca:	64 e0       	ldi	r22, 0x04	; 4
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	40 e0       	ldi	r20, 0x00	; 0
     8d0:	50 e0       	ldi	r21, 0x00	; 0
     8d2:	0e 94 93 2c 	call	0x5926	; 0x5926 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NO_STREAM_CALLBACK);
     8d6:	ce 01       	movw	r24, r28
     8d8:	05 96       	adiw	r24, 0x05	; 5
     8da:	64 e0       	ldi	r22, 0x04	; 4
     8dc:	70 e0       	ldi	r23, 0x00	; 0
     8de:	40 e0       	ldi	r20, 0x00	; 0
     8e0:	50 e0       	ldi	r21, 0x00	; 0
     8e2:	0e 94 93 2c 	call	0x5926	; 0x5926 <Endpoint_Write_Stream_BE>
     8e6:	80 91 e8 00 	lds	r24, 0x00E8
     8ea:	8e 77       	andi	r24, 0x7E	; 126
     8ec:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
     8f0:	f8 01       	movw	r30, r16
     8f2:	82 89       	ldd	r24, Z+18	; 0x12
     8f4:	93 89       	ldd	r25, Z+19	; 0x13
     8f6:	a4 89       	ldd	r26, Z+20	; 0x14
     8f8:	b5 89       	ldd	r27, Z+21	; 0x15
     8fa:	08 97       	sbiw	r24, 0x08	; 8
     8fc:	a1 09       	sbc	r26, r1
     8fe:	b1 09       	sbc	r27, r1
     900:	82 8b       	std	Z+18, r24	; 0x12
     902:	93 8b       	std	Z+19, r25	; 0x13
     904:	a4 8b       	std	Z+20, r26	; 0x14
     906:	b5 8b       	std	Z+21, r27	; 0x15
     908:	35 c0       	rjmp	.+106    	; 0x974 <SCSI_DecodeSCSICommand+0x13e>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
     90a:	f8 01       	movw	r30, r16
     90c:	82 8d       	ldd	r24, Z+26	; 0x1a
     90e:	82 fd       	sbrc	r24, 2
     910:	08 c0       	rjmp	.+16     	; 0x922 <SCSI_DecodeSCSICommand+0xec>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     912:	80 91 77 01 	lds	r24, 0x0177
     916:	80 7f       	andi	r24, 0xF0	; 240
     918:	85 60       	ori	r24, 0x05	; 5
     91a:	80 93 77 01 	sts	0x0177, r24
     91e:	84 e2       	ldi	r24, 0x24	; 36
     920:	22 c0       	rjmp	.+68     	; 0x966 <SCSI_DecodeSCSICommand+0x130>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
     922:	0f d1       	rcall	.+542    	; 0xb42 <DataflashManager_CheckDataflashOperation>
     924:	88 23       	and	r24, r24
     926:	91 f4       	brne	.+36     	; 0x94c <SCSI_DecodeSCSICommand+0x116>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
     928:	80 91 77 01 	lds	r24, 0x0177
     92c:	80 7f       	andi	r24, 0xF0	; 240
     92e:	84 60       	ori	r24, 0x04	; 4
     930:	80 93 77 01 	sts	0x0177, r24
     934:	10 92 81 01 	sts	0x0181, r1
     938:	10 92 82 01 	sts	0x0182, r1
     93c:	19 c0       	rjmp	.+50     	; 0x970 <SCSI_DecodeSCSICommand+0x13a>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
     93e:	c8 01       	movw	r24, r16
     940:	60 e0       	ldi	r22, 0x00	; 0
     942:	02 c0       	rjmp	.+4      	; 0x948 <SCSI_DecodeSCSICommand+0x112>
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
     944:	c8 01       	movw	r24, r16
     946:	61 e0       	ldi	r22, 0x01	; 1
     948:	2e df       	rcall	.-420    	; 0x7a6 <SCSI_Command_ReadWrite_10>
     94a:	10 c0       	rjmp	.+32     	; 0x96c <SCSI_DecodeSCSICommand+0x136>
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
     94c:	f8 01       	movw	r30, r16
     94e:	12 8a       	std	Z+18, r1	; 0x12
     950:	13 8a       	std	Z+19, r1	; 0x13
     952:	14 8a       	std	Z+20, r1	; 0x14
     954:	15 8a       	std	Z+21, r1	; 0x15
     956:	0e c0       	rjmp	.+28     	; 0x974 <SCSI_DecodeSCSICommand+0x13e>
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     958:	80 91 77 01 	lds	r24, 0x0177
     95c:	80 7f       	andi	r24, 0xF0	; 240
     95e:	85 60       	ori	r24, 0x05	; 5
     960:	80 93 77 01 	sts	0x0177, r24
     964:	80 e2       	ldi	r24, 0x20	; 32
     966:	80 93 81 01 	sts	0x0181, r24
     96a:	e6 cf       	rjmp	.-52     	; 0x938 <SCSI_DecodeSCSICommand+0x102>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     96c:	88 23       	and	r24, r24
     96e:	11 f4       	brne	.+4      	; 0x974 <SCSI_DecodeSCSICommand+0x13e>
     970:	80 e0       	ldi	r24, 0x00	; 0
     972:	0a c0       	rjmp	.+20     	; 0x988 <SCSI_DecodeSCSICommand+0x152>
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
     974:	80 91 77 01 	lds	r24, 0x0177
     978:	80 7f       	andi	r24, 0xF0	; 240
     97a:	80 93 77 01 	sts	0x0177, r24
     97e:	10 92 81 01 	sts	0x0181, r1
     982:	10 92 82 01 	sts	0x0182, r1
     986:	81 e0       	ldi	r24, 0x01	; 1

		return true;
	}

	return false;
}
     988:	28 96       	adiw	r28, 0x08	; 8
     98a:	0f b6       	in	r0, 0x3f	; 63
     98c:	f8 94       	cli
     98e:	de bf       	out	0x3e, r29	; 62
     990:	0f be       	out	0x3f, r0	; 63
     992:	cd bf       	out	0x3d, r28	; 61
     994:	cf 91       	pop	r28
     996:	df 91       	pop	r29
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	08 95       	ret

0000099e <Dataflash_SelectChipFromPage>:
			 *
			 *  \param[in] PageAddress  Address of the page to manipulate, ranging from
			 *                          ((DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS) - 1).
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
     99e:	9c 01       	movw	r18, r24
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     9a0:	8e b1       	in	r24, 0x0e	; 14
     9a2:	83 60       	ori	r24, 0x03	; 3
     9a4:	8e b9       	out	0x0e, r24	; 14
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
				Dataflash_DeselectChip();

				if (PageAddress >= (DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS))
     9a6:	80 e4       	ldi	r24, 0x40	; 64
     9a8:	20 30       	cpi	r18, 0x00	; 0
     9aa:	38 07       	cpc	r19, r24
     9ac:	58 f4       	brcc	.+22     	; 0x9c4 <Dataflash_SelectChipFromPage+0x26>
				  return;

				if (PageAddress & 0x01)
     9ae:	20 ff       	sbrs	r18, 0
     9b0:	05 c0       	rjmp	.+10     	; 0x9bc <Dataflash_SelectChipFromPage+0x1e>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     9b2:	8e b1       	in	r24, 0x0e	; 14
     9b4:	8c 7f       	andi	r24, 0xFC	; 252
     9b6:	81 60       	ori	r24, 0x01	; 1
     9b8:	8e b9       	out	0x0e, r24	; 14
     9ba:	08 95       	ret
     9bc:	8e b1       	in	r24, 0x0e	; 14
     9be:	8c 7f       	andi	r24, 0xFC	; 252
     9c0:	82 60       	ori	r24, 0x02	; 2
     9c2:	8e b9       	out	0x0e, r24	; 14
     9c4:	08 95       	ret

000009c6 <Dataflash_ToggleSelectedChipCS>:
			 *  or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     9c6:	8e b1       	in	r24, 0x0e	; 14
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     9c8:	9e b1       	in	r25, 0x0e	; 14
     9ca:	93 60       	ori	r25, 0x03	; 3
     9cc:	9e b9       	out	0x0e, r25	; 14
			{
				uint8_t SelectedChipMask = Dataflash_GetSelectedChip();

				Dataflash_DeselectChip();
				Dataflash_SelectChip(SelectedChipMask);
			}
     9ce:	9e b1       	in	r25, 0x0e	; 14
     9d0:	83 70       	andi	r24, 0x03	; 3
     9d2:	9c 7f       	andi	r25, 0xFC	; 252
     9d4:	89 2b       	or	r24, r25
     9d6:	8e b9       	out	0x0e, r24	; 14
     9d8:	08 95       	ret

000009da <Dataflash_WaitWhileBusy>:
			/** Spin-loops while the currently selected dataflash is busy executing a command, such as a main
			 *  memory page program or main memory to buffer transfer.
			 */
			static inline void Dataflash_WaitWhileBusy(void)
			{
				Dataflash_ToggleSelectedChipCS();
     9da:	f5 df       	rcall	.-22     	; 0x9c6 <Dataflash_ToggleSelectedChipCS>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9dc:	87 ed       	ldi	r24, 0xD7	; 215
     9de:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     9e0:	0d b4       	in	r0, 0x2d	; 45
     9e2:	07 fe       	sbrs	r0, 7
     9e4:	fd cf       	rjmp	.-6      	; 0x9e0 <Dataflash_WaitWhileBusy+0x6>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     9e6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     9e8:	0d b4       	in	r0, 0x2d	; 45
     9ea:	07 fe       	sbrs	r0, 7
     9ec:	fd cf       	rjmp	.-6      	; 0x9e8 <Dataflash_WaitWhileBusy+0xe>
				Dataflash_SendByte(DF_CMD_GETSTATUS);
				while (!(Dataflash_ReceiveByte() & DF_STATUS_READY));
     9ee:	0e b4       	in	r0, 0x2e	; 46
     9f0:	07 fe       	sbrs	r0, 7
     9f2:	f9 cf       	rjmp	.-14     	; 0x9e6 <Dataflash_WaitWhileBusy+0xc>
				Dataflash_ToggleSelectedChipCS();
			}
     9f4:	e8 cf       	rjmp	.-48     	; 0x9c6 <Dataflash_ToggleSelectedChipCS>

000009f6 <Dataflash_SendAddressBytes>:
			 *  \param[in] BufferByte   Address within the dataflash's buffer
			 */
			static inline void Dataflash_SendAddressBytes(uint16_t PageAddress,
			                                              const uint16_t BufferByte)
			{
				PageAddress >>= 1;
     9f6:	9c 01       	movw	r18, r24
     9f8:	36 95       	lsr	r19
     9fa:	27 95       	ror	r18

				Dataflash_SendByte(PageAddress >> 5);
     9fc:	36 e0       	ldi	r19, 0x06	; 6
     9fe:	96 95       	lsr	r25
     a00:	87 95       	ror	r24
     a02:	3a 95       	dec	r19
     a04:	e1 f7       	brne	.-8      	; 0x9fe <Dataflash_SendAddressBytes+0x8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a06:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a08:	0d b4       	in	r0, 0x2d	; 45
     a0a:	07 fe       	sbrs	r0, 7
     a0c:	fd cf       	rjmp	.-6      	; 0xa08 <Dataflash_SendAddressBytes+0x12>
				Dataflash_SendByte((PageAddress << 3) | (BufferByte >> 8));
     a0e:	82 2f       	mov	r24, r18
     a10:	88 0f       	add	r24, r24
     a12:	88 0f       	add	r24, r24
     a14:	88 0f       	add	r24, r24
     a16:	87 2b       	or	r24, r23
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a18:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a1a:	0d b4       	in	r0, 0x2d	; 45
     a1c:	07 fe       	sbrs	r0, 7
     a1e:	fd cf       	rjmp	.-6      	; 0xa1a <Dataflash_SendAddressBytes+0x24>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a20:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
     a22:	0d b4       	in	r0, 0x2d	; 45
     a24:	07 fe       	sbrs	r0, 7
     a26:	fd cf       	rjmp	.-6      	; 0xa22 <Dataflash_SendAddressBytes+0x2c>
				Dataflash_SendByte(BufferByte);
			}
     a28:	08 95       	ret

00000a2a <DataflashManager_ReadBlocks_RAM>:
 *  \param[out] BufferPtr    Pointer to the data destination RAM buffer
 */
void DataflashManager_ReadBlocks_RAM(const uint32_t BlockAddress,
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
     a2a:	af 92       	push	r10
     a2c:	bf 92       	push	r11
     a2e:	cf 92       	push	r12
     a30:	df 92       	push	r13
     a32:	ef 92       	push	r14
     a34:	ff 92       	push	r15
     a36:	0f 93       	push	r16
     a38:	1f 93       	push	r17
     a3a:	cf 93       	push	r28
     a3c:	df 93       	push	r29
     a3e:	6a 01       	movw	r12, r20
     a40:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     a42:	09 e0       	ldi	r16, 0x09	; 9
     a44:	66 0f       	add	r22, r22
     a46:	77 1f       	adc	r23, r23
     a48:	88 1f       	adc	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	0a 95       	dec	r16
     a4e:	d1 f7       	brne	.-12     	; 0xa44 <DataflashManager_ReadBlocks_RAM+0x1a>
     a50:	9b 01       	movw	r18, r22
     a52:	ac 01       	movw	r20, r24
     a54:	1a e0       	ldi	r17, 0x0A	; 10
     a56:	56 95       	lsr	r21
     a58:	47 95       	ror	r20
     a5a:	37 95       	ror	r19
     a5c:	27 95       	ror	r18
     a5e:	1a 95       	dec	r17
     a60:	d1 f7       	brne	.-12     	; 0xa56 <DataflashManager_ReadBlocks_RAM+0x2c>
     a62:	89 01       	movw	r16, r18
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     a64:	eb 01       	movw	r28, r22
     a66:	d3 70       	andi	r29, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     a68:	c9 01       	movw	r24, r18
     a6a:	99 df       	rcall	.-206    	; 0x99e <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a6c:	82 ed       	ldi	r24, 0xD2	; 210
     a6e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a70:	0d b4       	in	r0, 0x2d	; 45
     a72:	07 fe       	sbrs	r0, 7
     a74:	fd cf       	rjmp	.-6      	; 0xa70 <DataflashManager_ReadBlocks_RAM+0x46>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     a76:	c8 01       	movw	r24, r16
     a78:	be 01       	movw	r22, r28
     a7a:	bd df       	rcall	.-134    	; 0x9f6 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a7c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     a7e:	0d b4       	in	r0, 0x2d	; 45
     a80:	07 fe       	sbrs	r0, 7
     a82:	fd cf       	rjmp	.-6      	; 0xa7e <DataflashManager_ReadBlocks_RAM+0x54>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a84:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     a86:	0d b4       	in	r0, 0x2d	; 45
     a88:	07 fe       	sbrs	r0, 7
     a8a:	fd cf       	rjmp	.-6      	; 0xa86 <DataflashManager_ReadBlocks_RAM+0x5c>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a8c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     a8e:	0d b4       	in	r0, 0x2d	; 45
     a90:	07 fe       	sbrs	r0, 7
     a92:	fd cf       	rjmp	.-6      	; 0xa8e <DataflashManager_ReadBlocks_RAM+0x64>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a94:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     a96:	0d b4       	in	r0, 0x2d	; 45
     a98:	07 fe       	sbrs	r0, 7
     a9a:	fd cf       	rjmp	.-6      	; 0xa96 <DataflashManager_ReadBlocks_RAM+0x6c>
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     a9c:	b4 e0       	ldi	r27, 0x04	; 4
     a9e:	d6 95       	lsr	r29
     aa0:	c7 95       	ror	r28
     aa2:	ba 95       	dec	r27
     aa4:	e1 f7       	brne	.-8      	; 0xa9e <DataflashManager_ReadBlocks_RAM+0x74>
     aa6:	6c 2f       	mov	r22, r28
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     aa8:	a2 ed       	ldi	r26, 0xD2	; 210
     aaa:	aa 2e       	mov	r10, r26
     aac:	39 c0       	rjmp	.+114    	; 0xb20 <DataflashManager_ReadBlocks_RAM+0xf6>
     aae:	e7 01       	movw	r28, r14
     ab0:	bb 24       	eor	r11, r11

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     ab2:	60 34       	cpi	r22, 0x40	; 64
     ab4:	e9 f4       	brne	.+58     	; 0xaf0 <DataflashManager_ReadBlocks_RAM+0xc6>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     ab6:	0f 5f       	subi	r16, 0xFF	; 255
     ab8:	1f 4f       	sbci	r17, 0xFF	; 255

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     aba:	c8 01       	movw	r24, r16
     abc:	70 df       	rcall	.-288    	; 0x99e <Dataflash_SelectChipFromPage>
     abe:	ae bc       	out	0x2e, r10	; 46
				while (!(SPSR & (1 << SPIF)));
     ac0:	0d b4       	in	r0, 0x2d	; 45
     ac2:	07 fe       	sbrs	r0, 7
     ac4:	fd cf       	rjmp	.-6      	; 0xac0 <DataflashManager_ReadBlocks_RAM+0x96>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     ac6:	c8 01       	movw	r24, r16
     ac8:	60 e0       	ldi	r22, 0x00	; 0
     aca:	70 e0       	ldi	r23, 0x00	; 0
     acc:	94 df       	rcall	.-216    	; 0x9f6 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ace:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ad0:	0d b4       	in	r0, 0x2d	; 45
     ad2:	07 fe       	sbrs	r0, 7
     ad4:	fd cf       	rjmp	.-6      	; 0xad0 <DataflashManager_ReadBlocks_RAM+0xa6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ad6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ad8:	0d b4       	in	r0, 0x2d	; 45
     ada:	07 fe       	sbrs	r0, 7
     adc:	fd cf       	rjmp	.-6      	; 0xad8 <DataflashManager_ReadBlocks_RAM+0xae>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ade:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ae0:	0d b4       	in	r0, 0x2d	; 45
     ae2:	07 fe       	sbrs	r0, 7
     ae4:	fd cf       	rjmp	.-6      	; 0xae0 <DataflashManager_ReadBlocks_RAM+0xb6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ae6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ae8:	0d b4       	in	r0, 0x2d	; 45
     aea:	07 fe       	sbrs	r0, 7
     aec:	fd cf       	rjmp	.-6      	; 0xae8 <DataflashManager_ReadBlocks_RAM+0xbe>
     aee:	60 e0       	ldi	r22, 0x00	; 0
     af0:	fe 01       	movw	r30, r28
     af2:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     af4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     af6:	0d b4       	in	r0, 0x2d	; 45
     af8:	07 fe       	sbrs	r0, 7
     afa:	fd cf       	rjmp	.-6      	; 0xaf6 <DataflashManager_ReadBlocks_RAM+0xcc>
				return SPDR;
     afc:	8e b5       	in	r24, 0x2e	; 46
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  *(BufferPtr++) = Dataflash_ReceiveByte();
     afe:	81 93       	st	Z+, r24
				Dataflash_SendByte(0x00);
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
     b00:	9f 5f       	subi	r25, 0xFF	; 255
     b02:	90 31       	cpi	r25, 0x10	; 16
     b04:	b9 f7       	brne	.-18     	; 0xaf4 <DataflashManager_ReadBlocks_RAM+0xca>
     b06:	60 96       	adiw	r28, 0x10	; 16
			  *(BufferPtr++) = Dataflash_ReceiveByte();

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     b08:	6f 5f       	subi	r22, 0xFF	; 255

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
     b0a:	b3 94       	inc	r11
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     b0c:	80 e2       	ldi	r24, 0x20	; 32
     b0e:	b8 16       	cp	r11, r24
     b10:	81 f6       	brne	.-96     	; 0xab2 <DataflashManager_ReadBlocks_RAM+0x88>
     b12:	80 e0       	ldi	r24, 0x00	; 0
     b14:	92 e0       	ldi	r25, 0x02	; 2
     b16:	e8 0e       	add	r14, r24
     b18:	f9 1e       	adc	r15, r25
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     b1a:	08 94       	sec
     b1c:	c1 08       	sbc	r12, r1
     b1e:	d1 08       	sbc	r13, r1
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     b20:	c1 14       	cp	r12, r1
     b22:	d1 04       	cpc	r13, r1
     b24:	21 f6       	brne	.-120    	; 0xaae <DataflashManager_ReadBlocks_RAM+0x84>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     b26:	8e b1       	in	r24, 0x0e	; 14
     b28:	83 60       	ori	r24, 0x03	; 3
     b2a:	8e b9       	out	0x0e, r24	; 14
		TotalBlocks--;
	}

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     b2c:	df 91       	pop	r29
     b2e:	cf 91       	pop	r28
     b30:	1f 91       	pop	r17
     b32:	0f 91       	pop	r16
     b34:	ff 90       	pop	r15
     b36:	ef 90       	pop	r14
     b38:	df 90       	pop	r13
     b3a:	cf 90       	pop	r12
     b3c:	bf 90       	pop	r11
     b3e:	af 90       	pop	r10
     b40:	08 95       	ret

00000b42 <DataflashManager_CheckDataflashOperation>:
     b42:	8e b1       	in	r24, 0x0e	; 14
     b44:	8c 7f       	andi	r24, 0xFC	; 252
     b46:	82 60       	ori	r24, 0x02	; 2
     b48:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b4a:	8f e9       	ldi	r24, 0x9F	; 159
     b4c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     b4e:	0d b4       	in	r0, 0x2d	; 45
     b50:	07 fe       	sbrs	r0, 7
     b52:	fd cf       	rjmp	.-6      	; 0xb4e <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     b54:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b56:	0d b4       	in	r0, 0x2d	; 45
     b58:	07 fe       	sbrs	r0, 7
     b5a:	fd cf       	rjmp	.-6      	; 0xb56 <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
     b5c:	9e b5       	in	r25, 0x2e	; 46
     b5e:	8e b1       	in	r24, 0x0e	; 14
     b60:	83 60       	ori	r24, 0x03	; 3
     b62:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
     b64:	9f 31       	cpi	r25, 0x1F	; 31
     b66:	11 f0       	breq	.+4      	; 0xb6c <DataflashManager_CheckDataflashOperation+0x2a>
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	08 95       	ret
     b6c:	8e b1       	in	r24, 0x0e	; 14
     b6e:	8c 7f       	andi	r24, 0xFC	; 252
     b70:	81 60       	ori	r24, 0x01	; 1
     b72:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b74:	8f e9       	ldi	r24, 0x9F	; 159
     b76:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     b78:	0d b4       	in	r0, 0x2d	; 45
     b7a:	07 fe       	sbrs	r0, 7
     b7c:	fd cf       	rjmp	.-6      	; 0xb78 <DataflashManager_CheckDataflashOperation+0x36>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     b7e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b80:	0d b4       	in	r0, 0x2d	; 45
     b82:	07 fe       	sbrs	r0, 7
     b84:	fd cf       	rjmp	.-6      	; 0xb80 <DataflashManager_CheckDataflashOperation+0x3e>
				return SPDR;
     b86:	9e b5       	in	r25, 0x2e	; 46
     b88:	8e b1       	in	r24, 0x0e	; 14
     b8a:	83 60       	ori	r24, 0x03	; 3
     b8c:	8e b9       	out	0x0e, r24	; 14
     b8e:	80 e0       	ldi	r24, 0x00	; 0
     b90:	9f 31       	cpi	r25, 0x1F	; 31
     b92:	09 f4       	brne	.+2      	; 0xb96 <DataflashManager_CheckDataflashOperation+0x54>
     b94:	81 e0       	ldi	r24, 0x01	; 1
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
     b96:	08 95       	ret

00000b98 <DataflashManager_ReadBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void DataflashManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
     b98:	af 92       	push	r10
     b9a:	bf 92       	push	r11
     b9c:	cf 92       	push	r12
     b9e:	df 92       	push	r13
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	df 93       	push	r29
     baa:	cf 93       	push	r28
     bac:	0f 92       	push	r0
     bae:	cd b7       	in	r28, 0x3d	; 61
     bb0:	de b7       	in	r29, 0x3e	; 62
     bb2:	5c 01       	movw	r10, r24
     bb4:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     bb6:	e9 e0       	ldi	r30, 0x09	; 9
     bb8:	44 0f       	add	r20, r20
     bba:	55 1f       	adc	r21, r21
     bbc:	66 1f       	adc	r22, r22
     bbe:	77 1f       	adc	r23, r23
     bc0:	ea 95       	dec	r30
     bc2:	d1 f7       	brne	.-12     	; 0xbb8 <DataflashManager_ReadBlocks+0x20>
     bc4:	db 01       	movw	r26, r22
     bc6:	ca 01       	movw	r24, r20
     bc8:	3a e0       	ldi	r19, 0x0A	; 10
     bca:	b6 95       	lsr	r27
     bcc:	a7 95       	ror	r26
     bce:	97 95       	ror	r25
     bd0:	87 95       	ror	r24
     bd2:	3a 95       	dec	r19
     bd4:	d1 f7       	brne	.-12     	; 0xbca <DataflashManager_ReadBlocks+0x32>
     bd6:	8c 01       	movw	r16, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     bd8:	2f ef       	ldi	r18, 0xFF	; 255
     bda:	c2 2e       	mov	r12, r18
     bdc:	23 e0       	ldi	r18, 0x03	; 3
     bde:	d2 2e       	mov	r13, r18
     be0:	c4 22       	and	r12, r20
     be2:	d5 22       	and	r13, r21
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     be4:	dc de       	rcall	.-584    	; 0x99e <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     be6:	82 ed       	ldi	r24, 0xD2	; 210
     be8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bea:	0d b4       	in	r0, 0x2d	; 45
     bec:	07 fe       	sbrs	r0, 7
     bee:	fd cf       	rjmp	.-6      	; 0xbea <DataflashManager_ReadBlocks+0x52>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     bf0:	c8 01       	movw	r24, r16
     bf2:	b6 01       	movw	r22, r12
     bf4:	00 df       	rcall	.-512    	; 0x9f6 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bf6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     bf8:	0d b4       	in	r0, 0x2d	; 45
     bfa:	07 fe       	sbrs	r0, 7
     bfc:	fd cf       	rjmp	.-6      	; 0xbf8 <DataflashManager_ReadBlocks+0x60>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bfe:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c00:	0d b4       	in	r0, 0x2d	; 45
     c02:	07 fe       	sbrs	r0, 7
     c04:	fd cf       	rjmp	.-6      	; 0xc00 <DataflashManager_ReadBlocks+0x68>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c06:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c08:	0d b4       	in	r0, 0x2d	; 45
     c0a:	07 fe       	sbrs	r0, 7
     c0c:	fd cf       	rjmp	.-6      	; 0xc08 <DataflashManager_ReadBlocks+0x70>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c0e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c10:	0d b4       	in	r0, 0x2d	; 45
     c12:	07 fe       	sbrs	r0, 7
     c14:	fd cf       	rjmp	.-6      	; 0xc10 <DataflashManager_ReadBlocks+0x78>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     c16:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
     c1a:	88 23       	and	r24, r24
     c1c:	09 f0       	breq	.+2      	; 0xc20 <DataflashManager_ReadBlocks+0x88>
     c1e:	c6 c0       	rjmp	.+396    	; 0xdac <DataflashManager_ReadBlocks+0x214>
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     c20:	94 e0       	ldi	r25, 0x04	; 4
     c22:	d6 94       	lsr	r13
     c24:	c7 94       	ror	r12
     c26:	9a 95       	dec	r25
     c28:	e1 f7       	brne	.-8      	; 0xc22 <DataflashManager_ReadBlocks+0x8a>
     c2a:	9c 2d       	mov	r25, r12
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c2c:	82 ed       	ldi	r24, 0xD2	; 210
     c2e:	c8 2e       	mov	r12, r24
     c30:	ad c0       	rjmp	.+346    	; 0xd8c <DataflashManager_ReadBlocks+0x1f4>
     c32:	dd 24       	eor	r13, r13
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     c34:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently full */
			if (!(Endpoint_IsReadWriteAllowed()))
     c38:	85 fd       	sbrc	r24, 5
     c3a:	0c c0       	rjmp	.+24     	; 0xc54 <DataflashManager_ReadBlocks+0xbc>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     c3c:	80 91 e8 00 	lds	r24, 0x00E8
     c40:	8e 77       	andi	r24, 0x7E	; 126
     c42:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the endpoint bank to send its contents to the host */
				Endpoint_ClearIN();

				/* Wait until the endpoint is ready for more data */
				if (Endpoint_WaitUntilReady())
     c46:	99 83       	std	Y+1, r25	; 0x01
     c48:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
     c4c:	99 81       	ldd	r25, Y+1	; 0x01
     c4e:	88 23       	and	r24, r24
     c50:	09 f0       	breq	.+2      	; 0xc54 <DataflashManager_ReadBlocks+0xbc>
     c52:	ac c0       	rjmp	.+344    	; 0xdac <DataflashManager_ReadBlocks+0x214>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     c54:	90 34       	cpi	r25, 0x40	; 64
     c56:	e9 f4       	brne	.+58     	; 0xc92 <DataflashManager_ReadBlocks+0xfa>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     c58:	0f 5f       	subi	r16, 0xFF	; 255
     c5a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     c5c:	c8 01       	movw	r24, r16
     c5e:	9f de       	rcall	.-706    	; 0x99e <Dataflash_SelectChipFromPage>
     c60:	ce bc       	out	0x2e, r12	; 46
				while (!(SPSR & (1 << SPIF)));
     c62:	0d b4       	in	r0, 0x2d	; 45
     c64:	07 fe       	sbrs	r0, 7
     c66:	fd cf       	rjmp	.-6      	; 0xc62 <DataflashManager_ReadBlocks+0xca>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     c68:	c8 01       	movw	r24, r16
     c6a:	60 e0       	ldi	r22, 0x00	; 0
     c6c:	70 e0       	ldi	r23, 0x00	; 0
     c6e:	c3 de       	rcall	.-634    	; 0x9f6 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c70:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c72:	0d b4       	in	r0, 0x2d	; 45
     c74:	07 fe       	sbrs	r0, 7
     c76:	fd cf       	rjmp	.-6      	; 0xc72 <DataflashManager_ReadBlocks+0xda>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c78:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c7a:	0d b4       	in	r0, 0x2d	; 45
     c7c:	07 fe       	sbrs	r0, 7
     c7e:	fd cf       	rjmp	.-6      	; 0xc7a <DataflashManager_ReadBlocks+0xe2>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c80:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c82:	0d b4       	in	r0, 0x2d	; 45
     c84:	07 fe       	sbrs	r0, 7
     c86:	fd cf       	rjmp	.-6      	; 0xc82 <DataflashManager_ReadBlocks+0xea>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c88:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c8a:	0d b4       	in	r0, 0x2d	; 45
     c8c:	07 fe       	sbrs	r0, 7
     c8e:	fd cf       	rjmp	.-6      	; 0xc8a <DataflashManager_ReadBlocks+0xf2>
     c90:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     c92:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c94:	0d b4       	in	r0, 0x2d	; 45
     c96:	07 fe       	sbrs	r0, 7
     c98:	fd cf       	rjmp	.-6      	; 0xc94 <DataflashManager_ReadBlocks+0xfc>
				return SPDR;
     c9a:	8e b5       	in	r24, 0x2e	; 46
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
     c9c:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     ca0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ca2:	0d b4       	in	r0, 0x2d	; 45
     ca4:	07 fe       	sbrs	r0, 7
     ca6:	fd cf       	rjmp	.-6      	; 0xca2 <DataflashManager_ReadBlocks+0x10a>
				return SPDR;
     ca8:	8e b5       	in	r24, 0x2e	; 46
     caa:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cae:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cb0:	0d b4       	in	r0, 0x2d	; 45
     cb2:	07 fe       	sbrs	r0, 7
     cb4:	fd cf       	rjmp	.-6      	; 0xcb0 <DataflashManager_ReadBlocks+0x118>
				return SPDR;
     cb6:	8e b5       	in	r24, 0x2e	; 46
     cb8:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cbc:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cbe:	0d b4       	in	r0, 0x2d	; 45
     cc0:	07 fe       	sbrs	r0, 7
     cc2:	fd cf       	rjmp	.-6      	; 0xcbe <DataflashManager_ReadBlocks+0x126>
				return SPDR;
     cc4:	8e b5       	in	r24, 0x2e	; 46
     cc6:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cca:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ccc:	0d b4       	in	r0, 0x2d	; 45
     cce:	07 fe       	sbrs	r0, 7
     cd0:	fd cf       	rjmp	.-6      	; 0xccc <DataflashManager_ReadBlocks+0x134>
				return SPDR;
     cd2:	8e b5       	in	r24, 0x2e	; 46
     cd4:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cd8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cda:	0d b4       	in	r0, 0x2d	; 45
     cdc:	07 fe       	sbrs	r0, 7
     cde:	fd cf       	rjmp	.-6      	; 0xcda <DataflashManager_ReadBlocks+0x142>
				return SPDR;
     ce0:	8e b5       	in	r24, 0x2e	; 46
     ce2:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     ce6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ce8:	0d b4       	in	r0, 0x2d	; 45
     cea:	07 fe       	sbrs	r0, 7
     cec:	fd cf       	rjmp	.-6      	; 0xce8 <DataflashManager_ReadBlocks+0x150>
				return SPDR;
     cee:	8e b5       	in	r24, 0x2e	; 46
     cf0:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cf4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cf6:	0d b4       	in	r0, 0x2d	; 45
     cf8:	07 fe       	sbrs	r0, 7
     cfa:	fd cf       	rjmp	.-6      	; 0xcf6 <DataflashManager_ReadBlocks+0x15e>
				return SPDR;
     cfc:	8e b5       	in	r24, 0x2e	; 46
     cfe:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d02:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d04:	0d b4       	in	r0, 0x2d	; 45
     d06:	07 fe       	sbrs	r0, 7
     d08:	fd cf       	rjmp	.-6      	; 0xd04 <DataflashManager_ReadBlocks+0x16c>
				return SPDR;
     d0a:	8e b5       	in	r24, 0x2e	; 46
     d0c:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d10:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d12:	0d b4       	in	r0, 0x2d	; 45
     d14:	07 fe       	sbrs	r0, 7
     d16:	fd cf       	rjmp	.-6      	; 0xd12 <DataflashManager_ReadBlocks+0x17a>
				return SPDR;
     d18:	8e b5       	in	r24, 0x2e	; 46
     d1a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d1e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d20:	0d b4       	in	r0, 0x2d	; 45
     d22:	07 fe       	sbrs	r0, 7
     d24:	fd cf       	rjmp	.-6      	; 0xd20 <DataflashManager_ReadBlocks+0x188>
				return SPDR;
     d26:	8e b5       	in	r24, 0x2e	; 46
     d28:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d2c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d2e:	0d b4       	in	r0, 0x2d	; 45
     d30:	07 fe       	sbrs	r0, 7
     d32:	fd cf       	rjmp	.-6      	; 0xd2e <DataflashManager_ReadBlocks+0x196>
				return SPDR;
     d34:	8e b5       	in	r24, 0x2e	; 46
     d36:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d3a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d3c:	0d b4       	in	r0, 0x2d	; 45
     d3e:	07 fe       	sbrs	r0, 7
     d40:	fd cf       	rjmp	.-6      	; 0xd3c <DataflashManager_ReadBlocks+0x1a4>
				return SPDR;
     d42:	8e b5       	in	r24, 0x2e	; 46
     d44:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d48:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d4a:	0d b4       	in	r0, 0x2d	; 45
     d4c:	07 fe       	sbrs	r0, 7
     d4e:	fd cf       	rjmp	.-6      	; 0xd4a <DataflashManager_ReadBlocks+0x1b2>
				return SPDR;
     d50:	8e b5       	in	r24, 0x2e	; 46
     d52:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d56:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d58:	0d b4       	in	r0, 0x2d	; 45
     d5a:	07 fe       	sbrs	r0, 7
     d5c:	fd cf       	rjmp	.-6      	; 0xd58 <DataflashManager_ReadBlocks+0x1c0>
				return SPDR;
     d5e:	8e b5       	in	r24, 0x2e	; 46
     d60:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d64:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d66:	0d b4       	in	r0, 0x2d	; 45
     d68:	07 fe       	sbrs	r0, 7
     d6a:	fd cf       	rjmp	.-6      	; 0xd66 <DataflashManager_ReadBlocks+0x1ce>
				return SPDR;
     d6c:	8e b5       	in	r24, 0x2e	; 46
     d6e:	80 93 f1 00 	sts	0x00F1, r24

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     d72:	f5 01       	movw	r30, r10
     d74:	86 a9       	ldd	r24, Z+54	; 0x36
     d76:	88 23       	and	r24, r24
     d78:	c9 f4       	brne	.+50     	; 0xdac <DataflashManager_ReadBlocks+0x214>
			Endpoint_Write_Byte(Dataflash_ReceiveByte());
			Endpoint_Write_Byte(Dataflash_ReceiveByte());
			Endpoint_Write_Byte(Dataflash_ReceiveByte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     d7a:	9f 5f       	subi	r25, 0xFF	; 255

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
     d7c:	d3 94       	inc	r13
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     d7e:	f0 e2       	ldi	r31, 0x20	; 32
     d80:	df 16       	cp	r13, r31
     d82:	09 f0       	breq	.+2      	; 0xd86 <DataflashManager_ReadBlocks+0x1ee>
     d84:	57 cf       	rjmp	.-338    	; 0xc34 <DataflashManager_ReadBlocks+0x9c>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     d86:	08 94       	sec
     d88:	e1 08       	sbc	r14, r1
     d8a:	f1 08       	sbc	r15, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     d8c:	e1 14       	cp	r14, r1
     d8e:	f1 04       	cpc	r15, r1
     d90:	09 f0       	breq	.+2      	; 0xd94 <DataflashManager_ReadBlocks+0x1fc>
     d92:	4f cf       	rjmp	.-354    	; 0xc32 <DataflashManager_ReadBlocks+0x9a>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     d94:	80 91 e8 00 	lds	r24, 0x00E8
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     d98:	85 fd       	sbrc	r24, 5
     d9a:	05 c0       	rjmp	.+10     	; 0xda6 <DataflashManager_ReadBlocks+0x20e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     d9c:	80 91 e8 00 	lds	r24, 0x00E8
     da0:	8e 77       	andi	r24, 0x7E	; 126
     da2:	80 93 e8 00 	sts	0x00E8, r24
     da6:	8e b1       	in	r24, 0x0e	; 14
     da8:	83 60       	ori	r24, 0x03	; 3
     daa:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearIN();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     dac:	0f 90       	pop	r0
     dae:	cf 91       	pop	r28
     db0:	df 91       	pop	r29
     db2:	1f 91       	pop	r17
     db4:	0f 91       	pop	r16
     db6:	ff 90       	pop	r15
     db8:	ef 90       	pop	r14
     dba:	df 90       	pop	r13
     dbc:	cf 90       	pop	r12
     dbe:	bf 90       	pop	r11
     dc0:	af 90       	pop	r10
     dc2:	08 95       	ret

00000dc4 <DataflashManager_WriteBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
     dc4:	8f 92       	push	r8
     dc6:	9f 92       	push	r9
     dc8:	af 92       	push	r10
     dca:	bf 92       	push	r11
     dcc:	cf 92       	push	r12
     dce:	df 92       	push	r13
     dd0:	ef 92       	push	r14
     dd2:	ff 92       	push	r15
     dd4:	0f 93       	push	r16
     dd6:	1f 93       	push	r17
     dd8:	df 93       	push	r29
     dda:	cf 93       	push	r28
     ddc:	0f 92       	push	r0
     dde:	cd b7       	in	r28, 0x3d	; 61
     de0:	de b7       	in	r29, 0x3e	; 62
     de2:	5c 01       	movw	r10, r24
     de4:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     de6:	09 e0       	ldi	r16, 0x09	; 9
     de8:	44 0f       	add	r20, r20
     dea:	55 1f       	adc	r21, r21
     dec:	66 1f       	adc	r22, r22
     dee:	77 1f       	adc	r23, r23
     df0:	0a 95       	dec	r16
     df2:	d1 f7       	brne	.-12     	; 0xde8 <DataflashManager_WriteBlocks+0x24>
     df4:	db 01       	movw	r26, r22
     df6:	ca 01       	movw	r24, r20
     df8:	1a e0       	ldi	r17, 0x0A	; 10
     dfa:	b6 95       	lsr	r27
     dfc:	a7 95       	ror	r26
     dfe:	97 95       	ror	r25
     e00:	87 95       	ror	r24
     e02:	1a 95       	dec	r17
     e04:	d1 f7       	brne	.-12     	; 0xdfa <DataflashManager_WriteBlocks+0x36>
     e06:	8c 01       	movw	r16, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     e08:	bf ef       	ldi	r27, 0xFF	; 255
     e0a:	cb 2e       	mov	r12, r27
     e0c:	b3 e0       	ldi	r27, 0x03	; 3
     e0e:	db 2e       	mov	r13, r27
     e10:	c4 22       	and	r12, r20
     e12:	d5 22       	and	r13, r21
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     e14:	c4 dd       	rcall	.-1144   	; 0x99e <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     e16:	83 e5       	ldi	r24, 0x53	; 83
     e18:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     e1a:	0d b4       	in	r0, 0x2d	; 45
     e1c:	07 fe       	sbrs	r0, 7
     e1e:	fd cf       	rjmp	.-6      	; 0xe1a <DataflashManager_WriteBlocks+0x56>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
     e20:	c8 01       	movw	r24, r16
     e22:	60 e0       	ldi	r22, 0x00	; 0
     e24:	70 e0       	ldi	r23, 0x00	; 0
     e26:	e7 dd       	rcall	.-1074   	; 0x9f6 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
     e28:	d8 dd       	rcall	.-1104   	; 0x9da <Dataflash_WaitWhileBusy>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     e2a:	84 e8       	ldi	r24, 0x84	; 132
     e2c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     e2e:	0d b4       	in	r0, 0x2d	; 45
     e30:	07 fe       	sbrs	r0, 7
     e32:	fd cf       	rjmp	.-6      	; 0xe2e <DataflashManager_WriteBlocks+0x6a>
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
     e34:	80 e0       	ldi	r24, 0x00	; 0
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	b6 01       	movw	r22, r12
     e3a:	dd dd       	rcall	.-1094   	; 0x9f6 <Dataflash_SendAddressBytes>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     e3c:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
     e40:	88 23       	and	r24, r24
     e42:	09 f0       	breq	.+2      	; 0xe46 <DataflashManager_WriteBlocks+0x82>
     e44:	eb c0       	rjmp	.+470    	; 0x101c <DataflashManager_WriteBlocks+0x258>
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     e46:	a4 e0       	ldi	r26, 0x04	; 4
     e48:	d6 94       	lsr	r13
     e4a:	c7 94       	ror	r12
     e4c:	aa 95       	dec	r26
     e4e:	e1 f7       	brne	.-8      	; 0xe48 <DataflashManager_WriteBlocks+0x84>
     e50:	9c 2d       	mov	r25, r12
     e52:	47 01       	movw	r8, r14
     e54:	f5 e0       	ldi	r31, 0x05	; 5
     e56:	88 0c       	add	r8, r8
     e58:	99 1c       	adc	r9, r9
     e5a:	fa 95       	dec	r31
     e5c:	e1 f7       	brne	.-8      	; 0xe56 <DataflashManager_WriteBlocks+0x92>
     e5e:	dd 24       	eor	r13, r13
     e60:	be c0       	rjmp	.+380    	; 0xfde <DataflashManager_WriteBlocks+0x21a>
     e62:	cc 24       	eor	r12, r12
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     e64:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently empty */
			if (!(Endpoint_IsReadWriteAllowed()))
     e68:	85 fd       	sbrc	r24, 5
     e6a:	0c c0       	rjmp	.+24     	; 0xe84 <DataflashManager_WriteBlocks+0xc0>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     e6c:	80 91 e8 00 	lds	r24, 0x00E8
     e70:	8b 77       	andi	r24, 0x7B	; 123
     e72:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the current endpoint bank */
				Endpoint_ClearOUT();

				/* Wait until the host has sent another packet */
				if (Endpoint_WaitUntilReady())
     e76:	99 83       	std	Y+1, r25	; 0x01
     e78:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
     e7c:	99 81       	ldd	r25, Y+1	; 0x01
     e7e:	88 23       	and	r24, r24
     e80:	09 f0       	breq	.+2      	; 0xe84 <DataflashManager_WriteBlocks+0xc0>
     e82:	cc c0       	rjmp	.+408    	; 0x101c <DataflashManager_WriteBlocks+0x258>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     e84:	90 34       	cpi	r25, 0x40	; 64
     e86:	09 f0       	breq	.+2      	; 0xe8a <DataflashManager_WriteBlocks+0xc6>
     e88:	39 c0       	rjmp	.+114    	; 0xefc <DataflashManager_WriteBlocks+0x138>
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
     e8a:	a7 dd       	rcall	.-1202   	; 0x9da <Dataflash_WaitWhileBusy>
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     e8c:	dd 20       	and	r13, r13
     e8e:	11 f4       	brne	.+4      	; 0xe94 <DataflashManager_WriteBlocks+0xd0>
     e90:	83 e8       	ldi	r24, 0x83	; 131
     e92:	01 c0       	rjmp	.+2      	; 0xe96 <DataflashManager_WriteBlocks+0xd2>
     e94:	86 e8       	ldi	r24, 0x86	; 134
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     e96:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     e98:	0d b4       	in	r0, 0x2d	; 45
     e9a:	07 fe       	sbrs	r0, 7
     e9c:	fd cf       	rjmp	.-6      	; 0xe98 <DataflashManager_WriteBlocks+0xd4>
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     e9e:	c8 01       	movw	r24, r16
     ea0:	60 e0       	ldi	r22, 0x00	; 0
     ea2:	70 e0       	ldi	r23, 0x00	; 0
     ea4:	a8 dd       	rcall	.-1200   	; 0x9f6 <Dataflash_SendAddressBytes>

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     ea6:	0f 5f       	subi	r16, 0xFF	; 255
     ea8:	1f 4f       	sbci	r17, 0xFF	; 255
			 *  or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     eaa:	8e b1       	in	r24, 0x0e	; 14

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
     eac:	83 70       	andi	r24, 0x03	; 3
     eae:	81 30       	cpi	r24, 0x01	; 1
     eb0:	09 f4       	brne	.+2      	; 0xeb4 <DataflashManager_WriteBlocks+0xf0>
				  UsingSecondBuffer = !(UsingSecondBuffer);
     eb2:	d8 26       	eor	r13, r24

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     eb4:	c8 01       	movw	r24, r16
     eb6:	73 dd       	rcall	.-1306   	; 0x99e <Dataflash_SelectChipFromPage>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
     eb8:	20 e4       	ldi	r18, 0x40	; 64
     eba:	82 16       	cp	r8, r18
     ebc:	91 04       	cpc	r9, r1
     ebe:	78 f4       	brcc	.+30     	; 0xede <DataflashManager_WriteBlocks+0x11a>
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
     ec0:	8c dd       	rcall	.-1256   	; 0x9da <Dataflash_WaitWhileBusy>
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
     ec2:	dd 20       	and	r13, r13
     ec4:	11 f4       	brne	.+4      	; 0xeca <DataflashManager_WriteBlocks+0x106>
     ec6:	83 e5       	ldi	r24, 0x53	; 83
     ec8:	01 c0       	rjmp	.+2      	; 0xecc <DataflashManager_WriteBlocks+0x108>
     eca:	85 e5       	ldi	r24, 0x55	; 85
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ecc:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     ece:	0d b4       	in	r0, 0x2d	; 45
     ed0:	07 fe       	sbrs	r0, 7
     ed2:	fd cf       	rjmp	.-6      	; 0xece <DataflashManager_WriteBlocks+0x10a>
					Dataflash_SendAddressBytes(CurrDFPage, 0);
     ed4:	c8 01       	movw	r24, r16
     ed6:	60 e0       	ldi	r22, 0x00	; 0
     ed8:	70 e0       	ldi	r23, 0x00	; 0
     eda:	8d dd       	rcall	.-1254   	; 0x9f6 <Dataflash_SendAddressBytes>
					Dataflash_WaitWhileBusy();
     edc:	7e dd       	rcall	.-1284   	; 0x9da <Dataflash_WaitWhileBusy>
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
     ede:	dd 20       	and	r13, r13
     ee0:	11 f4       	brne	.+4      	; 0xee6 <DataflashManager_WriteBlocks+0x122>
     ee2:	84 e8       	ldi	r24, 0x84	; 132
     ee4:	01 c0       	rjmp	.+2      	; 0xee8 <DataflashManager_WriteBlocks+0x124>
     ee6:	87 e8       	ldi	r24, 0x87	; 135
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ee8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     eea:	0d b4       	in	r0, 0x2d	; 45
     eec:	07 fe       	sbrs	r0, 7
     eee:	fd cf       	rjmp	.-6      	; 0xeea <DataflashManager_WriteBlocks+0x126>
				Dataflash_SendAddressBytes(0, 0);
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	60 e0       	ldi	r22, 0x00	; 0
     ef6:	70 e0       	ldi	r23, 0x00	; 0
     ef8:	7e dd       	rcall	.-1284   	; 0x9f6 <Dataflash_SendAddressBytes>
     efa:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
     efc:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f00:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f02:	0d b4       	in	r0, 0x2d	; 45
     f04:	07 fe       	sbrs	r0, 7
     f06:	fd cf       	rjmp	.-6      	; 0xf02 <DataflashManager_WriteBlocks+0x13e>
     f08:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f0c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f0e:	0d b4       	in	r0, 0x2d	; 45
     f10:	07 fe       	sbrs	r0, 7
     f12:	fd cf       	rjmp	.-6      	; 0xf0e <DataflashManager_WriteBlocks+0x14a>
     f14:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f18:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f1a:	0d b4       	in	r0, 0x2d	; 45
     f1c:	07 fe       	sbrs	r0, 7
     f1e:	fd cf       	rjmp	.-6      	; 0xf1a <DataflashManager_WriteBlocks+0x156>
     f20:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f24:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f26:	0d b4       	in	r0, 0x2d	; 45
     f28:	07 fe       	sbrs	r0, 7
     f2a:	fd cf       	rjmp	.-6      	; 0xf26 <DataflashManager_WriteBlocks+0x162>
     f2c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f30:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f32:	0d b4       	in	r0, 0x2d	; 45
     f34:	07 fe       	sbrs	r0, 7
     f36:	fd cf       	rjmp	.-6      	; 0xf32 <DataflashManager_WriteBlocks+0x16e>
     f38:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f3c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f3e:	0d b4       	in	r0, 0x2d	; 45
     f40:	07 fe       	sbrs	r0, 7
     f42:	fd cf       	rjmp	.-6      	; 0xf3e <DataflashManager_WriteBlocks+0x17a>
     f44:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f48:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f4a:	0d b4       	in	r0, 0x2d	; 45
     f4c:	07 fe       	sbrs	r0, 7
     f4e:	fd cf       	rjmp	.-6      	; 0xf4a <DataflashManager_WriteBlocks+0x186>
     f50:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f54:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f56:	0d b4       	in	r0, 0x2d	; 45
     f58:	07 fe       	sbrs	r0, 7
     f5a:	fd cf       	rjmp	.-6      	; 0xf56 <DataflashManager_WriteBlocks+0x192>
     f5c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f60:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f62:	0d b4       	in	r0, 0x2d	; 45
     f64:	07 fe       	sbrs	r0, 7
     f66:	fd cf       	rjmp	.-6      	; 0xf62 <DataflashManager_WriteBlocks+0x19e>
     f68:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f6c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f6e:	0d b4       	in	r0, 0x2d	; 45
     f70:	07 fe       	sbrs	r0, 7
     f72:	fd cf       	rjmp	.-6      	; 0xf6e <DataflashManager_WriteBlocks+0x1aa>
     f74:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f78:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f7a:	0d b4       	in	r0, 0x2d	; 45
     f7c:	07 fe       	sbrs	r0, 7
     f7e:	fd cf       	rjmp	.-6      	; 0xf7a <DataflashManager_WriteBlocks+0x1b6>
     f80:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f84:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f86:	0d b4       	in	r0, 0x2d	; 45
     f88:	07 fe       	sbrs	r0, 7
     f8a:	fd cf       	rjmp	.-6      	; 0xf86 <DataflashManager_WriteBlocks+0x1c2>
     f8c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f90:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f92:	0d b4       	in	r0, 0x2d	; 45
     f94:	07 fe       	sbrs	r0, 7
     f96:	fd cf       	rjmp	.-6      	; 0xf92 <DataflashManager_WriteBlocks+0x1ce>
     f98:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f9c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f9e:	0d b4       	in	r0, 0x2d	; 45
     fa0:	07 fe       	sbrs	r0, 7
     fa2:	fd cf       	rjmp	.-6      	; 0xf9e <DataflashManager_WriteBlocks+0x1da>
     fa4:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fa8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     faa:	0d b4       	in	r0, 0x2d	; 45
     fac:	07 fe       	sbrs	r0, 7
     fae:	fd cf       	rjmp	.-6      	; 0xfaa <DataflashManager_WriteBlocks+0x1e6>
     fb0:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fb4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fb6:	0d b4       	in	r0, 0x2d	; 45
     fb8:	07 fe       	sbrs	r0, 7
     fba:	fd cf       	rjmp	.-6      	; 0xfb6 <DataflashManager_WriteBlocks+0x1f2>

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     fbc:	f5 01       	movw	r30, r10
     fbe:	86 a9       	ldd	r24, Z+54	; 0x36
     fc0:	88 23       	and	r24, r24
     fc2:	61 f5       	brne	.+88     	; 0x101c <DataflashManager_WriteBlocks+0x258>
			Dataflash_SendByte(Endpoint_Read_Byte());
			Dataflash_SendByte(Endpoint_Read_Byte());
			Dataflash_SendByte(Endpoint_Read_Byte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     fc4:	9f 5f       	subi	r25, 0xFF	; 255

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
     fc6:	c3 94       	inc	r12
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     fc8:	f0 e2       	ldi	r31, 0x20	; 32
     fca:	cf 16       	cp	r12, r31
     fcc:	09 f0       	breq	.+2      	; 0xfd0 <DataflashManager_WriteBlocks+0x20c>
     fce:	4a cf       	rjmp	.-364    	; 0xe64 <DataflashManager_WriteBlocks+0xa0>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter and reset the sub block counter */
		TotalBlocks--;
     fd0:	08 94       	sec
     fd2:	e1 08       	sbc	r14, r1
     fd4:	f1 08       	sbc	r15, r1
     fd6:	20 ee       	ldi	r18, 0xE0	; 224
     fd8:	3f ef       	ldi	r19, 0xFF	; 255
     fda:	82 0e       	add	r8, r18
     fdc:	93 1e       	adc	r9, r19

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     fde:	e1 14       	cp	r14, r1
     fe0:	f1 04       	cpc	r15, r1
     fe2:	09 f0       	breq	.+2      	; 0xfe6 <DataflashManager_WriteBlocks+0x222>
     fe4:	3e cf       	rjmp	.-388    	; 0xe62 <DataflashManager_WriteBlocks+0x9e>
		/* Decrement the blocks remaining counter and reset the sub block counter */
		TotalBlocks--;
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
     fe6:	f9 dc       	rcall	.-1550   	; 0x9da <Dataflash_WaitWhileBusy>
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     fe8:	dd 20       	and	r13, r13
     fea:	11 f4       	brne	.+4      	; 0xff0 <DataflashManager_WriteBlocks+0x22c>
     fec:	83 e8       	ldi	r24, 0x83	; 131
     fee:	01 c0       	rjmp	.+2      	; 0xff2 <DataflashManager_WriteBlocks+0x22e>
     ff0:	86 e8       	ldi	r24, 0x86	; 134
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ff2:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     ff4:	0d b4       	in	r0, 0x2d	; 45
     ff6:	07 fe       	sbrs	r0, 7
     ff8:	fd cf       	rjmp	.-6      	; 0xff4 <DataflashManager_WriteBlocks+0x230>
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
     ffa:	c8 01       	movw	r24, r16
     ffc:	60 e0       	ldi	r22, 0x00	; 0
     ffe:	70 e0       	ldi	r23, 0x00	; 0
    1000:	fa dc       	rcall	.-1548   	; 0x9f6 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
    1002:	eb dc       	rcall	.-1578   	; 0x9da <Dataflash_WaitWhileBusy>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1004:	80 91 e8 00 	lds	r24, 0x00E8

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    1008:	85 fd       	sbrc	r24, 5
    100a:	05 c0       	rjmp	.+10     	; 0x1016 <DataflashManager_WriteBlocks+0x252>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    100c:	80 91 e8 00 	lds	r24, 0x00E8
    1010:	8b 77       	andi	r24, 0x7B	; 123
    1012:	80 93 e8 00 	sts	0x00E8, r24
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
    1016:	8e b1       	in	r24, 0x0e	; 14
    1018:	83 60       	ori	r24, 0x03	; 3
    101a:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearOUT();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
    101c:	0f 90       	pop	r0
    101e:	cf 91       	pop	r28
    1020:	df 91       	pop	r29
    1022:	1f 91       	pop	r17
    1024:	0f 91       	pop	r16
    1026:	ff 90       	pop	r15
    1028:	ef 90       	pop	r14
    102a:	df 90       	pop	r13
    102c:	cf 90       	pop	r12
    102e:	bf 90       	pop	r11
    1030:	af 90       	pop	r10
    1032:	9f 90       	pop	r9
    1034:	8f 90       	pop	r8
    1036:	08 95       	ret

00001038 <uIPManagement_UDPCallback>:
 *  to the appropriate UDP protocol application based on the connection's listen port number.
 */
void uIPManagement_UDPCallback(void)
{
	/* Call the correct UDP application based on the port number the connection is listening on */
	switch (uip_udp_conn->lport)
    1038:	e0 91 56 05 	lds	r30, 0x0556
    103c:	f0 91 57 05 	lds	r31, 0x0557
    1040:	84 81       	ldd	r24, Z+4	; 0x04
    1042:	95 81       	ldd	r25, Z+5	; 0x05
    1044:	80 50       	subi	r24, 0x00	; 0
    1046:	94 44       	sbci	r25, 0x44	; 68
    1048:	09 f4       	brne	.+2      	; 0x104c <uIPManagement_UDPCallback+0x14>
	{
		case HTONS(DHCPC_CLIENT_PORT):
			DHCPClientApp_Callback();
    104a:	96 c1       	rjmp	.+812    	; 0x1378 <DHCPClientApp_Callback>
    104c:	08 95       	ret

0000104e <uIPManagement_TCPCallback>:
 *  to the appropriate TCP protocol application based on the connection's listen port number.
 */
void uIPManagement_TCPCallback(void)
{
	/* Call the correct TCP application based on the port number the connection is listening on */
	switch (uip_conn->lport)
    104e:	e0 91 5a 05 	lds	r30, 0x055A
    1052:	f0 91 5b 05 	lds	r31, 0x055B
    1056:	84 81       	ldd	r24, Z+4	; 0x04
    1058:	95 81       	ldd	r25, Z+5	; 0x05
    105a:	27 e1       	ldi	r18, 0x17	; 23
    105c:	80 30       	cpi	r24, 0x00	; 0
    105e:	92 07       	cpc	r25, r18
    1060:	21 f0       	breq	.+8      	; 0x106a <uIPManagement_TCPCallback+0x1c>
    1062:	80 50       	subi	r24, 0x00	; 0
    1064:	90 45       	sbci	r25, 0x50	; 80
    1066:	11 f4       	brne	.+4      	; 0x106c <uIPManagement_TCPCallback+0x1e>
	{
		case HTONS(HTTP_SERVER_PORT):
			HTTPServerApp_Callback();
    1068:	d8 c2       	rjmp	.+1456   	; 0x161a <HTTPServerApp_Callback>
			break;
		#if defined(ENABLE_TELNET_SERVER)
		case HTONS(TELNET_SERVER_PORT):
			TELNETServerApp_Callback();
    106a:	89 c4       	rjmp	.+2322   	; 0x197e <TELNETServerApp_Callback>
    106c:	08 95       	ret

0000106e <uIPManagement_ManageNetwork>:

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    106e:	0f 93       	push	r16
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
	if ((USB_CurrentMode == USB_MODE_Host) && (USB_HostState == HOST_STATE_Configured))
    1076:	80 91 17 03 	lds	r24, 0x0317
    107a:	82 30       	cpi	r24, 0x02	; 2
    107c:	09 f0       	breq	.+2      	; 0x1080 <uIPManagement_ManageNetwork+0x12>
    107e:	a8 c0       	rjmp	.+336    	; 0x11d0 <uIPManagement_ManageNetwork+0x162>
    1080:	80 91 de 0c 	lds	r24, 0x0CDE
    1084:	8c 30       	cpi	r24, 0x0C	; 12
    1086:	09 f0       	breq	.+2      	; 0x108a <uIPManagement_ManageNetwork+0x1c>
    1088:	a3 c0       	rjmp	.+326    	; 0x11d0 <uIPManagement_ManageNetwork+0x162>

/** Processes Incoming packets to the server from the connected RNDIS device, creating responses as needed. */
static void uIPManagement_ProcessIncomingPacket(void)
{
	/* If no packet received, exit processing routine */
	if (!(RNDIS_Host_IsPacketReceived(&Ethernet_RNDIS_Interface)))
    108a:	87 e3       	ldi	r24, 0x37	; 55
    108c:	91 e0       	ldi	r25, 0x01	; 1
    108e:	0e 94 40 32 	call	0x6480	; 0x6480 <RNDIS_Host_IsPacketReceived>
    1092:	88 23       	and	r24, r24
    1094:	09 f4       	brne	.+2      	; 0x1098 <uIPManagement_ManageNetwork+0x2a>
    1096:	3d c0       	rjmp	.+122    	; 0x1112 <uIPManagement_ManageNetwork+0xa4>
    1098:	8b b1       	in	r24, 0x0b	; 11
    109a:	8f 70       	andi	r24, 0x0F	; 15
    109c:	80 6d       	ori	r24, 0xD0	; 208
    109e:	8b b9       	out	0x0b, r24	; 11
	  return;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

	/* Read the Incoming packet straight into the UIP packet buffer */
	RNDIS_Host_ReadPacket(&Ethernet_RNDIS_Interface, uip_buf, &uip_len);
    10a0:	87 e3       	ldi	r24, 0x37	; 55
    10a2:	91 e0       	ldi	r25, 0x01	; 1
    10a4:	65 ec       	ldi	r22, 0xC5	; 197
    10a6:	76 e0       	ldi	r23, 0x06	; 6
    10a8:	4d e4       	ldi	r20, 0x4D	; 77
    10aa:	55 e0       	ldi	r21, 0x05	; 5
    10ac:	0e 94 d6 32 	call	0x65ac	; 0x65ac <RNDIS_Host_ReadPacket>

	/* If the packet contains an Ethernet frame, process it */
	if (uip_len > 0)
    10b0:	80 91 4d 05 	lds	r24, 0x054D
    10b4:	90 91 4e 05 	lds	r25, 0x054E
    10b8:	89 2b       	or	r24, r25
    10ba:	01 f1       	breq	.+64     	; 0x10fc <uIPManagement_ManageNetwork+0x8e>
	{
		switch (((struct uip_eth_hdr*)uip_buf)->type)
    10bc:	80 91 d1 06 	lds	r24, 0x06D1
    10c0:	90 91 d2 06 	lds	r25, 0x06D2
    10c4:	88 30       	cpi	r24, 0x08	; 8
    10c6:	91 05       	cpc	r25, r1
    10c8:	21 f0       	breq	.+8      	; 0x10d2 <uIPManagement_ManageNetwork+0x64>
    10ca:	88 50       	subi	r24, 0x08	; 8
    10cc:	96 40       	sbci	r25, 0x06	; 6
    10ce:	b1 f4       	brne	.+44     	; 0x10fc <uIPManagement_ManageNetwork+0x8e>
    10d0:	0b c0       	rjmp	.+22     	; 0x10e8 <uIPManagement_ManageNetwork+0x7a>
			case HTONS(UIP_ETHTYPE_IP):
				/* Filter packet by MAC destination */
				uip_arp_ipin();

				/* Process Incoming packet */
				uip_input();
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	76 d6       	rcall	.+3308   	; 0x1dc2 <uip_process>

				/* If a response was generated, send it */
				if (uip_len > 0)
    10d6:	80 91 4d 05 	lds	r24, 0x054D
    10da:	90 91 4e 05 	lds	r25, 0x054E
    10de:	89 2b       	or	r24, r25
    10e0:	69 f0       	breq	.+26     	; 0x10fc <uIPManagement_ManageNetwork+0x8e>
				{
					/* Add destination MAC to outgoing packet */
					uip_arp_out();
    10e2:	0e 94 3b 18 	call	0x3076	; 0x3076 <uip_arp_out>
    10e6:	08 c0       	rjmp	.+16     	; 0x10f8 <uIPManagement_ManageNetwork+0x8a>
				}

				break;
			case HTONS(UIP_ETHTYPE_ARP):
				/* Process ARP packet */
				uip_arp_arpin();
    10e8:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <uip_arp_arpin>

				/* If a response was generated, send it */
				if (uip_len > 0)
    10ec:	80 91 4d 05 	lds	r24, 0x054D
    10f0:	90 91 4e 05 	lds	r25, 0x054E
    10f4:	89 2b       	or	r24, r25
    10f6:	11 f0       	breq	.+4      	; 0x10fc <uIPManagement_ManageNetwork+0x8e>
				  uip_split_output();
    10f8:	0e 94 ec 19 	call	0x33d8	; 0x33d8 <uip_split_output>

				break;
		}
	}

	LEDs_SetAllLEDs(LEDMASK_USB_READY | ((HaveIPConfiguration) ? LEDMASK_UIP_READY_CONFIG : LEDMASK_UIP_READY_NOCONFIG));
    10fc:	80 91 20 03 	lds	r24, 0x0320
    1100:	88 23       	and	r24, r24
    1102:	11 f4       	brne	.+4      	; 0x1108 <uIPManagement_ManageNetwork+0x9a>
    1104:	90 ea       	ldi	r25, 0xA0	; 160
    1106:	01 c0       	rjmp	.+2      	; 0x110a <uIPManagement_ManageNetwork+0x9c>
    1108:	90 e6       	ldi	r25, 0x60	; 96
    110a:	8b b1       	in	r24, 0x0b	; 11
    110c:	8f 70       	andi	r24, 0x0F	; 15
    110e:	98 2b       	or	r25, r24
    1110:	9b b9       	out	0x0b, r25	; 11
    1112:	0c e5       	ldi	r16, 0x5C	; 92
    1114:	15 e0       	ldi	r17, 0x05	; 5
    1116:	e8 01       	movw	r28, r16
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		uip_poll_conn(&uip_conns[i]);
    1118:	d0 93 5b 05 	sts	0x055B, r29
    111c:	c0 93 5a 05 	sts	0x055A, r28
    1120:	83 e0       	ldi	r24, 0x03	; 3
    1122:	4f d6       	rcall	.+3230   	; 0x1dc2 <uip_process>

		/* If a response was generated, send it */
		if (uip_len > 0)
    1124:	80 91 4d 05 	lds	r24, 0x054D
    1128:	90 91 4e 05 	lds	r25, 0x054E
    112c:	89 2b       	or	r24, r25
    112e:	21 f0       	breq	.+8      	; 0x1138 <uIPManagement_ManageNetwork+0xca>
		{
			/* Add destination MAC to outgoing packet */
			uip_arp_out();
    1130:	0e 94 3b 18 	call	0x3076	; 0x3076 <uip_arp_out>

			/* Split and send the outgoing packet */
			uip_split_output();
    1134:	0e 94 ec 19 	call	0x33d8	; 0x33d8 <uip_split_output>
    1138:	cf 58       	subi	r28, 0x8F	; 143
    113a:	df 4f       	sbci	r29, 0xFF	; 255

/** Manages the currently open network connections, including TCP and (if enabled) UDP. */
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    113c:	86 e0       	ldi	r24, 0x06	; 6
    113e:	cf 3a       	cpi	r28, 0xAF	; 175
    1140:	d8 07       	cpc	r29, r24
    1142:	51 f7       	brne	.-44     	; 0x1118 <uIPManagement_ManageNetwork+0xaa>
			uip_split_output();
		}
	}

	/* Manage open connections for timeouts */
	if (timer_expired(&ConnectionTimer))
    1144:	8c e1       	ldi	r24, 0x1C	; 28
    1146:	93 e0       	ldi	r25, 0x03	; 3
    1148:	0e 94 9d 19 	call	0x333a	; 0x333a <timer_expired>
    114c:	89 2b       	or	r24, r25
    114e:	a1 f1       	breq	.+104    	; 0x11b8 <uIPManagement_ManageNetwork+0x14a>
	{
		timer_reset(&ConnectionTimer);
    1150:	8c e1       	ldi	r24, 0x1C	; 28
    1152:	93 e0       	ldi	r25, 0x03	; 3
    1154:	0e 94 93 19 	call	0x3326	; 0x3326 <timer_reset>
    1158:	8b b1       	in	r24, 0x0b	; 11
    115a:	8f 70       	andi	r24, 0x0F	; 15
    115c:	80 6d       	ori	r24, 0xD0	; 208
    115e:	8b b9       	out	0x0b, r24	; 11
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
		{
			/* Run periodic connection management for each TCP connection */
			uip_periodic(i);
    1160:	10 93 5b 05 	sts	0x055B, r17
    1164:	00 93 5a 05 	sts	0x055A, r16
    1168:	82 e0       	ldi	r24, 0x02	; 2
    116a:	2b d6       	rcall	.+3158   	; 0x1dc2 <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    116c:	80 91 4d 05 	lds	r24, 0x054D
    1170:	90 91 4e 05 	lds	r25, 0x054E
    1174:	89 2b       	or	r24, r25
    1176:	21 f0       	breq	.+8      	; 0x1180 <uIPManagement_ManageNetwork+0x112>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    1178:	0e 94 3b 18 	call	0x3076	; 0x3076 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    117c:	0e 94 ec 19 	call	0x33d8	; 0x33d8 <uip_split_output>
    1180:	0f 58       	subi	r16, 0x8F	; 143
    1182:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		timer_reset(&ConnectionTimer);

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
    1184:	26 e0       	ldi	r18, 0x06	; 6
    1186:	0f 3a       	cpi	r16, 0xAF	; 175
    1188:	12 07       	cpc	r17, r18
    118a:	51 f7       	brne	.-44     	; 0x1160 <uIPManagement_ManageNetwork+0xf2>

		#if defined(ENABLE_DHCP_CLIENT)
		for (uint8_t i = 0; i < UIP_UDP_CONNS; i++)
		{
			/* Run periodic connection management for each UDP connection */
			uip_udp_periodic(i);
    118c:	83 eb       	ldi	r24, 0xB3	; 179
    118e:	9c e0       	ldi	r25, 0x0C	; 12
    1190:	90 93 57 05 	sts	0x0557, r25
    1194:	80 93 56 05 	sts	0x0556, r24
    1198:	85 e0       	ldi	r24, 0x05	; 5
    119a:	13 d6       	rcall	.+3110   	; 0x1dc2 <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    119c:	80 91 4d 05 	lds	r24, 0x054D
    11a0:	90 91 4e 05 	lds	r25, 0x054E
    11a4:	89 2b       	or	r24, r25
    11a6:	21 f0       	breq	.+8      	; 0x11b0 <uIPManagement_ManageNetwork+0x142>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    11a8:	0e 94 3b 18 	call	0x3076	; 0x3076 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    11ac:	0e 94 ec 19 	call	0x33d8	; 0x33d8 <uip_split_output>
    11b0:	8b b1       	in	r24, 0x0b	; 11
    11b2:	8f 70       	andi	r24, 0x0F	; 15
    11b4:	80 62       	ori	r24, 0x20	; 32
    11b6:	8b b9       	out	0x0b, r24	; 11

		LEDs_SetAllLEDs(LEDMASK_USB_READY);
	}

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
    11b8:	87 e2       	ldi	r24, 0x27	; 39
    11ba:	93 e0       	ldi	r25, 0x03	; 3
    11bc:	0e 94 9d 19 	call	0x333a	; 0x333a <timer_expired>
    11c0:	89 2b       	or	r24, r25
    11c2:	31 f0       	breq	.+12     	; 0x11d0 <uIPManagement_ManageNetwork+0x162>
	{
		timer_reset(&ARPTimer);
    11c4:	87 e2       	ldi	r24, 0x27	; 39
    11c6:	93 e0       	ldi	r25, 0x03	; 3
    11c8:	0e 94 93 19 	call	0x3326	; 0x3326 <timer_reset>
		uip_arp_timer();
    11cc:	0e 94 47 19 	call	0x328e	; 0x328e <uip_arp_timer>
	if ((USB_CurrentMode == USB_MODE_Host) && (USB_HostState == HOST_STATE_Configured))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	1f 91       	pop	r17
    11d6:	0f 91       	pop	r16
    11d8:	08 95       	ret

000011da <uIPManagement_Init>:

/** Configures the uIP stack ready for network traffic. */
void uIPManagement_Init(void)
{
	/* uIP Timing Initialization */
	clock_init();
    11da:	0e 94 d7 19 	call	0x33ae	; 0x33ae <clock_init>
	timer_set(&ConnectionTimer, CLOCK_SECOND / 2);
    11de:	8c e1       	ldi	r24, 0x1C	; 28
    11e0:	93 e0       	ldi	r25, 0x03	; 3
    11e2:	62 e3       	ldi	r22, 0x32	; 50
    11e4:	70 e0       	ldi	r23, 0x00	; 0
    11e6:	0e 94 b3 19 	call	0x3366	; 0x3366 <timer_set>
	timer_set(&ARPTimer, CLOCK_SECOND * 10);
    11ea:	87 e2       	ldi	r24, 0x27	; 39
    11ec:	93 e0       	ldi	r25, 0x03	; 3
    11ee:	68 ee       	ldi	r22, 0xE8	; 232
    11f0:	73 e0       	ldi	r23, 0x03	; 3
    11f2:	0e 94 b3 19 	call	0x3366	; 0x3366 <timer_set>

	/* uIP Stack Initialization */
	uip_init();
    11f6:	1d d5       	rcall	.+2618   	; 0x1c32 <uip_init>
	uip_arp_init();
    11f8:	0e 94 7e 19 	call	0x32fc	; 0x32fc <uip_arp_init>
	uip_setethaddr(MACAddress);
    11fc:	80 91 21 03 	lds	r24, 0x0321
    1200:	80 93 9c 02 	sts	0x029C, r24
    1204:	80 91 22 03 	lds	r24, 0x0322
    1208:	80 93 9d 02 	sts	0x029D, r24
    120c:	80 91 23 03 	lds	r24, 0x0323
    1210:	80 93 9e 02 	sts	0x029E, r24
    1214:	80 91 24 03 	lds	r24, 0x0324
    1218:	80 93 9f 02 	sts	0x029F, r24
    121c:	80 91 25 03 	lds	r24, 0x0325
    1220:	80 93 a0 02 	sts	0x02A0, r24
    1224:	80 91 26 03 	lds	r24, 0x0326
    1228:	80 93 a1 02 	sts	0x02A1, r24

	/* DHCP/Server IP Settings Initialization */
	#if defined(ENABLE_DHCP_CLIENT)
	HaveIPConfiguration = false;
    122c:	10 92 20 03 	sts	0x0320, r1
	DHCPClientApp_Init();
    1230:	df d1       	rcall	.+958    	; 0x15f0 <DHCPClientApp_Init>
	uip_setnetmask(&Netmask);
	uip_setdraddr(&GatewayIPAddress);
	#endif

	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();
    1232:	9d d3       	rcall	.+1850   	; 0x196e <HTTPServerApp_Init>

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
	#endif
}
    1234:	9d c4       	rjmp	.+2362   	; 0x1b70 <TELNETServerApp_Init>

00001236 <DHCPClientApp_FillDHCPHeader>:
 *  \return Size in bytes of the created DHCP packet
 */
static uint16_t DHCPClientApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             uip_udp_appstate_t* const AppState)
{
    1236:	cf 93       	push	r28
    1238:	df 93       	push	r29
    123a:	ec 01       	movw	r28, r24
    123c:	fa 01       	movw	r30, r20
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    123e:	80 ef       	ldi	r24, 0xF0	; 240
    1240:	de 01       	movw	r26, r28
    1242:	1d 92       	st	X+, r1
    1244:	8a 95       	dec	r24
    1246:	e9 f7       	brne	.-6      	; 0x1242 <DHCPClientApp_FillDHCPHeader+0xc>

	/* Fill out the DHCP packet header */
	DHCPHeader->Operation             = DHCP_OP_BOOTREQUEST;
    1248:	81 e0       	ldi	r24, 0x01	; 1
    124a:	88 83       	st	Y, r24
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    124c:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    124e:	86 e0       	ldi	r24, 0x06	; 6
    1250:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeader->Hops                  = 0;
    1252:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = DHCP_TRANSACTION_ID;
    1254:	86 e6       	ldi	r24, 0x66	; 102
    1256:	94 e5       	ldi	r25, 0x54	; 84
    1258:	a4 e2       	ldi	r26, 0x24	; 36
    125a:	b3 e1       	ldi	r27, 0x13	; 19
    125c:	8c 83       	std	Y+4, r24	; 0x04
    125e:	9d 83       	std	Y+5, r25	; 0x05
    1260:	ae 83       	std	Y+6, r26	; 0x06
    1262:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    1264:	19 86       	std	Y+9, r1	; 0x09
    1266:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = HTONS(BOOTP_BROADCAST);
    1268:	80 e8       	ldi	r24, 0x80	; 128
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	9b 87       	std	Y+11, r25	; 0x0b
    126e:	8a 87       	std	Y+10, r24	; 0x0a
	memcpy(&DHCPHeader->ClientIP,     &uip_hostaddr,        sizeof(uip_ipaddr_t));
    1270:	80 91 c1 06 	lds	r24, 0x06C1
    1274:	90 91 c2 06 	lds	r25, 0x06C2
    1278:	a0 91 c3 06 	lds	r26, 0x06C3
    127c:	b0 91 c4 06 	lds	r27, 0x06C4
    1280:	8c 87       	std	Y+12, r24	; 0x0c
    1282:	9d 87       	std	Y+13, r25	; 0x0d
    1284:	ae 87       	std	Y+14, r26	; 0x0e
    1286:	bf 87       	std	Y+15, r27	; 0x0f
	memcpy(&DHCPHeader->YourIP,       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, sizeof(uip_ipaddr_t));
    1288:	85 81       	ldd	r24, Z+5	; 0x05
    128a:	96 81       	ldd	r25, Z+6	; 0x06
    128c:	a7 81       	ldd	r26, Z+7	; 0x07
    128e:	b0 85       	ldd	r27, Z+8	; 0x08
    1290:	88 8b       	std	Y+16, r24	; 0x10
    1292:	99 8b       	std	Y+17, r25	; 0x11
    1294:	aa 8b       	std	Y+18, r26	; 0x12
    1296:	bb 8b       	std	Y+19, r27	; 0x13
	memcpy(&DHCPHeader->NextServerIP, &AppState->DHCPClient.DHCPOffer_Data.ServerIP,    sizeof(uip_ipaddr_t));
    1298:	81 89       	ldd	r24, Z+17	; 0x11
    129a:	92 89       	ldd	r25, Z+18	; 0x12
    129c:	a3 89       	ldd	r26, Z+19	; 0x13
    129e:	b4 89       	ldd	r27, Z+20	; 0x14
    12a0:	8c 8b       	std	Y+20, r24	; 0x14
    12a2:	9d 8b       	std	Y+21, r25	; 0x15
    12a4:	ae 8b       	std	Y+22, r26	; 0x16
    12a6:	bf 8b       	std	Y+23, r27	; 0x17
	memcpy(&DHCPHeader->ClientHardwareAddress, &MACAddress, sizeof(struct uip_eth_addr));
    12a8:	de 01       	movw	r26, r28
    12aa:	5c 96       	adiw	r26, 0x1c	; 28
    12ac:	e1 e2       	ldi	r30, 0x21	; 33
    12ae:	f3 e0       	ldi	r31, 0x03	; 3
    12b0:	86 e0       	ldi	r24, 0x06	; 6
    12b2:	01 90       	ld	r0, Z+
    12b4:	0d 92       	st	X+, r0
    12b6:	81 50       	subi	r24, 0x01	; 1
    12b8:	e1 f7       	brne	.-8      	; 0x12b2 <DHCPClientApp_FillDHCPHeader+0x7c>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    12ba:	c4 51       	subi	r28, 0x14	; 20
    12bc:	df 4f       	sbci	r29, 0xFF	; 255
    12be:	83 e6       	ldi	r24, 0x63	; 99
    12c0:	92 e8       	ldi	r25, 0x82	; 130
    12c2:	a3 e5       	ldi	r26, 0x53	; 83
    12c4:	b3 e6       	ldi	r27, 0x63	; 99
    12c6:	89 93       	st	Y+, r24
    12c8:	99 93       	st	Y+, r25
    12ca:	a9 93       	st	Y+, r26
    12cc:	b9 93       	st	Y+, r27

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    12ce:	85 e3       	ldi	r24, 0x35	; 53
    12d0:	89 93       	st	Y+, r24
	DHCPHeader->Options[1]            = 1;
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	89 93       	st	Y+, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    12d6:	69 93       	st	Y+, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    12d8:	8f ef       	ldi	r24, 0xFF	; 255
    12da:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    12dc:	84 ef       	ldi	r24, 0xF4	; 244
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	df 91       	pop	r29
    12e2:	cf 91       	pop	r28
    12e4:	08 95       	ret

000012e6 <DHCPClientApp_SetOption>:
 */
static uint8_t DHCPClientApp_SetOption(uint8_t* DHCPOptionList,
                                       const uint8_t Option,
                                       const uint8_t DataLen,
                                       void* const OptionData)
{
    12e6:	ef 92       	push	r14
    12e8:	ff 92       	push	r15
    12ea:	0f 93       	push	r16
    12ec:	1f 93       	push	r17
    12ee:	cf 93       	push	r28
    12f0:	df 93       	push	r29
    12f2:	ec 01       	movw	r28, r24
    12f4:	f4 2e       	mov	r15, r20
    12f6:	42 2f       	mov	r20, r18
    12f8:	73 2f       	mov	r23, r19
    12fa:	05 c0       	rjmp	.+10     	; 0x1306 <DHCPClientApp_SetOption+0x20>
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
	  DHCPOptionList += (DHCPOptionList[1] + 2);
    12fc:	89 81       	ldd	r24, Y+1	; 0x01
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	02 96       	adiw	r24, 0x02	; 2
    1302:	c8 0f       	add	r28, r24
    1304:	d9 1f       	adc	r29, r25
                                       const uint8_t Option,
                                       const uint8_t DataLen,
                                       void* const OptionData)
{
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1306:	e8 80       	ld	r14, Y
    1308:	8f ef       	ldi	r24, 0xFF	; 255
    130a:	e8 16       	cp	r14, r24
    130c:	b9 f7       	brne	.-18     	; 0x12fc <DHCPClientApp_SetOption+0x16>
	  DHCPOptionList += (DHCPOptionList[1] + 2);

	/* Overwrite the existing terminator with the new option, add a new terminator at the end of the list */
	DHCPOptionList[0] = Option;
    130e:	68 83       	st	Y, r22
	DHCPOptionList[1] = DataLen;
    1310:	f9 82       	std	Y+1, r15	; 0x01
	memcpy(&DHCPOptionList[2], OptionData, DataLen);
    1312:	0f 2d       	mov	r16, r15
    1314:	10 e0       	ldi	r17, 0x00	; 0
    1316:	9e 01       	movw	r18, r28
    1318:	2e 5f       	subi	r18, 0xFE	; 254
    131a:	3f 4f       	sbci	r19, 0xFF	; 255
    131c:	c9 01       	movw	r24, r18
    131e:	64 2f       	mov	r22, r20
    1320:	4f 2d       	mov	r20, r15
    1322:	50 e0       	ldi	r21, 0x00	; 0
    1324:	0e 94 b7 36 	call	0x6d6e	; 0x6d6e <memcpy>
	DHCPOptionList[2 + DataLen] = DHCP_OPTION_END;
    1328:	0c 0f       	add	r16, r28
    132a:	1d 1f       	adc	r17, r29
    132c:	f8 01       	movw	r30, r16
    132e:	e2 82       	std	Z+2, r14	; 0x02

	/* Calculate the total number of bytes added to the outgoing packet */
	return (2 + DataLen);
}
    1330:	8f 2d       	mov	r24, r15
    1332:	8e 5f       	subi	r24, 0xFE	; 254
    1334:	df 91       	pop	r29
    1336:	cf 91       	pop	r28
    1338:	1f 91       	pop	r17
    133a:	0f 91       	pop	r16
    133c:	ff 90       	pop	r15
    133e:	ef 90       	pop	r14
    1340:	08 95       	ret

00001342 <DHCPClientApp_GetOption>:
 *  \return Boolean true if the option was found in the DHCP packet's options list, false otherwise
 */
static bool DHCPClientApp_GetOption(const uint8_t* DHCPOptionList,
                                    const uint8_t Option,
                                    void* const Destination)
{
    1342:	fc 01       	movw	r30, r24
    1344:	74 2f       	mov	r23, r20
    1346:	13 c0       	rjmp	.+38     	; 0x136e <DHCPClientApp_GetOption+0x2c>
    1348:	41 81       	ldd	r20, Z+1	; 0x01
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
    134a:	86 17       	cp	r24, r22
    134c:	59 f4       	brne	.+22     	; 0x1364 <DHCPClientApp_GetOption+0x22>
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    134e:	9f 01       	movw	r18, r30
    1350:	2e 5f       	subi	r18, 0xFE	; 254
    1352:	3f 4f       	sbci	r19, 0xFF	; 255
    1354:	87 2f       	mov	r24, r23
    1356:	95 2f       	mov	r25, r21
    1358:	b9 01       	movw	r22, r18
    135a:	50 e0       	ldi	r21, 0x00	; 0
    135c:	0e 94 b7 36 	call	0x6d6e	; 0x6d6e <memcpy>
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	08 95       	ret
			/* Indicate that the requested option data was successfully retrieved */
			return true;
		}

		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
    1364:	84 2f       	mov	r24, r20
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	02 96       	adiw	r24, 0x02	; 2
    136a:	e8 0f       	add	r30, r24
    136c:	f9 1f       	adc	r31, r25
static bool DHCPClientApp_GetOption(const uint8_t* DHCPOptionList,
                                    const uint8_t Option,
                                    void* const Destination)
{
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    136e:	80 81       	ld	r24, Z
    1370:	8f 3f       	cpi	r24, 0xFF	; 255
    1372:	51 f7       	brne	.-44     	; 0x1348 <DHCPClientApp_GetOption+0x6>
    1374:	80 e0       	ldi	r24, 0x00	; 0
		DHCPOptionList += (DHCPOptionList[1] + 2);
	}

	/* Requested option not found in the incoming packet's DHCP options list */
	return false;
}
    1376:	08 95       	ret

00001378 <DHCPClientApp_Callback>:

/** uIP stack application callback for the DHCP client. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPClientApp_Callback(void)
{
    1378:	af 92       	push	r10
    137a:	bf 92       	push	r11
    137c:	cf 92       	push	r12
    137e:	df 92       	push	r13
    1380:	ef 92       	push	r14
    1382:	ff 92       	push	r15
    1384:	0f 93       	push	r16
    1386:	1f 93       	push	r17
    1388:	df 93       	push	r29
    138a:	cf 93       	push	r28
    138c:	00 d0       	rcall	.+0      	; 0x138e <DHCPClientApp_Callback+0x16>
    138e:	00 d0       	rcall	.+0      	; 0x1390 <DHCPClientApp_Callback+0x18>
    1390:	0f 92       	push	r0
    1392:	cd b7       	in	r28, 0x3d	; 61
    1394:	de b7       	in	r29, 0x3e	; 62
	uip_udp_appstate_t* const AppState    = &uip_udp_conn->appstate;
    1396:	a0 90 56 05 	lds	r10, 0x0556
    139a:	b0 90 57 05 	lds	r11, 0x0557
    139e:	a5 01       	movw	r20, r10
    13a0:	47 5f       	subi	r20, 0xF7	; 247
    13a2:	5f 4f       	sbci	r21, 0xFF	; 255
	DHCP_Header_t*      const AppData     = (DHCP_Header_t*)uip_appdata;
    13a4:	00 91 58 05 	lds	r16, 0x0558
    13a8:	10 91 59 05 	lds	r17, 0x0559
	uint16_t                  AppDataSize = 0;

	switch (AppState->DHCPClient.CurrentState)
    13ac:	d5 01       	movw	r26, r10
    13ae:	19 96       	adiw	r26, 0x09	; 9
    13b0:	8c 91       	ld	r24, X
    13b2:	81 30       	cpi	r24, 0x01	; 1
    13b4:	09 f4       	brne	.+2      	; 0x13b8 <DHCPClientApp_Callback+0x40>
    13b6:	45 c0       	rjmp	.+138    	; 0x1442 <DHCPClientApp_Callback+0xca>
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	38 f0       	brcs	.+14     	; 0x13ca <DHCPClientApp_Callback+0x52>
    13bc:	82 30       	cpi	r24, 0x02	; 2
    13be:	09 f4       	brne	.+2      	; 0x13c2 <DHCPClientApp_Callback+0x4a>
    13c0:	90 c0       	rjmp	.+288    	; 0x14e2 <DHCPClientApp_Callback+0x16a>
    13c2:	83 30       	cpi	r24, 0x03	; 3
    13c4:	09 f0       	breq	.+2      	; 0x13c8 <DHCPClientApp_Callback+0x50>
    13c6:	04 c1       	rjmp	.+520    	; 0x15d0 <DHCPClientApp_Callback+0x258>
    13c8:	b3 c0       	rjmp	.+358    	; 0x1530 <DHCPClientApp_Callback+0x1b8>
	{
		case DHCP_STATE_SendDiscover:
			/* Clear all DHCP settings, reset client IP address */
			memset(&AppState->DHCPClient.DHCPOffer_Data, 0x00, sizeof(AppState->DHCPClient.DHCPOffer_Data));
    13ca:	c5 01       	movw	r24, r10
    13cc:	0e 96       	adiw	r24, 0x0e	; 14
    13ce:	fc 01       	movw	r30, r24
    13d0:	80 e1       	ldi	r24, 0x10	; 16
    13d2:	df 01       	movw	r26, r30
    13d4:	1d 92       	st	X+, r1
    13d6:	8a 95       	dec	r24
    13d8:	e9 f7       	brne	.-6      	; 0x13d4 <DHCPClientApp_Callback+0x5c>
			uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    13da:	f5 01       	movw	r30, r10
    13dc:	86 85       	ldd	r24, Z+14	; 0x0e
    13de:	97 85       	ldd	r25, Z+15	; 0x0f
    13e0:	a0 89       	ldd	r26, Z+16	; 0x10
    13e2:	b1 89       	ldd	r27, Z+17	; 0x11
    13e4:	80 93 c1 06 	sts	0x06C1, r24
    13e8:	90 93 c2 06 	sts	0x06C2, r25
    13ec:	a0 93 c3 06 	sts	0x06C3, r26
    13f0:	b0 93 c4 06 	sts	0x06C4, r27

			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_DISCOVER, AppState);
    13f4:	c8 01       	movw	r24, r16
    13f6:	61 e0       	ldi	r22, 0x01	; 1
    13f8:	1e df       	rcall	.-452    	; 0x1236 <DHCPClientApp_FillDHCPHeader>
    13fa:	7c 01       	movw	r14, r24

			/* Add the required DHCP options list to the packet */
			uint8_t RequiredOptionList[] = {DHCP_OPTION_SUBNET_MASK, DHCP_OPTION_ROUTER, DHCP_OPTION_DNS_SERVER};
    13fc:	de 01       	movw	r26, r28
    13fe:	13 96       	adiw	r26, 0x03	; 3
    1400:	e7 e8       	ldi	r30, 0x87	; 135
    1402:	f1 e0       	ldi	r31, 0x01	; 1
    1404:	83 e0       	ldi	r24, 0x03	; 3
    1406:	01 90       	ld	r0, Z+
    1408:	0d 92       	st	X+, r0
    140a:	81 50       	subi	r24, 0x01	; 1
    140c:	e1 f7       	brne	.-8      	; 0x1406 <DHCPClientApp_Callback+0x8e>
			AppDataSize += DHCPClientApp_SetOption(AppData->Options, DHCP_OPTION_REQ_LIST, sizeof(RequiredOptionList),
    140e:	c8 01       	movw	r24, r16
    1410:	80 51       	subi	r24, 0x10	; 16
    1412:	9f 4f       	sbci	r25, 0xFF	; 255
    1414:	67 e3       	ldi	r22, 0x37	; 55
    1416:	43 e0       	ldi	r20, 0x03	; 3
    1418:	9e 01       	movw	r18, r28
    141a:	2d 5f       	subi	r18, 0xFD	; 253
    141c:	3f 4f       	sbci	r19, 0xFF	; 255
    141e:	63 df       	rcall	.-314    	; 0x12e6 <DHCPClientApp_SetOption>
			                                       RequiredOptionList);

			/* Send the DHCP DISCOVER packet */
			uip_udp_send(AppDataSize);
    1420:	e8 0e       	add	r14, r24
    1422:	f1 1c       	adc	r15, r1
    1424:	80 91 58 05 	lds	r24, 0x0558
    1428:	90 91 59 05 	lds	r25, 0x0559
    142c:	b7 01       	movw	r22, r14
    142e:	ac d4       	rcall	.+2392   	; 0x1d88 <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1430:	c5 01       	movw	r24, r10
    1432:	0a 96       	adiw	r24, 0x0a	; 10
    1434:	0e 94 93 19 	call	0x3326	; 0x3326 <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForOffer;
    1438:	81 e0       	ldi	r24, 0x01	; 1
    143a:	d5 01       	movw	r26, r10
    143c:	19 96       	adiw	r26, 0x09	; 9
    143e:	8c 93       	st	X, r24
    1440:	c7 c0       	rjmp	.+398    	; 0x15d0 <DHCPClientApp_Callback+0x258>

			break;
		case DHCP_STATE_WaitForOffer:
			if (!(uip_newdata()))
    1442:	80 91 55 05 	lds	r24, 0x0555
    1446:	81 fd       	sbrc	r24, 1
    1448:	0a c0       	rjmp	.+20     	; 0x145e <DHCPClientApp_Callback+0xe6>
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    144a:	c5 01       	movw	r24, r10
    144c:	0a 96       	adiw	r24, 0x0a	; 10
    144e:	0e 94 9d 19 	call	0x333a	; 0x333a <timer_expired>
    1452:	89 2b       	or	r24, r25
    1454:	09 f4       	brne	.+2      	; 0x1458 <DHCPClientApp_Callback+0xe0>
    1456:	bc c0       	rjmp	.+376    	; 0x15d0 <DHCPClientApp_Callback+0x258>
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1458:	f5 01       	movw	r30, r10
    145a:	11 86       	std	Z+9, r1	; 0x09
    145c:	b9 c0       	rjmp	.+370    	; 0x15d0 <DHCPClientApp_Callback+0x258>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    145e:	f8 01       	movw	r30, r16
    1460:	84 81       	ldd	r24, Z+4	; 0x04
    1462:	95 81       	ldd	r25, Z+5	; 0x05
    1464:	a6 81       	ldd	r26, Z+6	; 0x06
    1466:	b7 81       	ldd	r27, Z+7	; 0x07
    1468:	86 56       	subi	r24, 0x66	; 102
    146a:	94 45       	sbci	r25, 0x54	; 84
    146c:	a4 42       	sbci	r26, 0x24	; 36
    146e:	b3 41       	sbci	r27, 0x13	; 19
    1470:	09 f0       	breq	.+2      	; 0x1474 <DHCPClientApp_Callback+0xfc>
    1472:	ae c0       	rjmp	.+348    	; 0x15d0 <DHCPClientApp_Callback+0x258>
    1474:	80 ef       	ldi	r24, 0xF0	; 240
    1476:	e8 2e       	mov	r14, r24
    1478:	f1 2c       	mov	r15, r1
    147a:	e0 0e       	add	r14, r16
    147c:	f1 1e       	adc	r15, r17
    147e:	c7 01       	movw	r24, r14
    1480:	65 e3       	ldi	r22, 0x35	; 53
    1482:	ae 01       	movw	r20, r28
    1484:	4f 5f       	subi	r20, 0xFF	; 255
    1486:	5f 4f       	sbci	r21, 0xFF	; 255
    1488:	5c df       	rcall	.-328    	; 0x1342 <DHCPClientApp_GetOption>
    148a:	88 23       	and	r24, r24
    148c:	09 f4       	brne	.+2      	; 0x1490 <DHCPClientApp_Callback+0x118>
    148e:	a0 c0       	rjmp	.+320    	; 0x15d0 <DHCPClientApp_Callback+0x258>
    1490:	c9 80       	ldd	r12, Y+1	; 0x01
    1492:	22 e0       	ldi	r18, 0x02	; 2
    1494:	c2 16       	cp	r12, r18
    1496:	09 f0       	breq	.+2      	; 0x149a <DHCPClientApp_Callback+0x122>
    1498:	9b c0       	rjmp	.+310    	; 0x15d0 <DHCPClientApp_Callback+0x258>
			    DHCPClientApp_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
			    (OfferResponse_MessageType == DHCP_OFFER))
			{
				/* Received a DHCP offer for an IP address, copy over values for later request */
				memcpy(&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, &AppData->YourIP, sizeof(uip_ipaddr_t));
    149a:	f8 01       	movw	r30, r16
    149c:	80 89       	ldd	r24, Z+16	; 0x10
    149e:	91 89       	ldd	r25, Z+17	; 0x11
    14a0:	a2 89       	ldd	r26, Z+18	; 0x12
    14a2:	b3 89       	ldd	r27, Z+19	; 0x13
    14a4:	f5 01       	movw	r30, r10
    14a6:	86 87       	std	Z+14, r24	; 0x0e
    14a8:	97 87       	std	Z+15, r25	; 0x0f
    14aa:	a0 8b       	std	Z+16, r26	; 0x10
    14ac:	b1 8b       	std	Z+17, r27	; 0x11
				DHCPClientApp_GetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK, &AppState->DHCPClient.DHCPOffer_Data.Netmask);
    14ae:	a5 01       	movw	r20, r10
    14b0:	4e 5e       	subi	r20, 0xEE	; 238
    14b2:	5f 4f       	sbci	r21, 0xFF	; 255
    14b4:	c7 01       	movw	r24, r14
    14b6:	61 e0       	ldi	r22, 0x01	; 1
    14b8:	44 df       	rcall	.-376    	; 0x1342 <DHCPClientApp_GetOption>
				DHCPClientApp_GetOption(AppData->Options, DHCP_OPTION_ROUTER,      &AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    14ba:	a5 01       	movw	r20, r10
    14bc:	4a 5e       	subi	r20, 0xEA	; 234
    14be:	5f 4f       	sbci	r21, 0xFF	; 255
    14c0:	c7 01       	movw	r24, r14
    14c2:	63 e0       	ldi	r22, 0x03	; 3
    14c4:	3e df       	rcall	.-388    	; 0x1342 <DHCPClientApp_GetOption>
				DHCPClientApp_GetOption(AppData->Options, DHCP_OPTION_SERVER_ID,   &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    14c6:	a5 01       	movw	r20, r10
    14c8:	46 5e       	subi	r20, 0xE6	; 230
    14ca:	5f 4f       	sbci	r21, 0xFF	; 255
    14cc:	c7 01       	movw	r24, r14
    14ce:	66 e3       	ldi	r22, 0x36	; 54
    14d0:	38 df       	rcall	.-400    	; 0x1342 <DHCPClientApp_GetOption>

				timer_reset(&AppState->DHCPClient.Timeout);
    14d2:	c5 01       	movw	r24, r10
    14d4:	0a 96       	adiw	r24, 0x0a	; 10
    14d6:	0e 94 93 19 	call	0x3326	; 0x3326 <timer_reset>
				AppState->DHCPClient.CurrentState = DHCP_STATE_SendRequest;
    14da:	d5 01       	movw	r26, r10
    14dc:	19 96       	adiw	r26, 0x09	; 9
    14de:	cc 92       	st	X, r12
    14e0:	77 c0       	rjmp	.+238    	; 0x15d0 <DHCPClientApp_Callback+0x258>
			}

			break;
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);
    14e2:	c8 01       	movw	r24, r16
    14e4:	63 e0       	ldi	r22, 0x03	; 3
    14e6:	a7 de       	rcall	.-690    	; 0x1236 <DHCPClientApp_FillDHCPHeader>
    14e8:	6c 01       	movw	r12, r24

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPClientApp_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    14ea:	00 51       	subi	r16, 0x10	; 16
    14ec:	1f 4f       	sbci	r17, 0xFF	; 255
    14ee:	95 01       	movw	r18, r10
    14f0:	22 5f       	subi	r18, 0xF2	; 242
    14f2:	3f 4f       	sbci	r19, 0xFF	; 255
    14f4:	c8 01       	movw	r24, r16
    14f6:	62 e3       	ldi	r22, 0x32	; 50
    14f8:	44 e0       	ldi	r20, 0x04	; 4
    14fa:	f5 de       	rcall	.-534    	; 0x12e6 <DHCPClientApp_SetOption>
    14fc:	f8 2e       	mov	r15, r24
			                                       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPClientApp_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    14fe:	95 01       	movw	r18, r10
    1500:	26 5e       	subi	r18, 0xE6	; 230
    1502:	3f 4f       	sbci	r19, 0xFF	; 255
    1504:	c8 01       	movw	r24, r16
    1506:	66 e3       	ldi	r22, 0x36	; 54
    1508:	44 e0       	ldi	r20, 0x04	; 4
    150a:	ed de       	rcall	.-550    	; 0x12e6 <DHCPClientApp_SetOption>
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPClientApp_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    150c:	68 2f       	mov	r22, r24
    150e:	70 e0       	ldi	r23, 0x00	; 0
    1510:	6f 0d       	add	r22, r15
    1512:	71 1d       	adc	r23, r1
			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPClientApp_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
			                                       &AppState->DHCPClient.DHCPOffer_Data.ServerIP);

			/* Send the DHCP REQUEST packet */
			uip_udp_send(AppDataSize);
    1514:	6c 0d       	add	r22, r12
    1516:	7d 1d       	adc	r23, r13
    1518:	80 91 58 05 	lds	r24, 0x0558
    151c:	90 91 59 05 	lds	r25, 0x0559
    1520:	33 d4       	rcall	.+2150   	; 0x1d88 <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1522:	c5 01       	movw	r24, r10
    1524:	0a 96       	adiw	r24, 0x0a	; 10
    1526:	0e 94 93 19 	call	0x3326	; 0x3326 <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForACK;
    152a:	83 e0       	ldi	r24, 0x03	; 3
    152c:	f5 01       	movw	r30, r10
    152e:	4f c0       	rjmp	.+158    	; 0x15ce <DHCPClientApp_Callback+0x256>

			break;
		case DHCP_STATE_WaitForACK:
			if (!(uip_newdata()))
    1530:	80 91 55 05 	lds	r24, 0x0555
    1534:	81 fd       	sbrc	r24, 1
    1536:	0b c0       	rjmp	.+22     	; 0x154e <DHCPClientApp_Callback+0x1d6>
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    1538:	c5 01       	movw	r24, r10
    153a:	0a 96       	adiw	r24, 0x0a	; 10
    153c:	0e 94 9d 19 	call	0x333a	; 0x333a <timer_expired>
    1540:	89 2b       	or	r24, r25
    1542:	09 f4       	brne	.+2      	; 0x1546 <DHCPClientApp_Callback+0x1ce>
    1544:	45 c0       	rjmp	.+138    	; 0x15d0 <DHCPClientApp_Callback+0x258>
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1546:	d5 01       	movw	r26, r10
    1548:	19 96       	adiw	r26, 0x09	; 9
    154a:	1c 92       	st	X, r1
    154c:	41 c0       	rjmp	.+130    	; 0x15d0 <DHCPClientApp_Callback+0x258>

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    154e:	f8 01       	movw	r30, r16
    1550:	84 81       	ldd	r24, Z+4	; 0x04
    1552:	95 81       	ldd	r25, Z+5	; 0x05
    1554:	a6 81       	ldd	r26, Z+6	; 0x06
    1556:	b7 81       	ldd	r27, Z+7	; 0x07
    1558:	86 56       	subi	r24, 0x66	; 102
    155a:	94 45       	sbci	r25, 0x54	; 84
    155c:	a4 42       	sbci	r26, 0x24	; 36
    155e:	b3 41       	sbci	r27, 0x13	; 19
    1560:	b9 f5       	brne	.+110    	; 0x15d0 <DHCPClientApp_Callback+0x258>
    1562:	c8 01       	movw	r24, r16
    1564:	80 51       	subi	r24, 0x10	; 16
    1566:	9f 4f       	sbci	r25, 0xFF	; 255
    1568:	65 e3       	ldi	r22, 0x35	; 53
    156a:	ae 01       	movw	r20, r28
    156c:	4e 5f       	subi	r20, 0xFE	; 254
    156e:	5f 4f       	sbci	r21, 0xFF	; 255
    1570:	e8 de       	rcall	.-560    	; 0x1342 <DHCPClientApp_GetOption>
    1572:	88 23       	and	r24, r24
    1574:	69 f1       	breq	.+90     	; 0x15d0 <DHCPClientApp_Callback+0x258>
    1576:	8a 81       	ldd	r24, Y+2	; 0x02
    1578:	85 30       	cpi	r24, 0x05	; 5
    157a:	51 f5       	brne	.+84     	; 0x15d0 <DHCPClientApp_Callback+0x258>
			    DHCPClientApp_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
			    (RequestResponse_MessageType == DHCP_ACK))
			{
				/* Set the new network parameters from the DHCP server */
				uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    157c:	f5 01       	movw	r30, r10
    157e:	86 85       	ldd	r24, Z+14	; 0x0e
    1580:	97 85       	ldd	r25, Z+15	; 0x0f
    1582:	a0 89       	ldd	r26, Z+16	; 0x10
    1584:	b1 89       	ldd	r27, Z+17	; 0x11
    1586:	80 93 c1 06 	sts	0x06C1, r24
    158a:	90 93 c2 06 	sts	0x06C2, r25
    158e:	a0 93 c3 06 	sts	0x06C3, r26
    1592:	b0 93 c4 06 	sts	0x06C4, r27
				uip_setnetmask((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.Netmask);
    1596:	82 89       	ldd	r24, Z+18	; 0x12
    1598:	93 89       	ldd	r25, Z+19	; 0x13
    159a:	a4 89       	ldd	r26, Z+20	; 0x14
    159c:	b5 89       	ldd	r27, Z+21	; 0x15
    159e:	80 93 bd 06 	sts	0x06BD, r24
    15a2:	90 93 be 06 	sts	0x06BE, r25
    15a6:	a0 93 bf 06 	sts	0x06BF, r26
    15aa:	b0 93 c0 06 	sts	0x06C0, r27
				uip_setdraddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    15ae:	86 89       	ldd	r24, Z+22	; 0x16
    15b0:	97 89       	ldd	r25, Z+23	; 0x17
    15b2:	a0 8d       	ldd	r26, Z+24	; 0x18
    15b4:	b1 8d       	ldd	r27, Z+25	; 0x19
    15b6:	80 93 b9 06 	sts	0x06B9, r24
    15ba:	90 93 ba 06 	sts	0x06BA, r25
    15be:	a0 93 bb 06 	sts	0x06BB, r26
    15c2:	b0 93 bc 06 	sts	0x06BC, r27

				/* Indicate to the user that we now have a valid IP configuration */
				HaveIPConfiguration = true;
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	80 93 20 03 	sts	0x0320, r24

				AppState->DHCPClient.CurrentState = DHCP_STATE_AddressLeased;
    15cc:	84 e0       	ldi	r24, 0x04	; 4
    15ce:	81 87       	std	Z+9, r24	; 0x09
			}

			break;
	}
}
    15d0:	0f 90       	pop	r0
    15d2:	0f 90       	pop	r0
    15d4:	0f 90       	pop	r0
    15d6:	0f 90       	pop	r0
    15d8:	0f 90       	pop	r0
    15da:	cf 91       	pop	r28
    15dc:	df 91       	pop	r29
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	ff 90       	pop	r15
    15e4:	ef 90       	pop	r14
    15e6:	df 90       	pop	r13
    15e8:	cf 90       	pop	r12
    15ea:	bf 90       	pop	r11
    15ec:	af 90       	pop	r10
    15ee:	08 95       	ret

000015f0 <DHCPClientApp_Init>:

/** Initialization function for the DHCP client. */
void DHCPClientApp_Init(void)
{
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* Connection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCPC_SERVER_PORT));
    15f0:	87 e6       	ldi	r24, 0x67	; 103
    15f2:	92 e0       	ldi	r25, 0x02	; 2
    15f4:	60 e0       	ldi	r22, 0x00	; 0
    15f6:	73 e4       	ldi	r23, 0x43	; 67
    15f8:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <uip_udp_new>
    15fc:	fc 01       	movw	r30, r24

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (Connection != NULL)
    15fe:	00 97       	sbiw	r24, 0x00	; 0
    1600:	59 f0       	breq	.+22     	; 0x1618 <DHCPClientApp_Init+0x28>
	{
		uip_udp_appstate_t* const AppState = &Connection->appstate;
		uip_udp_bind(Connection, HTONS(DHCPC_CLIENT_PORT));
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	94 e4       	ldi	r25, 0x44	; 68
    1606:	95 83       	std	Z+5, r25	; 0x05
    1608:	84 83       	std	Z+4, r24	; 0x04

		/* Set the initial client state */
		AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    160a:	11 86       	std	Z+9, r1	; 0x09

		/* Set timeout period to half a second for a DHCP server to respond */
		timer_set(&AppState->DHCPClient.Timeout, CLOCK_SECOND / 2);
    160c:	cf 01       	movw	r24, r30
    160e:	0a 96       	adiw	r24, 0x0a	; 10
    1610:	62 e3       	ldi	r22, 0x32	; 50
    1612:	70 e0       	ldi	r23, 0x00	; 0
    1614:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <timer_set>
    1618:	08 95       	ret

0000161a <HTTPServerApp_Callback>:

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
{
    161a:	af 92       	push	r10
    161c:	bf 92       	push	r11
    161e:	cf 92       	push	r12
    1620:	df 92       	push	r13
    1622:	ef 92       	push	r14
    1624:	ff 92       	push	r15
    1626:	0f 93       	push	r16
    1628:	1f 93       	push	r17
    162a:	cf 93       	push	r28
    162c:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState = &uip_conn->appstate;
    162e:	c0 91 5a 05 	lds	r28, 0x055A
    1632:	d0 91 5b 05 	lds	r29, 0x055B

	if (uip_aborted() || uip_timedout() || uip_closed())
    1636:	80 91 55 05 	lds	r24, 0x0555
    163a:	85 fd       	sbrc	r24, 5
    163c:	04 c0       	rjmp	.+8      	; 0x1646 <HTTPServerApp_Callback+0x2c>
    163e:	87 fd       	sbrc	r24, 7
    1640:	02 c0       	rjmp	.+4      	; 0x1646 <HTTPServerApp_Callback+0x2c>
    1642:	84 ff       	sbrs	r24, 4
    1644:	03 c0       	rjmp	.+6      	; 0x164c <HTTPServerApp_Callback+0x32>
	{
		/* Lock to the closed state so that no further processing will occur on the connection */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_Closing;
    1646:	83 e0       	ldi	r24, 0x03	; 3
    1648:	8c 8f       	std	Y+28, r24	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_Closing;
    164a:	8d 8f       	std	Y+29, r24	; 0x1d
	}

	if (uip_connected())
    164c:	80 91 55 05 	lds	r24, 0x0555
    1650:	86 ff       	sbrs	r24, 6
    1652:	0d c0       	rjmp	.+26     	; 0x166e <HTTPServerApp_Callback+0x54>
	{
		/* New connection - initialize connection state values */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_OpenRequestedFile;
    1654:	1c 8e       	std	Y+28, r1	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_OpenRequestedFile;
    1656:	1d 8e       	std	Y+29, r1	; 0x1d
		AppState->HTTPServer.FileOpen      = false;
    1658:	c6 59       	subi	r28, 0x96	; 150
    165a:	df 4f       	sbci	r29, 0xFF	; 255
    165c:	19 92       	st	Y+, r1
		AppState->HTTPServer.ACKedFilePos  = 0;
    165e:	19 92       	st	Y+, r1
    1660:	19 92       	st	Y+, r1
    1662:	19 92       	st	Y+, r1
    1664:	19 92       	st	Y+, r1
		AppState->HTTPServer.SentChunkSize = 0;
    1666:	19 82       	std	Y+1, r1	; 0x01
    1668:	18 82       	st	Y, r1
    166a:	cf 56       	subi	r28, 0x6F	; 111
    166c:	d0 40       	sbci	r29, 0x00	; 0
	}

	if (uip_acked())
    166e:	80 91 55 05 	lds	r24, 0x0555
    1672:	80 ff       	sbrs	r24, 0
    1674:	19 c0       	rjmp	.+50     	; 0x16a8 <HTTPServerApp_Callback+0x8e>
	{
		/* Add the amount of ACKed file data to the total sent file bytes counter */
		AppState->HTTPServer.ACKedFilePos += AppState->HTTPServer.SentChunkSize;
    1676:	fe 01       	movw	r30, r28
    1678:	e5 59       	subi	r30, 0x95	; 149
    167a:	ff 4f       	sbci	r31, 0xFF	; 255
    167c:	c1 59       	subi	r28, 0x91	; 145
    167e:	df 4f       	sbci	r29, 0xFF	; 255
    1680:	88 81       	ld	r24, Y
    1682:	99 81       	ldd	r25, Y+1	; 0x01
    1684:	cf 56       	subi	r28, 0x6F	; 111
    1686:	d0 40       	sbci	r29, 0x00	; 0
    1688:	a0 e0       	ldi	r26, 0x00	; 0
    168a:	b0 e0       	ldi	r27, 0x00	; 0
    168c:	20 81       	ld	r18, Z
    168e:	31 81       	ldd	r19, Z+1	; 0x01
    1690:	42 81       	ldd	r20, Z+2	; 0x02
    1692:	53 81       	ldd	r21, Z+3	; 0x03
    1694:	82 0f       	add	r24, r18
    1696:	93 1f       	adc	r25, r19
    1698:	a4 1f       	adc	r26, r20
    169a:	b5 1f       	adc	r27, r21
    169c:	80 83       	st	Z, r24
    169e:	91 83       	std	Z+1, r25	; 0x01
    16a0:	a2 83       	std	Z+2, r26	; 0x02
    16a2:	b3 83       	std	Z+3, r27	; 0x03

		/* Progress to the next state once the current state's data has been ACKed */
		AppState->HTTPServer.CurrentState = AppState->HTTPServer.NextState;
    16a4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16a6:	8c 8f       	std	Y+28, r24	; 0x1c
	}

	if (uip_rexmit())
    16a8:	80 91 55 05 	lds	r24, 0x0555
    16ac:	82 ff       	sbrs	r24, 2
    16ae:	0d c0       	rjmp	.+26     	; 0x16ca <HTTPServerApp_Callback+0xb0>
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
    16b0:	c5 59       	subi	r28, 0x95	; 149
    16b2:	df 4f       	sbci	r29, 0xFF	; 255
    16b4:	48 81       	ld	r20, Y
    16b6:	59 81       	ldd	r21, Y+1	; 0x01
    16b8:	6a 81       	ldd	r22, Y+2	; 0x02
    16ba:	7b 81       	ldd	r23, Y+3	; 0x03
    16bc:	cb 56       	subi	r28, 0x6B	; 107
    16be:	d0 40       	sbci	r29, 0x00	; 0
    16c0:	ce 01       	movw	r24, r28
    16c2:	80 5b       	subi	r24, 0xB0	; 176
    16c4:	9f 4f       	sbci	r25, 0xFF	; 255
    16c6:	0e 94 09 1c 	call	0x3812	; 0x3812 <f_lseek>
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    16ca:	80 91 55 05 	lds	r24, 0x0555
    16ce:	28 2f       	mov	r18, r24
    16d0:	30 e0       	ldi	r19, 0x00	; 0
    16d2:	82 fd       	sbrc	r24, 2
    16d4:	0b c0       	rjmp	.+22     	; 0x16ec <HTTPServerApp_Callback+0xd2>
    16d6:	c9 01       	movw	r24, r18
    16d8:	83 70       	andi	r24, 0x03	; 3
    16da:	90 70       	andi	r25, 0x00	; 0
    16dc:	89 2b       	or	r24, r25
    16de:	31 f4       	brne	.+12     	; 0x16ec <HTTPServerApp_Callback+0xd2>
    16e0:	c9 01       	movw	r24, r18
    16e2:	88 74       	andi	r24, 0x48	; 72
    16e4:	90 70       	andi	r25, 0x00	; 0
    16e6:	89 2b       	or	r24, r25
    16e8:	09 f4       	brne	.+2      	; 0x16ec <HTTPServerApp_Callback+0xd2>
    16ea:	36 c1       	rjmp	.+620    	; 0x1958 <HTTPServerApp_Callback+0x33e>
	{
		switch (AppState->HTTPServer.CurrentState)
    16ec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    16ee:	81 30       	cpi	r24, 0x01	; 1
    16f0:	09 f4       	brne	.+2      	; 0x16f4 <HTTPServerApp_Callback+0xda>
    16f2:	67 c0       	rjmp	.+206    	; 0x17c2 <HTTPServerApp_Callback+0x1a8>
    16f4:	81 30       	cpi	r24, 0x01	; 1
    16f6:	38 f0       	brcs	.+14     	; 0x1706 <HTTPServerApp_Callback+0xec>
    16f8:	82 30       	cpi	r24, 0x02	; 2
    16fa:	09 f4       	brne	.+2      	; 0x16fe <HTTPServerApp_Callback+0xe4>
    16fc:	fb c0       	rjmp	.+502    	; 0x18f4 <HTTPServerApp_Callback+0x2da>
    16fe:	83 30       	cpi	r24, 0x03	; 3
    1700:	09 f0       	breq	.+2      	; 0x1704 <HTTPServerApp_Callback+0xea>
    1702:	2a c1       	rjmp	.+596    	; 0x1958 <HTTPServerApp_Callback+0x33e>
    1704:	19 c1       	rjmp	.+562    	; 0x1938 <HTTPServerApp_Callback+0x31e>
/** HTTP Server State handler for the Request Process state. This state manages the processing of incoming HTTP
 *  GET requests to the server from the receiving HTTP client.
 */
static void HTTPServerApp_OpenRequestedFile(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1706:	e0 90 5a 05 	lds	r14, 0x055A
    170a:	f0 90 5b 05 	lds	r15, 0x055B
	char*               const AppData     = (char*)uip_appdata;
    170e:	80 91 58 05 	lds	r24, 0x0558
    1712:	90 91 59 05 	lds	r25, 0x0559

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
    1716:	21 ff       	sbrs	r18, 1
    1718:	1f c1       	rjmp	.+574    	; 0x1958 <HTTPServerApp_Callback+0x33e>
	  return;

	char* RequestToken      = strtok(AppData, " ");
    171a:	6a e8       	ldi	r22, 0x8A	; 138
    171c:	71 e0       	ldi	r23, 0x01	; 1
    171e:	0e 94 b4 36 	call	0x6d68	; 0x6d68 <strtok>
    1722:	8c 01       	movw	r16, r24
	char* RequestedFileName = strtok(NULL, " ");
    1724:	80 e0       	ldi	r24, 0x00	; 0
    1726:	90 e0       	ldi	r25, 0x00	; 0
    1728:	6a e8       	ldi	r22, 0x8A	; 138
    172a:	71 e0       	ldi	r23, 0x01	; 1
    172c:	0e 94 b4 36 	call	0x6d68	; 0x6d68 <strtok>
    1730:	ec 01       	movw	r28, r24

	/* Must be a GET request, abort otherwise */
	if (strcmp_P(RequestToken, PSTR("GET")) != 0)
    1732:	c8 01       	movw	r24, r16
    1734:	64 e0       	ldi	r22, 0x04	; 4
    1736:	72 e0       	ldi	r23, 0x02	; 2
    1738:	0e 94 95 36 	call	0x6d2a	; 0x6d2a <strcmp_P>
    173c:	89 2b       	or	r24, r25
    173e:	21 f0       	breq	.+8      	; 0x1748 <HTTPServerApp_Callback+0x12e>
	{
		uip_abort();
    1740:	80 e2       	ldi	r24, 0x20	; 32
    1742:	80 93 55 05 	sts	0x0555, r24
    1746:	08 c1       	rjmp	.+528    	; 0x1958 <HTTPServerApp_Callback+0x33e>
		return;
	}

	/* Copy over the requested filename */
	strncpy(AppState->HTTPServer.FileName, &RequestedFileName[1], (sizeof(AppState->HTTPServer.FileName) - 1));
    1748:	87 01       	movw	r16, r14
    174a:	02 5e       	subi	r16, 0xE2	; 226
    174c:	1f 4f       	sbci	r17, 0xFF	; 255
    174e:	21 96       	adiw	r28, 0x01	; 1
    1750:	c8 01       	movw	r24, r16
    1752:	be 01       	movw	r22, r28
    1754:	41 e3       	ldi	r20, 0x31	; 49
    1756:	50 e0       	ldi	r21, 0x00	; 0
    1758:	0e 94 e2 36 	call	0x6dc4	; 0x6dc4 <strncpy>

	/* Ensure filename is null-terminated */
	AppState->HTTPServer.FileName[sizeof(AppState->HTTPServer.FileName) - 1] = 0x00;
    175c:	e7 01       	movw	r28, r14
    175e:	c1 5b       	subi	r28, 0xB1	; 177
    1760:	df 4f       	sbci	r29, 0xFF	; 255
    1762:	18 82       	st	Y, r1

	/* Determine the length of the URI so that it can be checked to see if it is a directory */
	uint8_t FileNameLen = strlen(AppState->HTTPServer.FileName);
    1764:	f8 01       	movw	r30, r16
    1766:	01 90       	ld	r0, Z+
    1768:	00 20       	and	r0, r0
    176a:	e9 f7       	brne	.-6      	; 0x1766 <HTTPServerApp_Callback+0x14c>
    176c:	31 97       	sbiw	r30, 0x01	; 1
    176e:	e0 1b       	sub	r30, r16

	/* If the URI is a directory, append the default filename */
	if (AppState->HTTPServer.FileName[FileNameLen - 1] == '/')
    1770:	2e 2f       	mov	r18, r30
    1772:	30 e0       	ldi	r19, 0x00	; 0
    1774:	f7 01       	movw	r30, r14
    1776:	e2 0f       	add	r30, r18
    1778:	f3 1f       	adc	r31, r19
    177a:	85 8d       	ldd	r24, Z+29	; 0x1d
    177c:	8f 32       	cpi	r24, 0x2F	; 47
    177e:	71 f4       	brne	.+28     	; 0x179c <HTTPServerApp_Callback+0x182>
	{
		strncpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
    1780:	42 e3       	ldi	r20, 0x32	; 50
    1782:	50 e0       	ldi	r21, 0x00	; 0
    1784:	42 1b       	sub	r20, r18
    1786:	53 0b       	sbc	r21, r19
    1788:	22 5e       	subi	r18, 0xE2	; 226
    178a:	3f 4f       	sbci	r19, 0xFF	; 255
    178c:	c7 01       	movw	r24, r14
    178e:	82 0f       	add	r24, r18
    1790:	93 1f       	adc	r25, r19
    1792:	6f ee       	ldi	r22, 0xEF	; 239
    1794:	71 e0       	ldi	r23, 0x01	; 1
    1796:	0e 94 a5 36 	call	0x6d4a	; 0x6d4a <strncpy_P>
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));

		/* Ensure altered filename is still null-terminated */
		AppState->HTTPServer.FileName[sizeof(AppState->HTTPServer.FileName) - 1] = 0x00;
    179a:	18 82       	st	Y, r1
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    179c:	c7 01       	movw	r24, r14
    179e:	80 5b       	subi	r24, 0xB0	; 176
    17a0:	9f 4f       	sbci	r25, 0xFF	; 255
    17a2:	b8 01       	movw	r22, r16
    17a4:	41 e0       	ldi	r20, 0x01	; 1
    17a6:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <f_open>
    17aa:	f7 01       	movw	r30, r14
    17ac:	e6 59       	subi	r30, 0x96	; 150
    17ae:	ff 4f       	sbci	r31, 0xFF	; 255
    17b0:	10 82       	st	Z, r1
    17b2:	88 23       	and	r24, r24
    17b4:	11 f4       	brne	.+4      	; 0x17ba <HTTPServerApp_Callback+0x1a0>
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	80 83       	st	Z, r24
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);

	/* Lock to the SendResponseHeader state until connection terminated */
	AppState->HTTPServer.CurrentState = WEBSERVER_STATE_SendResponseHeader;
    17ba:	81 e0       	ldi	r24, 0x01	; 1
    17bc:	f7 01       	movw	r30, r14
    17be:	84 8f       	std	Z+28, r24	; 0x1c
    17c0:	97 c0       	rjmp	.+302    	; 0x18f0 <HTTPServerApp_Callback+0x2d6>
/** HTTP Server State handler for the HTTP Response Header Send state. This state manages the transmission of
 *  the HTTP response header to the receiving HTTP client.
 */
static void HTTPServerApp_SendResponseHeader(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    17c2:	a0 90 5a 05 	lds	r10, 0x055A
    17c6:	b0 90 5b 05 	lds	r11, 0x055B
	char*               const AppData     = (char*)uip_appdata;
    17ca:	e0 90 58 05 	lds	r14, 0x0558
    17ce:	f0 90 59 05 	lds	r15, 0x0559

	char* Extension     = strpbrk(AppState->HTTPServer.FileName, ".");
    17d2:	e5 01       	movw	r28, r10
    17d4:	6e 96       	adiw	r28, 0x1e	; 30
    17d6:	ce 01       	movw	r24, r28
    17d8:	6e e2       	ldi	r22, 0x2E	; 46
    17da:	70 e0       	ldi	r23, 0x00	; 0
    17dc:	0e 94 c7 36 	call	0x6d8e	; 0x6d8e <strchr>
    17e0:	8c 01       	movw	r16, r24
	bool  FoundMIMEType = false;

	/* If the file isn't already open, it wasn't found - send back a 404 error response and abort */
	if (!(AppState->HTTPServer.FileOpen))
    17e2:	2a e6       	ldi	r18, 0x6A	; 106
    17e4:	30 e0       	ldi	r19, 0x00	; 0
    17e6:	a2 0e       	add	r10, r18
    17e8:	b3 1e       	adc	r11, r19
    17ea:	f5 01       	movw	r30, r10
    17ec:	80 81       	ld	r24, Z
    17ee:	26 e9       	ldi	r18, 0x96	; 150
    17f0:	3f ef       	ldi	r19, 0xFF	; 255
    17f2:	a2 0e       	add	r10, r18
    17f4:	b3 1e       	adc	r11, r19
    17f6:	88 23       	and	r24, r24
    17f8:	f1 f4       	brne	.+60     	; 0x1836 <HTTPServerApp_Callback+0x21c>
	{
		/* Copy over the HTTP 404 response header and send it to the receiving client */
		strcpy_P(AppData, HTTP404Header);
    17fa:	c7 01       	movw	r24, r14
    17fc:	63 e6       	ldi	r22, 0x63	; 99
    17fe:	71 e0       	ldi	r23, 0x01	; 1
    1800:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>
		strcpy(&AppData[strlen(AppData)], AppState->HTTPServer.FileName);
    1804:	f7 01       	movw	r30, r14
    1806:	01 90       	ld	r0, Z+
    1808:	00 20       	and	r0, r0
    180a:	e9 f7       	brne	.-6      	; 0x1806 <HTTPServerApp_Callback+0x1ec>
    180c:	31 97       	sbiw	r30, 0x01	; 1
    180e:	ee 19       	sub	r30, r14
    1810:	ff 09       	sbc	r31, r15
    1812:	c7 01       	movw	r24, r14
    1814:	8e 0f       	add	r24, r30
    1816:	9f 1f       	adc	r25, r31
    1818:	be 01       	movw	r22, r28
    181a:	0e 94 db 36 	call	0x6db6	; 0x6db6 <strcpy>
		uip_send(AppData, strlen(AppData));
    181e:	f7 01       	movw	r30, r14
    1820:	01 90       	ld	r0, Z+
    1822:	00 20       	and	r0, r0
    1824:	e9 f7       	brne	.-6      	; 0x1820 <HTTPServerApp_Callback+0x206>
    1826:	31 97       	sbiw	r30, 0x01	; 1
    1828:	ee 19       	sub	r30, r14
    182a:	ff 09       	sbc	r31, r15
    182c:	c7 01       	movw	r24, r14
    182e:	bf 01       	movw	r22, r30
    1830:	ab d2       	rcall	.+1366   	; 0x1d88 <uip_send>

		AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1832:	83 e0       	ldi	r24, 0x03	; 3
    1834:	5c c0       	rjmp	.+184    	; 0x18ee <HTTPServerApp_Callback+0x2d4>
		return;
	}

	/* Copy over the HTTP 200 response header and send it to the receiving client */
	strcpy_P(AppData, HTTP200Header);
    1836:	c7 01       	movw	r24, r14
    1838:	68 e0       	ldi	r22, 0x08	; 8
    183a:	71 e0       	ldi	r23, 0x01	; 1
    183c:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
    1840:	01 15       	cp	r16, r1
    1842:	11 05       	cpc	r17, r1
    1844:	69 f1       	breq	.+90     	; 0x18a0 <HTTPServerApp_Callback+0x286>
    1846:	9f e3       	ldi	r25, 0x3F	; 63
    1848:	c9 2e       	mov	r12, r25
    184a:	92 e0       	ldi	r25, 0x02	; 2
    184c:	d9 2e       	mov	r13, r25
    184e:	c0 e0       	ldi	r28, 0x00	; 0
    1850:	d0 e0       	ldi	r29, 0x00	; 0
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
		{
			if (strcmp(&Extension[1], MIMETypes[i].Extension) == 0)
    1852:	0f 5f       	subi	r16, 0xFF	; 255
    1854:	1f 4f       	sbci	r17, 0xFF	; 255
    1856:	f6 01       	movw	r30, r12
    1858:	60 81       	ld	r22, Z
    185a:	71 81       	ldd	r23, Z+1	; 0x01
    185c:	c8 01       	movw	r24, r16
    185e:	0e 94 d2 36 	call	0x6da4	; 0x6da4 <strcmp>
    1862:	00 97       	sbiw	r24, 0x00	; 0
    1864:	a9 f4       	brne	.+42     	; 0x1890 <HTTPServerApp_Callback+0x276>
			{
				strcpy(&AppData[strlen(AppData)], MIMETypes[i].MIMEType);
    1866:	d7 01       	movw	r26, r14
    1868:	0d 90       	ld	r0, X+
    186a:	00 20       	and	r0, r0
    186c:	e9 f7       	brne	.-6      	; 0x1868 <HTTPServerApp_Callback+0x24e>
    186e:	11 97       	sbiw	r26, 0x01	; 1
    1870:	ae 19       	sub	r26, r14
    1872:	bf 09       	sbc	r27, r15
    1874:	cc 0f       	add	r28, r28
    1876:	dd 1f       	adc	r29, r29
    1878:	cc 0f       	add	r28, r28
    187a:	dd 1f       	adc	r29, r29
    187c:	cf 5b       	subi	r28, 0xBF	; 191
    187e:	dd 4f       	sbci	r29, 0xFD	; 253
    1880:	68 81       	ld	r22, Y
    1882:	79 81       	ldd	r23, Y+1	; 0x01
    1884:	c7 01       	movw	r24, r14
    1886:	8a 0f       	add	r24, r26
    1888:	9b 1f       	adc	r25, r27
    188a:	0e 94 db 36 	call	0x6db6	; 0x6db6 <strcpy>
    188e:	16 c0       	rjmp	.+44     	; 0x18bc <HTTPServerApp_Callback+0x2a2>
    1890:	21 96       	adiw	r28, 0x01	; 1
    1892:	24 e0       	ldi	r18, 0x04	; 4
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	c2 0e       	add	r12, r18
    1898:	d3 1e       	adc	r13, r19

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
    189a:	ca 30       	cpi	r28, 0x0A	; 10
    189c:	d1 05       	cpc	r29, r1
    189e:	d9 f6       	brne	.-74     	; 0x1856 <HTTPServerApp_Callback+0x23c>

	/* Check if a MIME type was found and copied to the output buffer */
	if (!(FoundMIMEType))
	{
		/* MIME type not found - copy over the default MIME type */
		strcpy_P(&AppData[strlen(AppData)], DefaultMIMEType);
    18a0:	f7 01       	movw	r30, r14
    18a2:	01 90       	ld	r0, Z+
    18a4:	00 20       	and	r0, r0
    18a6:	e9 f7       	brne	.-6      	; 0x18a2 <HTTPServerApp_Callback+0x288>
    18a8:	31 97       	sbiw	r30, 0x01	; 1
    18aa:	ee 19       	sub	r30, r14
    18ac:	ff 09       	sbc	r31, r15
    18ae:	c7 01       	movw	r24, r14
    18b0:	8e 0f       	add	r24, r30
    18b2:	9f 1f       	adc	r25, r31
    18b4:	69 ef       	ldi	r22, 0xF9	; 249
    18b6:	71 e0       	ldi	r23, 0x01	; 1
    18b8:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>
	}

	/* Add the end-of-line terminator and end-of-headers terminator after the MIME type */
	strcpy_P(&AppData[strlen(AppData)], PSTR("\r\n\r\n"));
    18bc:	f7 01       	movw	r30, r14
    18be:	01 90       	ld	r0, Z+
    18c0:	00 20       	and	r0, r0
    18c2:	e9 f7       	brne	.-6      	; 0x18be <HTTPServerApp_Callback+0x2a4>
    18c4:	31 97       	sbiw	r30, 0x01	; 1
    18c6:	ee 19       	sub	r30, r14
    18c8:	ff 09       	sbc	r31, r15
    18ca:	c7 01       	movw	r24, r14
    18cc:	8e 0f       	add	r24, r30
    18ce:	9f 1f       	adc	r25, r31
    18d0:	68 e0       	ldi	r22, 0x08	; 8
    18d2:	72 e0       	ldi	r23, 0x02	; 2
    18d4:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>

	/* Send the MIME header to the receiving client */
	uip_send(AppData, strlen(AppData));
    18d8:	f7 01       	movw	r30, r14
    18da:	01 90       	ld	r0, Z+
    18dc:	00 20       	and	r0, r0
    18de:	e9 f7       	brne	.-6      	; 0x18da <HTTPServerApp_Callback+0x2c0>
    18e0:	31 97       	sbiw	r30, 0x01	; 1
    18e2:	ee 19       	sub	r30, r14
    18e4:	ff 09       	sbc	r31, r15
    18e6:	c7 01       	movw	r24, r14
    18e8:	bf 01       	movw	r22, r30
    18ea:	4e d2       	rcall	.+1180   	; 0x1d88 <uip_send>

	/* When the MIME header is ACKed, progress to the data send stage */
	AppState->HTTPServer.NextState = WEBSERVER_STATE_SendData;
    18ec:	82 e0       	ldi	r24, 0x02	; 2
    18ee:	f5 01       	movw	r30, r10
    18f0:	85 8f       	std	Z+29, r24	; 0x1d
    18f2:	32 c0       	rjmp	.+100    	; 0x1958 <HTTPServerApp_Callback+0x33e>
/** HTTP Server State handler for the Data Send state. This state manages the transmission of file chunks
 *  to the receiving HTTP client.
 */
static void HTTPServerApp_SendData(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    18f4:	c0 91 5a 05 	lds	r28, 0x055A
    18f8:	d0 91 5b 05 	lds	r29, 0x055B
	char*               const AppData     = (char*)uip_appdata;
    18fc:	e0 90 58 05 	lds	r14, 0x0558
    1900:	f0 90 59 05 	lds	r15, 0x0559

	/* Get the maximum segment size for the current packet */
	uint16_t MaxChunkSize = uip_mss();
    1904:	ca 88       	ldd	r12, Y+18	; 0x12
    1906:	db 88       	ldd	r13, Y+19	; 0x13

	/* Read the next chunk of data from the open file */
	f_read(&AppState->HTTPServer.FileHandle, AppData, MaxChunkSize, &AppState->HTTPServer.SentChunkSize);
    1908:	8e 01       	movw	r16, r28
    190a:	01 59       	subi	r16, 0x91	; 145
    190c:	1f 4f       	sbci	r17, 0xFF	; 255
    190e:	ce 01       	movw	r24, r28
    1910:	80 5b       	subi	r24, 0xB0	; 176
    1912:	9f 4f       	sbci	r25, 0xFF	; 255
    1914:	b7 01       	movw	r22, r14
    1916:	a6 01       	movw	r20, r12
    1918:	98 01       	movw	r18, r16
    191a:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <f_read>

	/* Send the next file chunk to the receiving client */
	uip_send(AppData, AppState->HTTPServer.SentChunkSize);
    191e:	f8 01       	movw	r30, r16
    1920:	60 81       	ld	r22, Z
    1922:	71 81       	ldd	r23, Z+1	; 0x01
    1924:	c7 01       	movw	r24, r14
    1926:	30 d2       	rcall	.+1120   	; 0x1d88 <uip_send>

	/* Check if we are at the last chunk of the file, if so next ACK should close the connection */
	if (MaxChunkSize != AppState->HTTPServer.SentChunkSize)
    1928:	f8 01       	movw	r30, r16
    192a:	80 81       	ld	r24, Z
    192c:	91 81       	ldd	r25, Z+1	; 0x01
    192e:	c8 16       	cp	r12, r24
    1930:	d9 06       	cpc	r13, r25
    1932:	91 f0       	breq	.+36     	; 0x1958 <HTTPServerApp_Callback+0x33e>
	  AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1934:	83 e0       	ldi	r24, 0x03	; 3
    1936:	0f c0       	rjmp	.+30     	; 0x1956 <HTTPServerApp_Callback+0x33c>
			case WEBSERVER_STATE_SendData:
				HTTPServerApp_SendData();
				break;
			case WEBSERVER_STATE_Closing:
				/* Connection is being terminated for some reason - close file handle */
				f_close(&AppState->HTTPServer.FileHandle);
    1938:	ce 01       	movw	r24, r28
    193a:	80 5b       	subi	r24, 0xB0	; 176
    193c:	9f 4f       	sbci	r25, 0xFF	; 255
    193e:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <f_close>
				AppState->HTTPServer.FileOpen = false;
    1942:	c6 59       	subi	r28, 0x96	; 150
    1944:	df 4f       	sbci	r29, 0xFF	; 255
    1946:	18 82       	st	Y, r1
    1948:	ca 56       	subi	r28, 0x6A	; 106
    194a:	d0 40       	sbci	r29, 0x00	; 0

				/* If connection is not already closed, close it */
				uip_close();
    194c:	80 e1       	ldi	r24, 0x10	; 16
    194e:	80 93 55 05 	sts	0x0555, r24

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1952:	84 e0       	ldi	r24, 0x04	; 4
    1954:	8c 8f       	std	Y+28, r24	; 0x1c
				AppState->HTTPServer.NextState    = WEBSERVER_STATE_Closed;
    1956:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1958:	df 91       	pop	r29
    195a:	cf 91       	pop	r28
    195c:	1f 91       	pop	r17
    195e:	0f 91       	pop	r16
    1960:	ff 90       	pop	r15
    1962:	ef 90       	pop	r14
    1964:	df 90       	pop	r13
    1966:	cf 90       	pop	r12
    1968:	bf 90       	pop	r11
    196a:	af 90       	pop	r10
    196c:	08 95       	ret

0000196e <HTTPServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void HTTPServerApp_Init(void)
{
	/* Listen on port 80 for HTTP connections from hosts */
	uip_listen(HTONS(HTTP_SERVER_PORT));
    196e:	80 e0       	ldi	r24, 0x00	; 0
    1970:	90 e5       	ldi	r25, 0x50	; 80
    1972:	8d d1       	rcall	.+794    	; 0x1c8e <uip_listen>

	/* Mount the Dataflash disk via FatFS */
	f_mount(0, &DiskFATState);
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	6b e2       	ldi	r22, 0x2B	; 43
    1978:	73 e0       	ldi	r23, 0x03	; 3
    197a:	0c 94 d0 1a 	jmp	0x35a0	; 0x35a0 <f_mount>

0000197e <TELNETServerApp_Callback>:

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
    197e:	8f 92       	push	r8
    1980:	9f 92       	push	r9
    1982:	bf 92       	push	r11
    1984:	cf 92       	push	r12
    1986:	df 92       	push	r13
    1988:	ef 92       	push	r14
    198a:	ff 92       	push	r15
    198c:	0f 93       	push	r16
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
    1994:	e0 90 5a 05 	lds	r14, 0x055A
    1998:	f0 90 5b 05 	lds	r15, 0x055B
	char*               const AppData    = (char*)uip_appdata;
    199c:	40 91 58 05 	lds	r20, 0x0558
    19a0:	10 91 59 05 	lds	r17, 0x0559

	if (uip_connected())
    19a4:	80 91 55 05 	lds	r24, 0x0555
    19a8:	86 ff       	sbrs	r24, 6
    19aa:	03 c0       	rjmp	.+6      	; 0x19b2 <TELNETServerApp_Callback+0x34>
	{
		/* New connection - initialize connection state values */
		AppState->TELNETServer.CurrentState = TELNET_STATE_SendHeader;
    19ac:	d7 01       	movw	r26, r14
    19ae:	5c 96       	adiw	r26, 0x1c	; 28
    19b0:	1c 92       	st	X, r1
	}

	if (uip_acked())
    19b2:	80 91 55 05 	lds	r24, 0x0555
    19b6:	80 ff       	sbrs	r24, 0
    19b8:	03 c0       	rjmp	.+6      	; 0x19c0 <TELNETServerApp_Callback+0x42>
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
    19ba:	f7 01       	movw	r30, r14
    19bc:	85 8d       	ldd	r24, Z+29	; 0x1d
    19be:	84 8f       	std	Z+28, r24	; 0x1c
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    19c0:	80 91 55 05 	lds	r24, 0x0555
    19c4:	28 2f       	mov	r18, r24
    19c6:	30 e0       	ldi	r19, 0x00	; 0
    19c8:	82 fd       	sbrc	r24, 2
    19ca:	0a c0       	rjmp	.+20     	; 0x19e0 <TELNETServerApp_Callback+0x62>
    19cc:	c9 01       	movw	r24, r18
    19ce:	83 70       	andi	r24, 0x03	; 3
    19d0:	90 70       	andi	r25, 0x00	; 0
    19d2:	89 2b       	or	r24, r25
    19d4:	29 f4       	brne	.+10     	; 0x19e0 <TELNETServerApp_Callback+0x62>
    19d6:	28 74       	andi	r18, 0x48	; 72
    19d8:	30 70       	andi	r19, 0x00	; 0
    19da:	23 2b       	or	r18, r19
    19dc:	09 f4       	brne	.+2      	; 0x19e0 <TELNETServerApp_Callback+0x62>
    19de:	bc c0       	rjmp	.+376    	; 0x1b58 <TELNETServerApp_Callback+0x1da>
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
	char*               const AppData    = (char*)uip_appdata;
    19e0:	c4 2f       	mov	r28, r20
    19e2:	d1 2f       	mov	r29, r17
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
	{
		switch (AppState->TELNETServer.CurrentState)
    19e4:	d7 01       	movw	r26, r14
    19e6:	5c 96       	adiw	r26, 0x1c	; 28
    19e8:	8c 91       	ld	r24, X
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	e9 f0       	breq	.+58     	; 0x1a28 <TELNETServerApp_Callback+0xaa>
    19ee:	81 30       	cpi	r24, 0x01	; 1
    19f0:	30 f0       	brcs	.+12     	; 0x19fe <TELNETServerApp_Callback+0x80>
    19f2:	82 30       	cpi	r24, 0x02	; 2
    19f4:	61 f1       	breq	.+88     	; 0x1a4e <TELNETServerApp_Callback+0xd0>
    19f6:	83 30       	cpi	r24, 0x03	; 3
    19f8:	09 f0       	breq	.+2      	; 0x19fc <TELNETServerApp_Callback+0x7e>
    19fa:	ae c0       	rjmp	.+348    	; 0x1b58 <TELNETServerApp_Callback+0x1da>
    19fc:	35 c0       	rjmp	.+106    	; 0x1a68 <TELNETServerApp_Callback+0xea>
		{
			case TELNET_STATE_SendHeader:
				/* Copy over and send the TELNET welcome message upon first connection */
				strcpy_P(AppData, WelcomeHeader);
    19fe:	ce 01       	movw	r24, r28
    1a00:	6d e0       	ldi	r22, 0x0D	; 13
    1a02:	72 e0       	ldi	r23, 0x02	; 2
    1a04:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1a08:	ec 2f       	mov	r30, r28
    1a0a:	f1 2f       	mov	r31, r17
    1a0c:	df 01       	movw	r26, r30
    1a0e:	0d 90       	ld	r0, X+
    1a10:	00 20       	and	r0, r0
    1a12:	e9 f7       	brne	.-6      	; 0x1a0e <TELNETServerApp_Callback+0x90>
    1a14:	11 97       	sbiw	r26, 0x01	; 1
    1a16:	ae 1b       	sub	r26, r30
    1a18:	bf 0b       	sbc	r27, r31
    1a1a:	ce 01       	movw	r24, r28
    1a1c:	bd 01       	movw	r22, r26
    1a1e:	b4 d1       	rcall	.+872    	; 0x1d88 <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	f7 01       	movw	r30, r14
    1a24:	85 8f       	std	Z+29, r24	; 0x1d
    1a26:	98 c0       	rjmp	.+304    	; 0x1b58 <TELNETServerApp_Callback+0x1da>
				break;
			case TELNET_STATE_SendMenu:
				/* Copy over and send the TELNET menu to the client */
				strcpy_P(AppData, TELNETMenu);
    1a28:	ce 01       	movw	r24, r28
    1a2a:	68 e9       	ldi	r22, 0x98	; 152
    1a2c:	72 e0       	ldi	r23, 0x02	; 2
    1a2e:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1a32:	ec 2f       	mov	r30, r28
    1a34:	f1 2f       	mov	r31, r17
    1a36:	df 01       	movw	r26, r30
    1a38:	0d 90       	ld	r0, X+
    1a3a:	00 20       	and	r0, r0
    1a3c:	e9 f7       	brne	.-6      	; 0x1a38 <TELNETServerApp_Callback+0xba>
    1a3e:	11 97       	sbiw	r26, 0x01	; 1
    1a40:	ae 1b       	sub	r26, r30
    1a42:	bf 0b       	sbc	r27, r31
    1a44:	ce 01       	movw	r24, r28
    1a46:	bd 01       	movw	r22, r26
    1a48:	9f d1       	rcall	.+830    	; 0x1d88 <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_GetCommand;
    1a4a:	82 e0       	ldi	r24, 0x02	; 2
    1a4c:	82 c0       	rjmp	.+260    	; 0x1b52 <TELNETServerApp_Callback+0x1d4>
				break;
			case TELNET_STATE_GetCommand:
				if (!(uip_datalen()))
    1a4e:	80 91 4d 05 	lds	r24, 0x054D
    1a52:	90 91 4e 05 	lds	r25, 0x054E
    1a56:	89 2b       	or	r24, r25
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <TELNETServerApp_Callback+0xde>
    1a5a:	7e c0       	rjmp	.+252    	; 0x1b58 <TELNETServerApp_Callback+0x1da>
				  break;

				/* Save the issued command for later processing */
				AppState->TELNETServer.IssuedCommand = AppData[0];
    1a5c:	88 81       	ld	r24, Y
    1a5e:	f7 01       	movw	r30, r14
    1a60:	86 8f       	std	Z+30, r24	; 0x1e

				AppState->TELNETServer.CurrentState  = TELNET_STATE_SendResponse;
    1a62:	83 e0       	ldi	r24, 0x03	; 3
    1a64:	84 8f       	std	Z+28, r24	; 0x1c
    1a66:	78 c0       	rjmp	.+240    	; 0x1b58 <TELNETServerApp_Callback+0x1da>
				break;
			case TELNET_STATE_SendResponse:
				/* Determine which command was issued, perform command processing */
				switch (AppState->TELNETServer.IssuedCommand)
    1a68:	d7 01       	movw	r26, r14
    1a6a:	5e 96       	adiw	r26, 0x1e	; 30
    1a6c:	8c 91       	ld	r24, X
    1a6e:	83 36       	cpi	r24, 0x63	; 99
    1a70:	09 f0       	breq	.+2      	; 0x1a74 <TELNETServerApp_Callback+0xf6>
    1a72:	5d c0       	rjmp	.+186    	; 0x1b2e <TELNETServerApp_Callback+0x1b0>
}

/** Sends a list of active TCP connections to the TELNET client. */
static void TELNETServerApp_DisplayTCPConnections(void)
{
	char* const AppData    = (char*)uip_appdata;
    1a74:	c0 90 58 05 	lds	r12, 0x0558
    1a78:	d0 90 59 05 	lds	r13, 0x0559

	strcpy_P(AppData, CurrentConnectionsHeader);
    1a7c:	c6 01       	movw	r24, r12
    1a7e:	6d ef       	ldi	r22, 0xFD	; 253
    1a80:	72 e0       	ldi	r23, 0x02	; 2
    1a82:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>

	uint16_t ResponseLen     = strlen(AppData);
    1a86:	d6 01       	movw	r26, r12
    1a88:	0d 90       	ld	r0, X+
    1a8a:	00 20       	and	r0, r0
    1a8c:	e9 f7       	brne	.-6      	; 0x1a88 <TELNETServerApp_Callback+0x10a>
    1a8e:	8d 01       	movw	r16, r26
    1a90:	01 50       	subi	r16, 0x01	; 1
    1a92:	10 40       	sbci	r17, 0x00	; 0
    1a94:	0c 19       	sub	r16, r12
    1a96:	1d 09       	sbc	r17, r13
    1a98:	cc e5       	ldi	r28, 0x5C	; 92
    1a9a:	d5 e0       	ldi	r29, 0x05	; 5
    1a9c:	bb 24       	eor	r11, r11

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %02d.%02d.%02d.%02d (Local %u, Remote %u)\r\n"),
    1a9e:	81 e3       	ldi	r24, 0x31	; 49
    1aa0:	88 2e       	mov	r8, r24
    1aa2:	83 e0       	ldi	r24, 0x03	; 3
    1aa4:	98 2e       	mov	r9, r24
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
    1aa6:	89 8d       	ldd	r24, Y+25	; 0x19
    1aa8:	88 23       	and	r24, r24
    1aaa:	b9 f1       	breq	.+110    	; 0x1b1a <TELNETServerApp_Callback+0x19c>
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %02d.%02d.%02d.%02d (Local %u, Remote %u)\r\n"),
    1aac:	b3 94       	inc	r11
    1aae:	ed b7       	in	r30, 0x3d	; 61
    1ab0:	fe b7       	in	r31, 0x3e	; 62
    1ab2:	72 97       	sbiw	r30, 0x12	; 18
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	f8 94       	cli
    1ab8:	fe bf       	out	0x3e, r31	; 62
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	ed bf       	out	0x3d, r30	; 61
    1abe:	31 96       	adiw	r30, 0x01	; 1
    1ac0:	c6 01       	movw	r24, r12
    1ac2:	80 0f       	add	r24, r16
    1ac4:	91 1f       	adc	r25, r17
    1ac6:	ad b7       	in	r26, 0x3d	; 61
    1ac8:	be b7       	in	r27, 0x3e	; 62
    1aca:	12 96       	adiw	r26, 0x02	; 2
    1acc:	9c 93       	st	X, r25
    1ace:	8e 93       	st	-X, r24
    1ad0:	11 97       	sbiw	r26, 0x01	; 1
    1ad2:	93 82       	std	Z+3, r9	; 0x03
    1ad4:	82 82       	std	Z+2, r8	; 0x02
    1ad6:	b4 82       	std	Z+4, r11	; 0x04
    1ad8:	15 82       	std	Z+5, r1	; 0x05
    1ada:	88 81       	ld	r24, Y
    1adc:	86 83       	std	Z+6, r24	; 0x06
    1ade:	17 82       	std	Z+7, r1	; 0x07
    1ae0:	89 81       	ldd	r24, Y+1	; 0x01
    1ae2:	80 87       	std	Z+8, r24	; 0x08
    1ae4:	11 86       	std	Z+9, r1	; 0x09
    1ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae8:	82 87       	std	Z+10, r24	; 0x0a
    1aea:	13 86       	std	Z+11, r1	; 0x0b
    1aec:	8b 81       	ldd	r24, Y+3	; 0x03
    1aee:	84 87       	std	Z+12, r24	; 0x0c
    1af0:	15 86       	std	Z+13, r1	; 0x0d
    1af2:	9c 81       	ldd	r25, Y+4	; 0x04
    1af4:	8d 81       	ldd	r24, Y+5	; 0x05
    1af6:	86 87       	std	Z+14, r24	; 0x0e
    1af8:	97 87       	std	Z+15, r25	; 0x0f
    1afa:	9e 81       	ldd	r25, Y+6	; 0x06
    1afc:	8f 81       	ldd	r24, Y+7	; 0x07
    1afe:	80 8b       	std	Z+16, r24	; 0x10
    1b00:	91 8b       	std	Z+17, r25	; 0x11
    1b02:	0e 94 18 37 	call	0x6e30	; 0x6e30 <sprintf_P>
    1b06:	08 0f       	add	r16, r24
    1b08:	19 1f       	adc	r17, r25
    1b0a:	ed b7       	in	r30, 0x3d	; 61
    1b0c:	fe b7       	in	r31, 0x3e	; 62
    1b0e:	72 96       	adiw	r30, 0x12	; 18
    1b10:	0f b6       	in	r0, 0x3f	; 63
    1b12:	f8 94       	cli
    1b14:	fe bf       	out	0x3e, r31	; 62
    1b16:	0f be       	out	0x3f, r0	; 63
    1b18:	ed bf       	out	0x3d, r30	; 61
    1b1a:	cf 58       	subi	r28, 0x8F	; 143
    1b1c:	df 4f       	sbci	r29, 0xFF	; 255

	uint16_t ResponseLen     = strlen(AppData);
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1b1e:	f6 e0       	ldi	r31, 0x06	; 6
    1b20:	cf 3a       	cpi	r28, 0xAF	; 175
    1b22:	df 07       	cpc	r29, r31
    1b24:	09 f0       	breq	.+2      	; 0x1b28 <TELNETServerApp_Callback+0x1aa>
    1b26:	bf cf       	rjmp	.-130    	; 0x1aa6 <TELNETServerApp_Callback+0x128>
			                         CurrConnection->ripaddr.u8[3],
			                         HTONS(CurrConnection->lport), HTONS(CurrConnection->rport));
		}
	}

	uip_send(AppData, ResponseLen);
    1b28:	c6 01       	movw	r24, r12
    1b2a:	b8 01       	movw	r22, r16
    1b2c:	10 c0       	rjmp	.+32     	; 0x1b4e <TELNETServerApp_Callback+0x1d0>
				{
					case 'c':
						TELNETServerApp_DisplayTCPConnections();
						break;
					default:
						strcpy_P(AppData, PSTR("Invalid Command.\r\n"));
    1b2e:	ce 01       	movw	r24, r28
    1b30:	6e e1       	ldi	r22, 0x1E	; 30
    1b32:	73 e0       	ldi	r23, 0x03	; 3
    1b34:	0e 94 9e 36 	call	0x6d3c	; 0x6d3c <strcpy_P>
						uip_send(AppData, strlen(AppData));
    1b38:	ac 2f       	mov	r26, r28
    1b3a:	b1 2f       	mov	r27, r17
    1b3c:	fd 01       	movw	r30, r26
    1b3e:	01 90       	ld	r0, Z+
    1b40:	00 20       	and	r0, r0
    1b42:	e9 f7       	brne	.-6      	; 0x1b3e <TELNETServerApp_Callback+0x1c0>
    1b44:	31 97       	sbiw	r30, 0x01	; 1
    1b46:	ea 1b       	sub	r30, r26
    1b48:	fb 0b       	sbc	r31, r27
    1b4a:	ce 01       	movw	r24, r28
    1b4c:	bf 01       	movw	r22, r30
    1b4e:	1c d1       	rcall	.+568    	; 0x1d88 <uip_send>
						break;
				}

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1b50:	81 e0       	ldi	r24, 0x01	; 1
    1b52:	d7 01       	movw	r26, r14
    1b54:	5d 96       	adiw	r26, 0x1d	; 29
    1b56:	8c 93       	st	X, r24
				break;
		}
	}
}
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	1f 91       	pop	r17
    1b5e:	0f 91       	pop	r16
    1b60:	ff 90       	pop	r15
    1b62:	ef 90       	pop	r14
    1b64:	df 90       	pop	r13
    1b66:	cf 90       	pop	r12
    1b68:	bf 90       	pop	r11
    1b6a:	9f 90       	pop	r9
    1b6c:	8f 90       	pop	r8
    1b6e:	08 95       	ret

00001b70 <TELNETServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void TELNETServerApp_Init(void)
{
	/* Listen on port 23 for TELNET connections from hosts */
	uip_listen(HTONS(TELNET_SERVER_PORT));
    1b70:	80 e0       	ldi	r24, 0x00	; 0
    1b72:	97 e1       	ldi	r25, 0x17	; 23
}
    1b74:	8c c0       	rjmp	.+280    	; 0x1c8e <uip_listen>

00001b76 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    1b76:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    1b78:	53 81       	ldd	r21, Z+3	; 0x03
    1b7a:	56 0f       	add	r21, r22
    1b7c:	50 93 54 05 	sts	0x0554, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    1b80:	27 2f       	mov	r18, r23
    1b82:	33 27       	eor	r19, r19
    1b84:	42 81       	ldd	r20, Z+2	; 0x02
    1b86:	42 0f       	add	r20, r18
    1b88:	40 93 53 05 	sts	0x0553, r20
  uip_acc32[1] = op32[1];
    1b8c:	a1 81       	ldd	r26, Z+1	; 0x01
    1b8e:	a0 93 52 05 	sts	0x0552, r26
  uip_acc32[0] = op32[0];
    1b92:	e0 81       	ld	r30, Z
    1b94:	e0 93 51 05 	sts	0x0551, r30

  if(uip_acc32[2] < (op16 >> 8)) {
    1b98:	84 2f       	mov	r24, r20
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	82 17       	cp	r24, r18
    1b9e:	93 07       	cpc	r25, r19
    1ba0:	48 f4       	brcc	.+18     	; 0x1bb4 <uip_add32+0x3e>
    ++uip_acc32[1];
    1ba2:	8a 2f       	mov	r24, r26
    1ba4:	8f 5f       	subi	r24, 0xFF	; 255
    1ba6:	80 93 52 05 	sts	0x0552, r24
    if(uip_acc32[1] == 0) {
    1baa:	88 23       	and	r24, r24
    1bac:	19 f4       	brne	.+6      	; 0x1bb4 <uip_add32+0x3e>
      ++uip_acc32[0];
    1bae:	ef 5f       	subi	r30, 0xFF	; 255
    1bb0:	e0 93 51 05 	sts	0x0551, r30
    }
  }


  if(uip_acc32[3] < (op16 & 0xff)) {
    1bb4:	85 2f       	mov	r24, r21
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	70 70       	andi	r23, 0x00	; 0
    1bba:	86 17       	cp	r24, r22
    1bbc:	97 07       	cpc	r25, r23
    1bbe:	90 f4       	brcc	.+36     	; 0x1be4 <uip_add32+0x6e>
    ++uip_acc32[2];
    1bc0:	84 2f       	mov	r24, r20
    1bc2:	8f 5f       	subi	r24, 0xFF	; 255
    1bc4:	80 93 53 05 	sts	0x0553, r24
    if(uip_acc32[2] == 0) {
    1bc8:	88 23       	and	r24, r24
    1bca:	61 f4       	brne	.+24     	; 0x1be4 <uip_add32+0x6e>
      ++uip_acc32[1];
    1bcc:	80 91 52 05 	lds	r24, 0x0552
    1bd0:	8f 5f       	subi	r24, 0xFF	; 255
    1bd2:	80 93 52 05 	sts	0x0552, r24
      if(uip_acc32[1] == 0) {
    1bd6:	88 23       	and	r24, r24
    1bd8:	29 f4       	brne	.+10     	; 0x1be4 <uip_add32+0x6e>
	++uip_acc32[0];
    1bda:	80 91 51 05 	lds	r24, 0x0551
    1bde:	8f 5f       	subi	r24, 0xFF	; 255
    1be0:	80 93 51 05 	sts	0x0551, r24
    1be4:	08 95       	ret

00001be6 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    1be6:	9c 01       	movw	r18, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    1be8:	41 50       	subi	r20, 0x01	; 1
    1bea:	50 40       	sbci	r21, 0x00	; 0
    1bec:	46 0f       	add	r20, r22
    1bee:	57 1f       	adc	r21, r23
    1bf0:	fb 01       	movw	r30, r22
    1bf2:	0e c0       	rjmp	.+28     	; 0x1c10 <chksum+0x2a>

  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    1bf4:	70 81       	ld	r23, Z
    1bf6:	60 e0       	ldi	r22, 0x00	; 0
    1bf8:	81 81       	ldd	r24, Z+1	; 0x01
    1bfa:	db 01       	movw	r26, r22
    1bfc:	a8 0f       	add	r26, r24
    1bfe:	b1 1d       	adc	r27, r1
    sum += t;
    1c00:	2a 0f       	add	r18, r26
    1c02:	3b 1f       	adc	r19, r27
    if(sum < t) {
    1c04:	2a 17       	cp	r18, r26
    1c06:	3b 07       	cpc	r19, r27
    1c08:	10 f4       	brcc	.+4      	; 0x1c0e <chksum+0x28>
      sum++;		/* carry */
    1c0a:	2f 5f       	subi	r18, 0xFF	; 255
    1c0c:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    1c0e:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;

  while(dataptr < last_byte) {	/* At least two more bytes */
    1c10:	e4 17       	cp	r30, r20
    1c12:	f5 07       	cpc	r31, r21
    1c14:	78 f3       	brcs	.-34     	; 0x1bf4 <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }

  if(dataptr == last_byte) {
    1c16:	e4 17       	cp	r30, r20
    1c18:	f5 07       	cpc	r31, r21
    1c1a:	49 f4       	brne	.+18     	; 0x1c2e <chksum+0x48>
    t = (dataptr[0] << 8) + 0;
    1c1c:	90 81       	ld	r25, Z
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    1c20:	28 0f       	add	r18, r24
    1c22:	39 1f       	adc	r19, r25
    if(sum < t) {
    1c24:	28 17       	cp	r18, r24
    1c26:	39 07       	cpc	r19, r25
    1c28:	10 f4       	brcc	.+4      	; 0x1c2e <chksum+0x48>
      sum++;		/* carry */
    1c2a:	2f 5f       	subi	r18, 0xFF	; 255
    1c2c:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    1c2e:	c9 01       	movw	r24, r18
    1c30:	08 95       	ret

00001c32 <uip_init>:
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	09 c0       	rjmp	.+18     	; 0x1c48 <uip_init+0x16>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    1c36:	e8 2f       	mov	r30, r24
    1c38:	f0 e0       	ldi	r31, 0x00	; 0
    1c3a:	ee 0f       	add	r30, r30
    1c3c:	ff 1f       	adc	r31, r31
    1c3e:	e1 55       	subi	r30, 0x51	; 81
    1c40:	f9 4f       	sbci	r31, 0xF9	; 249
    1c42:	11 82       	std	Z+1, r1	; 0x01
    1c44:	10 82       	st	Z, r1
    1c46:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    1c48:	85 30       	cpi	r24, 0x05	; 5
    1c4a:	a8 f3       	brcs	.-22     	; 0x1c36 <uip_init+0x4>
    1c4c:	20 e0       	ldi	r18, 0x00	; 0
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    1c4e:	41 e7       	ldi	r20, 0x71	; 113
    1c50:	50 e0       	ldi	r21, 0x00	; 0
    1c52:	0d c0       	rjmp	.+26     	; 0x1c6e <uip_init+0x3c>
    1c54:	82 2f       	mov	r24, r18
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	84 9f       	mul	r24, r20
    1c5a:	f0 01       	movw	r30, r0
    1c5c:	85 9f       	mul	r24, r21
    1c5e:	f0 0d       	add	r31, r0
    1c60:	94 9f       	mul	r25, r20
    1c62:	f0 0d       	add	r31, r0
    1c64:	11 24       	eor	r1, r1
    1c66:	e4 5a       	subi	r30, 0xA4	; 164
    1c68:	fa 4f       	sbci	r31, 0xFA	; 250
    1c6a:	11 8e       	std	Z+25, r1	; 0x19
    1c6c:	2f 5f       	subi	r18, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    1c6e:	23 30       	cpi	r18, 0x03	; 3
    1c70:	88 f3       	brcs	.-30     	; 0x1c54 <uip_init+0x22>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    1c72:	80 e0       	ldi	r24, 0x00	; 0
    1c74:	94 e0       	ldi	r25, 0x04	; 4
    1c76:	90 93 a9 02 	sts	0x02A9, r25
    1c7a:	80 93 a8 02 	sts	0x02A8, r24
#endif /* UIP_ACTIVE_OPEN */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    1c7e:	10 92 b8 0c 	sts	0x0CB8, r1
    1c82:	10 92 b7 0c 	sts	0x0CB7, r1
    1c86:	81 e0       	ldi	r24, 0x01	; 1
    1c88:	80 93 aa 02 	sts	0x02AA, r24
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    1c8c:	08 95       	ret

00001c8e <uip_listen>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
    1c8e:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    1c90:	10 92 aa 02 	sts	0x02AA, r1
    1c94:	20 e0       	ldi	r18, 0x00	; 0
    1c96:	12 c0       	rjmp	.+36     	; 0x1cbc <uip_listen+0x2e>
    if(uip_listenports[c] == 0) {
    1c98:	e2 2f       	mov	r30, r18
    1c9a:	f0 e0       	ldi	r31, 0x00	; 0
    1c9c:	32 2f       	mov	r19, r18
    1c9e:	3f 5f       	subi	r19, 0xFF	; 255
    1ca0:	ee 0f       	add	r30, r30
    1ca2:	ff 1f       	adc	r31, r31
    1ca4:	e1 55       	subi	r30, 0x51	; 81
    1ca6:	f9 4f       	sbci	r31, 0xF9	; 249
    1ca8:	80 81       	ld	r24, Z
    1caa:	91 81       	ldd	r25, Z+1	; 0x01
    1cac:	89 2b       	or	r24, r25
    1cae:	29 f4       	brne	.+10     	; 0x1cba <uip_listen+0x2c>
    1cb0:	20 93 aa 02 	sts	0x02AA, r18
      uip_listenports[c] = port;
    1cb4:	51 83       	std	Z+1, r21	; 0x01
    1cb6:	40 83       	st	Z, r20
    1cb8:	08 95       	ret
      return;
    1cba:	23 2f       	mov	r18, r19
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    1cbc:	25 30       	cpi	r18, 0x05	; 5
    1cbe:	60 f3       	brcs	.-40     	; 0x1c98 <uip_listen+0xa>
    1cc0:	20 93 aa 02 	sts	0x02AA, r18
    1cc4:	08 95       	ret

00001cc6 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    1cc6:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    1cc8:	80 91 5a 05 	lds	r24, 0x055A
    1ccc:	90 91 5b 05 	lds	r25, 0x055B
    1cd0:	08 96       	adiw	r24, 0x08	; 8
    1cd2:	51 df       	rcall	.-350    	; 0x1b76 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    1cd4:	e0 91 5a 05 	lds	r30, 0x055A
    1cd8:	f0 91 5b 05 	lds	r31, 0x055B
    1cdc:	80 91 51 05 	lds	r24, 0x0551
    1ce0:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    1ce2:	e0 91 5a 05 	lds	r30, 0x055A
    1ce6:	f0 91 5b 05 	lds	r31, 0x055B
    1cea:	80 91 52 05 	lds	r24, 0x0552
    1cee:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    1cf0:	e0 91 5a 05 	lds	r30, 0x055A
    1cf4:	f0 91 5b 05 	lds	r31, 0x055B
    1cf8:	80 91 53 05 	lds	r24, 0x0553
    1cfc:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    1cfe:	e0 91 5a 05 	lds	r30, 0x055A
    1d02:	f0 91 5b 05 	lds	r31, 0x055B
    1d06:	80 91 54 05 	lds	r24, 0x0554
    1d0a:	83 87       	std	Z+11, r24	; 0x0b
}
    1d0c:	08 95       	ret

00001d0e <htons>:
  return;
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
    1d0e:	28 2f       	mov	r18, r24
  return HTONS(val);
}
    1d10:	89 2f       	mov	r24, r25
    1d12:	92 2f       	mov	r25, r18
    1d14:	08 95       	ret

00001d16 <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    1d16:	0f 93       	push	r16
    1d18:	1f 93       	push	r17
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    1d1a:	00 91 d6 06 	lds	r16, 0x06D6
    1d1e:	10 e0       	ldi	r17, 0x00	; 0
    1d20:	04 51       	subi	r16, 0x14	; 20
    1d22:	10 40       	sbci	r17, 0x00	; 0
    1d24:	90 91 d5 06 	lds	r25, 0x06D5
    1d28:	80 e0       	ldi	r24, 0x00	; 0
    1d2a:	08 0f       	add	r16, r24
    1d2c:	19 1f       	adc	r17, r25
  /* First sum pseudoheader. */

  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    1d2e:	c8 01       	movw	r24, r16
    1d30:	06 96       	adiw	r24, 0x06	; 6
    1d32:	6f ed       	ldi	r22, 0xDF	; 223
    1d34:	76 e0       	ldi	r23, 0x06	; 6
    1d36:	48 e0       	ldi	r20, 0x08	; 8
    1d38:	50 e0       	ldi	r21, 0x00	; 0
    1d3a:	55 df       	rcall	.-342    	; 0x1be6 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    1d3c:	67 ee       	ldi	r22, 0xE7	; 231
    1d3e:	76 e0       	ldi	r23, 0x06	; 6
    1d40:	a8 01       	movw	r20, r16
    1d42:	51 df       	rcall	.-350    	; 0x1be6 <chksum>
	       upper_layer_len);

  return (sum == 0) ? 0xffff : htons(sum);
    1d44:	00 97       	sbiw	r24, 0x00	; 0
    1d46:	19 f4       	brne	.+6      	; 0x1d4e <uip_tcpchksum+0x38>
    1d48:	2f ef       	ldi	r18, 0xFF	; 255
    1d4a:	3f ef       	ldi	r19, 0xFF	; 255
    1d4c:	02 c0       	rjmp	.+4      	; 0x1d52 <uip_tcpchksum+0x3c>
    1d4e:	df df       	rcall	.-66     	; 0x1d0e <htons>
    1d50:	9c 01       	movw	r18, r24
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    1d52:	c9 01       	movw	r24, r18
    1d54:	1f 91       	pop	r17
    1d56:	0f 91       	pop	r16
    1d58:	08 95       	ret

00001d5a <uip_ipchksum>:
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    1d5a:	80 e0       	ldi	r24, 0x00	; 0
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	63 ed       	ldi	r22, 0xD3	; 211
    1d60:	76 e0       	ldi	r23, 0x06	; 6
    1d62:	44 e1       	ldi	r20, 0x14	; 20
    1d64:	50 e0       	ldi	r21, 0x00	; 0
    1d66:	3f df       	rcall	.-386    	; 0x1be6 <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    1d68:	00 97       	sbiw	r24, 0x00	; 0
    1d6a:	19 f4       	brne	.+6      	; 0x1d72 <uip_ipchksum+0x18>
    1d6c:	2f ef       	ldi	r18, 0xFF	; 255
    1d6e:	3f ef       	ldi	r19, 0xFF	; 255
    1d70:	02 c0       	rjmp	.+4      	; 0x1d76 <uip_ipchksum+0x1c>
    1d72:	cd df       	rcall	.-102    	; 0x1d0e <htons>
    1d74:	9c 01       	movw	r18, r24
}
    1d76:	c9 01       	movw	r24, r18
    1d78:	08 95       	ret

00001d7a <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    1d7a:	9c 01       	movw	r18, r24
    1d7c:	ab 01       	movw	r20, r22
  return htons(chksum(0, (u8_t *)data, len));
    1d7e:	80 e0       	ldi	r24, 0x00	; 0
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	b9 01       	movw	r22, r18
    1d84:	30 df       	rcall	.-416    	; 0x1be6 <chksum>
}
    1d86:	c3 cf       	rjmp	.-122    	; 0x1d0e <htons>

00001d88 <uip_send>:
  return HTONL(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    1d88:	fc 01       	movw	r30, r24
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    1d8a:	40 91 4f 05 	lds	r20, 0x054F
    1d8e:	50 91 50 05 	lds	r21, 0x0550
    1d92:	2f ea       	ldi	r18, 0xAF	; 175
    1d94:	3c e0       	ldi	r19, 0x0C	; 12
    1d96:	24 1b       	sub	r18, r20
    1d98:	35 0b       	sbc	r19, r21
    1d9a:	62 17       	cp	r22, r18
    1d9c:	73 07       	cpc	r23, r19
    1d9e:	0c f4       	brge	.+2      	; 0x1da2 <uip_send+0x1a>
    1da0:	9b 01       	movw	r18, r22
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    1da2:	12 16       	cp	r1, r18
    1da4:	13 06       	cpc	r1, r19
    1da6:	64 f4       	brge	.+24     	; 0x1dc0 <uip_send+0x38>
    uip_slen = copylen;
    1da8:	20 93 b1 0c 	sts	0x0CB1, r18
    1dac:	30 93 b2 0c 	sts	0x0CB2, r19
    if(data != uip_sappdata) {
    1db0:	e4 17       	cp	r30, r20
    1db2:	f5 07       	cpc	r31, r21
    1db4:	29 f0       	breq	.+10     	; 0x1dc0 <uip_send+0x38>
      memcpy(uip_sappdata, (data), uip_slen);
    1db6:	ca 01       	movw	r24, r20
    1db8:	bf 01       	movw	r22, r30
    1dba:	a9 01       	movw	r20, r18
    1dbc:	0c 94 b7 36 	jmp	0x6d6e	; 0x6d6e <memcpy>
    1dc0:	08 95       	ret

00001dc2 <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    1dc2:	0f 93       	push	r16
    1dc4:	1f 93       	push	r17
    1dc6:	cf 93       	push	r28
    1dc8:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    1dca:	c0 91 5a 05 	lds	r28, 0x055A
    1dce:	d0 91 5b 05 	lds	r29, 0x055B

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    1dd2:	84 30       	cpi	r24, 0x04	; 4
    1dd4:	09 f4       	brne	.+2      	; 0x1dd8 <uip_process+0x16>
    1dd6:	37 c2       	rjmp	.+1134   	; 0x2246 <__stack+0x147>
    goto udp_send;
  }
#endif /* UIP_UDP */

  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    1dd8:	2b ef       	ldi	r18, 0xFB	; 251
    1dda:	36 e0       	ldi	r19, 0x06	; 6
    1ddc:	30 93 59 05 	sts	0x0559, r19
    1de0:	20 93 58 05 	sts	0x0558, r18
    1de4:	30 93 50 05 	sts	0x0550, r19
    1de8:	20 93 4f 05 	sts	0x054F, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    1dec:	83 30       	cpi	r24, 0x03	; 3
    1dee:	59 f4       	brne	.+22     	; 0x1e06 <uip_process+0x44>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    1df0:	89 8d       	ldd	r24, Y+25	; 0x19
    1df2:	8f 70       	andi	r24, 0x0F	; 15
    1df4:	83 30       	cpi	r24, 0x03	; 3
    1df6:	09 f0       	breq	.+2      	; 0x1dfa <uip_process+0x38>
    1df8:	68 c7       	rjmp	.+3792   	; 0x2cca <__stack+0xbcb>
    1dfa:	88 89       	ldd	r24, Y+16	; 0x10
    1dfc:	99 89       	ldd	r25, Y+17	; 0x11
    1dfe:	89 2b       	or	r24, r25
    1e00:	09 f0       	breq	.+2      	; 0x1e04 <uip_process+0x42>
    1e02:	63 c7       	rjmp	.+3782   	; 0x2cca <__stack+0xbcb>
    1e04:	87 c0       	rjmp	.+270    	; 0x1f14 <uip_process+0x152>
	goto appsend;
    }
    goto drop;

    /* Check if we were invoked because of the periodic timer firing. */
  } else if(flag == UIP_TIMER) {
    1e06:	82 30       	cpi	r24, 0x02	; 2
    1e08:	09 f0       	breq	.+2      	; 0x1e0c <uip_process+0x4a>
    1e0a:	90 c0       	rjmp	.+288    	; 0x1f2c <uip_process+0x16a>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    1e0c:	80 91 a7 02 	lds	r24, 0x02A7
    1e10:	8f 5f       	subi	r24, 0xFF	; 255
    1e12:	80 93 a7 02 	sts	0x02A7, r24
    1e16:	88 23       	and	r24, r24
    1e18:	99 f4       	brne	.+38     	; 0x1e40 <uip_process+0x7e>
      if(++iss[2] == 0) {
    1e1a:	80 91 a6 02 	lds	r24, 0x02A6
    1e1e:	8f 5f       	subi	r24, 0xFF	; 255
    1e20:	80 93 a6 02 	sts	0x02A6, r24
    1e24:	88 23       	and	r24, r24
    1e26:	61 f4       	brne	.+24     	; 0x1e40 <uip_process+0x7e>
	if(++iss[1] == 0) {
    1e28:	80 91 a5 02 	lds	r24, 0x02A5
    1e2c:	8f 5f       	subi	r24, 0xFF	; 255
    1e2e:	80 93 a5 02 	sts	0x02A5, r24
    1e32:	88 23       	and	r24, r24
    1e34:	29 f4       	brne	.+10     	; 0x1e40 <uip_process+0x7e>
	  ++iss[0];
    1e36:	80 91 a4 02 	lds	r24, 0x02A4
    1e3a:	8f 5f       	subi	r24, 0xFF	; 255
    1e3c:	80 93 a4 02 	sts	0x02A4, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    1e40:	10 92 4e 05 	sts	0x054E, r1
    1e44:	10 92 4d 05 	sts	0x054D, r1
    uip_slen = 0;
    1e48:	10 92 b2 0c 	sts	0x0CB2, r1
    1e4c:	10 92 b1 0c 	sts	0x0CB1, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    1e50:	29 8d       	ldd	r18, Y+25	; 0x19
    1e52:	27 30       	cpi	r18, 0x07	; 7
    1e54:	11 f0       	breq	.+4      	; 0x1e5a <uip_process+0x98>
    1e56:	25 30       	cpi	r18, 0x05	; 5
    1e58:	41 f4       	brne	.+16     	; 0x1e6a <uip_process+0xa8>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    1e5a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e5c:	8f 5f       	subi	r24, 0xFF	; 255
    1e5e:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    1e60:	88 37       	cpi	r24, 0x78	; 120
    1e62:	09 f0       	breq	.+2      	; 0x1e66 <uip_process+0xa4>
    1e64:	32 c7       	rjmp	.+3684   	; 0x2cca <__stack+0xbcb>
	uip_connr->tcpstateflags = UIP_CLOSED;
    1e66:	19 8e       	std	Y+25, r1	; 0x19
    1e68:	30 c7       	rjmp	.+3680   	; 0x2cca <__stack+0xbcb>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    1e6a:	22 23       	and	r18, r18
    1e6c:	09 f4       	brne	.+2      	; 0x1e70 <uip_process+0xae>
    1e6e:	2d c7       	rjmp	.+3674   	; 0x2cca <__stack+0xbcb>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    1e70:	88 89       	ldd	r24, Y+16	; 0x10
    1e72:	99 89       	ldd	r25, Y+17	; 0x11
    1e74:	89 2b       	or	r24, r25
    1e76:	09 f4       	brne	.+2      	; 0x1e7a <uip_process+0xb8>
    1e78:	49 c0       	rjmp	.+146    	; 0x1f0c <uip_process+0x14a>
	if(uip_connr->timer-- == 0) {
    1e7a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e7c:	81 50       	subi	r24, 0x01	; 1
    1e7e:	8a 8f       	std	Y+26, r24	; 0x1a
    1e80:	8f 5f       	subi	r24, 0xFF	; 255
    1e82:	09 f0       	breq	.+2      	; 0x1e86 <uip_process+0xc4>
    1e84:	22 c7       	rjmp	.+3652   	; 0x2cca <__stack+0xbcb>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    1e86:	3b 8d       	ldd	r19, Y+27	; 0x1b
    1e88:	38 30       	cpi	r19, 0x08	; 8
    1e8a:	29 f0       	breq	.+10     	; 0x1e96 <uip_process+0xd4>
    1e8c:	21 50       	subi	r18, 0x01	; 1
    1e8e:	22 30       	cpi	r18, 0x02	; 2
    1e90:	40 f4       	brcc	.+16     	; 0x1ea2 <uip_process+0xe0>
    1e92:	35 30       	cpi	r19, 0x05	; 5
    1e94:	31 f4       	brne	.+12     	; 0x1ea2 <uip_process+0xe0>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    1e96:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    1e98:	80 e8       	ldi	r24, 0x80	; 128
    1e9a:	80 93 55 05 	sts	0x0555, r24
	    UIP_APPCALL();
    1e9e:	d7 d8       	rcall	.-3666   	; 0x104e <uIPManagement_TCPCallback>
    1ea0:	cf c5       	rjmp	.+2974   	; 0x2a40 <__stack+0x941>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential back-off. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    1ea2:	35 30       	cpi	r19, 0x05	; 5
    1ea4:	10 f0       	brcs	.+4      	; 0x1eaa <uip_process+0xe8>
    1ea6:	80 e3       	ldi	r24, 0x30	; 48
    1ea8:	07 c0       	rjmp	.+14     	; 0x1eb8 <uip_process+0xf6>
    1eaa:	83 e0       	ldi	r24, 0x03	; 3
    1eac:	90 e0       	ldi	r25, 0x00	; 0
    1eae:	02 c0       	rjmp	.+4      	; 0x1eb4 <uip_process+0xf2>
    1eb0:	88 0f       	add	r24, r24
    1eb2:	99 1f       	adc	r25, r25
    1eb4:	3a 95       	dec	r19
    1eb6:	e2 f7       	brpl	.-8      	; 0x1eb0 <uip_process+0xee>
    1eb8:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    1eba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ebc:	8f 5f       	subi	r24, 0xFF	; 255
    1ebe:	8b 8f       	std	Y+27, r24	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    1ec0:	89 8d       	ldd	r24, Y+25	; 0x19
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	8f 70       	andi	r24, 0x0F	; 15
    1ec6:	90 70       	andi	r25, 0x00	; 0
    1ec8:	83 30       	cpi	r24, 0x03	; 3
    1eca:	91 05       	cpc	r25, r1
    1ecc:	d1 f0       	breq	.+52     	; 0x1f02 <uip_process+0x140>
    1ece:	84 30       	cpi	r24, 0x04	; 4
    1ed0:	91 05       	cpc	r25, r1
    1ed2:	44 f4       	brge	.+16     	; 0x1ee4 <uip_process+0x122>
    1ed4:	81 30       	cpi	r24, 0x01	; 1
    1ed6:	91 05       	cpc	r25, r1
    1ed8:	09 f4       	brne	.+2      	; 0x1edc <uip_process+0x11a>
    1eda:	9b c3       	rjmp	.+1846   	; 0x2612 <__stack+0x513>
    1edc:	02 97       	sbiw	r24, 0x02	; 2
    1ede:	09 f0       	breq	.+2      	; 0x1ee2 <uip_process+0x120>
    1ee0:	f4 c6       	rjmp	.+3560   	; 0x2cca <__stack+0xbcb>
    1ee2:	0c c0       	rjmp	.+24     	; 0x1efc <uip_process+0x13a>
    1ee4:	86 30       	cpi	r24, 0x06	; 6
    1ee6:	91 05       	cpc	r25, r1
    1ee8:	09 f4       	brne	.+2      	; 0x1eec <uip_process+0x12a>
    1eea:	3e c5       	rjmp	.+2684   	; 0x2968 <__stack+0x869>
    1eec:	88 30       	cpi	r24, 0x08	; 8
    1eee:	91 05       	cpc	r25, r1
    1ef0:	09 f4       	brne	.+2      	; 0x1ef4 <uip_process+0x132>
    1ef2:	3a c5       	rjmp	.+2676   	; 0x2968 <__stack+0x869>
    1ef4:	04 97       	sbiw	r24, 0x04	; 4
    1ef6:	09 f0       	breq	.+2      	; 0x1efa <uip_process+0x138>
    1ef8:	e8 c6       	rjmp	.+3536   	; 0x2cca <__stack+0xbcb>
    1efa:	36 c5       	rjmp	.+2668   	; 0x2968 <__stack+0x869>
	    goto tcp_send_synack;

#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    1efc:	10 92 f4 06 	sts	0x06F4, r1
    1f00:	8b c3       	rjmp	.+1814   	; 0x2618 <__stack+0x519>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    1f02:	84 e0       	ldi	r24, 0x04	; 4
    1f04:	80 93 55 05 	sts	0x0555, r24
	    UIP_APPCALL();
    1f08:	a2 d8       	rcall	.-3772   	; 0x104e <uIPManagement_TCPCallback>
    1f0a:	cf c5       	rjmp	.+2974   	; 0x2aaa <__stack+0x9ab>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;

	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    1f0c:	2f 70       	andi	r18, 0x0F	; 15
    1f0e:	23 30       	cpi	r18, 0x03	; 3
    1f10:	09 f0       	breq	.+2      	; 0x1f14 <uip_process+0x152>
    1f12:	db c6       	rjmp	.+3510   	; 0x2cca <__stack+0xbcb>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_len = uip_slen = 0;
    1f14:	10 92 b2 0c 	sts	0x0CB2, r1
    1f18:	10 92 b1 0c 	sts	0x0CB1, r1
    1f1c:	10 92 4e 05 	sts	0x054E, r1
    1f20:	10 92 4d 05 	sts	0x054D, r1
	uip_flags = UIP_POLL;
    1f24:	88 e0       	ldi	r24, 0x08	; 8
    1f26:	80 93 55 05 	sts	0x0555, r24
    1f2a:	7e c5       	rjmp	.+2812   	; 0x2a28 <__stack+0x929>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    1f2c:	85 30       	cpi	r24, 0x05	; 5
    1f2e:	19 f5       	brne	.+70     	; 0x1f76 <uip_process+0x1b4>
    if(uip_udp_conn->lport != 0) {
    1f30:	e0 91 56 05 	lds	r30, 0x0556
    1f34:	f0 91 57 05 	lds	r31, 0x0557
    1f38:	84 81       	ldd	r24, Z+4	; 0x04
    1f3a:	95 81       	ldd	r25, Z+5	; 0x05
    1f3c:	89 2b       	or	r24, r25
    1f3e:	09 f4       	brne	.+2      	; 0x1f42 <uip_process+0x180>
    1f40:	c4 c6       	rjmp	.+3464   	; 0x2cca <__stack+0xbcb>
      uip_conn = NULL;
    1f42:	10 92 5b 05 	sts	0x055B, r1
    1f46:	10 92 5a 05 	sts	0x055A, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    1f4a:	c9 01       	movw	r24, r18
    1f4c:	0c 97       	sbiw	r24, 0x0c	; 12
    1f4e:	90 93 59 05 	sts	0x0559, r25
    1f52:	80 93 58 05 	sts	0x0558, r24
    1f56:	90 93 50 05 	sts	0x0550, r25
    1f5a:	80 93 4f 05 	sts	0x054F, r24
      uip_len = uip_slen = 0;
    1f5e:	10 92 b2 0c 	sts	0x0CB2, r1
    1f62:	10 92 b1 0c 	sts	0x0CB1, r1
    1f66:	10 92 4e 05 	sts	0x054E, r1
    1f6a:	10 92 4d 05 	sts	0x054D, r1
      uip_flags = UIP_POLL;
    1f6e:	88 e0       	ldi	r24, 0x08	; 8
    1f70:	80 93 55 05 	sts	0x0555, r24
    1f74:	66 c1       	rjmp	.+716    	; 0x2242 <__stack+0x143>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    1f76:	89 01       	movw	r16, r18
    1f78:	08 52       	subi	r16, 0x28	; 40
    1f7a:	10 40       	sbci	r17, 0x00	; 0
    1f7c:	80 91 d3 06 	lds	r24, 0x06D3
    1f80:	85 34       	cpi	r24, 0x45	; 69
    1f82:	09 f0       	breq	.+2      	; 0x1f86 <uip_process+0x1c4>
    1f84:	a2 c6       	rjmp	.+3396   	; 0x2cca <__stack+0xbcb>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    1f86:	90 91 d5 06 	lds	r25, 0x06D5
    1f8a:	80 e0       	ldi	r24, 0x00	; 0
    1f8c:	20 91 d6 06 	lds	r18, 0x06D6
    1f90:	ac 01       	movw	r20, r24
    1f92:	42 0f       	add	r20, r18
    1f94:	51 1d       	adc	r21, r1
    1f96:	80 91 4d 05 	lds	r24, 0x054D
    1f9a:	90 91 4e 05 	lds	r25, 0x054E
    1f9e:	84 17       	cp	r24, r20
    1fa0:	95 07       	cpc	r25, r21
    1fa2:	08 f4       	brcc	.+2      	; 0x1fa6 <uip_process+0x1e4>
    1fa4:	92 c6       	rjmp	.+3364   	; 0x2cca <__stack+0xbcb>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    1fa6:	50 93 4e 05 	sts	0x054E, r21
    1faa:	40 93 4d 05 	sts	0x054D, r20
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    1fae:	80 91 d9 06 	lds	r24, 0x06D9
    1fb2:	90 e0       	ldi	r25, 0x00	; 0
    1fb4:	8f 73       	andi	r24, 0x3F	; 63
    1fb6:	90 70       	andi	r25, 0x00	; 0
    1fb8:	89 2b       	or	r24, r25
    1fba:	09 f0       	breq	.+2      	; 0x1fbe <uip_process+0x1fc>
    1fbc:	86 c6       	rjmp	.+3340   	; 0x2cca <__stack+0xbcb>
    1fbe:	80 91 da 06 	lds	r24, 0x06DA
    1fc2:	88 23       	and	r24, r24
    1fc4:	09 f0       	breq	.+2      	; 0x1fc8 <uip_process+0x206>
    1fc6:	81 c6       	rjmp	.+3330   	; 0x2cca <__stack+0xbcb>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    1fc8:	40 91 c1 06 	lds	r20, 0x06C1
    1fcc:	50 91 c2 06 	lds	r21, 0x06C2
    1fd0:	c0 91 6b 02 	lds	r28, 0x026B
    1fd4:	d0 91 6c 02 	lds	r29, 0x026C
    1fd8:	4c 17       	cp	r20, r28
    1fda:	5d 07       	cpc	r21, r29
    1fdc:	59 f4       	brne	.+22     	; 0x1ff4 <uip_process+0x232>
    1fde:	20 91 c3 06 	lds	r18, 0x06C3
    1fe2:	30 91 c4 06 	lds	r19, 0x06C4
    1fe6:	80 91 6d 02 	lds	r24, 0x026D
    1fea:	90 91 6e 02 	lds	r25, 0x026E
    1fee:	28 17       	cp	r18, r24
    1ff0:	39 07       	cpc	r19, r25
    1ff2:	a1 f0       	breq	.+40     	; 0x201c <uip_process+0x25a>
    }
#endif /* UIP_BROADCAST */

    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    1ff4:	80 91 e3 06 	lds	r24, 0x06E3
    1ff8:	90 91 e4 06 	lds	r25, 0x06E4
    1ffc:	84 17       	cp	r24, r20
    1ffe:	95 07       	cpc	r25, r21
    2000:	09 f0       	breq	.+2      	; 0x2004 <uip_process+0x242>
    2002:	63 c6       	rjmp	.+3270   	; 0x2cca <__stack+0xbcb>
    2004:	20 91 e5 06 	lds	r18, 0x06E5
    2008:	30 91 e6 06 	lds	r19, 0x06E6
    200c:	80 91 c3 06 	lds	r24, 0x06C3
    2010:	90 91 c4 06 	lds	r25, 0x06C4
    2014:	28 17       	cp	r18, r24
    2016:	39 07       	cpc	r19, r25
    2018:	09 f0       	breq	.+2      	; 0x201c <uip_process+0x25a>
    201a:	57 c6       	rjmp	.+3246   	; 0x2cca <__stack+0xbcb>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    201c:	9e de       	rcall	.-708    	; 0x1d5a <uip_ipchksum>
    201e:	8f 5f       	subi	r24, 0xFF	; 255
    2020:	9f 4f       	sbci	r25, 0xFF	; 255
    2022:	09 f0       	breq	.+2      	; 0x2026 <uip_process+0x264>
    2024:	52 c6       	rjmp	.+3236   	; 0x2cca <__stack+0xbcb>
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    2026:	80 91 dc 06 	lds	r24, 0x06DC
    202a:	86 30       	cpi	r24, 0x06	; 6
    202c:	09 f4       	brne	.+2      	; 0x2030 <uip_process+0x26e>
    202e:	60 c1       	rjmp	.+704    	; 0x22f0 <__stack+0x1f1>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    2030:	81 31       	cpi	r24, 0x11	; 17
    2032:	e9 f1       	breq	.+122    	; 0x20ae <uip_process+0x2ec>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    2034:	81 30       	cpi	r24, 0x01	; 1
    2036:	09 f0       	breq	.+2      	; 0x203a <uip_process+0x278>
    2038:	48 c6       	rjmp	.+3216   	; 0x2cca <__stack+0xbcb>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    203a:	80 91 e7 06 	lds	r24, 0x06E7
    203e:	88 30       	cpi	r24, 0x08	; 8
    2040:	09 f0       	breq	.+2      	; 0x2044 <uip_process+0x282>
    2042:	43 c6       	rjmp	.+3206   	; 0x2cca <__stack+0xbcb>
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    2044:	10 92 e7 06 	sts	0x06E7, r1

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    2048:	80 91 e9 06 	lds	r24, 0x06E9
    204c:	90 91 ea 06 	lds	r25, 0x06EA
    2050:	ef ef       	ldi	r30, 0xFF	; 255
    2052:	87 3f       	cpi	r24, 0xF7	; 247
    2054:	9e 07       	cpc	r25, r30
    2056:	10 f0       	brcs	.+4      	; 0x205c <uip_process+0x29a>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    2058:	09 96       	adiw	r24, 0x09	; 9
    205a:	01 c0       	rjmp	.+2      	; 0x205e <uip_process+0x29c>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    205c:	08 96       	adiw	r24, 0x08	; 8
    205e:	90 93 ea 06 	sts	0x06EA, r25
    2062:	80 93 e9 06 	sts	0x06E9, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    2066:	80 91 df 06 	lds	r24, 0x06DF
    206a:	90 91 e0 06 	lds	r25, 0x06E0
    206e:	a0 91 e1 06 	lds	r26, 0x06E1
    2072:	b0 91 e2 06 	lds	r27, 0x06E2
    2076:	80 93 e3 06 	sts	0x06E3, r24
    207a:	90 93 e4 06 	sts	0x06E4, r25
    207e:	a0 93 e5 06 	sts	0x06E5, r26
    2082:	b0 93 e6 06 	sts	0x06E6, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2086:	80 91 c1 06 	lds	r24, 0x06C1
    208a:	90 91 c2 06 	lds	r25, 0x06C2
    208e:	a0 91 c3 06 	lds	r26, 0x06C3
    2092:	b0 91 c4 06 	lds	r27, 0x06C4
    2096:	80 93 df 06 	sts	0x06DF, r24
    209a:	90 93 e0 06 	sts	0x06E0, r25
    209e:	a0 93 e1 06 	sts	0x06E1, r26
    20a2:	b0 93 e2 06 	sts	0x06E2, r27

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    20a6:	80 e4       	ldi	r24, 0x40	; 64
    20a8:	f8 01       	movw	r30, r16
    20aa:	80 87       	std	Z+8, r24	; 0x08
    20ac:	ec c5       	rjmp	.+3032   	; 0x2c86 <__stack+0xb87>
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
    20ae:	80 91 4d 05 	lds	r24, 0x054D
    20b2:	90 91 4e 05 	lds	r25, 0x054E
    20b6:	4c 97       	sbiw	r24, 0x1c	; 28
    20b8:	90 93 4e 05 	sts	0x054E, r25
    20bc:	80 93 4d 05 	sts	0x054D, r24
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    20c0:	83 eb       	ldi	r24, 0xB3	; 179
    20c2:	9c e0       	ldi	r25, 0x0C	; 12
    20c4:	90 93 57 05 	sts	0x0557, r25
    20c8:	80 93 56 05 	sts	0x0556, r24
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    20cc:	a0 91 6d 02 	lds	r26, 0x026D
    20d0:	b0 91 6e 02 	lds	r27, 0x026E
    20d4:	60 91 67 02 	lds	r22, 0x0267
    20d8:	70 91 68 02 	lds	r23, 0x0268
    20dc:	40 91 69 02 	lds	r20, 0x0269
    20e0:	50 91 6a 02 	lds	r21, 0x026A
    20e4:	42 c0       	rjmp	.+132    	; 0x216a <__stack+0x6b>
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    20e6:	24 81       	ldd	r18, Z+4	; 0x04
    20e8:	35 81       	ldd	r19, Z+5	; 0x05
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    20ea:	21 15       	cp	r18, r1
    20ec:	31 05       	cpc	r19, r1
    20ee:	c1 f1       	breq	.+112    	; 0x2160 <__stack+0x61>
    20f0:	80 91 e9 06 	lds	r24, 0x06E9
    20f4:	90 91 ea 06 	lds	r25, 0x06EA
    20f8:	82 17       	cp	r24, r18
    20fa:	93 07       	cpc	r25, r19
    20fc:	89 f5       	brne	.+98     	; 0x2160 <__stack+0x61>
    20fe:	26 81       	ldd	r18, Z+6	; 0x06
    2100:	37 81       	ldd	r19, Z+7	; 0x07
    2102:	21 15       	cp	r18, r1
    2104:	31 05       	cpc	r19, r1
    2106:	39 f0       	breq	.+14     	; 0x2116 <__stack+0x17>
    2108:	80 91 e7 06 	lds	r24, 0x06E7
    210c:	90 91 e8 06 	lds	r25, 0x06E8
    2110:	82 17       	cp	r24, r18
    2112:	93 07       	cpc	r25, r19
    2114:	29 f5       	brne	.+74     	; 0x2160 <__stack+0x61>
    2116:	20 81       	ld	r18, Z
    2118:	31 81       	ldd	r19, Z+1	; 0x01
    211a:	2c 17       	cp	r18, r28
    211c:	3d 07       	cpc	r19, r29
    211e:	31 f4       	brne	.+12     	; 0x212c <__stack+0x2d>
    2120:	82 81       	ldd	r24, Z+2	; 0x02
    2122:	93 81       	ldd	r25, Z+3	; 0x03
    2124:	8a 17       	cp	r24, r26
    2126:	9b 07       	cpc	r25, r27
    2128:	09 f4       	brne	.+2      	; 0x212c <__stack+0x2d>
    212a:	76 c0       	rjmp	.+236    	; 0x2218 <__stack+0x119>
    212c:	26 17       	cp	r18, r22
    212e:	37 07       	cpc	r19, r23
    2130:	31 f4       	brne	.+12     	; 0x213e <__stack+0x3f>
    2132:	82 81       	ldd	r24, Z+2	; 0x02
    2134:	93 81       	ldd	r25, Z+3	; 0x03
    2136:	84 17       	cp	r24, r20
    2138:	95 07       	cpc	r25, r21
    213a:	09 f4       	brne	.+2      	; 0x213e <__stack+0x3f>
    213c:	6d c0       	rjmp	.+218    	; 0x2218 <__stack+0x119>
    213e:	80 91 df 06 	lds	r24, 0x06DF
    2142:	90 91 e0 06 	lds	r25, 0x06E0
    2146:	82 17       	cp	r24, r18
    2148:	93 07       	cpc	r25, r19
    214a:	51 f4       	brne	.+20     	; 0x2160 <__stack+0x61>
    214c:	20 91 e1 06 	lds	r18, 0x06E1
    2150:	30 91 e2 06 	lds	r19, 0x06E2
    2154:	82 81       	ldd	r24, Z+2	; 0x02
    2156:	93 81       	ldd	r25, Z+3	; 0x03
    2158:	28 17       	cp	r18, r24
    215a:	39 07       	cpc	r19, r25
    215c:	09 f4       	brne	.+2      	; 0x2160 <__stack+0x61>
    215e:	5c c0       	rjmp	.+184    	; 0x2218 <__stack+0x119>
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    2160:	7e 96       	adiw	r30, 0x1e	; 30
    2162:	f0 93 57 05 	sts	0x0557, r31
    2166:	e0 93 56 05 	sts	0x0556, r30
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    216a:	e0 91 56 05 	lds	r30, 0x0556
    216e:	f0 91 57 05 	lds	r31, 0x0557
    2172:	2c e0       	ldi	r18, 0x0C	; 12
    2174:	e1 3d       	cpi	r30, 0xD1	; 209
    2176:	f2 07       	cpc	r31, r18
    2178:	08 f4       	brcc	.+2      	; 0x217c <__stack+0x7d>
    217a:	b5 cf       	rjmp	.-150    	; 0x20e6 <uip_process+0x324>
    }
  }
  UIP_LOG("udp: no matching connection found");
#if UIP_CONF_ICMP_DEST_UNREACH && !UIP_CONF_IPV6
  /* Copy fields from packet header into payload of this ICMP packet. */
  memcpy(&(ICMPBUF->payload[0]), ICMPBUF, UIP_IPH_LEN + 8);
    217c:	ef ee       	ldi	r30, 0xEF	; 239
    217e:	f6 e0       	ldi	r31, 0x06	; 6
    2180:	df 01       	movw	r26, r30
    2182:	5c 97       	sbiw	r26, 0x1c	; 28
    2184:	8c e1       	ldi	r24, 0x1C	; 28
    2186:	0d 90       	ld	r0, X+
    2188:	01 92       	st	Z+, r0
    218a:	81 50       	subi	r24, 0x01	; 1
    218c:	e1 f7       	brne	.-8      	; 0x2186 <__stack+0x87>

  /* Set the ICMP type and code. */
  ICMPBUF->type = ICMP_DEST_UNREACHABLE;
    218e:	83 e0       	ldi	r24, 0x03	; 3
    2190:	80 93 e7 06 	sts	0x06E7, r24
  ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
    2194:	80 93 e8 06 	sts	0x06E8, r24

  /* Calculate the ICMP checksum. */
  ICMPBUF->icmpchksum = 0;
    2198:	10 92 ea 06 	sts	0x06EA, r1
    219c:	10 92 e9 06 	sts	0x06E9, r1
  ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
    21a0:	87 ee       	ldi	r24, 0xE7	; 231
    21a2:	96 e0       	ldi	r25, 0x06	; 6
    21a4:	64 e2       	ldi	r22, 0x24	; 36
    21a6:	70 e0       	ldi	r23, 0x00	; 0
    21a8:	e8 dd       	rcall	.-1072   	; 0x1d7a <uip_chksum>
    21aa:	80 95       	com	r24
    21ac:	90 95       	com	r25
    21ae:	90 93 ea 06 	sts	0x06EA, r25
    21b2:	80 93 e9 06 	sts	0x06E9, r24

  /* Set the IP destination address to be the source address of the
     original packet. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    21b6:	80 91 df 06 	lds	r24, 0x06DF
    21ba:	90 91 e0 06 	lds	r25, 0x06E0
    21be:	a0 91 e1 06 	lds	r26, 0x06E1
    21c2:	b0 91 e2 06 	lds	r27, 0x06E2
    21c6:	80 93 e3 06 	sts	0x06E3, r24
    21ca:	90 93 e4 06 	sts	0x06E4, r25
    21ce:	a0 93 e5 06 	sts	0x06E5, r26
    21d2:	b0 93 e6 06 	sts	0x06E6, r27

  /* Set our IP address as the source address. */
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    21d6:	80 91 c1 06 	lds	r24, 0x06C1
    21da:	90 91 c2 06 	lds	r25, 0x06C2
    21de:	a0 91 c3 06 	lds	r26, 0x06C3
    21e2:	b0 91 c4 06 	lds	r27, 0x06C4
    21e6:	80 93 df 06 	sts	0x06DF, r24
    21ea:	90 93 e0 06 	sts	0x06E0, r25
    21ee:	a0 93 e1 06 	sts	0x06E1, r26
    21f2:	b0 93 e2 06 	sts	0x06E2, r27

  /* The size of the ICMP destination unreachable packet is 36 + the
     size of the IP header (20) = 56. */
  uip_len = 36 + UIP_IPH_LEN;
    21f6:	88 e3       	ldi	r24, 0x38	; 56
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	90 93 4e 05 	sts	0x054E, r25
    21fe:	80 93 4d 05 	sts	0x054D, r24
  ICMPBUF->len[0] = 0;
    2202:	10 92 d5 06 	sts	0x06D5, r1
  ICMPBUF->len[1] = (u8_t)uip_len;
    2206:	80 93 d6 06 	sts	0x06D6, r24
  ICMPBUF->ttl = UIP_TTL;
    220a:	80 e4       	ldi	r24, 0x40	; 64
    220c:	80 93 db 06 	sts	0x06DB, r24
  ICMPBUF->proto = UIP_PROTO_ICMP;
    2210:	81 e0       	ldi	r24, 0x01	; 1
    2212:	80 93 dc 06 	sts	0x06DC, r24
    2216:	37 c5       	rjmp	.+2670   	; 0x2c86 <__stack+0xb87>
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */

 udp_found:
  uip_conn = NULL;
    2218:	10 92 5b 05 	sts	0x055B, r1
    221c:	10 92 5a 05 	sts	0x055A, r1
  uip_flags = UIP_NEWDATA;
    2220:	82 e0       	ldi	r24, 0x02	; 2
    2222:	80 93 55 05 	sts	0x0555, r24
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2226:	8f ee       	ldi	r24, 0xEF	; 239
    2228:	96 e0       	ldi	r25, 0x06	; 6
    222a:	90 93 59 05 	sts	0x0559, r25
    222e:	80 93 58 05 	sts	0x0558, r24
    2232:	90 93 50 05 	sts	0x0550, r25
    2236:	80 93 4f 05 	sts	0x054F, r24
  uip_slen = 0;
    223a:	10 92 b2 0c 	sts	0x0CB2, r1
    223e:	10 92 b1 0c 	sts	0x0CB1, r1
  UIP_UDP_APPCALL();
    2242:	0e 94 1c 08 	call	0x1038	; 0x1038 <uIPManagement_UDPCallback>

 udp_send:
  if(uip_slen == 0) {
    2246:	20 91 b1 0c 	lds	r18, 0x0CB1
    224a:	30 91 b2 0c 	lds	r19, 0x0CB2
    224e:	21 15       	cp	r18, r1
    2250:	31 05       	cpc	r19, r1
    2252:	09 f4       	brne	.+2      	; 0x2256 <__stack+0x157>
    2254:	3a c5       	rjmp	.+2676   	; 0x2cca <__stack+0xbcb>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    2256:	c9 01       	movw	r24, r18
    2258:	4c 96       	adiw	r24, 0x1c	; 28
    225a:	90 93 4e 05 	sts	0x054E, r25
    225e:	80 93 4d 05 	sts	0x054D, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    2262:	90 93 d5 06 	sts	0x06D5, r25
  BUF->len[1] = (uip_len & 0xff);
    2266:	80 93 d6 06 	sts	0x06D6, r24
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    226a:	e0 91 56 05 	lds	r30, 0x0556
    226e:	f0 91 57 05 	lds	r31, 0x0557
    2272:	80 85       	ldd	r24, Z+8	; 0x08
    2274:	80 93 db 06 	sts	0x06DB, r24
  BUF->proto = UIP_PROTO_UDP;
    2278:	81 e1       	ldi	r24, 0x11	; 17
    227a:	80 93 dc 06 	sts	0x06DC, r24

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
    227e:	c9 01       	movw	r24, r18
    2280:	08 96       	adiw	r24, 0x08	; 8
    2282:	90 93 eb 06 	sts	0x06EB, r25
    2286:	80 93 ec 06 	sts	0x06EC, r24
  UDPBUF->udpchksum = 0;
    228a:	10 92 ee 06 	sts	0x06EE, r1
    228e:	10 92 ed 06 	sts	0x06ED, r1

  BUF->srcport  = uip_udp_conn->lport;
    2292:	84 81       	ldd	r24, Z+4	; 0x04
    2294:	95 81       	ldd	r25, Z+5	; 0x05
    2296:	90 93 e8 06 	sts	0x06E8, r25
    229a:	80 93 e7 06 	sts	0x06E7, r24
  BUF->destport = uip_udp_conn->rport;
    229e:	86 81       	ldd	r24, Z+6	; 0x06
    22a0:	97 81       	ldd	r25, Z+7	; 0x07
    22a2:	90 93 ea 06 	sts	0x06EA, r25
    22a6:	80 93 e9 06 	sts	0x06E9, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    22aa:	80 91 c1 06 	lds	r24, 0x06C1
    22ae:	90 91 c2 06 	lds	r25, 0x06C2
    22b2:	a0 91 c3 06 	lds	r26, 0x06C3
    22b6:	b0 91 c4 06 	lds	r27, 0x06C4
    22ba:	80 93 df 06 	sts	0x06DF, r24
    22be:	90 93 e0 06 	sts	0x06E0, r25
    22c2:	a0 93 e1 06 	sts	0x06E1, r26
    22c6:	b0 93 e2 06 	sts	0x06E2, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    22ca:	80 81       	ld	r24, Z
    22cc:	91 81       	ldd	r25, Z+1	; 0x01
    22ce:	a2 81       	ldd	r26, Z+2	; 0x02
    22d0:	b3 81       	ldd	r27, Z+3	; 0x03
    22d2:	80 93 e3 06 	sts	0x06E3, r24
    22d6:	90 93 e4 06 	sts	0x06E4, r25
    22da:	a0 93 e5 06 	sts	0x06E5, r26
    22de:	b0 93 e6 06 	sts	0x06E6, r27

  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    22e2:	8b ef       	ldi	r24, 0xFB	; 251
    22e4:	96 e0       	ldi	r25, 0x06	; 6
    22e6:	90 93 59 05 	sts	0x0559, r25
    22ea:	80 93 58 05 	sts	0x0558, r24
    22ee:	cb c4       	rjmp	.+2454   	; 0x2c86 <__stack+0xb87>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */

  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    22f0:	12 dd       	rcall	.-1500   	; 0x1d16 <uip_tcpchksum>
    22f2:	8f 5f       	subi	r24, 0xFF	; 255
    22f4:	9f 4f       	sbci	r25, 0xFF	; 255
    22f6:	09 f0       	breq	.+2      	; 0x22fa <__stack+0x1fb>
    22f8:	e8 c4       	rjmp	.+2512   	; 0x2cca <__stack+0xbcb>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    UIP_LOG("tcp: bad checksum.");
    goto drop;
    22fa:	cc e5       	ldi	r28, 0x5C	; 92
    22fc:	d5 e0       	ldi	r29, 0x05	; 5

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    22fe:	89 8d       	ldd	r24, Y+25	; 0x19
    2300:	88 23       	and	r24, r24
    2302:	29 f1       	breq	.+74     	; 0x234e <__stack+0x24f>
    2304:	20 91 e9 06 	lds	r18, 0x06E9
    2308:	30 91 ea 06 	lds	r19, 0x06EA
    230c:	8c 81       	ldd	r24, Y+4	; 0x04
    230e:	9d 81       	ldd	r25, Y+5	; 0x05
    2310:	28 17       	cp	r18, r24
    2312:	39 07       	cpc	r19, r25
    2314:	e1 f4       	brne	.+56     	; 0x234e <__stack+0x24f>
    2316:	20 91 e7 06 	lds	r18, 0x06E7
    231a:	30 91 e8 06 	lds	r19, 0x06E8
    231e:	8e 81       	ldd	r24, Y+6	; 0x06
    2320:	9f 81       	ldd	r25, Y+7	; 0x07
    2322:	28 17       	cp	r18, r24
    2324:	39 07       	cpc	r19, r25
    2326:	99 f4       	brne	.+38     	; 0x234e <__stack+0x24f>
    2328:	20 91 df 06 	lds	r18, 0x06DF
    232c:	30 91 e0 06 	lds	r19, 0x06E0
    2330:	88 81       	ld	r24, Y
    2332:	99 81       	ldd	r25, Y+1	; 0x01
    2334:	28 17       	cp	r18, r24
    2336:	39 07       	cpc	r19, r25
    2338:	51 f4       	brne	.+20     	; 0x234e <__stack+0x24f>
    233a:	20 91 e1 06 	lds	r18, 0x06E1
    233e:	30 91 e2 06 	lds	r19, 0x06E2
    2342:	8a 81       	ldd	r24, Y+2	; 0x02
    2344:	9b 81       	ldd	r25, Y+3	; 0x03
    2346:	28 17       	cp	r18, r24
    2348:	39 07       	cpc	r19, r25
    234a:	09 f4       	brne	.+2      	; 0x234e <__stack+0x24f>
    234c:	7e c1       	rjmp	.+764    	; 0x264a <__stack+0x54b>
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    234e:	cf 58       	subi	r28, 0x8F	; 143
    2350:	df 4f       	sbci	r29, 0xFF	; 255
    goto drop;
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    2352:	56 e0       	ldi	r21, 0x06	; 6
    2354:	ce 33       	cpi	r28, 0x3E	; 62
    2356:	d5 07       	cpc	r29, r21
    2358:	91 f2       	breq	.-92     	; 0x22fe <__stack+0x1ff>
    235a:	88 f2       	brcs	.-94     	; 0x22fe <__stack+0x1ff>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    235c:	80 91 f4 06 	lds	r24, 0x06F4
    2360:	8f 73       	andi	r24, 0x3F	; 63
    2362:	82 30       	cpi	r24, 0x02	; 2
    2364:	11 f5       	brne	.+68     	; 0x23aa <__stack+0x2ab>
    goto reset;
  }

  tmp16 = BUF->destport;
    2366:	80 91 e9 06 	lds	r24, 0x06E9
    236a:	90 91 ea 06 	lds	r25, 0x06EA
    236e:	90 93 ad 02 	sts	0x02AD, r25
    2372:	80 93 ac 02 	sts	0x02AC, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2376:	10 92 aa 02 	sts	0x02AA, r1
    237a:	13 c0       	rjmp	.+38     	; 0x23a2 <__stack+0x2a3>
    if(tmp16 == uip_listenports[c]) {
    237c:	e4 2f       	mov	r30, r20
    237e:	f0 e0       	ldi	r31, 0x00	; 0
    2380:	ee 0f       	add	r30, r30
    2382:	ff 1f       	adc	r31, r31
    2384:	e1 55       	subi	r30, 0x51	; 81
    2386:	f9 4f       	sbci	r31, 0xF9	; 249
    2388:	20 91 ac 02 	lds	r18, 0x02AC
    238c:	30 91 ad 02 	lds	r19, 0x02AD
    2390:	80 81       	ld	r24, Z
    2392:	91 81       	ldd	r25, Z+1	; 0x01
    2394:	28 17       	cp	r18, r24
    2396:	39 07       	cpc	r19, r25
    2398:	09 f4       	brne	.+2      	; 0x239c <__stack+0x29d>
    239a:	71 c0       	rjmp	.+226    	; 0x247e <__stack+0x37f>
    goto reset;
  }

  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    239c:	4f 5f       	subi	r20, 0xFF	; 255
    239e:	40 93 aa 02 	sts	0x02AA, r20
    23a2:	40 91 aa 02 	lds	r20, 0x02AA
    23a6:	45 30       	cpi	r20, 0x05	; 5
    23a8:	48 f3       	brcs	.-46     	; 0x237c <__stack+0x27d>
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    23aa:	80 91 f4 06 	lds	r24, 0x06F4
    23ae:	82 fd       	sbrc	r24, 2
    23b0:	8c c4       	rjmp	.+2328   	; 0x2cca <__stack+0xbcb>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);

  BUF->flags = TCP_RST | TCP_ACK;
    23b2:	84 e1       	ldi	r24, 0x14	; 20
    23b4:	f8 01       	movw	r30, r16
    23b6:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    23b8:	88 e2       	ldi	r24, 0x28	; 40
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	90 93 4e 05 	sts	0x054E, r25
    23c0:	80 93 4d 05 	sts	0x054D, r24
  BUF->tcpoffset = 5 << 4;
    23c4:	80 e5       	ldi	r24, 0x50	; 80
    23c6:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    23c8:	90 91 ee 06 	lds	r25, 0x06EE
  BUF->seqno[3] = BUF->ackno[3];
    23cc:	80 91 f2 06 	lds	r24, 0x06F2
    23d0:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;

  c = BUF->seqno[2];
    23d2:	30 91 ed 06 	lds	r19, 0x06ED
  BUF->seqno[2] = BUF->ackno[2];
    23d6:	80 91 f1 06 	lds	r24, 0x06F1
    23da:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    23dc:	36 8f       	std	Z+30, r19	; 0x1e

  c = BUF->seqno[1];
    23de:	40 91 ec 06 	lds	r20, 0x06EC
  BUF->seqno[1] = BUF->ackno[1];
    23e2:	80 91 f0 06 	lds	r24, 0x06F0
    23e6:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    23e8:	45 8f       	std	Z+29, r20	; 0x1d

  c = BUF->seqno[0];
    23ea:	20 91 eb 06 	lds	r18, 0x06EB
    23ee:	20 93 aa 02 	sts	0x02AA, r18
  BUF->seqno[0] = BUF->ackno[0];
    23f2:	80 91 ef 06 	lds	r24, 0x06EF
    23f6:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    23f8:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    23fa:	9f 5f       	subi	r25, 0xFF	; 255
    23fc:	97 8f       	std	Z+31, r25	; 0x1f
    23fe:	99 23       	and	r25, r25
    2400:	61 f4       	brne	.+24     	; 0x241a <__stack+0x31b>
    if(++BUF->ackno[2] == 0) {
    2402:	83 2f       	mov	r24, r19
    2404:	8f 5f       	subi	r24, 0xFF	; 255
    2406:	86 8f       	std	Z+30, r24	; 0x1e
    2408:	88 23       	and	r24, r24
    240a:	39 f4       	brne	.+14     	; 0x241a <__stack+0x31b>
      if(++BUF->ackno[1] == 0) {
    240c:	84 2f       	mov	r24, r20
    240e:	8f 5f       	subi	r24, 0xFF	; 255
    2410:	85 8f       	std	Z+29, r24	; 0x1d
    2412:	88 23       	and	r24, r24
    2414:	11 f4       	brne	.+4      	; 0x241a <__stack+0x31b>
	++BUF->ackno[0];
    2416:	2f 5f       	subi	r18, 0xFF	; 255
    2418:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }

  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    241a:	20 91 e7 06 	lds	r18, 0x06E7
    241e:	30 91 e8 06 	lds	r19, 0x06E8
    2422:	30 93 ad 02 	sts	0x02AD, r19
    2426:	20 93 ac 02 	sts	0x02AC, r18
  BUF->srcport = BUF->destport;
    242a:	80 91 e9 06 	lds	r24, 0x06E9
    242e:	90 91 ea 06 	lds	r25, 0x06EA
    2432:	f8 01       	movw	r30, r16
    2434:	95 8b       	std	Z+21, r25	; 0x15
    2436:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    2438:	37 8b       	std	Z+23, r19	; 0x17
    243a:	26 8b       	std	Z+22, r18	; 0x16

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    243c:	80 91 df 06 	lds	r24, 0x06DF
    2440:	90 91 e0 06 	lds	r25, 0x06E0
    2444:	a0 91 e1 06 	lds	r26, 0x06E1
    2448:	b0 91 e2 06 	lds	r27, 0x06E2
    244c:	80 93 e3 06 	sts	0x06E3, r24
    2450:	90 93 e4 06 	sts	0x06E4, r25
    2454:	a0 93 e5 06 	sts	0x06E5, r26
    2458:	b0 93 e6 06 	sts	0x06E6, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    245c:	80 91 c1 06 	lds	r24, 0x06C1
    2460:	90 91 c2 06 	lds	r25, 0x06C2
    2464:	a0 91 c3 06 	lds	r26, 0x06C3
    2468:	b0 91 c4 06 	lds	r27, 0x06C4
    246c:	80 93 df 06 	sts	0x06DF, r24
    2470:	90 93 e0 06 	sts	0x06E0, r25
    2474:	a0 93 e1 06 	sts	0x06E1, r26
    2478:	b0 93 e2 06 	sts	0x06E2, r27
    247c:	ea c3       	rjmp	.+2004   	; 0x2c52 <__stack+0xb53>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    247e:	10 92 aa 02 	sts	0x02AA, r1
    2482:	c0 e0       	ldi	r28, 0x00	; 0
    2484:	d0 e0       	ldi	r29, 0x00	; 0
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    2486:	41 e7       	ldi	r20, 0x71	; 113
    2488:	50 e0       	ldi	r21, 0x00	; 0
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    248a:	31 e7       	ldi	r19, 0x71	; 113
    248c:	25 c0       	rjmp	.+74     	; 0x24d8 <__stack+0x3d9>
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    248e:	82 2f       	mov	r24, r18
    2490:	90 e0       	ldi	r25, 0x00	; 0
    2492:	84 9f       	mul	r24, r20
    2494:	f0 01       	movw	r30, r0
    2496:	85 9f       	mul	r24, r21
    2498:	f0 0d       	add	r31, r0
    249a:	94 9f       	mul	r25, r20
    249c:	f0 0d       	add	r31, r0
    249e:	11 24       	eor	r1, r1
    24a0:	e4 5a       	subi	r30, 0xA4	; 164
    24a2:	fa 4f       	sbci	r31, 0xFA	; 250
    24a4:	81 8d       	ldd	r24, Z+25	; 0x19
    24a6:	88 23       	and	r24, r24
    24a8:	39 f4       	brne	.+14     	; 0x24b8 <__stack+0x3b9>
      uip_connr = &uip_conns[c];
    24aa:	81 e7       	ldi	r24, 0x71	; 113
    24ac:	28 9f       	mul	r18, r24
    24ae:	e0 01       	movw	r28, r0
    24b0:	11 24       	eor	r1, r1
    24b2:	c4 5a       	subi	r28, 0xA4	; 164
    24b4:	da 4f       	sbci	r29, 0xFA	; 250
    24b6:	14 c0       	rjmp	.+40     	; 0x24e0 <__stack+0x3e1>
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    24b8:	87 30       	cpi	r24, 0x07	; 7
    24ba:	59 f4       	brne	.+22     	; 0x24d2 <__stack+0x3d3>
      if(uip_connr == 0 ||
    24bc:	20 97       	sbiw	r28, 0x00	; 0
    24be:	21 f0       	breq	.+8      	; 0x24c8 <__stack+0x3c9>
    24c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    24c2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    24c4:	89 17       	cp	r24, r25
    24c6:	28 f4       	brcc	.+10     	; 0x24d2 <__stack+0x3d3>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    24c8:	23 9f       	mul	r18, r19
    24ca:	e0 01       	movw	r28, r0
    24cc:	11 24       	eor	r1, r1
    24ce:	c4 5a       	subi	r28, 0xA4	; 164
    24d0:	da 4f       	sbci	r29, 0xFA	; 250
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    24d2:	2f 5f       	subi	r18, 0xFF	; 255
    24d4:	20 93 aa 02 	sts	0x02AA, r18
    24d8:	20 91 aa 02 	lds	r18, 0x02AA
    24dc:	23 30       	cpi	r18, 0x03	; 3
    24de:	b8 f2       	brcs	.-82     	; 0x248e <__stack+0x38f>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    24e0:	20 97       	sbiw	r28, 0x00	; 0
    24e2:	09 f4       	brne	.+2      	; 0x24e6 <__stack+0x3e7>
    24e4:	f2 c3       	rjmp	.+2020   	; 0x2cca <__stack+0xbcb>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    24e6:	d0 93 5b 05 	sts	0x055B, r29
    24ea:	c0 93 5a 05 	sts	0x055A, r28

  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    24ee:	83 e0       	ldi	r24, 0x03	; 3
    24f0:	8a 8f       	std	Y+26, r24	; 0x1a
    24f2:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    24f4:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    24f6:	84 e0       	ldi	r24, 0x04	; 4
    24f8:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    24fa:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    24fc:	80 91 e9 06 	lds	r24, 0x06E9
    2500:	90 91 ea 06 	lds	r25, 0x06EA
    2504:	9d 83       	std	Y+5, r25	; 0x05
    2506:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    2508:	80 91 e7 06 	lds	r24, 0x06E7
    250c:	90 91 e8 06 	lds	r25, 0x06E8
    2510:	9f 83       	std	Y+7, r25	; 0x07
    2512:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    2514:	80 91 df 06 	lds	r24, 0x06DF
    2518:	90 91 e0 06 	lds	r25, 0x06E0
    251c:	a0 91 e1 06 	lds	r26, 0x06E1
    2520:	b0 91 e2 06 	lds	r27, 0x06E2
    2524:	88 83       	st	Y, r24
    2526:	99 83       	std	Y+1, r25	; 0x01
    2528:	aa 83       	std	Y+2, r26	; 0x02
    252a:	bb 83       	std	Y+3, r27	; 0x03
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    252c:	81 e0       	ldi	r24, 0x01	; 1
    252e:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    2530:	80 91 a4 02 	lds	r24, 0x02A4
    2534:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    2536:	80 91 a5 02 	lds	r24, 0x02A5
    253a:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    253c:	80 91 a6 02 	lds	r24, 0x02A6
    2540:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    2542:	80 91 a7 02 	lds	r24, 0x02A7
    2546:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    2548:	81 e0       	ldi	r24, 0x01	; 1
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	99 8b       	std	Y+17, r25	; 0x11
    254e:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2550:	80 91 ee 06 	lds	r24, 0x06EE
    2554:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2556:	80 91 ed 06 	lds	r24, 0x06ED
    255a:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    255c:	80 91 ec 06 	lds	r24, 0x06EC
    2560:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2562:	80 91 eb 06 	lds	r24, 0x06EB
    2566:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    2568:	81 e0       	ldi	r24, 0x01	; 1
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	ac db       	rcall	.-2216   	; 0x1cc6 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    256e:	80 91 f3 06 	lds	r24, 0x06F3
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	80 7f       	andi	r24, 0xF0	; 240
    2576:	90 70       	andi	r25, 0x00	; 0
    2578:	81 35       	cpi	r24, 0x51	; 81
    257a:	91 05       	cpc	r25, r1
    257c:	0c f4       	brge	.+2      	; 0x2580 <__stack+0x481>
    257e:	49 c0       	rjmp	.+146    	; 0x2612 <__stack+0x513>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2580:	10 92 aa 02 	sts	0x02AA, r1
    2584:	34 c0       	rjmp	.+104    	; 0x25ee <__stack+0x4ef>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    2586:	f9 01       	movw	r30, r18
    2588:	eb 53       	subi	r30, 0x3B	; 59
    258a:	f9 4f       	sbci	r31, 0xF9	; 249
    258c:	86 a9       	ldd	r24, Z+54	; 0x36
    258e:	80 93 ab 02 	sts	0x02AB, r24
      if(opt == TCP_OPT_END) {
    2592:	88 23       	and	r24, r24
    2594:	f1 f1       	breq	.+124    	; 0x2612 <__stack+0x513>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    2596:	81 30       	cpi	r24, 0x01	; 1
    2598:	21 f4       	brne	.+8      	; 0x25a2 <__stack+0x4a3>
	++c;
    259a:	4f 5f       	subi	r20, 0xFF	; 255
    259c:	40 93 aa 02 	sts	0x02AA, r20
    25a0:	26 c0       	rjmp	.+76     	; 0x25ee <__stack+0x4ef>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    25a2:	82 30       	cpi	r24, 0x02	; 2
    25a4:	c1 f4       	brne	.+48     	; 0x25d6 <__stack+0x4d7>
    25a6:	87 a9       	ldd	r24, Z+55	; 0x37
    25a8:	84 30       	cpi	r24, 0x04	; 4
    25aa:	a9 f4       	brne	.+42     	; 0x25d6 <__stack+0x4d7>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    25ac:	30 ad       	ldd	r19, Z+56	; 0x38
    25ae:	20 e0       	ldi	r18, 0x00	; 0
    25b0:	81 ad       	ldd	r24, Z+57	; 0x39
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	82 2b       	or	r24, r18
    25b6:	93 2b       	or	r25, r19
    25b8:	90 93 ad 02 	sts	0x02AD, r25
    25bc:	80 93 ac 02 	sts	0x02AC, r24
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    25c0:	f5 e0       	ldi	r31, 0x05	; 5
    25c2:	85 3b       	cpi	r24, 0xB5	; 181
    25c4:	9f 07       	cpc	r25, r31
    25c6:	10 f0       	brcs	.+4      	; 0x25cc <__stack+0x4cd>
    25c8:	84 eb       	ldi	r24, 0xB4	; 180
    25ca:	95 e0       	ldi	r25, 0x05	; 5
    25cc:	9b 8b       	std	Y+19, r25	; 0x13
    25ce:	8a 8b       	std	Y+18, r24	; 0x12
    25d0:	9d 8b       	std	Y+21, r25	; 0x15
    25d2:	8c 8b       	std	Y+20, r24	; 0x14
    25d4:	1e c0       	rjmp	.+60     	; 0x2612 <__stack+0x513>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    25d6:	90 91 aa 02 	lds	r25, 0x02AA
    25da:	e9 2f       	mov	r30, r25
    25dc:	f0 e0       	ldi	r31, 0x00	; 0
    25de:	eb 53       	subi	r30, 0x3B	; 59
    25e0:	f9 4f       	sbci	r31, 0xF9	; 249
    25e2:	87 a9       	ldd	r24, Z+55	; 0x37
    25e4:	88 23       	and	r24, r24
    25e6:	a9 f0       	breq	.+42     	; 0x2612 <__stack+0x513>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    25e8:	89 0f       	add	r24, r25
    25ea:	80 93 aa 02 	sts	0x02AA, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    25ee:	40 91 aa 02 	lds	r20, 0x02AA
    25f2:	24 2f       	mov	r18, r20
    25f4:	30 e0       	ldi	r19, 0x00	; 0
    25f6:	80 91 f3 06 	lds	r24, 0x06F3
    25fa:	82 95       	swap	r24
    25fc:	8f 70       	andi	r24, 0x0F	; 15
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	05 97       	sbiw	r24, 0x05	; 5
    2602:	88 0f       	add	r24, r24
    2604:	99 1f       	adc	r25, r25
    2606:	88 0f       	add	r24, r24
    2608:	99 1f       	adc	r25, r25
    260a:	28 17       	cp	r18, r24
    260c:	39 07       	cpc	r19, r25
    260e:	0c f4       	brge	.+2      	; 0x2612 <__stack+0x513>
    2610:	ba cf       	rjmp	.-140    	; 0x2586 <__stack+0x487>
  }

  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    2612:	80 e1       	ldi	r24, 0x10	; 16
    2614:	80 93 f4 06 	sts	0x06F4, r24

 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    2618:	80 91 f4 06 	lds	r24, 0x06F4
    261c:	82 60       	ori	r24, 0x02	; 2
    261e:	80 93 f4 06 	sts	0x06F4, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */

  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    2622:	82 e0       	ldi	r24, 0x02	; 2
    2624:	80 93 fb 06 	sts	0x06FB, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    2628:	84 e0       	ldi	r24, 0x04	; 4
    262a:	80 93 fc 06 	sts	0x06FC, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    262e:	85 e0       	ldi	r24, 0x05	; 5
    2630:	80 93 fd 06 	sts	0x06FD, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2634:	84 eb       	ldi	r24, 0xB4	; 180
    2636:	80 93 fe 06 	sts	0x06FE, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    263a:	8c e2       	ldi	r24, 0x2C	; 44
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	90 93 4e 05 	sts	0x054E, r25
    2642:	80 93 4d 05 	sts	0x054D, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    2646:	80 e6       	ldi	r24, 0x60	; 96
    2648:	b1 c2       	rjmp	.+1378   	; 0x2bac <__stack+0xaad>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    264a:	d0 93 5b 05 	sts	0x055B, r29
    264e:	c0 93 5a 05 	sts	0x055A, r28
  uip_flags = 0;
    2652:	10 92 55 05 	sts	0x0555, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is within our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2656:	80 91 f4 06 	lds	r24, 0x06F4
    265a:	48 2f       	mov	r20, r24
    265c:	50 e0       	ldi	r21, 0x00	; 0
    265e:	82 ff       	sbrs	r24, 2
    2660:	03 c0       	rjmp	.+6      	; 0x2668 <__stack+0x569>
    uip_connr->tcpstateflags = UIP_CLOSED;
    2662:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2664:	80 e2       	ldi	r24, 0x20	; 32
    2666:	4e c2       	rjmp	.+1180   	; 0x2b04 <__stack+0xa05>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2668:	80 91 f3 06 	lds	r24, 0x06F3
    266c:	82 95       	swap	r24
    266e:	8f 70       	andi	r24, 0x0F	; 15
    2670:	88 0f       	add	r24, r24
    2672:	88 0f       	add	r24, r24
    2674:	80 93 aa 02 	sts	0x02AA, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    2678:	20 91 4d 05 	lds	r18, 0x054D
    267c:	30 91 4e 05 	lds	r19, 0x054E
    2680:	24 51       	subi	r18, 0x14	; 20
    2682:	30 40       	sbci	r19, 0x00	; 0
    2684:	28 1b       	sub	r18, r24
    2686:	31 09       	sbc	r19, r1
    2688:	30 93 4e 05 	sts	0x054E, r19
    268c:	20 93 4d 05 	sts	0x054D, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2690:	89 8d       	ldd	r24, Y+25	; 0x19
    2692:	8f 70       	andi	r24, 0x0F	; 15
    2694:	82 30       	cpi	r24, 0x02	; 2
    2696:	29 f4       	brne	.+10     	; 0x26a2 <__stack+0x5a3>
    2698:	4f 73       	andi	r20, 0x3F	; 63
    269a:	50 70       	andi	r21, 0x00	; 0
    269c:	42 31       	cpi	r20, 0x12	; 18
    269e:	51 05       	cpc	r21, r1
    26a0:	09 f1       	breq	.+66     	; 0x26e4 <__stack+0x5e5>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    26a2:	23 2b       	or	r18, r19
    26a4:	39 f4       	brne	.+14     	; 0x26b4 <__stack+0x5b5>
    26a6:	80 91 f4 06 	lds	r24, 0x06F4
    26aa:	90 e0       	ldi	r25, 0x00	; 0
    26ac:	83 70       	andi	r24, 0x03	; 3
    26ae:	90 70       	andi	r25, 0x00	; 0
    26b0:	89 2b       	or	r24, r25
    26b2:	c1 f0       	breq	.+48     	; 0x26e4 <__stack+0x5e5>
    26b4:	90 91 eb 06 	lds	r25, 0x06EB
    26b8:	88 85       	ldd	r24, Y+8	; 0x08
    26ba:	98 17       	cp	r25, r24
    26bc:	09 f0       	breq	.+2      	; 0x26c0 <__stack+0x5c1>
    26be:	6c c2       	rjmp	.+1240   	; 0x2b98 <__stack+0xa99>
    26c0:	90 91 ec 06 	lds	r25, 0x06EC
    26c4:	89 85       	ldd	r24, Y+9	; 0x09
    26c6:	98 17       	cp	r25, r24
    26c8:	09 f0       	breq	.+2      	; 0x26cc <__stack+0x5cd>
    26ca:	66 c2       	rjmp	.+1228   	; 0x2b98 <__stack+0xa99>
    26cc:	90 91 ed 06 	lds	r25, 0x06ED
    26d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    26d2:	98 17       	cp	r25, r24
    26d4:	09 f0       	breq	.+2      	; 0x26d8 <__stack+0x5d9>
    26d6:	60 c2       	rjmp	.+1216   	; 0x2b98 <__stack+0xa99>
    26d8:	90 91 ee 06 	lds	r25, 0x06EE
    26dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    26de:	98 17       	cp	r25, r24
    26e0:	09 f0       	breq	.+2      	; 0x26e4 <__stack+0x5e5>
    26e2:	5a c2       	rjmp	.+1204   	; 0x2b98 <__stack+0xa99>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    26e4:	80 91 f4 06 	lds	r24, 0x06F4
    26e8:	84 ff       	sbrs	r24, 4
    26ea:	50 c0       	rjmp	.+160    	; 0x278c <__stack+0x68d>
    26ec:	68 89       	ldd	r22, Y+16	; 0x10
    26ee:	79 89       	ldd	r23, Y+17	; 0x11
    26f0:	61 15       	cp	r22, r1
    26f2:	71 05       	cpc	r23, r1
    26f4:	09 f4       	brne	.+2      	; 0x26f8 <__stack+0x5f9>
    26f6:	4a c0       	rjmp	.+148    	; 0x278c <__stack+0x68d>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    26f8:	ce 01       	movw	r24, r28
    26fa:	0c 96       	adiw	r24, 0x0c	; 12
    26fc:	3c da       	rcall	.-2952   	; 0x1b76 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    26fe:	20 91 ef 06 	lds	r18, 0x06EF
    2702:	80 91 51 05 	lds	r24, 0x0551
    2706:	28 17       	cp	r18, r24
    2708:	09 f0       	breq	.+2      	; 0x270c <__stack+0x60d>
    270a:	40 c0       	rjmp	.+128    	; 0x278c <__stack+0x68d>
    270c:	90 91 f0 06 	lds	r25, 0x06F0
    2710:	80 91 52 05 	lds	r24, 0x0552
    2714:	98 17       	cp	r25, r24
    2716:	d1 f5       	brne	.+116    	; 0x278c <__stack+0x68d>
    2718:	90 91 f1 06 	lds	r25, 0x06F1
    271c:	80 91 53 05 	lds	r24, 0x0553
    2720:	98 17       	cp	r25, r24
    2722:	a1 f5       	brne	.+104    	; 0x278c <__stack+0x68d>
    2724:	90 91 f2 06 	lds	r25, 0x06F2
    2728:	80 91 54 05 	lds	r24, 0x0554
    272c:	98 17       	cp	r25, r24
    272e:	71 f5       	brne	.+92     	; 0x278c <__stack+0x68d>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2730:	2c 87       	std	Y+12, r18	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2732:	80 91 52 05 	lds	r24, 0x0552
    2736:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2738:	80 91 53 05 	lds	r24, 0x0553
    273c:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    273e:	80 91 54 05 	lds	r24, 0x0554
    2742:	8f 87       	std	Y+15, r24	; 0x0f

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    2744:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2746:	88 23       	and	r24, r24
    2748:	d1 f4       	brne	.+52     	; 0x277e <__stack+0x67f>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    274a:	2e 89       	ldd	r18, Y+22	; 0x16
    274c:	98 8d       	ldd	r25, Y+24	; 0x18
    274e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2750:	98 1b       	sub	r25, r24
    2752:	82 2f       	mov	r24, r18
    2754:	86 95       	lsr	r24
    2756:	86 95       	lsr	r24
    2758:	86 95       	lsr	r24
    275a:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    275c:	39 2f       	mov	r19, r25
    275e:	32 0f       	add	r19, r18
    2760:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    2762:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    2764:	28 2f       	mov	r18, r24
    2766:	26 95       	lsr	r18
    2768:	26 95       	lsr	r18
    276a:	82 1b       	sub	r24, r18
    276c:	97 fd       	sbrc	r25, 7
    276e:	91 95       	neg	r25
    2770:	89 0f       	add	r24, r25
    2772:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    2774:	36 95       	lsr	r19
    2776:	36 95       	lsr	r19
    2778:	36 95       	lsr	r19
    277a:	83 0f       	add	r24, r19
    277c:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    277e:	81 e0       	ldi	r24, 0x01	; 1
    2780:	80 93 55 05 	sts	0x0555, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    2784:	88 8d       	ldd	r24, Y+24	; 0x18
    2786:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    2788:	19 8a       	std	Y+17, r1	; 0x11
    278a:	18 8a       	std	Y+16, r1	; 0x10
    }

  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    278c:	89 8d       	ldd	r24, Y+25	; 0x19
    278e:	28 2f       	mov	r18, r24
    2790:	30 e0       	ldi	r19, 0x00	; 0
    2792:	c9 01       	movw	r24, r18
    2794:	8f 70       	andi	r24, 0x0F	; 15
    2796:	90 70       	andi	r25, 0x00	; 0
    2798:	84 30       	cpi	r24, 0x04	; 4
    279a:	91 05       	cpc	r25, r1
    279c:	09 f4       	brne	.+2      	; 0x27a0 <__stack+0x6a1>
    279e:	b7 c1       	rjmp	.+878    	; 0x2b0e <__stack+0xa0f>
    27a0:	85 30       	cpi	r24, 0x05	; 5
    27a2:	91 05       	cpc	r25, r1
    27a4:	5c f4       	brge	.+22     	; 0x27bc <__stack+0x6bd>
    27a6:	82 30       	cpi	r24, 0x02	; 2
    27a8:	91 05       	cpc	r25, r1
    27aa:	99 f1       	breq	.+102    	; 0x2812 <__stack+0x713>
    27ac:	83 30       	cpi	r24, 0x03	; 3
    27ae:	91 05       	cpc	r25, r1
    27b0:	0c f0       	brlt	.+2      	; 0x27b4 <__stack+0x6b5>
    27b2:	b1 c0       	rjmp	.+354    	; 0x2916 <__stack+0x817>
    27b4:	01 97       	sbiw	r24, 0x01	; 1
    27b6:	09 f0       	breq	.+2      	; 0x27ba <__stack+0x6bb>
    27b8:	88 c2       	rjmp	.+1296   	; 0x2cca <__stack+0xbcb>
    27ba:	10 c0       	rjmp	.+32     	; 0x27dc <__stack+0x6dd>
    27bc:	86 30       	cpi	r24, 0x06	; 6
    27be:	91 05       	cpc	r25, r1
    27c0:	09 f4       	brne	.+2      	; 0x27c4 <__stack+0x6c5>
    27c2:	e2 c1       	rjmp	.+964    	; 0x2b88 <__stack+0xa89>
    27c4:	86 30       	cpi	r24, 0x06	; 6
    27c6:	91 05       	cpc	r25, r1
    27c8:	0c f4       	brge	.+2      	; 0x27cc <__stack+0x6cd>
    27ca:	c0 c1       	rjmp	.+896    	; 0x2b4c <__stack+0xa4d>
    27cc:	87 30       	cpi	r24, 0x07	; 7
    27ce:	91 05       	cpc	r25, r1
    27d0:	09 f4       	brne	.+2      	; 0x27d4 <__stack+0x6d5>
    27d2:	e2 c1       	rjmp	.+964    	; 0x2b98 <__stack+0xa99>
    27d4:	08 97       	sbiw	r24, 0x08	; 8
    27d6:	09 f0       	breq	.+2      	; 0x27da <__stack+0x6db>
    27d8:	78 c2       	rjmp	.+1264   	; 0x2cca <__stack+0xbcb>
    27da:	8e c1       	rjmp	.+796    	; 0x2af8 <__stack+0x9f9>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    27dc:	80 91 55 05 	lds	r24, 0x0555
    27e0:	80 ff       	sbrs	r24, 0
    27e2:	73 c2       	rjmp	.+1254   	; 0x2cca <__stack+0xbcb>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    27e4:	83 e0       	ldi	r24, 0x03	; 3
    27e6:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    27e8:	80 e4       	ldi	r24, 0x40	; 64
    27ea:	80 93 55 05 	sts	0x0555, r24
      uip_connr->len = 0;
    27ee:	19 8a       	std	Y+17, r1	; 0x11
    27f0:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    27f2:	20 91 4d 05 	lds	r18, 0x054D
    27f6:	30 91 4e 05 	lds	r19, 0x054E
    27fa:	21 15       	cp	r18, r1
    27fc:	31 05       	cpc	r19, r1
    27fe:	09 f4       	brne	.+2      	; 0x2802 <__stack+0x703>
    2800:	0f c1       	rjmp	.+542    	; 0x2a20 <__stack+0x921>
        uip_flags |= UIP_NEWDATA;
    2802:	80 91 55 05 	lds	r24, 0x0555
    2806:	82 60       	ori	r24, 0x02	; 2
    2808:	80 93 55 05 	sts	0x0555, r24
        uip_add_rcv_nxt(uip_len);
    280c:	c9 01       	movw	r24, r18
    280e:	5b da       	rcall	.-2890   	; 0x1cc6 <uip_add_rcv_nxt>
    2810:	07 c1       	rjmp	.+526    	; 0x2a20 <__stack+0x921>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2812:	80 91 55 05 	lds	r24, 0x0555
    2816:	80 ff       	sbrs	r24, 0
    2818:	73 c0       	rjmp	.+230    	; 0x2900 <__stack+0x801>
    281a:	80 91 f4 06 	lds	r24, 0x06F4
    281e:	8f 73       	andi	r24, 0x3F	; 63
    2820:	82 31       	cpi	r24, 0x12	; 18
    2822:	09 f0       	breq	.+2      	; 0x2826 <__stack+0x727>
    2824:	6d c0       	rjmp	.+218    	; 0x2900 <__stack+0x801>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    2826:	80 91 f3 06 	lds	r24, 0x06F3
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	80 7f       	andi	r24, 0xF0	; 240
    282e:	90 70       	andi	r25, 0x00	; 0
    2830:	81 35       	cpi	r24, 0x51	; 81
    2832:	91 05       	cpc	r25, r1
    2834:	0c f4       	brge	.+2      	; 0x2838 <__stack+0x739>
    2836:	49 c0       	rjmp	.+146    	; 0x28ca <__stack+0x7cb>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2838:	10 92 aa 02 	sts	0x02AA, r1
    283c:	34 c0       	rjmp	.+104    	; 0x28a6 <__stack+0x7a7>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    283e:	f9 01       	movw	r30, r18
    2840:	eb 53       	subi	r30, 0x3B	; 59
    2842:	f9 4f       	sbci	r31, 0xF9	; 249
    2844:	86 a9       	ldd	r24, Z+54	; 0x36
    2846:	80 93 ab 02 	sts	0x02AB, r24
	  if(opt == TCP_OPT_END) {
    284a:	88 23       	and	r24, r24
    284c:	f1 f1       	breq	.+124    	; 0x28ca <__stack+0x7cb>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    284e:	81 30       	cpi	r24, 0x01	; 1
    2850:	21 f4       	brne	.+8      	; 0x285a <__stack+0x75b>
	    ++c;
    2852:	4f 5f       	subi	r20, 0xFF	; 255
    2854:	40 93 aa 02 	sts	0x02AA, r20
    2858:	26 c0       	rjmp	.+76     	; 0x28a6 <__stack+0x7a7>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    285a:	82 30       	cpi	r24, 0x02	; 2
    285c:	c1 f4       	brne	.+48     	; 0x288e <__stack+0x78f>
    285e:	87 a9       	ldd	r24, Z+55	; 0x37
    2860:	84 30       	cpi	r24, 0x04	; 4
    2862:	a9 f4       	brne	.+42     	; 0x288e <__stack+0x78f>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2864:	30 ad       	ldd	r19, Z+56	; 0x38
    2866:	20 e0       	ldi	r18, 0x00	; 0
    2868:	81 ad       	ldd	r24, Z+57	; 0x39
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	82 2b       	or	r24, r18
    286e:	93 2b       	or	r25, r19
    2870:	90 93 ad 02 	sts	0x02AD, r25
    2874:	80 93 ac 02 	sts	0x02AC, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    2878:	25 e0       	ldi	r18, 0x05	; 5
    287a:	85 3b       	cpi	r24, 0xB5	; 181
    287c:	92 07       	cpc	r25, r18
    287e:	10 f0       	brcs	.+4      	; 0x2884 <__stack+0x785>
    2880:	84 eb       	ldi	r24, 0xB4	; 180
    2882:	95 e0       	ldi	r25, 0x05	; 5
    2884:	9b 8b       	std	Y+19, r25	; 0x13
    2886:	8a 8b       	std	Y+18, r24	; 0x12
    2888:	9d 8b       	std	Y+21, r25	; 0x15
    288a:	8c 8b       	std	Y+20, r24	; 0x14
    288c:	1e c0       	rjmp	.+60     	; 0x28ca <__stack+0x7cb>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    288e:	90 91 aa 02 	lds	r25, 0x02AA
    2892:	e9 2f       	mov	r30, r25
    2894:	f0 e0       	ldi	r31, 0x00	; 0
    2896:	eb 53       	subi	r30, 0x3B	; 59
    2898:	f9 4f       	sbci	r31, 0xF9	; 249
    289a:	87 a9       	ldd	r24, Z+55	; 0x37
    289c:	88 23       	and	r24, r24
    289e:	a9 f0       	breq	.+42     	; 0x28ca <__stack+0x7cb>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    28a0:	89 0f       	add	r24, r25
    28a2:	80 93 aa 02 	sts	0x02AA, r24
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    28a6:	40 91 aa 02 	lds	r20, 0x02AA
    28aa:	24 2f       	mov	r18, r20
    28ac:	30 e0       	ldi	r19, 0x00	; 0
    28ae:	80 91 f3 06 	lds	r24, 0x06F3
    28b2:	82 95       	swap	r24
    28b4:	8f 70       	andi	r24, 0x0F	; 15
    28b6:	90 e0       	ldi	r25, 0x00	; 0
    28b8:	05 97       	sbiw	r24, 0x05	; 5
    28ba:	88 0f       	add	r24, r24
    28bc:	99 1f       	adc	r25, r25
    28be:	88 0f       	add	r24, r24
    28c0:	99 1f       	adc	r25, r25
    28c2:	28 17       	cp	r18, r24
    28c4:	39 07       	cpc	r19, r25
    28c6:	0c f4       	brge	.+2      	; 0x28ca <__stack+0x7cb>
    28c8:	ba cf       	rjmp	.-140    	; 0x283e <__stack+0x73f>
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    28ca:	83 e0       	ldi	r24, 0x03	; 3
    28cc:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    28ce:	80 91 eb 06 	lds	r24, 0x06EB
    28d2:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    28d4:	80 91 ec 06 	lds	r24, 0x06EC
    28d8:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    28da:	80 91 ed 06 	lds	r24, 0x06ED
    28de:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    28e0:	80 91 ee 06 	lds	r24, 0x06EE
    28e4:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    28e6:	81 e0       	ldi	r24, 0x01	; 1
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	ed d9       	rcall	.-3110   	; 0x1cc6 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    28ec:	82 e4       	ldi	r24, 0x42	; 66
    28ee:	80 93 55 05 	sts	0x0555, r24
      uip_connr->len = 0;
    28f2:	19 8a       	std	Y+17, r1	; 0x11
    28f4:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    28f6:	10 92 4e 05 	sts	0x054E, r1
    28fa:	10 92 4d 05 	sts	0x054D, r1
    28fe:	90 c0       	rjmp	.+288    	; 0x2a20 <__stack+0x921>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    2900:	80 e2       	ldi	r24, 0x20	; 32
    2902:	80 93 55 05 	sts	0x0555, r24
    UIP_APPCALL();
    2906:	0e 94 27 08 	call	0x104e	; 0x104e <uIPManagement_TCPCallback>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    290a:	e0 91 5a 05 	lds	r30, 0x055A
    290e:	f0 91 5b 05 	lds	r31, 0x055B
    2912:	11 8e       	std	Z+25, r1	; 0x19
    2914:	4a cd       	rjmp	.-1388   	; 0x23aa <__stack+0x2ab>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2916:	80 91 f4 06 	lds	r24, 0x06F4
    291a:	80 ff       	sbrs	r24, 0
    291c:	29 c0       	rjmp	.+82     	; 0x2970 <__stack+0x871>
    291e:	24 fd       	sbrc	r18, 4
    2920:	27 c0       	rjmp	.+78     	; 0x2970 <__stack+0x871>
      if(uip_outstanding(uip_connr)) {
    2922:	88 89       	ldd	r24, Y+16	; 0x10
    2924:	99 89       	ldd	r25, Y+17	; 0x11
    2926:	89 2b       	or	r24, r25
    2928:	09 f0       	breq	.+2      	; 0x292c <__stack+0x82d>
    292a:	cf c1       	rjmp	.+926    	; 0x2cca <__stack+0xbcb>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    292c:	80 91 4d 05 	lds	r24, 0x054D
    2930:	90 91 4e 05 	lds	r25, 0x054E
    2934:	01 96       	adiw	r24, 0x01	; 1
    2936:	c7 d9       	rcall	.-3186   	; 0x1cc6 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    2938:	20 91 55 05 	lds	r18, 0x0555
    293c:	82 2f       	mov	r24, r18
    293e:	80 61       	ori	r24, 0x10	; 16
    2940:	80 93 55 05 	sts	0x0555, r24
      if(uip_len > 0) {
    2944:	80 91 4d 05 	lds	r24, 0x054D
    2948:	90 91 4e 05 	lds	r25, 0x054E
    294c:	89 2b       	or	r24, r25
    294e:	19 f0       	breq	.+6      	; 0x2956 <__stack+0x857>
	uip_flags |= UIP_NEWDATA;
    2950:	22 61       	ori	r18, 0x12	; 18
    2952:	20 93 55 05 	sts	0x0555, r18
      }
      UIP_APPCALL();
    2956:	0e 94 27 08 	call	0x104e	; 0x104e <uIPManagement_TCPCallback>
      uip_connr->len = 1;
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	99 8b       	std	Y+17, r25	; 0x11
    2960:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    2962:	88 e0       	ldi	r24, 0x08	; 8
    2964:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    2966:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    2968:	81 e1       	ldi	r24, 0x11	; 17
    296a:	80 93 f4 06 	sts	0x06F4, r24
    296e:	17 c1       	rjmp	.+558    	; 0x2b9e <__stack+0xa9f>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    2970:	85 ff       	sbrs	r24, 5
    2972:	21 c0       	rjmp	.+66     	; 0x29b6 <__stack+0x8b7>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    2974:	60 91 f9 06 	lds	r22, 0x06F9
    2978:	36 2f       	mov	r19, r22
    297a:	20 e0       	ldi	r18, 0x00	; 0
    297c:	40 91 fa 06 	lds	r20, 0x06FA
    2980:	50 e0       	ldi	r21, 0x00	; 0
    2982:	24 2b       	or	r18, r20
    2984:	35 2b       	or	r19, r21
    2986:	80 91 58 05 	lds	r24, 0x0558
    298a:	90 91 59 05 	lds	r25, 0x0559
    298e:	82 0f       	add	r24, r18
    2990:	93 1f       	adc	r25, r19
    2992:	90 93 59 05 	sts	0x0559, r25
    2996:	80 93 58 05 	sts	0x0558, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    299a:	96 2f       	mov	r25, r22
    299c:	80 e0       	ldi	r24, 0x00	; 0
    299e:	84 2b       	or	r24, r20
    29a0:	95 2b       	or	r25, r21
    29a2:	20 91 4d 05 	lds	r18, 0x054D
    29a6:	30 91 4e 05 	lds	r19, 0x054E
    29aa:	28 1b       	sub	r18, r24
    29ac:	39 0b       	sbc	r19, r25
    29ae:	30 93 4e 05 	sts	0x054E, r19
    29b2:	20 93 4d 05 	sts	0x054D, r18
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    29b6:	20 91 4d 05 	lds	r18, 0x054D
    29ba:	30 91 4e 05 	lds	r19, 0x054E
    29be:	21 15       	cp	r18, r1
    29c0:	31 05       	cpc	r19, r1
    29c2:	51 f0       	breq	.+20     	; 0x29d8 <__stack+0x8d9>
    29c4:	89 8d       	ldd	r24, Y+25	; 0x19
    29c6:	84 fd       	sbrc	r24, 4
    29c8:	07 c0       	rjmp	.+14     	; 0x29d8 <__stack+0x8d9>
      uip_flags |= UIP_NEWDATA;
    29ca:	80 91 55 05 	lds	r24, 0x0555
    29ce:	82 60       	ori	r24, 0x02	; 2
    29d0:	80 93 55 05 	sts	0x0555, r24
      uip_add_rcv_nxt(uip_len);
    29d4:	c9 01       	movw	r24, r18
    29d6:	77 d9       	rcall	.-3346   	; 0x1cc6 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanism.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    29d8:	90 91 f5 06 	lds	r25, 0x06F5
    29dc:	80 e0       	ldi	r24, 0x00	; 0
    29de:	20 91 f6 06 	lds	r18, 0x06F6
    29e2:	82 0f       	add	r24, r18
    29e4:	91 1d       	adc	r25, r1
    29e6:	90 93 ad 02 	sts	0x02AD, r25
    29ea:	80 93 ac 02 	sts	0x02AC, r24
    if(tmp16 > uip_connr->initialmss ||
    29ee:	2c 89       	ldd	r18, Y+20	; 0x14
    29f0:	3d 89       	ldd	r19, Y+21	; 0x15
    29f2:	28 17       	cp	r18, r24
    29f4:	39 07       	cpc	r19, r25
    29f6:	10 f0       	brcs	.+4      	; 0x29fc <__stack+0x8fd>
    29f8:	89 2b       	or	r24, r25
    29fa:	21 f4       	brne	.+8      	; 0x2a04 <__stack+0x905>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    29fc:	30 93 ad 02 	sts	0x02AD, r19
    2a00:	20 93 ac 02 	sts	0x02AC, r18
    }
    uip_connr->mss = tmp16;
    2a04:	80 91 ac 02 	lds	r24, 0x02AC
    2a08:	90 91 ad 02 	lds	r25, 0x02AD
    2a0c:	9b 8b       	std	Y+19, r25	; 0x13
    2a0e:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    2a10:	80 91 55 05 	lds	r24, 0x0555
    2a14:	90 e0       	ldi	r25, 0x00	; 0
    2a16:	83 70       	andi	r24, 0x03	; 3
    2a18:	90 70       	andi	r25, 0x00	; 0
    2a1a:	89 2b       	or	r24, r25
    2a1c:	09 f4       	brne	.+2      	; 0x2a20 <__stack+0x921>
    2a1e:	55 c1       	rjmp	.+682    	; 0x2cca <__stack+0xbcb>
      uip_slen = 0;
    2a20:	10 92 b2 0c 	sts	0x0CB2, r1
    2a24:	10 92 b1 0c 	sts	0x0CB1, r1
      UIP_APPCALL();
    2a28:	0e 94 27 08 	call	0x104e	; 0x104e <uIPManagement_TCPCallback>

    appsend:

      if(uip_flags & UIP_ABORT) {
    2a2c:	80 91 55 05 	lds	r24, 0x0555
    2a30:	28 2f       	mov	r18, r24
    2a32:	85 ff       	sbrs	r24, 5
    2a34:	07 c0       	rjmp	.+14     	; 0x2a44 <__stack+0x945>
	uip_slen = 0;
    2a36:	10 92 b2 0c 	sts	0x0CB2, r1
    2a3a:	10 92 b1 0c 	sts	0x0CB1, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    2a3e:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    2a40:	84 e1       	ldi	r24, 0x14	; 20
    2a42:	93 cf       	rjmp	.-218    	; 0x296a <__stack+0x86b>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    2a44:	84 ff       	sbrs	r24, 4
    2a46:	0a c0       	rjmp	.+20     	; 0x2a5c <__stack+0x95d>
	uip_slen = 0;
    2a48:	10 92 b2 0c 	sts	0x0CB2, r1
    2a4c:	10 92 b1 0c 	sts	0x0CB1, r1
	uip_connr->len = 1;
    2a50:	81 e0       	ldi	r24, 0x01	; 1
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	99 8b       	std	Y+17, r25	; 0x11
    2a56:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    2a58:	84 e0       	ldi	r24, 0x04	; 4
    2a5a:	84 cf       	rjmp	.-248    	; 0x2964 <__stack+0x865>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    2a5c:	80 91 b1 0c 	lds	r24, 0x0CB1
    2a60:	90 91 b2 0c 	lds	r25, 0x0CB2
    2a64:	89 2b       	or	r24, r25
    2a66:	01 f1       	breq	.+64     	; 0x2aa8 <__stack+0x9a9>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    2a68:	20 ff       	sbrs	r18, 0
    2a6a:	02 c0       	rjmp	.+4      	; 0x2a70 <__stack+0x971>
	  uip_connr->len = 0;
    2a6c:	19 8a       	std	Y+17, r1	; 0x11
    2a6e:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    2a70:	88 89       	ldd	r24, Y+16	; 0x10
    2a72:	99 89       	ldd	r25, Y+17	; 0x11
    2a74:	00 97       	sbiw	r24, 0x00	; 0
    2a76:	a1 f4       	brne	.+40     	; 0x2aa0 <__stack+0x9a1>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    2a78:	2a 89       	ldd	r18, Y+18	; 0x12
    2a7a:	3b 89       	ldd	r19, Y+19	; 0x13
    2a7c:	80 91 b1 0c 	lds	r24, 0x0CB1
    2a80:	90 91 b2 0c 	lds	r25, 0x0CB2
    2a84:	28 17       	cp	r18, r24
    2a86:	39 07       	cpc	r19, r25
    2a88:	20 f4       	brcc	.+8      	; 0x2a92 <__stack+0x993>
	    uip_slen = uip_connr->mss;
    2a8a:	30 93 b2 0c 	sts	0x0CB2, r19
    2a8e:	20 93 b1 0c 	sts	0x0CB1, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    2a92:	80 91 b1 0c 	lds	r24, 0x0CB1
    2a96:	90 91 b2 0c 	lds	r25, 0x0CB2
    2a9a:	99 8b       	std	Y+17, r25	; 0x11
    2a9c:	88 8b       	std	Y+16, r24	; 0x10
    2a9e:	04 c0       	rjmp	.+8      	; 0x2aa8 <__stack+0x9a9>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    2aa0:	90 93 b2 0c 	sts	0x0CB2, r25
    2aa4:	80 93 b1 0c 	sts	0x0CB1, r24
	}
      }
      uip_connr->nrtx = 0;
    2aa8:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    2aaa:	80 91 4f 05 	lds	r24, 0x054F
    2aae:	90 91 50 05 	lds	r25, 0x0550
    2ab2:	90 93 59 05 	sts	0x0559, r25
    2ab6:	80 93 58 05 	sts	0x0558, r24

      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    2aba:	80 91 b1 0c 	lds	r24, 0x0CB1
    2abe:	90 91 b2 0c 	lds	r25, 0x0CB2
    2ac2:	89 2b       	or	r24, r25
    2ac4:	59 f0       	breq	.+22     	; 0x2adc <__stack+0x9dd>
    2ac6:	88 89       	ldd	r24, Y+16	; 0x10
    2ac8:	99 89       	ldd	r25, Y+17	; 0x11
    2aca:	00 97       	sbiw	r24, 0x00	; 0
    2acc:	39 f0       	breq	.+14     	; 0x2adc <__stack+0x9dd>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    2ace:	88 96       	adiw	r24, 0x28	; 40
    2ad0:	90 93 4e 05 	sts	0x054E, r25
    2ad4:	80 93 4d 05 	sts	0x054D, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    2ad8:	88 e1       	ldi	r24, 0x18	; 24
    2ada:	0b c0       	rjmp	.+22     	; 0x2af2 <__stack+0x9f3>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    2adc:	80 91 55 05 	lds	r24, 0x0555
    2ae0:	81 ff       	sbrs	r24, 1
    2ae2:	f3 c0       	rjmp	.+486    	; 0x2cca <__stack+0xbcb>
	uip_len = UIP_TCPIP_HLEN;
    2ae4:	88 e2       	ldi	r24, 0x28	; 40
    2ae6:	90 e0       	ldi	r25, 0x00	; 0
    2ae8:	90 93 4e 05 	sts	0x054E, r25
    2aec:	80 93 4d 05 	sts	0x054D, r24
	BUF->flags = TCP_ACK;
    2af0:	80 e1       	ldi	r24, 0x10	; 16
    2af2:	80 93 f4 06 	sts	0x06F4, r24
    2af6:	59 c0       	rjmp	.+178    	; 0x2baa <__stack+0xaab>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    2af8:	80 91 55 05 	lds	r24, 0x0555
    2afc:	80 ff       	sbrs	r24, 0
    2afe:	e5 c0       	rjmp	.+458    	; 0x2cca <__stack+0xbcb>
      uip_connr->tcpstateflags = UIP_CLOSED;
    2b00:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    2b02:	80 e1       	ldi	r24, 0x10	; 16
    2b04:	80 93 55 05 	sts	0x0555, r24
      UIP_APPCALL();
    2b08:	0e 94 27 08 	call	0x104e	; 0x104e <uIPManagement_TCPCallback>
    2b0c:	de c0       	rjmp	.+444    	; 0x2cca <__stack+0xbcb>

  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    2b0e:	80 91 4d 05 	lds	r24, 0x054D
    2b12:	90 91 4e 05 	lds	r25, 0x054E
    2b16:	00 97       	sbiw	r24, 0x00	; 0
    2b18:	09 f0       	breq	.+2      	; 0x2b1c <__stack+0xa1d>
      uip_add_rcv_nxt(uip_len);
    2b1a:	d5 d8       	rcall	.-3670   	; 0x1cc6 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    2b1c:	80 91 f4 06 	lds	r24, 0x06F4
    2b20:	90 91 55 05 	lds	r25, 0x0555
    2b24:	80 ff       	sbrs	r24, 0
    2b26:	0b c0       	rjmp	.+22     	; 0x2b3e <__stack+0xa3f>
      if(uip_flags & UIP_ACKDATA) {
    2b28:	90 ff       	sbrs	r25, 0
    2b2a:	06 c0       	rjmp	.+12     	; 0x2b38 <__stack+0xa39>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    2b2c:	87 e0       	ldi	r24, 0x07	; 7
    2b2e:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    2b30:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    2b32:	19 8a       	std	Y+17, r1	; 0x11
    2b34:	18 8a       	std	Y+16, r1	; 0x10
    2b36:	18 c0       	rjmp	.+48     	; 0x2b68 <__stack+0xa69>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    2b38:	86 e0       	ldi	r24, 0x06	; 6
    2b3a:	89 8f       	std	Y+25, r24	; 0x19
    2b3c:	15 c0       	rjmp	.+42     	; 0x2b68 <__stack+0xa69>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    2b3e:	90 ff       	sbrs	r25, 0
    2b40:	1c c0       	rjmp	.+56     	; 0x2b7a <__stack+0xa7b>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    2b42:	85 e0       	ldi	r24, 0x05	; 5
    2b44:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    2b46:	19 8a       	std	Y+17, r1	; 0x11
    2b48:	18 8a       	std	Y+16, r1	; 0x10
    2b4a:	bf c0       	rjmp	.+382    	; 0x2cca <__stack+0xbcb>
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    2b4c:	80 91 4d 05 	lds	r24, 0x054D
    2b50:	90 91 4e 05 	lds	r25, 0x054E
    2b54:	00 97       	sbiw	r24, 0x00	; 0
    2b56:	09 f0       	breq	.+2      	; 0x2b5a <__stack+0xa5b>
      uip_add_rcv_nxt(uip_len);
    2b58:	b6 d8       	rcall	.-3732   	; 0x1cc6 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    2b5a:	80 91 f4 06 	lds	r24, 0x06F4
    2b5e:	80 ff       	sbrs	r24, 0
    2b60:	0c c0       	rjmp	.+24     	; 0x2b7a <__stack+0xa7b>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    2b62:	87 e0       	ldi	r24, 0x07	; 7
    2b64:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    2b66:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    2b68:	81 e0       	ldi	r24, 0x01	; 1
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	ac d8       	rcall	.-3752   	; 0x1cc6 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    2b6e:	80 e1       	ldi	r24, 0x10	; 16
    2b70:	80 93 55 05 	sts	0x0555, r24
      UIP_APPCALL();
    2b74:	0e 94 27 08 	call	0x104e	; 0x104e <uIPManagement_TCPCallback>
    2b78:	0f c0       	rjmp	.+30     	; 0x2b98 <__stack+0xa99>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    2b7a:	80 91 4d 05 	lds	r24, 0x054D
    2b7e:	90 91 4e 05 	lds	r25, 0x054E
    2b82:	89 2b       	or	r24, r25
    2b84:	49 f4       	brne	.+18     	; 0x2b98 <__stack+0xa99>
    2b86:	a1 c0       	rjmp	.+322    	; 0x2cca <__stack+0xbcb>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;

  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    2b88:	80 91 55 05 	lds	r24, 0x0555
    2b8c:	80 ff       	sbrs	r24, 0
    2b8e:	9d c0       	rjmp	.+314    	; 0x2cca <__stack+0xbcb>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    2b90:	87 e0       	ldi	r24, 0x07	; 7
    2b92:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    2b94:	1a 8e       	std	Y+26, r1	; 0x1a
    2b96:	99 c0       	rjmp	.+306    	; 0x2cca <__stack+0xbcb>
  goto drop;

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    2b98:	80 e1       	ldi	r24, 0x10	; 16
    2b9a:	f8 01       	movw	r30, r16
    2b9c:	81 a3       	std	Z+33, r24	; 0x21

 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    2b9e:	88 e2       	ldi	r24, 0x28	; 40
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	90 93 4e 05 	sts	0x054E, r25
    2ba6:	80 93 4d 05 	sts	0x054D, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    2baa:	80 e5       	ldi	r24, 0x50	; 80
    2bac:	80 93 f3 06 	sts	0x06F3, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    2bb0:	88 85       	ldd	r24, Y+8	; 0x08
    2bb2:	80 93 ef 06 	sts	0x06EF, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    2bb6:	89 85       	ldd	r24, Y+9	; 0x09
    2bb8:	80 93 f0 06 	sts	0x06F0, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    2bbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bbe:	80 93 f1 06 	sts	0x06F1, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    2bc2:	8b 85       	ldd	r24, Y+11	; 0x0b
    2bc4:	80 93 f2 06 	sts	0x06F2, r24

  BUF->seqno[0] = uip_connr->snd_nxt[0];
    2bc8:	8c 85       	ldd	r24, Y+12	; 0x0c
    2bca:	80 93 eb 06 	sts	0x06EB, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    2bce:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bd0:	80 93 ec 06 	sts	0x06EC, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    2bd4:	8e 85       	ldd	r24, Y+14	; 0x0e
    2bd6:	80 93 ed 06 	sts	0x06ED, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    2bda:	8f 85       	ldd	r24, Y+15	; 0x0f
    2bdc:	80 93 ee 06 	sts	0x06EE, r24

  BUF->proto = UIP_PROTO_TCP;
    2be0:	86 e0       	ldi	r24, 0x06	; 6
    2be2:	80 93 dc 06 	sts	0x06DC, r24

  BUF->srcport  = uip_connr->lport;
    2be6:	8c 81       	ldd	r24, Y+4	; 0x04
    2be8:	9d 81       	ldd	r25, Y+5	; 0x05
    2bea:	90 93 e8 06 	sts	0x06E8, r25
    2bee:	80 93 e7 06 	sts	0x06E7, r24
  BUF->destport = uip_connr->rport;
    2bf2:	8e 81       	ldd	r24, Y+6	; 0x06
    2bf4:	9f 81       	ldd	r25, Y+7	; 0x07
    2bf6:	90 93 ea 06 	sts	0x06EA, r25
    2bfa:	80 93 e9 06 	sts	0x06E9, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2bfe:	80 91 c1 06 	lds	r24, 0x06C1
    2c02:	90 91 c2 06 	lds	r25, 0x06C2
    2c06:	a0 91 c3 06 	lds	r26, 0x06C3
    2c0a:	b0 91 c4 06 	lds	r27, 0x06C4
    2c0e:	80 93 df 06 	sts	0x06DF, r24
    2c12:	90 93 e0 06 	sts	0x06E0, r25
    2c16:	a0 93 e1 06 	sts	0x06E1, r26
    2c1a:	b0 93 e2 06 	sts	0x06E2, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    2c1e:	88 81       	ld	r24, Y
    2c20:	99 81       	ldd	r25, Y+1	; 0x01
    2c22:	aa 81       	ldd	r26, Y+2	; 0x02
    2c24:	bb 81       	ldd	r27, Y+3	; 0x03
    2c26:	80 93 e3 06 	sts	0x06E3, r24
    2c2a:	90 93 e4 06 	sts	0x06E4, r25
    2c2e:	a0 93 e5 06 	sts	0x06E5, r26
    2c32:	b0 93 e6 06 	sts	0x06E6, r27

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    2c36:	89 8d       	ldd	r24, Y+25	; 0x19
    2c38:	84 ff       	sbrs	r24, 4
    2c3a:	05 c0       	rjmp	.+10     	; 0x2c46 <__stack+0xb47>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    2c3c:	10 92 f6 06 	sts	0x06F6, r1
    2c40:	10 92 f5 06 	sts	0x06F5, r1
    2c44:	06 c0       	rjmp	.+12     	; 0x2c52 <__stack+0xb53>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    2c46:	85 e0       	ldi	r24, 0x05	; 5
    2c48:	80 93 f5 06 	sts	0x06F5, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    2c4c:	84 eb       	ldi	r24, 0xB4	; 180
    2c4e:	80 93 f6 06 	sts	0x06F6, r24
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    2c52:	80 e4       	ldi	r24, 0x40	; 64
    2c54:	80 93 db 06 	sts	0x06DB, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    2c58:	80 91 4e 05 	lds	r24, 0x054E
    2c5c:	80 93 d5 06 	sts	0x06D5, r24
  BUF->len[1] = (uip_len & 0xff);
    2c60:	80 91 4d 05 	lds	r24, 0x054D
    2c64:	80 93 d6 06 	sts	0x06D6, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    2c68:	10 92 fa 06 	sts	0x06FA, r1
    2c6c:	10 92 f9 06 	sts	0x06F9, r1

  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    2c70:	10 92 f8 06 	sts	0x06F8, r1
    2c74:	10 92 f7 06 	sts	0x06F7, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    2c78:	4e d8       	rcall	.-3940   	; 0x1d16 <uip_tcpchksum>
    2c7a:	80 95       	com	r24
    2c7c:	90 95       	com	r25
    2c7e:	90 93 f8 06 	sts	0x06F8, r25
    2c82:	80 93 f7 06 	sts	0x06F7, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    2c86:	85 e4       	ldi	r24, 0x45	; 69
    2c88:	80 93 d3 06 	sts	0x06D3, r24
  BUF->tos = 0;
    2c8c:	10 92 d4 06 	sts	0x06D4, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    2c90:	10 92 da 06 	sts	0x06DA, r1
    2c94:	10 92 d9 06 	sts	0x06D9, r1
  ++ipid;
    2c98:	80 91 a2 02 	lds	r24, 0x02A2
    2c9c:	90 91 a3 02 	lds	r25, 0x02A3
    2ca0:	01 96       	adiw	r24, 0x01	; 1
    2ca2:	90 93 a3 02 	sts	0x02A3, r25
    2ca6:	80 93 a2 02 	sts	0x02A2, r24
  BUF->ipid[0] = ipid >> 8;
    2caa:	90 93 d7 06 	sts	0x06D7, r25
  BUF->ipid[1] = ipid & 0xff;
    2cae:	80 93 d8 06 	sts	0x06D8, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    2cb2:	10 92 de 06 	sts	0x06DE, r1
    2cb6:	10 92 dd 06 	sts	0x06DD, r1
  BUF->ipchksum = ~(uip_ipchksum());
    2cba:	4f d8       	rcall	.-3938   	; 0x1d5a <uip_ipchksum>
    2cbc:	80 95       	com	r24
    2cbe:	90 95       	com	r25
    2cc0:	90 93 de 06 	sts	0x06DE, r25
    2cc4:	80 93 dd 06 	sts	0x06DD, r24
    2cc8:	04 c0       	rjmp	.+8      	; 0x2cd2 <__stack+0xbd3>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    2cca:	10 92 4e 05 	sts	0x054E, r1
    2cce:	10 92 4d 05 	sts	0x054D, r1
  uip_flags = 0;
    2cd2:	10 92 55 05 	sts	0x0555, r1
  return;
}
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	1f 91       	pop	r17
    2cdc:	0f 91       	pop	r16
    2cde:	08 95       	ret

00002ce0 <uip_udp_new>:
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(const uip_ipaddr_t *ripaddr, u16_t rport)
{
    2ce0:	cf 92       	push	r12
    2ce2:	df 92       	push	r13
    2ce4:	ef 92       	push	r14
    2ce6:	ff 92       	push	r15
    2ce8:	0f 93       	push	r16
    2cea:	1f 93       	push	r17
    2cec:	cf 93       	push	r28
    2cee:	df 93       	push	r29
    2cf0:	7c 01       	movw	r14, r24
    2cf2:	6b 01       	movw	r12, r22
  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    2cf4:	00 91 b7 0c 	lds	r16, 0x0CB7
    2cf8:	10 91 b8 0c 	lds	r17, 0x0CB8
    2cfc:	c0 91 a8 02 	lds	r28, 0x02A8
    2d00:	d0 91 a9 02 	lds	r29, 0x02A9
{
  register struct uip_udp_conn *conn;

  /* Find an unused local port. */
 again:
  ++lastport;
    2d04:	21 96       	adiw	r28, 0x01	; 1

  if(lastport >= 32000) {
    2d06:	8d e7       	ldi	r24, 0x7D	; 125
    2d08:	c0 30       	cpi	r28, 0x00	; 0
    2d0a:	d8 07       	cpc	r29, r24
    2d0c:	10 f0       	brcs	.+4      	; 0x2d12 <uip_udp_new+0x32>
    2d0e:	c0 e0       	ldi	r28, 0x00	; 0
    2d10:	d0 e1       	ldi	r29, 0x10	; 16
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    2d12:	ce 01       	movw	r24, r28
    2d14:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <htons>
    2d18:	08 17       	cp	r16, r24
    2d1a:	19 07       	cpc	r17, r25
    2d1c:	99 f3       	breq	.-26     	; 0x2d04 <uip_udp_new+0x24>

  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    2d1e:	c0 93 a8 02 	sts	0x02A8, r28
    2d22:	d0 93 a9 02 	sts	0x02A9, r29
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    2d26:	01 2b       	or	r16, r17
    2d28:	71 f4       	brne	.+28     	; 0x2d46 <uip_udp_new+0x66>
    2d2a:	10 92 aa 02 	sts	0x02AA, r1

  if(conn == 0) {
    return 0;
  }

  conn->lport = HTONS(lastport);
    2d2e:	d0 93 b7 0c 	sts	0x0CB7, r29
    2d32:	c0 93 b8 0c 	sts	0x0CB8, r28
  conn->rport = rport;
    2d36:	d0 92 ba 0c 	sts	0x0CBA, r13
    2d3a:	c0 92 b9 0c 	sts	0x0CB9, r12
  if(ripaddr == NULL) {
    2d3e:	e1 14       	cp	r14, r1
    2d40:	f1 04       	cpc	r15, r1
    2d42:	81 f4       	brne	.+32     	; 0x2d64 <uip_udp_new+0x84>
    2d44:	06 c0       	rjmp	.+12     	; 0x2d52 <uip_udp_new+0x72>
    2d46:	81 e0       	ldi	r24, 0x01	; 1
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    2d48:	80 93 aa 02 	sts	0x02AA, r24
    2d4c:	20 e0       	ldi	r18, 0x00	; 0
    2d4e:	30 e0       	ldi	r19, 0x00	; 0
    2d50:	1b c0       	rjmp	.+54     	; 0x2d88 <uip_udp_new+0xa8>
  }

  conn->lport = HTONS(lastport);
  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    2d52:	10 92 b3 0c 	sts	0x0CB3, r1
    2d56:	10 92 b4 0c 	sts	0x0CB4, r1
    2d5a:	10 92 b5 0c 	sts	0x0CB5, r1
    2d5e:	10 92 b6 0c 	sts	0x0CB6, r1
    2d62:	0d c0       	rjmp	.+26     	; 0x2d7e <uip_udp_new+0x9e>
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    2d64:	f7 01       	movw	r30, r14
    2d66:	80 81       	ld	r24, Z
    2d68:	91 81       	ldd	r25, Z+1	; 0x01
    2d6a:	a2 81       	ldd	r26, Z+2	; 0x02
    2d6c:	b3 81       	ldd	r27, Z+3	; 0x03
    2d6e:	80 93 b3 0c 	sts	0x0CB3, r24
    2d72:	90 93 b4 0c 	sts	0x0CB4, r25
    2d76:	a0 93 b5 0c 	sts	0x0CB5, r26
    2d7a:	b0 93 b6 0c 	sts	0x0CB6, r27
  }
  conn->ttl = UIP_TTL;
    2d7e:	80 e4       	ldi	r24, 0x40	; 64
    2d80:	80 93 bb 0c 	sts	0x0CBB, r24
    2d84:	23 eb       	ldi	r18, 0xB3	; 179
    2d86:	3c e0       	ldi	r19, 0x0C	; 12

  return conn;
}
    2d88:	c9 01       	movw	r24, r18
    2d8a:	df 91       	pop	r29
    2d8c:	cf 91       	pop	r28
    2d8e:	1f 91       	pop	r17
    2d90:	0f 91       	pop	r16
    2d92:	ff 90       	pop	r15
    2d94:	ef 90       	pop	r14
    2d96:	df 90       	pop	r13
    2d98:	cf 90       	pop	r12
    2d9a:	08 95       	ret

00002d9c <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    2d9c:	df 92       	push	r13
    2d9e:	ef 92       	push	r14
    2da0:	ff 92       	push	r15
    2da2:	0f 93       	push	r16
    2da4:	1f 93       	push	r17
    2da6:	cf 93       	push	r28
    2da8:	df 93       	push	r29
    2daa:	dc 01       	movw	r26, r24
    2dac:	06 2f       	mov	r16, r22
    2dae:	d7 2e       	mov	r13, r23
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    2db0:	10 92 0a 03 	sts	0x030A, r1

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    2db4:	60 91 6b 02 	lds	r22, 0x026B
    2db8:	70 91 6c 02 	lds	r23, 0x026C
    2dbc:	c0 91 6d 02 	lds	r28, 0x026D
    2dc0:	d0 91 6e 02 	lds	r29, 0x026E
    2dc4:	e0 e0       	ldi	r30, 0x00	; 0
    2dc6:	f0 e0       	ldi	r31, 0x00	; 0
    2dc8:	40 e0       	ldi	r20, 0x00	; 0
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    2dca:	5b e0       	ldi	r21, 0x0B	; 11
    2dcc:	2d c0       	rjmp	.+90     	; 0x2e28 <uip_arp_update+0x8c>
    2dce:	45 9f       	mul	r20, r21
    2dd0:	f0 01       	movw	r30, r0
    2dd2:	11 24       	eor	r1, r1
    2dd4:	e2 55       	subi	r30, 0x52	; 82
    2dd6:	fd 4f       	sbci	r31, 0xFD	; 253
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    2dd8:	20 81       	ld	r18, Z
    2dda:	31 81       	ldd	r19, Z+1	; 0x01
    2ddc:	26 17       	cp	r18, r22
    2dde:	37 07       	cpc	r19, r23
    2de0:	29 f4       	brne	.+10     	; 0x2dec <uip_arp_update+0x50>
    2de2:	82 81       	ldd	r24, Z+2	; 0x02
    2de4:	93 81       	ldd	r25, Z+3	; 0x03
    2de6:	8c 17       	cp	r24, r28
    2de8:	9d 07       	cpc	r25, r29
    2dea:	e9 f0       	breq	.+58     	; 0x2e26 <uip_arp_update+0x8a>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    2dec:	8d 91       	ld	r24, X+
    2dee:	9c 91       	ld	r25, X
    2df0:	11 97       	sbiw	r26, 0x01	; 1
    2df2:	82 17       	cp	r24, r18
    2df4:	93 07       	cpc	r25, r19
    2df6:	b9 f4       	brne	.+46     	; 0x2e26 <uip_arp_update+0x8a>
    2df8:	12 96       	adiw	r26, 0x02	; 2
    2dfa:	2d 91       	ld	r18, X+
    2dfc:	3c 91       	ld	r19, X
    2dfe:	13 97       	sbiw	r26, 0x03	; 3
    2e00:	82 81       	ldd	r24, Z+2	; 0x02
    2e02:	93 81       	ldd	r25, Z+3	; 0x03
    2e04:	28 17       	cp	r18, r24
    2e06:	39 07       	cpc	r19, r25
    2e08:	71 f4       	brne	.+28     	; 0x2e26 <uip_arp_update+0x8a>
    2e0a:	40 93 0a 03 	sts	0x030A, r20

	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    2e0e:	ef 01       	movw	r28, r30
    2e10:	24 96       	adiw	r28, 0x04	; 4
    2e12:	80 2f       	mov	r24, r16
    2e14:	9d 2d       	mov	r25, r13
    2e16:	9c 01       	movw	r18, r24
    2e18:	d9 01       	movw	r26, r18
    2e1a:	86 e0       	ldi	r24, 0x06	; 6
    2e1c:	0d 90       	ld	r0, X+
    2e1e:	09 92       	st	Y+, r0
    2e20:	81 50       	subi	r24, 0x01	; 1
    2e22:	e1 f7       	brne	.-8      	; 0x2e1c <uip_arp_update+0x80>
    2e24:	69 c0       	rjmp	.+210    	; 0x2ef8 <uip_arp_update+0x15c>
	tabptr->time = arptime;

	return;
    2e26:	4f 5f       	subi	r20, 0xFF	; 255
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    2e28:	48 30       	cpi	r20, 0x08	; 8
    2e2a:	88 f2       	brcs	.-94     	; 0x2dce <uip_arp_update+0x32>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    2e2c:	10 92 0a 03 	sts	0x030A, r1
    2e30:	20 e0       	ldi	r18, 0x00	; 0
    tabptr = &arp_table[i];
    2e32:	3b e0       	ldi	r19, 0x0B	; 11
    2e34:	13 c0       	rjmp	.+38     	; 0x2e5c <uip_arp_update+0xc0>
    2e36:	23 9f       	mul	r18, r19
    2e38:	f0 01       	movw	r30, r0
    2e3a:	11 24       	eor	r1, r1
    2e3c:	e2 55       	subi	r30, 0x52	; 82
    2e3e:	fd 4f       	sbci	r31, 0xFD	; 253
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    2e40:	80 81       	ld	r24, Z
    2e42:	91 81       	ldd	r25, Z+1	; 0x01
    2e44:	86 17       	cp	r24, r22
    2e46:	97 07       	cpc	r25, r23
    2e48:	41 f4       	brne	.+16     	; 0x2e5a <uip_arp_update+0xbe>
    2e4a:	82 81       	ldd	r24, Z+2	; 0x02
    2e4c:	93 81       	ldd	r25, Z+3	; 0x03
    2e4e:	8c 17       	cp	r24, r28
    2e50:	9d 07       	cpc	r25, r29
    2e52:	19 f4       	brne	.+6      	; 0x2e5a <uip_arp_update+0xbe>
    2e54:	20 93 0a 03 	sts	0x030A, r18
    2e58:	3c c0       	rjmp	.+120    	; 0x2ed2 <uip_arp_update+0x136>
    2e5a:	2f 5f       	subi	r18, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    2e5c:	28 30       	cpi	r18, 0x08	; 8
    2e5e:	58 f3       	brcs	.-42     	; 0x2e36 <uip_arp_update+0x9a>
    2e60:	20 93 0a 03 	sts	0x030A, r18
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    2e64:	28 30       	cpi	r18, 0x08	; 8
    2e66:	a9 f5       	brne	.+106    	; 0x2ed2 <uip_arp_update+0x136>
    tmpage = 0;
    2e68:	10 92 0d 03 	sts	0x030D, r1
    c = 0;
    2e6c:	10 92 0b 03 	sts	0x030B, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    2e70:	10 91 0c 03 	lds	r17, 0x030C
    2e74:	c1 2f       	mov	r28, r17
    2e76:	d0 e0       	ldi	r29, 0x00	; 0
    2e78:	60 e0       	ldi	r22, 0x00	; 0
    2e7a:	70 e0       	ldi	r23, 0x00	; 0
    2e7c:	40 e0       	ldi	r20, 0x00	; 0
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    2e7e:	8b e0       	ldi	r24, 0x0B	; 11
    2e80:	e8 2e       	mov	r14, r24
    2e82:	f1 2c       	mov	r15, r1
    2e84:	18 c0       	rjmp	.+48     	; 0x2eb6 <uip_arp_update+0x11a>
    2e86:	84 2f       	mov	r24, r20
    2e88:	90 e0       	ldi	r25, 0x00	; 0
    2e8a:	8e 9d       	mul	r24, r14
    2e8c:	f0 01       	movw	r30, r0
    2e8e:	8f 9d       	mul	r24, r15
    2e90:	f0 0d       	add	r31, r0
    2e92:	9e 9d       	mul	r25, r14
    2e94:	f0 0d       	add	r31, r0
    2e96:	11 24       	eor	r1, r1
    2e98:	e2 55       	subi	r30, 0x52	; 82
    2e9a:	fd 4f       	sbci	r31, 0xFD	; 253
    2e9c:	52 85       	ldd	r21, Z+10	; 0x0a
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    2e9e:	9e 01       	movw	r18, r28
    2ea0:	25 1b       	sub	r18, r21
    2ea2:	31 09       	sbc	r19, r1
    2ea4:	87 2f       	mov	r24, r23
    2ea6:	90 e0       	ldi	r25, 0x00	; 0
    2ea8:	82 17       	cp	r24, r18
    2eaa:	93 07       	cpc	r25, r19
    2eac:	1c f4       	brge	.+6      	; 0x2eb4 <uip_arp_update+0x118>
	tmpage = arptime - tabptr->time;
    2eae:	71 2f       	mov	r23, r17
    2eb0:	75 1b       	sub	r23, r21
    2eb2:	64 2f       	mov	r22, r20
    2eb4:	4f 5f       	subi	r20, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    2eb6:	48 30       	cpi	r20, 0x08	; 8
    2eb8:	30 f3       	brcs	.-52     	; 0x2e86 <uip_arp_update+0xea>
    2eba:	60 93 0b 03 	sts	0x030B, r22
    2ebe:	70 93 0d 03 	sts	0x030D, r23
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    2ec2:	60 93 0a 03 	sts	0x030A, r22
    tabptr = &arp_table[i];
    2ec6:	8b e0       	ldi	r24, 0x0B	; 11
    2ec8:	68 9f       	mul	r22, r24
    2eca:	f0 01       	movw	r30, r0
    2ecc:	11 24       	eor	r1, r1
    2ece:	e2 55       	subi	r30, 0x52	; 82
    2ed0:	fd 4f       	sbci	r31, 0xFD	; 253
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  uip_ipaddr_copy(&tabptr->ipaddr, ipaddr);
    2ed2:	8d 91       	ld	r24, X+
    2ed4:	9d 91       	ld	r25, X+
    2ed6:	0d 90       	ld	r0, X+
    2ed8:	bc 91       	ld	r27, X
    2eda:	a0 2d       	mov	r26, r0
    2edc:	ef 01       	movw	r28, r30
    2ede:	89 93       	st	Y+, r24
    2ee0:	99 93       	st	Y+, r25
    2ee2:	a9 93       	st	Y+, r26
    2ee4:	b9 93       	st	Y+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    2ee6:	20 2f       	mov	r18, r16
    2ee8:	3d 2d       	mov	r19, r13
    2eea:	c9 01       	movw	r24, r18
    2eec:	dc 01       	movw	r26, r24
    2eee:	86 e0       	ldi	r24, 0x06	; 6
    2ef0:	0d 90       	ld	r0, X+
    2ef2:	09 92       	st	Y+, r0
    2ef4:	81 50       	subi	r24, 0x01	; 1
    2ef6:	e1 f7       	brne	.-8      	; 0x2ef0 <uip_arp_update+0x154>
  tabptr->time = arptime;
    2ef8:	80 91 0c 03 	lds	r24, 0x030C
    2efc:	82 87       	std	Z+10, r24	; 0x0a
}
    2efe:	df 91       	pop	r29
    2f00:	cf 91       	pop	r28
    2f02:	1f 91       	pop	r17
    2f04:	0f 91       	pop	r16
    2f06:	ff 90       	pop	r15
    2f08:	ef 90       	pop	r14
    2f0a:	df 90       	pop	r13
    2f0c:	08 95       	ret

00002f0e <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    2f0e:	cf 93       	push	r28
    2f10:	df 93       	push	r29
  if(uip_len < sizeof(struct arp_hdr)) {
    2f12:	80 91 4d 05 	lds	r24, 0x054D
    2f16:	90 91 4e 05 	lds	r25, 0x054E
    2f1a:	8a 97       	sbiw	r24, 0x2a	; 42
    2f1c:	28 f4       	brcc	.+10     	; 0x2f28 <uip_arp_arpin+0x1a>
    uip_len = 0;
    2f1e:	10 92 4e 05 	sts	0x054E, r1
    2f22:	10 92 4d 05 	sts	0x054D, r1
    2f26:	a4 c0       	rjmp	.+328    	; 0x3070 <uip_arp_arpin+0x162>
    return;
  }
  uip_len = 0;
    2f28:	10 92 4e 05 	sts	0x054E, r1
    2f2c:	10 92 4d 05 	sts	0x054D, r1

  switch(BUF->opcode) {
    2f30:	c5 ec       	ldi	r28, 0xC5	; 197
    2f32:	d6 e0       	ldi	r29, 0x06	; 6
    2f34:	80 91 d9 06 	lds	r24, 0x06D9
    2f38:	90 91 da 06 	lds	r25, 0x06DA
    2f3c:	21 e0       	ldi	r18, 0x01	; 1
    2f3e:	80 30       	cpi	r24, 0x00	; 0
    2f40:	92 07       	cpc	r25, r18
    2f42:	29 f0       	breq	.+10     	; 0x2f4e <uip_arp_arpin+0x40>
    2f44:	80 50       	subi	r24, 0x00	; 0
    2f46:	92 40       	sbci	r25, 0x02	; 2
    2f48:	09 f0       	breq	.+2      	; 0x2f4c <uip_arp_arpin+0x3e>
    2f4a:	92 c0       	rjmp	.+292    	; 0x3070 <uip_arp_arpin+0x162>
    2f4c:	75 c0       	rjmp	.+234    	; 0x3038 <uip_arp_arpin+0x12a>
    PRINTF("uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n",
	   BUF->dipaddr.u8[0], BUF->dipaddr.u8[1],
	   BUF->dipaddr.u8[2], BUF->dipaddr.u8[3],
	   uip_hostaddr.u8[0], uip_hostaddr.u8[1],
	   uip_hostaddr.u8[2], uip_hostaddr.u8[3]);
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    2f4e:	20 91 eb 06 	lds	r18, 0x06EB
    2f52:	30 91 ec 06 	lds	r19, 0x06EC
    2f56:	80 91 c1 06 	lds	r24, 0x06C1
    2f5a:	90 91 c2 06 	lds	r25, 0x06C2
    2f5e:	28 17       	cp	r18, r24
    2f60:	39 07       	cpc	r19, r25
    2f62:	09 f0       	breq	.+2      	; 0x2f66 <uip_arp_arpin+0x58>
    2f64:	85 c0       	rjmp	.+266    	; 0x3070 <uip_arp_arpin+0x162>
    2f66:	20 91 ed 06 	lds	r18, 0x06ED
    2f6a:	30 91 ee 06 	lds	r19, 0x06EE
    2f6e:	80 91 c3 06 	lds	r24, 0x06C3
    2f72:	90 91 c4 06 	lds	r25, 0x06C4
    2f76:	28 17       	cp	r18, r24
    2f78:	39 07       	cpc	r19, r25
    2f7a:	09 f0       	breq	.+2      	; 0x2f7e <uip_arp_arpin+0x70>
    2f7c:	79 c0       	rjmp	.+242    	; 0x3070 <uip_arp_arpin+0x162>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    2f7e:	ce 01       	movw	r24, r28
    2f80:	4c 96       	adiw	r24, 0x1c	; 28
    2f82:	be 01       	movw	r22, r28
    2f84:	6a 5e       	subi	r22, 0xEA	; 234
    2f86:	7f 4f       	sbci	r23, 0xFF	; 255
    2f88:	09 df       	rcall	.-494    	; 0x2d9c <uip_arp_update>

      BUF->opcode = HTONS(ARP_REPLY);
    2f8a:	80 e0       	ldi	r24, 0x00	; 0
    2f8c:	92 e0       	ldi	r25, 0x02	; 2
    2f8e:	90 93 da 06 	sts	0x06DA, r25
    2f92:	80 93 d9 06 	sts	0x06D9, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    2f96:	de 01       	movw	r26, r28
    2f98:	90 96       	adiw	r26, 0x20	; 32
    2f9a:	fe 01       	movw	r30, r28
    2f9c:	76 96       	adiw	r30, 0x16	; 22
    2f9e:	86 e0       	ldi	r24, 0x06	; 6
    2fa0:	01 90       	ld	r0, Z+
    2fa2:	0d 92       	st	X+, r0
    2fa4:	81 50       	subi	r24, 0x01	; 1
    2fa6:	e1 f7       	brne	.-8      	; 0x2fa0 <uip_arp_arpin+0x92>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    2fa8:	ab ed       	ldi	r26, 0xDB	; 219
    2faa:	b6 e0       	ldi	r27, 0x06	; 6
    2fac:	ec e9       	ldi	r30, 0x9C	; 156
    2fae:	f2 e0       	ldi	r31, 0x02	; 2
    2fb0:	86 e0       	ldi	r24, 0x06	; 6
    2fb2:	01 90       	ld	r0, Z+
    2fb4:	0d 92       	st	X+, r0
    2fb6:	81 50       	subi	r24, 0x01	; 1
    2fb8:	e1 f7       	brne	.-8      	; 0x2fb2 <uip_arp_arpin+0xa4>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    2fba:	ab ec       	ldi	r26, 0xCB	; 203
    2fbc:	b6 e0       	ldi	r27, 0x06	; 6
    2fbe:	ec e9       	ldi	r30, 0x9C	; 156
    2fc0:	f2 e0       	ldi	r31, 0x02	; 2
    2fc2:	86 e0       	ldi	r24, 0x06	; 6
    2fc4:	01 90       	ld	r0, Z+
    2fc6:	0d 92       	st	X+, r0
    2fc8:	81 50       	subi	r24, 0x01	; 1
    2fca:	e1 f7       	brne	.-8      	; 0x2fc4 <uip_arp_arpin+0xb6>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    2fcc:	e5 ec       	ldi	r30, 0xC5	; 197
    2fce:	f6 e0       	ldi	r31, 0x06	; 6
    2fd0:	df 01       	movw	r26, r30
    2fd2:	90 96       	adiw	r26, 0x20	; 32
    2fd4:	86 e0       	ldi	r24, 0x06	; 6
    2fd6:	0d 90       	ld	r0, X+
    2fd8:	01 92       	st	Z+, r0
    2fda:	81 50       	subi	r24, 0x01	; 1
    2fdc:	e1 f7       	brne	.-8      	; 0x2fd6 <uip_arp_arpin+0xc8>

      uip_ipaddr_copy(&BUF->dipaddr, &BUF->sipaddr);
    2fde:	80 91 e1 06 	lds	r24, 0x06E1
    2fe2:	90 91 e2 06 	lds	r25, 0x06E2
    2fe6:	a0 91 e3 06 	lds	r26, 0x06E3
    2fea:	b0 91 e4 06 	lds	r27, 0x06E4
    2fee:	80 93 eb 06 	sts	0x06EB, r24
    2ff2:	90 93 ec 06 	sts	0x06EC, r25
    2ff6:	a0 93 ed 06 	sts	0x06ED, r26
    2ffa:	b0 93 ee 06 	sts	0x06EE, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    2ffe:	80 91 c1 06 	lds	r24, 0x06C1
    3002:	90 91 c2 06 	lds	r25, 0x06C2
    3006:	a0 91 c3 06 	lds	r26, 0x06C3
    300a:	b0 91 c4 06 	lds	r27, 0x06C4
    300e:	80 93 e1 06 	sts	0x06E1, r24
    3012:	90 93 e2 06 	sts	0x06E2, r25
    3016:	a0 93 e3 06 	sts	0x06E3, r26
    301a:	b0 93 e4 06 	sts	0x06E4, r27

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    301e:	88 e0       	ldi	r24, 0x08	; 8
    3020:	96 e0       	ldi	r25, 0x06	; 6
    3022:	90 93 d2 06 	sts	0x06D2, r25
    3026:	80 93 d1 06 	sts	0x06D1, r24
      uip_len = sizeof(struct arp_hdr);
    302a:	8a e2       	ldi	r24, 0x2A	; 42
    302c:	90 e0       	ldi	r25, 0x00	; 0
    302e:	90 93 4e 05 	sts	0x054E, r25
    3032:	80 93 4d 05 	sts	0x054D, r24
    3036:	1c c0       	rjmp	.+56     	; 0x3070 <uip_arp_arpin+0x162>
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    3038:	20 91 eb 06 	lds	r18, 0x06EB
    303c:	30 91 ec 06 	lds	r19, 0x06EC
    3040:	80 91 c1 06 	lds	r24, 0x06C1
    3044:	90 91 c2 06 	lds	r25, 0x06C2
    3048:	28 17       	cp	r18, r24
    304a:	39 07       	cpc	r19, r25
    304c:	89 f4       	brne	.+34     	; 0x3070 <uip_arp_arpin+0x162>
    304e:	20 91 ed 06 	lds	r18, 0x06ED
    3052:	30 91 ee 06 	lds	r19, 0x06EE
    3056:	80 91 c3 06 	lds	r24, 0x06C3
    305a:	90 91 c4 06 	lds	r25, 0x06C4
    305e:	28 17       	cp	r18, r24
    3060:	39 07       	cpc	r19, r25
    3062:	31 f4       	brne	.+12     	; 0x3070 <uip_arp_arpin+0x162>
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    3064:	ce 01       	movw	r24, r28
    3066:	4c 96       	adiw	r24, 0x1c	; 28
    3068:	be 01       	movw	r22, r28
    306a:	6a 5e       	subi	r22, 0xEA	; 234
    306c:	7f 4f       	sbci	r23, 0xFF	; 255
    306e:	96 de       	rcall	.-724    	; 0x2d9c <uip_arp_update>
    }
    break;
  }

  return;
}
    3070:	df 91       	pop	r29
    3072:	cf 91       	pop	r28
    3074:	08 95       	ret

00003076 <uip_arp_out>:

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr)) {
    3076:	20 91 e3 06 	lds	r18, 0x06E3
    307a:	30 91 e4 06 	lds	r19, 0x06E4
    307e:	80 91 67 02 	lds	r24, 0x0267
    3082:	90 91 68 02 	lds	r25, 0x0268
    3086:	28 17       	cp	r18, r24
    3088:	39 07       	cpc	r19, r25
    308a:	a9 f4       	brne	.+42     	; 0x30b6 <uip_arp_out+0x40>
    308c:	20 91 e5 06 	lds	r18, 0x06E5
    3090:	30 91 e6 06 	lds	r19, 0x06E6
    3094:	80 91 69 02 	lds	r24, 0x0269
    3098:	90 91 6a 02 	lds	r25, 0x026A
    309c:	28 17       	cp	r18, r24
    309e:	39 07       	cpc	r19, r25
    30a0:	51 f4       	brne	.+20     	; 0x30b6 <uip_arp_out+0x40>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    30a2:	a5 ec       	ldi	r26, 0xC5	; 197
    30a4:	b6 e0       	ldi	r27, 0x06	; 6
    30a6:	ef e6       	ldi	r30, 0x6F	; 111
    30a8:	f2 e0       	ldi	r31, 0x02	; 2
    30aa:	86 e0       	ldi	r24, 0x06	; 6
    30ac:	01 90       	ld	r0, Z+
    30ae:	0d 92       	st	X+, r0
    30b0:	81 50       	subi	r24, 0x01	; 1
    30b2:	e1 f7       	brne	.-8      	; 0x30ac <uip_arp_out+0x36>
    30b4:	d3 c0       	rjmp	.+422    	; 0x325c <uip_arp_out+0x1e6>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask)) {
    30b6:	80 91 e3 06 	lds	r24, 0x06E3
    30ba:	90 91 e4 06 	lds	r25, 0x06E4
    30be:	20 91 c1 06 	lds	r18, 0x06C1
    30c2:	30 91 c2 06 	lds	r19, 0x06C2
    30c6:	82 27       	eor	r24, r18
    30c8:	93 27       	eor	r25, r19
    30ca:	20 91 bd 06 	lds	r18, 0x06BD
    30ce:	30 91 be 06 	lds	r19, 0x06BE
    30d2:	82 23       	and	r24, r18
    30d4:	93 23       	and	r25, r19
    30d6:	89 2b       	or	r24, r25
    30d8:	91 f4       	brne	.+36     	; 0x30fe <uip_arp_out+0x88>
    30da:	80 91 e5 06 	lds	r24, 0x06E5
    30de:	90 91 e6 06 	lds	r25, 0x06E6
    30e2:	20 91 c3 06 	lds	r18, 0x06C3
    30e6:	30 91 c4 06 	lds	r19, 0x06C4
    30ea:	82 27       	eor	r24, r18
    30ec:	93 27       	eor	r25, r19
    30ee:	20 91 bf 06 	lds	r18, 0x06BF
    30f2:	30 91 c0 06 	lds	r19, 0x06C0
    30f6:	82 23       	and	r24, r18
    30f8:	93 23       	and	r25, r19
    30fa:	89 2b       	or	r24, r25
    30fc:	49 f0       	breq	.+18     	; 0x3110 <uip_arp_out+0x9a>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(&ipaddr, &uip_draddr);
    30fe:	80 91 b9 06 	lds	r24, 0x06B9
    3102:	90 91 ba 06 	lds	r25, 0x06BA
    3106:	a0 91 bb 06 	lds	r26, 0x06BB
    310a:	b0 91 bc 06 	lds	r27, 0x06BC
    310e:	08 c0       	rjmp	.+16     	; 0x3120 <uip_arp_out+0xaa>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    3110:	80 91 e3 06 	lds	r24, 0x06E3
    3114:	90 91 e4 06 	lds	r25, 0x06E4
    3118:	a0 91 e5 06 	lds	r26, 0x06E5
    311c:	b0 91 e6 06 	lds	r27, 0x06E6
    3120:	80 93 06 03 	sts	0x0306, r24
    3124:	90 93 07 03 	sts	0x0307, r25
    3128:	a0 93 08 03 	sts	0x0308, r26
    312c:	b0 93 09 03 	sts	0x0309, r27
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3130:	10 92 0a 03 	sts	0x030A, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    3134:	60 91 06 03 	lds	r22, 0x0306
    3138:	70 91 07 03 	lds	r23, 0x0307
    313c:	40 91 08 03 	lds	r20, 0x0308
    3140:	50 91 09 03 	lds	r21, 0x0309
    3144:	e0 e0       	ldi	r30, 0x00	; 0
    3146:	f0 e0       	ldi	r31, 0x00	; 0
    3148:	20 e0       	ldi	r18, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    314a:	3b e0       	ldi	r19, 0x0B	; 11
    314c:	13 c0       	rjmp	.+38     	; 0x3174 <uip_arp_out+0xfe>
    314e:	23 9f       	mul	r18, r19
    3150:	f0 01       	movw	r30, r0
    3152:	11 24       	eor	r1, r1
    3154:	e2 55       	subi	r30, 0x52	; 82
    3156:	fd 4f       	sbci	r31, 0xFD	; 253
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    3158:	80 81       	ld	r24, Z
    315a:	91 81       	ldd	r25, Z+1	; 0x01
    315c:	68 17       	cp	r22, r24
    315e:	79 07       	cpc	r23, r25
    3160:	41 f4       	brne	.+16     	; 0x3172 <uip_arp_out+0xfc>
    3162:	82 81       	ldd	r24, Z+2	; 0x02
    3164:	93 81       	ldd	r25, Z+3	; 0x03
    3166:	48 17       	cp	r20, r24
    3168:	59 07       	cpc	r21, r25
    316a:	19 f4       	brne	.+6      	; 0x3172 <uip_arp_out+0xfc>
    316c:	20 93 0a 03 	sts	0x030A, r18
    3170:	6d c0       	rjmp	.+218    	; 0x324c <uip_arp_out+0x1d6>
    3172:	2f 5f       	subi	r18, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3174:	28 30       	cpi	r18, 0x08	; 8
    3176:	58 f3       	brcs	.-42     	; 0x314e <uip_arp_out+0xd8>
    3178:	20 93 0a 03 	sts	0x030A, r18
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    317c:	28 30       	cpi	r18, 0x08	; 8
    317e:	09 f0       	breq	.+2      	; 0x3182 <uip_arp_out+0x10c>
    3180:	65 c0       	rjmp	.+202    	; 0x324c <uip_arp_out+0x1d6>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    3182:	85 ec       	ldi	r24, 0xC5	; 197
    3184:	96 e0       	ldi	r25, 0x06	; 6
    3186:	6f ef       	ldi	r22, 0xFF	; 255
    3188:	70 e0       	ldi	r23, 0x00	; 0
    318a:	46 e0       	ldi	r20, 0x06	; 6
    318c:	50 e0       	ldi	r21, 0x00	; 0
    318e:	0e 94 c0 36 	call	0x6d80	; 0x6d80 <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    3192:	e5 ee       	ldi	r30, 0xE5	; 229
    3194:	f6 e0       	ldi	r31, 0x06	; 6
    3196:	86 e0       	ldi	r24, 0x06	; 6
    3198:	df 01       	movw	r26, r30
    319a:	1d 92       	st	X+, r1
    319c:	8a 95       	dec	r24
    319e:	e9 f7       	brne	.-6      	; 0x319a <uip_arp_out+0x124>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    31a0:	7a 97       	sbiw	r30, 0x1a	; 26
    31a2:	ac e9       	ldi	r26, 0x9C	; 156
    31a4:	b2 e0       	ldi	r27, 0x02	; 2
    31a6:	86 e0       	ldi	r24, 0x06	; 6
    31a8:	0d 90       	ld	r0, X+
    31aa:	01 92       	st	Z+, r0
    31ac:	81 50       	subi	r24, 0x01	; 1
    31ae:	e1 f7       	brne	.-8      	; 0x31a8 <uip_arp_out+0x132>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    31b0:	ab ed       	ldi	r26, 0xDB	; 219
    31b2:	b6 e0       	ldi	r27, 0x06	; 6
    31b4:	ec e9       	ldi	r30, 0x9C	; 156
    31b6:	f2 e0       	ldi	r31, 0x02	; 2
    31b8:	86 e0       	ldi	r24, 0x06	; 6
    31ba:	01 90       	ld	r0, Z+
    31bc:	0d 92       	st	X+, r0
    31be:	81 50       	subi	r24, 0x01	; 1
    31c0:	e1 f7       	brne	.-8      	; 0x31ba <uip_arp_out+0x144>

      uip_ipaddr_copy(&BUF->dipaddr, &ipaddr);
    31c2:	80 91 06 03 	lds	r24, 0x0306
    31c6:	90 91 07 03 	lds	r25, 0x0307
    31ca:	a0 91 08 03 	lds	r26, 0x0308
    31ce:	b0 91 09 03 	lds	r27, 0x0309
    31d2:	80 93 eb 06 	sts	0x06EB, r24
    31d6:	90 93 ec 06 	sts	0x06EC, r25
    31da:	a0 93 ed 06 	sts	0x06ED, r26
    31de:	b0 93 ee 06 	sts	0x06EE, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    31e2:	80 91 c1 06 	lds	r24, 0x06C1
    31e6:	90 91 c2 06 	lds	r25, 0x06C2
    31ea:	a0 91 c3 06 	lds	r26, 0x06C3
    31ee:	b0 91 c4 06 	lds	r27, 0x06C4
    31f2:	80 93 e1 06 	sts	0x06E1, r24
    31f6:	90 93 e2 06 	sts	0x06E2, r25
    31fa:	a0 93 e3 06 	sts	0x06E3, r26
    31fe:	b0 93 e4 06 	sts	0x06E4, r27
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    3202:	80 e0       	ldi	r24, 0x00	; 0
    3204:	91 e0       	ldi	r25, 0x01	; 1
    3206:	90 93 da 06 	sts	0x06DA, r25
    320a:	80 93 d9 06 	sts	0x06D9, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    320e:	90 93 d4 06 	sts	0x06D4, r25
    3212:	80 93 d3 06 	sts	0x06D3, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    3216:	88 e0       	ldi	r24, 0x08	; 8
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	90 93 d6 06 	sts	0x06D6, r25
    321e:	80 93 d5 06 	sts	0x06D5, r24
      BUF->hwlen = 6;
    3222:	86 e0       	ldi	r24, 0x06	; 6
    3224:	80 93 d7 06 	sts	0x06D7, r24
      BUF->protolen = 4;
    3228:	84 e0       	ldi	r24, 0x04	; 4
    322a:	80 93 d8 06 	sts	0x06D8, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    322e:	88 e0       	ldi	r24, 0x08	; 8
    3230:	96 e0       	ldi	r25, 0x06	; 6
    3232:	90 93 d2 06 	sts	0x06D2, r25
    3236:	80 93 d1 06 	sts	0x06D1, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    323a:	8b ef       	ldi	r24, 0xFB	; 251
    323c:	96 e0       	ldi	r25, 0x06	; 6
    323e:	90 93 59 05 	sts	0x0559, r25
    3242:	80 93 58 05 	sts	0x0558, r24

      uip_len = sizeof(struct arp_hdr);
    3246:	8a e2       	ldi	r24, 0x2A	; 42
    3248:	90 e0       	ldi	r25, 0x00	; 0
    324a:	1c c0       	rjmp	.+56     	; 0x3284 <uip_arp_out+0x20e>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    324c:	a5 ec       	ldi	r26, 0xC5	; 197
    324e:	b6 e0       	ldi	r27, 0x06	; 6
    3250:	34 96       	adiw	r30, 0x04	; 4
    3252:	86 e0       	ldi	r24, 0x06	; 6
    3254:	01 90       	ld	r0, Z+
    3256:	0d 92       	st	X+, r0
    3258:	81 50       	subi	r24, 0x01	; 1
    325a:	e1 f7       	brne	.-8      	; 0x3254 <uip_arp_out+0x1de>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    325c:	ab ec       	ldi	r26, 0xCB	; 203
    325e:	b6 e0       	ldi	r27, 0x06	; 6
    3260:	ec e9       	ldi	r30, 0x9C	; 156
    3262:	f2 e0       	ldi	r31, 0x02	; 2
    3264:	86 e0       	ldi	r24, 0x06	; 6
    3266:	01 90       	ld	r0, Z+
    3268:	0d 92       	st	X+, r0
    326a:	81 50       	subi	r24, 0x01	; 1
    326c:	e1 f7       	brne	.-8      	; 0x3266 <uip_arp_out+0x1f0>

  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    326e:	88 e0       	ldi	r24, 0x08	; 8
    3270:	90 e0       	ldi	r25, 0x00	; 0
    3272:	90 93 d2 06 	sts	0x06D2, r25
    3276:	80 93 d1 06 	sts	0x06D1, r24

  uip_len += sizeof(struct uip_eth_hdr);
    327a:	80 91 4d 05 	lds	r24, 0x054D
    327e:	90 91 4e 05 	lds	r25, 0x054E
    3282:	0e 96       	adiw	r24, 0x0e	; 14
    3284:	90 93 4e 05 	sts	0x054E, r25
    3288:	80 93 4d 05 	sts	0x054D, r24
    328c:	08 95       	ret

0000328e <uip_arp_timer>:
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
    328e:	80 91 0c 03 	lds	r24, 0x030C
    3292:	8f 5f       	subi	r24, 0xFF	; 255
    3294:	80 93 0c 03 	sts	0x030C, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3298:	10 92 0a 03 	sts	0x030A, r1
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    329c:	60 91 6b 02 	lds	r22, 0x026B
    32a0:	70 91 6c 02 	lds	r23, 0x026C
    32a4:	40 91 6d 02 	lds	r20, 0x026D
    32a8:	50 91 6e 02 	lds	r21, 0x026E
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    32ac:	3b e0       	ldi	r19, 0x0B	; 11
    32ae:	21 c0       	rjmp	.+66     	; 0x32f2 <uip_arp_timer+0x64>
    32b0:	83 9f       	mul	r24, r19
    32b2:	f0 01       	movw	r30, r0
    32b4:	11 24       	eor	r1, r1
    32b6:	e2 55       	subi	r30, 0x52	; 82
    32b8:	fd 4f       	sbci	r31, 0xFD	; 253
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    32ba:	80 81       	ld	r24, Z
    32bc:	91 81       	ldd	r25, Z+1	; 0x01
    32be:	86 17       	cp	r24, r22
    32c0:	97 07       	cpc	r25, r23
    32c2:	91 f4       	brne	.+36     	; 0x32e8 <uip_arp_timer+0x5a>
    32c4:	82 81       	ldd	r24, Z+2	; 0x02
    32c6:	93 81       	ldd	r25, Z+3	; 0x03
    32c8:	84 17       	cp	r24, r20
    32ca:	95 07       	cpc	r25, r21
    32cc:	69 f4       	brne	.+26     	; 0x32e8 <uip_arp_timer+0x5a>
    32ce:	80 91 0c 03 	lds	r24, 0x030C
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	22 85       	ldd	r18, Z+10	; 0x0a
    32d6:	82 1b       	sub	r24, r18
    32d8:	91 09       	sbc	r25, r1
    32da:	88 37       	cpi	r24, 0x78	; 120
    32dc:	91 05       	cpc	r25, r1
    32de:	24 f0       	brlt	.+8      	; 0x32e8 <uip_arp_timer+0x5a>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    32e0:	10 82       	st	Z, r1
    32e2:	11 82       	std	Z+1, r1	; 0x01
    32e4:	12 82       	std	Z+2, r1	; 0x02
    32e6:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32e8:	80 91 0a 03 	lds	r24, 0x030A
    32ec:	8f 5f       	subi	r24, 0xFF	; 255
    32ee:	80 93 0a 03 	sts	0x030A, r24
    32f2:	80 91 0a 03 	lds	r24, 0x030A
    32f6:	88 30       	cpi	r24, 0x08	; 8
    32f8:	d8 f2       	brcs	.-74     	; 0x32b0 <uip_arp_timer+0x22>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }

}
    32fa:	08 95       	ret

000032fc <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32fc:	10 92 0a 03 	sts	0x030A, r1
    memset(&arp_table[i].ipaddr, 0, 4);
    3300:	9b e0       	ldi	r25, 0x0B	; 11
    3302:	0c c0       	rjmp	.+24     	; 0x331c <uip_arp_init+0x20>
    3304:	89 9f       	mul	r24, r25
    3306:	f0 01       	movw	r30, r0
    3308:	11 24       	eor	r1, r1
    330a:	e2 55       	subi	r30, 0x52	; 82
    330c:	fd 4f       	sbci	r31, 0xFD	; 253
    330e:	10 82       	st	Z, r1
    3310:	11 82       	std	Z+1, r1	; 0x01
    3312:	12 82       	std	Z+2, r1	; 0x02
    3314:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3316:	8f 5f       	subi	r24, 0xFF	; 255
    3318:	80 93 0a 03 	sts	0x030A, r24
    331c:	80 91 0a 03 	lds	r24, 0x030A
    3320:	88 30       	cpi	r24, 0x08	; 8
    3322:	80 f3       	brcs	.-32     	; 0x3304 <uip_arp_init+0x8>
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
    3324:	08 95       	ret

00003326 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    3326:	fc 01       	movw	r30, r24
  t->start += t->interval;
    3328:	80 81       	ld	r24, Z
    332a:	91 81       	ldd	r25, Z+1	; 0x01
    332c:	22 81       	ldd	r18, Z+2	; 0x02
    332e:	33 81       	ldd	r19, Z+3	; 0x03
    3330:	82 0f       	add	r24, r18
    3332:	93 1f       	adc	r25, r19
    3334:	91 83       	std	Z+1, r25	; 0x01
    3336:	80 83       	st	Z, r24
}
    3338:	08 95       	ret

0000333a <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    333a:	0f 93       	push	r16
    333c:	1f 93       	push	r17
    333e:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    3340:	43 d0       	rcall	.+134    	; 0x33c8 <clock_time>
    3342:	40 e0       	ldi	r20, 0x00	; 0
    3344:	50 e0       	ldi	r21, 0x00	; 0
    3346:	f8 01       	movw	r30, r16
    3348:	20 81       	ld	r18, Z
    334a:	31 81       	ldd	r19, Z+1	; 0x01
    334c:	82 1b       	sub	r24, r18
    334e:	93 0b       	sbc	r25, r19
    3350:	22 81       	ldd	r18, Z+2	; 0x02
    3352:	33 81       	ldd	r19, Z+3	; 0x03
    3354:	82 17       	cp	r24, r18
    3356:	93 07       	cpc	r25, r19
    3358:	10 f0       	brcs	.+4      	; 0x335e <timer_expired+0x24>
    335a:	41 e0       	ldi	r20, 0x01	; 1
    335c:	50 e0       	ldi	r21, 0x00	; 0
}
    335e:	ca 01       	movw	r24, r20
    3360:	1f 91       	pop	r17
    3362:	0f 91       	pop	r16
    3364:	08 95       	ret

00003366 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    3366:	0f 93       	push	r16
    3368:	1f 93       	push	r17
    336a:	8c 01       	movw	r16, r24
  t->interval = interval;
    336c:	fc 01       	movw	r30, r24
    336e:	73 83       	std	Z+3, r23	; 0x03
    3370:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    3372:	2a d0       	rcall	.+84     	; 0x33c8 <clock_time>
    3374:	f8 01       	movw	r30, r16
    3376:	91 83       	std	Z+1, r25	; 0x01
    3378:	80 83       	st	Z, r24
}
    337a:	1f 91       	pop	r17
    337c:	0f 91       	pop	r16
    337e:	08 95       	ret

00003380 <__vector_17>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER1_COMPA_vect)
{
    3380:	1f 92       	push	r1
    3382:	0f 92       	push	r0
    3384:	0f b6       	in	r0, 0x3f	; 63
    3386:	0f 92       	push	r0
    3388:	11 24       	eor	r1, r1
    338a:	8f 93       	push	r24
    338c:	9f 93       	push	r25
	clock_datetime += 1;
    338e:	80 91 0e 03 	lds	r24, 0x030E
    3392:	90 91 0f 03 	lds	r25, 0x030F
    3396:	01 96       	adiw	r24, 0x01	; 1
    3398:	90 93 0f 03 	sts	0x030F, r25
    339c:	80 93 0e 03 	sts	0x030E, r24
}
    33a0:	9f 91       	pop	r25
    33a2:	8f 91       	pop	r24
    33a4:	0f 90       	pop	r0
    33a6:	0f be       	out	0x3f, r0	; 63
    33a8:	0f 90       	pop	r0
    33aa:	1f 90       	pop	r1
    33ac:	18 95       	reti

000033ae <clock_init>:

//Initialise the clock
void clock_init()
{
	OCR1A  = (((F_CPU / 1024) / 100) - 1);
    33ae:	8d e4       	ldi	r24, 0x4D	; 77
    33b0:	90 e0       	ldi	r25, 0x00	; 0
    33b2:	90 93 89 00 	sts	0x0089, r25
    33b6:	80 93 88 00 	sts	0x0088, r24
	TCCR1B = ((1 << WGM12) | (1 << CS12) | (1 << CS10));
    33ba:	8d e0       	ldi	r24, 0x0D	; 13
    33bc:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1 << OCIE1A);
    33c0:	82 e0       	ldi	r24, 0x02	; 2
    33c2:	80 93 6f 00 	sts	0x006F, r24
}
    33c6:	08 95       	ret

000033c8 <clock_time>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    33c8:	f8 94       	cli
{
	clock_time_t time;

	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		time = clock_datetime;
    33ca:	20 91 0e 03 	lds	r18, 0x030E
    33ce:	30 91 0f 03 	lds	r19, 0x030F
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    33d2:	78 94       	sei
	}

	return time;
}
    33d4:	c9 01       	movw	r24, r18
    33d6:	08 95       	ret

000033d8 <uip_split_output>:
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])

/*-----------------------------------------------------------------------------*/
void
uip_split_output(void)
{
    33d8:	ef 92       	push	r14
    33da:	ff 92       	push	r15
    33dc:	0f 93       	push	r16
    33de:	1f 93       	push	r17
#if UIP_TCP
  u16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP  && uip_len == UIP_BUFSIZE) {
    33e0:	80 91 dc 06 	lds	r24, 0x06DC
    33e4:	86 30       	cpi	r24, 0x06	; 6
    33e6:	09 f0       	breq	.+2      	; 0x33ea <uip_split_output+0x12>
    33e8:	7f c0       	rjmp	.+254    	; 0x34e8 <uip_split_output+0x110>
    33ea:	80 91 4d 05 	lds	r24, 0x054D
    33ee:	90 91 4e 05 	lds	r25, 0x054E
    33f2:	8a 5e       	subi	r24, 0xEA	; 234
    33f4:	95 40       	sbci	r25, 0x05	; 5
    33f6:	09 f0       	breq	.+2      	; 0x33fa <uip_split_output+0x22>
    33f8:	77 c0       	rjmp	.+238    	; 0x34e8 <uip_split_output+0x110>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    33fa:	00 e1       	ldi	r16, 0x10	; 16
    33fc:	13 e0       	ldi	r17, 0x03	; 3
    33fe:	10 93 4e 05 	sts	0x054E, r17
    3402:	00 93 4d 05 	sts	0x054D, r16
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len - UIP_LLH_LEN) >> 8;
    3406:	93 e0       	ldi	r25, 0x03	; 3
    3408:	e9 2e       	mov	r14, r25
    340a:	e0 92 d5 06 	sts	0x06D5, r14
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    340e:	82 e0       	ldi	r24, 0x02	; 2
    3410:	f8 2e       	mov	r15, r24
    3412:	f0 92 d6 06 	sts	0x06D6, r15
#endif /* UIP_CONF_IPV6 */

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    3416:	10 92 f8 06 	sts	0x06F8, r1
    341a:	10 92 f7 06 	sts	0x06F7, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    341e:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <uip_tcpchksum>
    3422:	80 95       	com	r24
    3424:	90 95       	com	r25
    3426:	90 93 f8 06 	sts	0x06F8, r25
    342a:	80 93 f7 06 	sts	0x06F7, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    342e:	10 92 de 06 	sts	0x06DE, r1
    3432:	10 92 dd 06 	sts	0x06DD, r1
    BUF->ipchksum = ~(uip_ipchksum());
    3436:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <uip_ipchksum>
    343a:	80 95       	com	r24
    343c:	90 95       	com	r25
    343e:	90 93 de 06 	sts	0x06DE, r25
    3442:	80 93 dd 06 	sts	0x06DD, r24

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface, uip_buf, uip_len);
    3446:	40 91 4d 05 	lds	r20, 0x054D
    344a:	50 91 4e 05 	lds	r21, 0x054E
    344e:	87 e3       	ldi	r24, 0x37	; 55
    3450:	91 e0       	ldi	r25, 0x01	; 1
    3452:	63 ed       	ldi	r22, 0xD3	; 211
    3454:	76 e0       	ldi	r23, 0x06	; 6
    3456:	6e 50       	subi	r22, 0x0E	; 14
    3458:	70 40       	sbci	r23, 0x00	; 0
    345a:	0e 94 5c 32 	call	0x64b8	; 0x64b8 <RNDIS_Host_SendPacket>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is determined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    345e:	10 93 4e 05 	sts	0x054E, r17
    3462:	00 93 4d 05 	sts	0x054D, r16
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len  - UIP_LLH_LEN) >> 8;
    3466:	e0 92 d5 06 	sts	0x06D5, r14
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    346a:	f0 92 d6 06 	sts	0x06D6, r15
#endif /* UIP_CONF_IPV6 */

    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
    346e:	20 91 58 05 	lds	r18, 0x0558
    3472:	30 91 59 05 	lds	r19, 0x0559
    3476:	c9 01       	movw	r24, r18
    3478:	fc 01       	movw	r30, r24
    347a:	dc 01       	movw	r26, r24
    347c:	a6 52       	subi	r26, 0x26	; 38
    347e:	bd 4f       	sbci	r27, 0xFD	; 253
    3480:	8a ed       	ldi	r24, 0xDA	; 218
    3482:	92 e0       	ldi	r25, 0x02	; 2
    3484:	0d 90       	ld	r0, X+
    3486:	01 92       	st	Z+, r0
    3488:	01 97       	sbiw	r24, 0x01	; 1
    348a:	e1 f7       	brne	.-8      	; 0x3484 <uip_split_output+0xac>

    uip_add32(BUF->seqno, len1);
    348c:	8b ee       	ldi	r24, 0xEB	; 235
    348e:	96 e0       	ldi	r25, 0x06	; 6
    3490:	6a ed       	ldi	r22, 0xDA	; 218
    3492:	72 e0       	ldi	r23, 0x02	; 2
    3494:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    3498:	80 91 51 05 	lds	r24, 0x0551
    349c:	80 93 eb 06 	sts	0x06EB, r24
    BUF->seqno[1] = uip_acc32[1];
    34a0:	80 91 52 05 	lds	r24, 0x0552
    34a4:	80 93 ec 06 	sts	0x06EC, r24
    BUF->seqno[2] = uip_acc32[2];
    34a8:	80 91 53 05 	lds	r24, 0x0553
    34ac:	80 93 ed 06 	sts	0x06ED, r24
    BUF->seqno[3] = uip_acc32[3];
    34b0:	80 91 54 05 	lds	r24, 0x0554
    34b4:	80 93 ee 06 	sts	0x06EE, r24

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    34b8:	10 92 f8 06 	sts	0x06F8, r1
    34bc:	10 92 f7 06 	sts	0x06F7, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    34c0:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <uip_tcpchksum>
    34c4:	80 95       	com	r24
    34c6:	90 95       	com	r25
    34c8:	90 93 f8 06 	sts	0x06F8, r25
    34cc:	80 93 f7 06 	sts	0x06F7, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    34d0:	10 92 de 06 	sts	0x06DE, r1
    34d4:	10 92 dd 06 	sts	0x06DD, r1
    BUF->ipchksum = ~(uip_ipchksum());
    34d8:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <uip_ipchksum>
    34dc:	80 95       	com	r24
    34de:	90 95       	com	r25
    34e0:	90 93 de 06 	sts	0x06DE, r25
    34e4:	80 93 dd 06 	sts	0x06DD, r24

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface, uip_buf, uip_len);
    34e8:	40 91 4d 05 	lds	r20, 0x054D
    34ec:	50 91 4e 05 	lds	r21, 0x054E
    34f0:	87 e3       	ldi	r24, 0x37	; 55
    34f2:	91 e0       	ldi	r25, 0x01	; 1
    34f4:	65 ec       	ldi	r22, 0xC5	; 197
    34f6:	76 e0       	ldi	r23, 0x06	; 6
    34f8:	0e 94 5c 32 	call	0x64b8	; 0x64b8 <RNDIS_Host_SendPacket>
#endif /* UIP_CONF_IPV6 */
}
    34fc:	1f 91       	pop	r17
    34fe:	0f 91       	pop	r16
    3500:	ff 90       	pop	r15
    3502:	ef 90       	pop	r14
    3504:	08 95       	ret

00003506 <disk_initialize>:
DSTATUS disk_initialize (
	BYTE drv				/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    3506:	80 e0       	ldi	r24, 0x00	; 0
    3508:	08 95       	ret

0000350a <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    350a:	80 e0       	ldi	r24, 0x00	; 0
    350c:	08 95       	ret

0000350e <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..255) */
)
{
    350e:	0f 93       	push	r16
    3510:	fb 01       	movw	r30, r22
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
    3512:	ca 01       	movw	r24, r20
    3514:	b9 01       	movw	r22, r18
    3516:	40 2f       	mov	r20, r16
    3518:	50 e0       	ldi	r21, 0x00	; 0
    351a:	9f 01       	movw	r18, r30
    351c:	0e 94 15 05 	call	0xa2a	; 0xa2a <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
    3520:	80 e0       	ldi	r24, 0x00	; 0
    3522:	0f 91       	pop	r16
    3524:	08 95       	ret

00003526 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    3526:	ef 92       	push	r14
    3528:	ff 92       	push	r15
    352a:	0f 93       	push	r16
    352c:	1f 93       	push	r17
    352e:	cf 93       	push	r28
    3530:	df 93       	push	r29
    3532:	ec 01       	movw	r28, r24
    3534:	7a 01       	movw	r14, r20
    3536:	8b 01       	movw	r16, r22
	clst -= 2;
    3538:	8e ef       	ldi	r24, 0xFE	; 254
    353a:	9f ef       	ldi	r25, 0xFF	; 255
    353c:	af ef       	ldi	r26, 0xFF	; 255
    353e:	bf ef       	ldi	r27, 0xFF	; 255
    3540:	e8 0e       	add	r14, r24
    3542:	f9 1e       	adc	r15, r25
    3544:	0a 1f       	adc	r16, r26
    3546:	1b 1f       	adc	r17, r27
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3548:	8a 85       	ldd	r24, Y+10	; 0x0a
    354a:	9b 85       	ldd	r25, Y+11	; 0x0b
    354c:	ac 85       	ldd	r26, Y+12	; 0x0c
    354e:	bd 85       	ldd	r27, Y+13	; 0x0d
    3550:	02 97       	sbiw	r24, 0x02	; 2
    3552:	a1 09       	sbc	r26, r1
    3554:	b1 09       	sbc	r27, r1
    3556:	e8 16       	cp	r14, r24
    3558:	f9 06       	cpc	r15, r25
    355a:	0a 07       	cpc	r16, r26
    355c:	1b 07       	cpc	r17, r27
    355e:	28 f0       	brcs	.+10     	; 0x356a <clust2sect+0x44>
    3560:	20 e0       	ldi	r18, 0x00	; 0
    3562:	30 e0       	ldi	r19, 0x00	; 0
    3564:	40 e0       	ldi	r20, 0x00	; 0
    3566:	50 e0       	ldi	r21, 0x00	; 0
    3568:	12 c0       	rjmp	.+36     	; 0x358e <clust2sect+0x68>
	return clst * fs->csize + fs->database;
    356a:	2a 81       	ldd	r18, Y+2	; 0x02
    356c:	30 e0       	ldi	r19, 0x00	; 0
    356e:	40 e0       	ldi	r20, 0x00	; 0
    3570:	50 e0       	ldi	r21, 0x00	; 0
    3572:	c8 01       	movw	r24, r16
    3574:	b7 01       	movw	r22, r14
    3576:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__mulsi3>
    357a:	9b 01       	movw	r18, r22
    357c:	ac 01       	movw	r20, r24
    357e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3580:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3582:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3584:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3586:	28 0f       	add	r18, r24
    3588:	39 1f       	adc	r19, r25
    358a:	4a 1f       	adc	r20, r26
    358c:	5b 1f       	adc	r21, r27
}
    358e:	b9 01       	movw	r22, r18
    3590:	ca 01       	movw	r24, r20
    3592:	df 91       	pop	r29
    3594:	cf 91       	pop	r28
    3596:	1f 91       	pop	r17
    3598:	0f 91       	pop	r16
    359a:	ff 90       	pop	r15
    359c:	ef 90       	pop	r14
    359e:	08 95       	ret

000035a0 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
    35a0:	db 01       	movw	r26, r22
	FATFS *rfs;


	if (vol >= _DRIVES)				/* Check if the drive number is valid */
    35a2:	88 23       	and	r24, r24
    35a4:	11 f0       	breq	.+4      	; 0x35aa <f_mount+0xa>
    35a6:	8b e0       	ldi	r24, 0x0B	; 11
    35a8:	08 95       	ret
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];				/* Get current fs object */
    35aa:	e0 91 12 03 	lds	r30, 0x0312
    35ae:	f0 91 13 03 	lds	r31, 0x0313

	if (rfs) {
    35b2:	30 97       	sbiw	r30, 0x00	; 0
    35b4:	09 f0       	breq	.+2      	; 0x35b8 <f_mount+0x18>
#if _FS_REENTRANT					/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;			/* Clear old fs object */
    35b6:	10 82       	st	Z, r1
	}

	if (fs) {
    35b8:	10 97       	sbiw	r26, 0x00	; 0
    35ba:	09 f0       	breq	.+2      	; 0x35be <f_mount+0x1e>
		fs->fs_type = 0;			/* Clear new fs object */
    35bc:	1c 92       	st	X, r1
#if _FS_REENTRANT					/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */
    35be:	b0 93 13 03 	sts	0x0313, r27
    35c2:	a0 93 12 03 	sts	0x0312, r26
    35c6:	80 e0       	ldi	r24, 0x00	; 0

	return FR_OK;
}
    35c8:	08 95       	ret

000035ca <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
    35ca:	fc 01       	movw	r30, r24
	if (!fs || !fs->fs_type || fs->id != id)
    35cc:	00 97       	sbiw	r24, 0x00	; 0
    35ce:	81 f0       	breq	.+32     	; 0x35f0 <validate+0x26>
    35d0:	80 81       	ld	r24, Z
    35d2:	88 23       	and	r24, r24
    35d4:	69 f0       	breq	.+26     	; 0x35f0 <validate+0x26>
    35d6:	86 81       	ldd	r24, Z+6	; 0x06
    35d8:	97 81       	ldd	r25, Z+7	; 0x07
    35da:	86 17       	cp	r24, r22
    35dc:	97 07       	cpc	r25, r23
    35de:	41 f4       	brne	.+16     	; 0x35f0 <validate+0x26>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
    35e0:	81 81       	ldd	r24, Z+1	; 0x01
    35e2:	93 df       	rcall	.-218    	; 0x350a <disk_status>
    35e4:	80 fd       	sbrc	r24, 0
    35e6:	02 c0       	rjmp	.+4      	; 0x35ec <validate+0x22>
    35e8:	80 e0       	ldi	r24, 0x00	; 0
    35ea:	08 95       	ret
    35ec:	83 e0       	ldi	r24, 0x03	; 3
    35ee:	08 95       	ret
    35f0:	89 e0       	ldi	r24, 0x09	; 9
		return FR_NOT_READY;

	return FR_OK;
}
    35f2:	08 95       	ret

000035f4 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    35f4:	cf 93       	push	r28
    35f6:	df 93       	push	r29
    35f8:	ec 01       	movw	r28, r24
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
    35fa:	6a 81       	ldd	r22, Y+2	; 0x02
    35fc:	7b 81       	ldd	r23, Y+3	; 0x03
    35fe:	88 81       	ld	r24, Y
    3600:	99 81       	ldd	r25, Y+1	; 0x01
    3602:	e3 df       	rcall	.-58     	; 0x35ca <validate>
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    3604:	88 23       	and	r24, r24
    3606:	11 f4       	brne	.+4      	; 0x360c <f_close+0x18>
    3608:	19 82       	std	Y+1, r1	; 0x01
    360a:	18 82       	st	Y, r1
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
    360c:	df 91       	pop	r29
    360e:	cf 91       	pop	r28
    3610:	08 95       	ret

00003612 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    3612:	cf 92       	push	r12
    3614:	df 92       	push	r13
    3616:	ef 92       	push	r14
    3618:	ff 92       	push	r15
    361a:	0f 93       	push	r16
    361c:	cf 93       	push	r28
    361e:	df 93       	push	r29
    3620:	ec 01       	movw	r28, r24
    3622:	6a 01       	movw	r12, r20
    3624:	7b 01       	movw	r14, r22
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
    3626:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3628:	9f 8d       	ldd	r25, Y+31	; 0x1f
    362a:	a8 a1       	ldd	r26, Y+32	; 0x20
    362c:	b9 a1       	ldd	r27, Y+33	; 0x21
    362e:	84 17       	cp	r24, r20
    3630:	95 07       	cpc	r25, r21
    3632:	a6 07       	cpc	r26, r22
    3634:	b7 07       	cpc	r27, r23
    3636:	a9 f0       	breq	.+42     	; 0x3662 <move_window+0x50>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    3638:	41 15       	cp	r20, r1
    363a:	51 05       	cpc	r21, r1
    363c:	61 05       	cpc	r22, r1
    363e:	71 05       	cpc	r23, r1
    3640:	81 f0       	breq	.+32     	; 0x3662 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    3642:	be 01       	movw	r22, r28
    3644:	6e 5d       	subi	r22, 0xDE	; 222
    3646:	7f 4f       	sbci	r23, 0xFF	; 255
    3648:	89 81       	ldd	r24, Y+1	; 0x01
    364a:	a7 01       	movw	r20, r14
    364c:	96 01       	movw	r18, r12
    364e:	01 e0       	ldi	r16, 0x01	; 1
    3650:	5e df       	rcall	.-324    	; 0x350e <disk_read>
    3652:	88 23       	and	r24, r24
    3654:	11 f0       	breq	.+4      	; 0x365a <move_window+0x48>
    3656:	81 e0       	ldi	r24, 0x01	; 1
    3658:	05 c0       	rjmp	.+10     	; 0x3664 <move_window+0x52>
				return FR_DISK_ERR;
			fs->winsect = sector;
    365a:	ce 8e       	std	Y+30, r12	; 0x1e
    365c:	df 8e       	std	Y+31, r13	; 0x1f
    365e:	e8 a2       	std	Y+32, r14	; 0x20
    3660:	f9 a2       	std	Y+33, r15	; 0x21
    3662:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return FR_OK;
}
    3664:	df 91       	pop	r29
    3666:	cf 91       	pop	r28
    3668:	0f 91       	pop	r16
    366a:	ff 90       	pop	r15
    366c:	ef 90       	pop	r14
    366e:	df 90       	pop	r13
    3670:	cf 90       	pop	r12
    3672:	08 95       	ret

00003674 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    3674:	bf 92       	push	r11
    3676:	cf 92       	push	r12
    3678:	df 92       	push	r13
    367a:	ef 92       	push	r14
    367c:	ff 92       	push	r15
    367e:	0f 93       	push	r16
    3680:	1f 93       	push	r17
    3682:	cf 93       	push	r28
    3684:	df 93       	push	r29
    3686:	6c 01       	movw	r12, r24
    3688:	7a 01       	movw	r14, r20
    368a:	8b 01       	movw	r16, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    368c:	42 30       	cpi	r20, 0x02	; 2
    368e:	51 05       	cpc	r21, r1
    3690:	61 05       	cpc	r22, r1
    3692:	71 05       	cpc	r23, r1
    3694:	08 f4       	brcc	.+2      	; 0x3698 <get_fat+0x24>
    3696:	a8 c0       	rjmp	.+336    	; 0x37e8 <get_fat+0x174>
    3698:	f6 01       	movw	r30, r12
    369a:	82 85       	ldd	r24, Z+10	; 0x0a
    369c:	93 85       	ldd	r25, Z+11	; 0x0b
    369e:	a4 85       	ldd	r26, Z+12	; 0x0c
    36a0:	b5 85       	ldd	r27, Z+13	; 0x0d
    36a2:	48 17       	cp	r20, r24
    36a4:	59 07       	cpc	r21, r25
    36a6:	6a 07       	cpc	r22, r26
    36a8:	7b 07       	cpc	r23, r27
    36aa:	08 f0       	brcs	.+2      	; 0x36ae <get_fat+0x3a>
    36ac:	9d c0       	rjmp	.+314    	; 0x37e8 <get_fat+0x174>
		return 1;

	switch (fs->fs_type) {
    36ae:	80 81       	ld	r24, Z
    36b0:	82 30       	cpi	r24, 0x02	; 2
    36b2:	09 f4       	brne	.+2      	; 0x36b6 <get_fat+0x42>
    36b4:	55 c0       	rjmp	.+170    	; 0x3760 <get_fat+0xec>
    36b6:	83 30       	cpi	r24, 0x03	; 3
    36b8:	09 f4       	brne	.+2      	; 0x36bc <get_fat+0x48>
    36ba:	71 c0       	rjmp	.+226    	; 0x379e <get_fat+0x12a>
    36bc:	81 30       	cpi	r24, 0x01	; 1
    36be:	09 f0       	breq	.+2      	; 0x36c2 <get_fat+0x4e>
    36c0:	98 c0       	rjmp	.+304    	; 0x37f2 <get_fat+0x17e>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    36c2:	ea 01       	movw	r28, r20
    36c4:	d6 95       	lsr	r29
    36c6:	c7 95       	ror	r28
    36c8:	c4 0f       	add	r28, r20
    36ca:	d5 1f       	adc	r29, r21
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    36cc:	ae 01       	movw	r20, r28
    36ce:	45 2f       	mov	r20, r21
    36d0:	55 27       	eor	r21, r21
    36d2:	46 95       	lsr	r20
    36d4:	60 e0       	ldi	r22, 0x00	; 0
    36d6:	70 e0       	ldi	r23, 0x00	; 0
    36d8:	f6 01       	movw	r30, r12
    36da:	82 89       	ldd	r24, Z+18	; 0x12
    36dc:	93 89       	ldd	r25, Z+19	; 0x13
    36de:	a4 89       	ldd	r26, Z+20	; 0x14
    36e0:	b5 89       	ldd	r27, Z+21	; 0x15
    36e2:	48 0f       	add	r20, r24
    36e4:	59 1f       	adc	r21, r25
    36e6:	6a 1f       	adc	r22, r26
    36e8:	7b 1f       	adc	r23, r27
    36ea:	c6 01       	movw	r24, r12
    36ec:	92 df       	rcall	.-220    	; 0x3612 <move_window>
    36ee:	88 23       	and	r24, r24
    36f0:	09 f0       	breq	.+2      	; 0x36f4 <get_fat+0x80>
    36f2:	7f c0       	rjmp	.+254    	; 0x37f2 <get_fat+0x17e>
		wc = fs->win[bc % SS(fs)]; bc++;
    36f4:	fe 01       	movw	r30, r28
    36f6:	f1 70       	andi	r31, 0x01	; 1
    36f8:	ec 0d       	add	r30, r12
    36fa:	fd 1d       	adc	r31, r13
    36fc:	b2 a0       	ldd	r11, Z+34	; 0x22
    36fe:	21 96       	adiw	r28, 0x01	; 1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3700:	ae 01       	movw	r20, r28
    3702:	45 2f       	mov	r20, r21
    3704:	55 27       	eor	r21, r21
    3706:	46 95       	lsr	r20
    3708:	60 e0       	ldi	r22, 0x00	; 0
    370a:	70 e0       	ldi	r23, 0x00	; 0
    370c:	f6 01       	movw	r30, r12
    370e:	82 89       	ldd	r24, Z+18	; 0x12
    3710:	93 89       	ldd	r25, Z+19	; 0x13
    3712:	a4 89       	ldd	r26, Z+20	; 0x14
    3714:	b5 89       	ldd	r27, Z+21	; 0x15
    3716:	48 0f       	add	r20, r24
    3718:	59 1f       	adc	r21, r25
    371a:	6a 1f       	adc	r22, r26
    371c:	7b 1f       	adc	r23, r27
    371e:	c6 01       	movw	r24, r12
    3720:	78 df       	rcall	.-272    	; 0x3612 <move_window>
    3722:	88 23       	and	r24, r24
    3724:	09 f0       	breq	.+2      	; 0x3728 <get_fat+0xb4>
    3726:	65 c0       	rjmp	.+202    	; 0x37f2 <get_fat+0x17e>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    3728:	6b 2d       	mov	r22, r11
    372a:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    372c:	d1 70       	andi	r29, 0x01	; 1
    372e:	cc 0d       	add	r28, r12
    3730:	dd 1d       	adc	r29, r13
    3732:	9a a1       	ldd	r25, Y+34	; 0x22
    3734:	80 e0       	ldi	r24, 0x00	; 0
    3736:	68 2b       	or	r22, r24
    3738:	79 2b       	or	r23, r25
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    373a:	c7 01       	movw	r24, r14
    373c:	81 70       	andi	r24, 0x01	; 1
    373e:	90 70       	andi	r25, 0x00	; 0
    3740:	89 2b       	or	r24, r25
    3742:	39 f0       	breq	.+14     	; 0x3752 <get_fat+0xde>
    3744:	44 e0       	ldi	r20, 0x04	; 4
    3746:	76 95       	lsr	r23
    3748:	67 95       	ror	r22
    374a:	4a 95       	dec	r20
    374c:	e1 f7       	brne	.-8      	; 0x3746 <get_fat+0xd2>
    374e:	9b 01       	movw	r18, r22
    3750:	23 c0       	rjmp	.+70     	; 0x3798 <get_fat+0x124>
    3752:	9b 01       	movw	r18, r22
    3754:	40 e0       	ldi	r20, 0x00	; 0
    3756:	50 e0       	ldi	r21, 0x00	; 0
    3758:	3f 70       	andi	r19, 0x0F	; 15
    375a:	40 70       	andi	r20, 0x00	; 0
    375c:	50 70       	andi	r21, 0x00	; 0
    375e:	4d c0       	rjmp	.+154    	; 0x37fa <get_fat+0x186>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    3760:	45 2f       	mov	r20, r21
    3762:	56 2f       	mov	r21, r22
    3764:	67 2f       	mov	r22, r23
    3766:	77 27       	eor	r23, r23
    3768:	f6 01       	movw	r30, r12
    376a:	82 89       	ldd	r24, Z+18	; 0x12
    376c:	93 89       	ldd	r25, Z+19	; 0x13
    376e:	a4 89       	ldd	r26, Z+20	; 0x14
    3770:	b5 89       	ldd	r27, Z+21	; 0x15
    3772:	48 0f       	add	r20, r24
    3774:	59 1f       	adc	r21, r25
    3776:	6a 1f       	adc	r22, r26
    3778:	7b 1f       	adc	r23, r27
    377a:	c6 01       	movw	r24, r12
    377c:	4a df       	rcall	.-364    	; 0x3612 <move_window>
    377e:	88 23       	and	r24, r24
    3780:	c1 f5       	brne	.+112    	; 0x37f2 <get_fat+0x17e>
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);
    3782:	ee 0c       	add	r14, r14
    3784:	ff 1c       	adc	r15, r15
    3786:	00 1f       	adc	r16, r16
    3788:	11 1f       	adc	r17, r17
    378a:	f7 01       	movw	r30, r14
    378c:	f1 70       	andi	r31, 0x01	; 1
    378e:	ec 0d       	add	r30, r12
    3790:	fd 1d       	adc	r31, r13
    3792:	82 a1       	ldd	r24, Z+34	; 0x22
    3794:	93 a1       	ldd	r25, Z+35	; 0x23
    3796:	9c 01       	movw	r18, r24
    3798:	40 e0       	ldi	r20, 0x00	; 0
    379a:	50 e0       	ldi	r21, 0x00	; 0
    379c:	2e c0       	rjmp	.+92     	; 0x37fa <get_fat+0x186>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    379e:	97 e0       	ldi	r25, 0x07	; 7
    37a0:	76 95       	lsr	r23
    37a2:	67 95       	ror	r22
    37a4:	57 95       	ror	r21
    37a6:	47 95       	ror	r20
    37a8:	9a 95       	dec	r25
    37aa:	d1 f7       	brne	.-12     	; 0x37a0 <get_fat+0x12c>
    37ac:	f6 01       	movw	r30, r12
    37ae:	82 89       	ldd	r24, Z+18	; 0x12
    37b0:	93 89       	ldd	r25, Z+19	; 0x13
    37b2:	a4 89       	ldd	r26, Z+20	; 0x14
    37b4:	b5 89       	ldd	r27, Z+21	; 0x15
    37b6:	48 0f       	add	r20, r24
    37b8:	59 1f       	adc	r21, r25
    37ba:	6a 1f       	adc	r22, r26
    37bc:	7b 1f       	adc	r23, r27
    37be:	c6 01       	movw	r24, r12
    37c0:	28 df       	rcall	.-432    	; 0x3612 <move_window>
    37c2:	88 23       	and	r24, r24
    37c4:	b1 f4       	brne	.+44     	; 0x37f2 <get_fat+0x17e>
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
    37c6:	82 e0       	ldi	r24, 0x02	; 2
    37c8:	ee 0c       	add	r14, r14
    37ca:	ff 1c       	adc	r15, r15
    37cc:	00 1f       	adc	r16, r16
    37ce:	11 1f       	adc	r17, r17
    37d0:	8a 95       	dec	r24
    37d2:	d1 f7       	brne	.-12     	; 0x37c8 <get_fat+0x154>
    37d4:	f7 01       	movw	r30, r14
    37d6:	f1 70       	andi	r31, 0x01	; 1
    37d8:	ec 0d       	add	r30, r12
    37da:	fd 1d       	adc	r31, r13
    37dc:	22 a1       	ldd	r18, Z+34	; 0x22
    37de:	33 a1       	ldd	r19, Z+35	; 0x23
    37e0:	44 a1       	ldd	r20, Z+36	; 0x24
    37e2:	55 a1       	ldd	r21, Z+37	; 0x25
    37e4:	5f 70       	andi	r21, 0x0F	; 15
    37e6:	09 c0       	rjmp	.+18     	; 0x37fa <get_fat+0x186>
    37e8:	21 e0       	ldi	r18, 0x01	; 1
    37ea:	30 e0       	ldi	r19, 0x00	; 0
    37ec:	40 e0       	ldi	r20, 0x00	; 0
    37ee:	50 e0       	ldi	r21, 0x00	; 0
    37f0:	04 c0       	rjmp	.+8      	; 0x37fa <get_fat+0x186>
    37f2:	2f ef       	ldi	r18, 0xFF	; 255
    37f4:	3f ef       	ldi	r19, 0xFF	; 255
    37f6:	4f ef       	ldi	r20, 0xFF	; 255
    37f8:	5f ef       	ldi	r21, 0xFF	; 255
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
    37fa:	b9 01       	movw	r22, r18
    37fc:	ca 01       	movw	r24, r20
    37fe:	df 91       	pop	r29
    3800:	cf 91       	pop	r28
    3802:	1f 91       	pop	r17
    3804:	0f 91       	pop	r16
    3806:	ff 90       	pop	r15
    3808:	ef 90       	pop	r14
    380a:	df 90       	pop	r13
    380c:	cf 90       	pop	r12
    380e:	bf 90       	pop	r11
    3810:	08 95       	ret

00003812 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    3812:	2f 92       	push	r2
    3814:	3f 92       	push	r3
    3816:	4f 92       	push	r4
    3818:	5f 92       	push	r5
    381a:	6f 92       	push	r6
    381c:	7f 92       	push	r7
    381e:	8f 92       	push	r8
    3820:	9f 92       	push	r9
    3822:	af 92       	push	r10
    3824:	bf 92       	push	r11
    3826:	cf 92       	push	r12
    3828:	df 92       	push	r13
    382a:	ef 92       	push	r14
    382c:	ff 92       	push	r15
    382e:	0f 93       	push	r16
    3830:	1f 93       	push	r17
    3832:	df 93       	push	r29
    3834:	cf 93       	push	r28
    3836:	00 d0       	rcall	.+0      	; 0x3838 <f_lseek+0x26>
    3838:	0f 92       	push	r0
    383a:	cd b7       	in	r28, 0x3d	; 61
    383c:	de b7       	in	r29, 0x3e	; 62
    383e:	9b 83       	std	Y+3, r25	; 0x03
    3840:	8a 83       	std	Y+2, r24	; 0x02
    3842:	e4 2e       	mov	r14, r20
    3844:	95 2e       	mov	r9, r21
    3846:	86 2e       	mov	r8, r22
    3848:	77 2e       	mov	r7, r23
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    384a:	dc 01       	movw	r26, r24
    384c:	12 96       	adiw	r26, 0x02	; 2
    384e:	6d 91       	ld	r22, X+
    3850:	7c 91       	ld	r23, X
    3852:	13 97       	sbiw	r26, 0x03	; 3
    3854:	8d 91       	ld	r24, X+
    3856:	9c 91       	ld	r25, X
    3858:	b8 de       	rcall	.-656    	; 0x35ca <validate>
    385a:	89 83       	std	Y+1, r24	; 0x01
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    385c:	88 23       	and	r24, r24
    385e:	09 f0       	breq	.+2      	; 0x3862 <f_lseek+0x50>
    3860:	32 c1       	rjmp	.+612    	; 0x3ac6 <f_lseek+0x2b4>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    3862:	ea 81       	ldd	r30, Y+2	; 0x02
    3864:	fb 81       	ldd	r31, Y+3	; 0x03
    3866:	84 81       	ldd	r24, Z+4	; 0x04
    3868:	87 fd       	sbrc	r24, 7
    386a:	b5 c0       	rjmp	.+362    	; 0x39d6 <f_lseek+0x1c4>
    386c:	aa 81       	ldd	r26, Y+2	; 0x02
    386e:	bb 81       	ldd	r27, Y+3	; 0x03
    3870:	1a 96       	adiw	r26, 0x0a	; 10
    3872:	ad 90       	ld	r10, X+
    3874:	bd 90       	ld	r11, X+
    3876:	cd 90       	ld	r12, X+
    3878:	dc 90       	ld	r13, X
    387a:	1d 97       	sbiw	r26, 0x0d	; 13
    387c:	2e 2d       	mov	r18, r14
    387e:	39 2d       	mov	r19, r9
    3880:	48 2d       	mov	r20, r8
    3882:	57 2d       	mov	r21, r7
    3884:	c9 01       	movw	r24, r18
    3886:	da 01       	movw	r26, r20
    3888:	3c 01       	movw	r6, r24
    388a:	4d 01       	movw	r8, r26
    388c:	a6 14       	cp	r10, r6
    388e:	b7 04       	cpc	r11, r7
    3890:	c8 04       	cpc	r12, r8
    3892:	d9 04       	cpc	r13, r9
    3894:	10 f4       	brcc	.+4      	; 0x389a <f_lseek+0x88>
    3896:	35 01       	movw	r6, r10
    3898:	46 01       	movw	r8, r12
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    389a:	ea 81       	ldd	r30, Y+2	; 0x02
    389c:	fb 81       	ldd	r31, Y+3	; 0x03
    389e:	26 81       	ldd	r18, Z+6	; 0x06
    38a0:	37 81       	ldd	r19, Z+7	; 0x07
    38a2:	40 85       	ldd	r20, Z+8	; 0x08
    38a4:	51 85       	ldd	r21, Z+9	; 0x09
		fp->fptr = nsect = 0;
    38a6:	16 82       	std	Z+6, r1	; 0x06
    38a8:	17 82       	std	Z+7, r1	; 0x07
    38aa:	10 86       	std	Z+8, r1	; 0x08
    38ac:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    38ae:	61 14       	cp	r6, r1
    38b0:	71 04       	cpc	r7, r1
    38b2:	81 04       	cpc	r8, r1
    38b4:	91 04       	cpc	r9, r1
    38b6:	09 f4       	brne	.+2      	; 0x38ba <f_lseek+0xa8>
    38b8:	e8 c0       	rjmp	.+464    	; 0x3a8a <f_lseek+0x278>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    38ba:	01 90       	ld	r0, Z+
    38bc:	f0 81       	ld	r31, Z
    38be:	e0 2d       	mov	r30, r0
    38c0:	82 81       	ldd	r24, Z+2	; 0x02
    38c2:	a8 2e       	mov	r10, r24
    38c4:	bb 24       	eor	r11, r11
    38c6:	cc 24       	eor	r12, r12
    38c8:	dd 24       	eor	r13, r13
    38ca:	a9 e0       	ldi	r26, 0x09	; 9
    38cc:	aa 0c       	add	r10, r10
    38ce:	bb 1c       	adc	r11, r11
    38d0:	cc 1c       	adc	r12, r12
    38d2:	dd 1c       	adc	r13, r13
    38d4:	aa 95       	dec	r26
    38d6:	d1 f7       	brne	.-12     	; 0x38cc <f_lseek+0xba>
			if (ifptr > 0 &&
    38d8:	21 15       	cp	r18, r1
    38da:	31 05       	cpc	r19, r1
    38dc:	41 05       	cpc	r20, r1
    38de:	51 05       	cpc	r21, r1
    38e0:	c1 f1       	breq	.+112    	; 0x3952 <f_lseek+0x140>
    38e2:	19 01       	movw	r2, r18
    38e4:	2a 01       	movw	r4, r20
    38e6:	08 94       	sec
    38e8:	21 08       	sbc	r2, r1
    38ea:	31 08       	sbc	r3, r1
    38ec:	41 08       	sbc	r4, r1
    38ee:	51 08       	sbc	r5, r1
    38f0:	c4 01       	movw	r24, r8
    38f2:	b3 01       	movw	r22, r6
    38f4:	61 50       	subi	r22, 0x01	; 1
    38f6:	70 40       	sbci	r23, 0x00	; 0
    38f8:	80 40       	sbci	r24, 0x00	; 0
    38fa:	90 40       	sbci	r25, 0x00	; 0
    38fc:	a6 01       	movw	r20, r12
    38fe:	95 01       	movw	r18, r10
    3900:	0e 94 73 36 	call	0x6ce6	; 0x6ce6 <__udivmodsi4>
    3904:	79 01       	movw	r14, r18
    3906:	8a 01       	movw	r16, r20
    3908:	c2 01       	movw	r24, r4
    390a:	b1 01       	movw	r22, r2
    390c:	a6 01       	movw	r20, r12
    390e:	95 01       	movw	r18, r10
    3910:	0e 94 73 36 	call	0x6ce6	; 0x6ce6 <__udivmodsi4>
    3914:	e2 16       	cp	r14, r18
    3916:	f3 06       	cpc	r15, r19
    3918:	04 07       	cpc	r16, r20
    391a:	15 07       	cpc	r17, r21
    391c:	d0 f0       	brcs	.+52     	; 0x3952 <f_lseek+0x140>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    391e:	88 27       	eor	r24, r24
    3920:	99 27       	eor	r25, r25
    3922:	dc 01       	movw	r26, r24
    3924:	8a 19       	sub	r24, r10
    3926:	9b 09       	sbc	r25, r11
    3928:	ac 09       	sbc	r26, r12
    392a:	bd 09       	sbc	r27, r13
    392c:	82 21       	and	r24, r2
    392e:	93 21       	and	r25, r3
    3930:	a4 21       	and	r26, r4
    3932:	b5 21       	and	r27, r5
    3934:	ea 81       	ldd	r30, Y+2	; 0x02
    3936:	fb 81       	ldd	r31, Y+3	; 0x03
    3938:	86 83       	std	Z+6, r24	; 0x06
    393a:	97 83       	std	Z+7, r25	; 0x07
    393c:	a0 87       	std	Z+8, r26	; 0x08
    393e:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    3940:	68 1a       	sub	r6, r24
    3942:	79 0a       	sbc	r7, r25
    3944:	8a 0a       	sbc	r8, r26
    3946:	9b 0a       	sbc	r9, r27
				clst = fp->curr_clust;
    3948:	42 89       	ldd	r20, Z+18	; 0x12
    394a:	53 89       	ldd	r21, Z+19	; 0x13
    394c:	64 89       	ldd	r22, Z+20	; 0x14
    394e:	75 89       	ldd	r23, Z+21	; 0x15
    3950:	0d c0       	rjmp	.+26     	; 0x396c <f_lseek+0x15a>
			} else {									/* When seek to back cluster, */
				clst = fp->org_clust;					/* start from the first cluster */
    3952:	aa 81       	ldd	r26, Y+2	; 0x02
    3954:	bb 81       	ldd	r27, Y+3	; 0x03
    3956:	1e 96       	adiw	r26, 0x0e	; 14
    3958:	4d 91       	ld	r20, X+
    395a:	5d 91       	ld	r21, X+
    395c:	6d 91       	ld	r22, X+
    395e:	7c 91       	ld	r23, X
    3960:	51 97       	sbiw	r26, 0x11	; 17
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->org_clust = clst;
				}
#endif
				fp->curr_clust = clst;
    3962:	fd 01       	movw	r30, r26
    3964:	42 8b       	std	Z+18, r20	; 0x12
    3966:	53 8b       	std	Z+19, r21	; 0x13
    3968:	64 8b       	std	Z+20, r22	; 0x14
    396a:	75 8b       	std	Z+21, r23	; 0x15
			}
			if (clst != 0) {
    396c:	41 15       	cp	r20, r1
    396e:	51 05       	cpc	r21, r1
    3970:	61 05       	cpc	r22, r1
    3972:	71 05       	cpc	r23, r1
    3974:	09 f0       	breq	.+2      	; 0x3978 <f_lseek+0x166>
    3976:	4b c0       	rjmp	.+150    	; 0x3a0e <f_lseek+0x1fc>
    3978:	88 c0       	rjmp	.+272    	; 0x3a8a <f_lseek+0x278>
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    397a:	aa 81       	ldd	r26, Y+2	; 0x02
    397c:	bb 81       	ldd	r27, Y+3	; 0x03
    397e:	8d 91       	ld	r24, X+
    3980:	9c 91       	ld	r25, X
    3982:	78 de       	rcall	.-784    	; 0x3674 <get_fat>
    3984:	ab 01       	movw	r20, r22
    3986:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3988:	4f 3f       	cpi	r20, 0xFF	; 255
    398a:	bf ef       	ldi	r27, 0xFF	; 255
    398c:	5b 07       	cpc	r21, r27
    398e:	bf ef       	ldi	r27, 0xFF	; 255
    3990:	6b 07       	cpc	r22, r27
    3992:	bf ef       	ldi	r27, 0xFF	; 255
    3994:	7b 07       	cpc	r23, r27
    3996:	41 f4       	brne	.+16     	; 0x39a8 <f_lseek+0x196>
    3998:	ea 81       	ldd	r30, Y+2	; 0x02
    399a:	fb 81       	ldd	r31, Y+3	; 0x03
    399c:	84 81       	ldd	r24, Z+4	; 0x04
    399e:	80 68       	ori	r24, 0x80	; 128
    39a0:	84 83       	std	Z+4, r24	; 0x04
    39a2:	f1 e0       	ldi	r31, 0x01	; 1
    39a4:	f9 83       	std	Y+1, r31	; 0x01
    39a6:	8f c0       	rjmp	.+286    	; 0x3ac6 <f_lseek+0x2b4>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    39a8:	42 30       	cpi	r20, 0x02	; 2
    39aa:	51 05       	cpc	r21, r1
    39ac:	61 05       	cpc	r22, r1
    39ae:	71 05       	cpc	r23, r1
    39b0:	68 f0       	brcs	.+26     	; 0x39cc <f_lseek+0x1ba>
    39b2:	aa 81       	ldd	r26, Y+2	; 0x02
    39b4:	bb 81       	ldd	r27, Y+3	; 0x03
    39b6:	ed 91       	ld	r30, X+
    39b8:	fc 91       	ld	r31, X
    39ba:	82 85       	ldd	r24, Z+10	; 0x0a
    39bc:	93 85       	ldd	r25, Z+11	; 0x0b
    39be:	a4 85       	ldd	r26, Z+12	; 0x0c
    39c0:	b5 85       	ldd	r27, Z+13	; 0x0d
    39c2:	48 17       	cp	r20, r24
    39c4:	59 07       	cpc	r21, r25
    39c6:	6a 07       	cpc	r22, r26
    39c8:	7b 07       	cpc	r23, r27
    39ca:	38 f0       	brcs	.+14     	; 0x39da <f_lseek+0x1c8>
    39cc:	ea 81       	ldd	r30, Y+2	; 0x02
    39ce:	fb 81       	ldd	r31, Y+3	; 0x03
    39d0:	84 81       	ldd	r24, Z+4	; 0x04
    39d2:	80 68       	ori	r24, 0x80	; 128
    39d4:	84 83       	std	Z+4, r24	; 0x04
    39d6:	f2 e0       	ldi	r31, 0x02	; 2
    39d8:	e5 cf       	rjmp	.-54     	; 0x39a4 <f_lseek+0x192>
					fp->curr_clust = clst;
    39da:	aa 81       	ldd	r26, Y+2	; 0x02
    39dc:	bb 81       	ldd	r27, Y+3	; 0x03
    39de:	52 96       	adiw	r26, 0x12	; 18
    39e0:	4d 93       	st	X+, r20
    39e2:	5d 93       	st	X+, r21
    39e4:	6d 93       	st	X+, r22
    39e6:	7c 93       	st	X, r23
    39e8:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    39ea:	ea 81       	ldd	r30, Y+2	; 0x02
    39ec:	fb 81       	ldd	r31, Y+3	; 0x03
    39ee:	86 81       	ldd	r24, Z+6	; 0x06
    39f0:	97 81       	ldd	r25, Z+7	; 0x07
    39f2:	a0 85       	ldd	r26, Z+8	; 0x08
    39f4:	b1 85       	ldd	r27, Z+9	; 0x09
    39f6:	8a 0d       	add	r24, r10
    39f8:	9b 1d       	adc	r25, r11
    39fa:	ac 1d       	adc	r26, r12
    39fc:	bd 1d       	adc	r27, r13
    39fe:	86 83       	std	Z+6, r24	; 0x06
    3a00:	97 83       	std	Z+7, r25	; 0x07
    3a02:	a0 87       	std	Z+8, r26	; 0x08
    3a04:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    3a06:	6a 18       	sub	r6, r10
    3a08:	7b 08       	sbc	r7, r11
    3a0a:	8c 08       	sbc	r8, r12
    3a0c:	9d 08       	sbc	r9, r13
				}
#endif
				fp->curr_clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    3a0e:	a6 14       	cp	r10, r6
    3a10:	b7 04       	cpc	r11, r7
    3a12:	c8 04       	cpc	r12, r8
    3a14:	d9 04       	cpc	r13, r9
    3a16:	08 f4       	brcc	.+2      	; 0x3a1a <f_lseek+0x208>
    3a18:	b0 cf       	rjmp	.-160    	; 0x397a <f_lseek+0x168>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->curr_clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    3a1a:	ea 81       	ldd	r30, Y+2	; 0x02
    3a1c:	fb 81       	ldd	r31, Y+3	; 0x03
    3a1e:	86 81       	ldd	r24, Z+6	; 0x06
    3a20:	97 81       	ldd	r25, Z+7	; 0x07
    3a22:	a0 85       	ldd	r26, Z+8	; 0x08
    3a24:	b1 85       	ldd	r27, Z+9	; 0x09
    3a26:	86 0d       	add	r24, r6
    3a28:	97 1d       	adc	r25, r7
    3a2a:	a8 1d       	adc	r26, r8
    3a2c:	b9 1d       	adc	r27, r9
    3a2e:	86 83       	std	Z+6, r24	; 0x06
    3a30:	97 83       	std	Z+7, r25	; 0x07
    3a32:	a0 87       	std	Z+8, r26	; 0x08
    3a34:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    3a36:	d4 01       	movw	r26, r8
    3a38:	c3 01       	movw	r24, r6
    3a3a:	91 70       	andi	r25, 0x01	; 1
    3a3c:	a0 70       	andi	r26, 0x00	; 0
    3a3e:	b0 70       	andi	r27, 0x00	; 0
    3a40:	00 97       	sbiw	r24, 0x00	; 0
    3a42:	a1 05       	cpc	r26, r1
    3a44:	b1 05       	cpc	r27, r1
    3a46:	09 f1       	breq	.+66     	; 0x3a8a <f_lseek+0x278>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    3a48:	80 81       	ld	r24, Z
    3a4a:	91 81       	ldd	r25, Z+1	; 0x01
    3a4c:	6c dd       	rcall	.-1320   	; 0x3526 <clust2sect>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    3a4e:	61 15       	cp	r22, r1
    3a50:	71 05       	cpc	r23, r1
    3a52:	81 05       	cpc	r24, r1
    3a54:	91 05       	cpc	r25, r1
    3a56:	59 f4       	brne	.+22     	; 0x3a6e <f_lseek+0x25c>
    3a58:	aa 81       	ldd	r26, Y+2	; 0x02
    3a5a:	bb 81       	ldd	r27, Y+3	; 0x03
    3a5c:	14 96       	adiw	r26, 0x04	; 4
    3a5e:	8c 91       	ld	r24, X
    3a60:	14 97       	sbiw	r26, 0x04	; 4
    3a62:	80 68       	ori	r24, 0x80	; 128
    3a64:	14 96       	adiw	r26, 0x04	; 4
    3a66:	8c 93       	st	X, r24
    3a68:	b2 e0       	ldi	r27, 0x02	; 2
    3a6a:	b9 83       	std	Y+1, r27	; 0x01
    3a6c:	2c c0       	rjmp	.+88     	; 0x3ac6 <f_lseek+0x2b4>
					nsect += ofs / SS(fp->fs);
    3a6e:	a4 01       	movw	r20, r8
    3a70:	93 01       	movw	r18, r6
    3a72:	f9 e0       	ldi	r31, 0x09	; 9
    3a74:	56 95       	lsr	r21
    3a76:	47 95       	ror	r20
    3a78:	37 95       	ror	r19
    3a7a:	27 95       	ror	r18
    3a7c:	fa 95       	dec	r31
    3a7e:	d1 f7       	brne	.-12     	; 0x3a74 <f_lseek+0x262>
    3a80:	26 0f       	add	r18, r22
    3a82:	37 1f       	adc	r19, r23
    3a84:	48 1f       	adc	r20, r24
    3a86:	59 1f       	adc	r21, r25
    3a88:	04 c0       	rjmp	.+8      	; 0x3a92 <f_lseek+0x280>
    3a8a:	20 e0       	ldi	r18, 0x00	; 0
    3a8c:	30 e0       	ldi	r19, 0x00	; 0
    3a8e:	40 e0       	ldi	r20, 0x00	; 0
    3a90:	50 e0       	ldi	r21, 0x00	; 0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
    3a92:	ea 81       	ldd	r30, Y+2	; 0x02
    3a94:	fb 81       	ldd	r31, Y+3	; 0x03
    3a96:	86 81       	ldd	r24, Z+6	; 0x06
    3a98:	97 81       	ldd	r25, Z+7	; 0x07
    3a9a:	a0 85       	ldd	r26, Z+8	; 0x08
    3a9c:	b1 85       	ldd	r27, Z+9	; 0x09
    3a9e:	91 70       	andi	r25, 0x01	; 1
    3aa0:	a0 70       	andi	r26, 0x00	; 0
    3aa2:	b0 70       	andi	r27, 0x00	; 0
    3aa4:	00 97       	sbiw	r24, 0x00	; 0
    3aa6:	a1 05       	cpc	r26, r1
    3aa8:	b1 05       	cpc	r27, r1
    3aaa:	69 f0       	breq	.+26     	; 0x3ac6 <f_lseek+0x2b4>
    3aac:	86 89       	ldd	r24, Z+22	; 0x16
    3aae:	97 89       	ldd	r25, Z+23	; 0x17
    3ab0:	a0 8d       	ldd	r26, Z+24	; 0x18
    3ab2:	b1 8d       	ldd	r27, Z+25	; 0x19
    3ab4:	28 17       	cp	r18, r24
    3ab6:	39 07       	cpc	r19, r25
    3ab8:	4a 07       	cpc	r20, r26
    3aba:	5b 07       	cpc	r21, r27
    3abc:	21 f0       	breq	.+8      	; 0x3ac6 <f_lseek+0x2b4>
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    3abe:	26 8b       	std	Z+22, r18	; 0x16
    3ac0:	37 8b       	std	Z+23, r19	; 0x17
    3ac2:	40 8f       	std	Z+24, r20	; 0x18
    3ac4:	51 8f       	std	Z+25, r21	; 0x19
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    3ac6:	89 81       	ldd	r24, Y+1	; 0x01
    3ac8:	0f 90       	pop	r0
    3aca:	0f 90       	pop	r0
    3acc:	0f 90       	pop	r0
    3ace:	cf 91       	pop	r28
    3ad0:	df 91       	pop	r29
    3ad2:	1f 91       	pop	r17
    3ad4:	0f 91       	pop	r16
    3ad6:	ff 90       	pop	r15
    3ad8:	ef 90       	pop	r14
    3ada:	df 90       	pop	r13
    3adc:	cf 90       	pop	r12
    3ade:	bf 90       	pop	r11
    3ae0:	af 90       	pop	r10
    3ae2:	9f 90       	pop	r9
    3ae4:	8f 90       	pop	r8
    3ae6:	7f 90       	pop	r7
    3ae8:	6f 90       	pop	r6
    3aea:	5f 90       	pop	r5
    3aec:	4f 90       	pop	r4
    3aee:	3f 90       	pop	r3
    3af0:	2f 90       	pop	r2
    3af2:	08 95       	ret

00003af4 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
    3af4:	ef 92       	push	r14
    3af6:	ff 92       	push	r15
    3af8:	0f 93       	push	r16
    3afa:	1f 93       	push	r17
    3afc:	cf 93       	push	r28
    3afe:	df 93       	push	r29
    3b00:	8c 01       	movw	r16, r24
    3b02:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    3b04:	dc 01       	movw	r26, r24
    3b06:	15 96       	adiw	r26, 0x05	; 5
    3b08:	7c 93       	st	X, r23
    3b0a:	6e 93       	st	-X, r22
    3b0c:	14 97       	sbiw	r26, 0x04	; 4
	clst = dj->sclust;
    3b0e:	16 96       	adiw	r26, 0x06	; 6
    3b10:	4d 91       	ld	r20, X+
    3b12:	5d 91       	ld	r21, X+
    3b14:	6d 91       	ld	r22, X+
    3b16:	7c 91       	ld	r23, X
    3b18:	19 97       	sbiw	r26, 0x09	; 9
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3b1a:	41 30       	cpi	r20, 0x01	; 1
    3b1c:	51 05       	cpc	r21, r1
    3b1e:	61 05       	cpc	r22, r1
    3b20:	71 05       	cpc	r23, r1
    3b22:	09 f4       	brne	.+2      	; 0x3b26 <dir_sdi+0x32>
    3b24:	9e c0       	rjmp	.+316    	; 0x3c62 <dir_sdi+0x16e>
    3b26:	ed 91       	ld	r30, X+
    3b28:	fc 91       	ld	r31, X
    3b2a:	82 85       	ldd	r24, Z+10	; 0x0a
    3b2c:	93 85       	ldd	r25, Z+11	; 0x0b
    3b2e:	a4 85       	ldd	r26, Z+12	; 0x0c
    3b30:	b5 85       	ldd	r27, Z+13	; 0x0d
    3b32:	48 17       	cp	r20, r24
    3b34:	59 07       	cpc	r21, r25
    3b36:	6a 07       	cpc	r22, r26
    3b38:	7b 07       	cpc	r23, r27
    3b3a:	08 f0       	brcs	.+2      	; 0x3b3e <dir_sdi+0x4a>
    3b3c:	92 c0       	rjmp	.+292    	; 0x3c62 <dir_sdi+0x16e>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    3b3e:	41 15       	cp	r20, r1
    3b40:	51 05       	cpc	r21, r1
    3b42:	61 05       	cpc	r22, r1
    3b44:	71 05       	cpc	r23, r1
    3b46:	81 f5       	brne	.+96     	; 0x3ba8 <dir_sdi+0xb4>
    3b48:	80 81       	ld	r24, Z
    3b4a:	83 30       	cpi	r24, 0x03	; 3
    3b4c:	49 f4       	brne	.+18     	; 0x3b60 <dir_sdi+0x6c>
		clst = dj->fs->dirbase;
    3b4e:	46 89       	ldd	r20, Z+22	; 0x16
    3b50:	57 89       	ldd	r21, Z+23	; 0x17
    3b52:	60 8d       	ldd	r22, Z+24	; 0x18
    3b54:	71 8d       	ldd	r23, Z+25	; 0x19

	if (clst == 0) {	/* Static table */
    3b56:	41 15       	cp	r20, r1
    3b58:	51 05       	cpc	r21, r1
    3b5a:	61 05       	cpc	r22, r1
    3b5c:	71 05       	cpc	r23, r1
    3b5e:	21 f5       	brne	.+72     	; 0x3ba8 <dir_sdi+0xb4>
		dj->clust = clst;
    3b60:	f8 01       	movw	r30, r16
    3b62:	12 86       	std	Z+10, r1	; 0x0a
    3b64:	13 86       	std	Z+11, r1	; 0x0b
    3b66:	14 86       	std	Z+12, r1	; 0x0c
    3b68:	15 86       	std	Z+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    3b6a:	01 90       	ld	r0, Z+
    3b6c:	f0 81       	ld	r31, Z
    3b6e:	e0 2d       	mov	r30, r0
    3b70:	80 85       	ldd	r24, Z+8	; 0x08
    3b72:	91 85       	ldd	r25, Z+9	; 0x09
    3b74:	c8 17       	cp	r28, r24
    3b76:	d9 07       	cpc	r29, r25
    3b78:	08 f0       	brcs	.+2      	; 0x3b7c <dir_sdi+0x88>
    3b7a:	73 c0       	rjmp	.+230    	; 0x3c62 <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
    3b7c:	ce 01       	movw	r24, r28
    3b7e:	a4 e0       	ldi	r26, 0x04	; 4
    3b80:	96 95       	lsr	r25
    3b82:	87 95       	ror	r24
    3b84:	aa 95       	dec	r26
    3b86:	e1 f7       	brne	.-8      	; 0x3b80 <dir_sdi+0x8c>
    3b88:	a0 e0       	ldi	r26, 0x00	; 0
    3b8a:	b0 e0       	ldi	r27, 0x00	; 0
    3b8c:	26 89       	ldd	r18, Z+22	; 0x16
    3b8e:	37 89       	ldd	r19, Z+23	; 0x17
    3b90:	40 8d       	ldd	r20, Z+24	; 0x18
    3b92:	51 8d       	ldd	r21, Z+25	; 0x19
    3b94:	82 0f       	add	r24, r18
    3b96:	93 1f       	adc	r25, r19
    3b98:	a4 1f       	adc	r26, r20
    3b9a:	b5 1f       	adc	r27, r21
    3b9c:	f8 01       	movw	r30, r16
    3b9e:	86 87       	std	Z+14, r24	; 0x0e
    3ba0:	97 87       	std	Z+15, r25	; 0x0f
    3ba2:	a0 8b       	std	Z+16, r26	; 0x10
    3ba4:	b1 8b       	std	Z+17, r27	; 0x11
    3ba6:	49 c0       	rjmp	.+146    	; 0x3c3a <dir_sdi+0x146>
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
    3ba8:	82 81       	ldd	r24, Z+2	; 0x02
    3baa:	e8 2e       	mov	r14, r24
    3bac:	ff 24       	eor	r15, r15
    3bae:	e4 e0       	ldi	r30, 0x04	; 4
    3bb0:	ee 0c       	add	r14, r14
    3bb2:	ff 1c       	adc	r15, r15
    3bb4:	ea 95       	dec	r30
    3bb6:	e1 f7       	brne	.-8      	; 0x3bb0 <dir_sdi+0xbc>
    3bb8:	21 c0       	rjmp	.+66     	; 0x3bfc <dir_sdi+0x108>
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    3bba:	5c dd       	rcall	.-1352   	; 0x3674 <get_fat>
    3bbc:	ab 01       	movw	r20, r22
    3bbe:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3bc0:	4f 3f       	cpi	r20, 0xFF	; 255
    3bc2:	ff ef       	ldi	r31, 0xFF	; 255
    3bc4:	5f 07       	cpc	r21, r31
    3bc6:	ff ef       	ldi	r31, 0xFF	; 255
    3bc8:	6f 07       	cpc	r22, r31
    3bca:	ff ef       	ldi	r31, 0xFF	; 255
    3bcc:	7f 07       	cpc	r23, r31
    3bce:	11 f4       	brne	.+4      	; 0x3bd4 <dir_sdi+0xe0>
    3bd0:	81 e0       	ldi	r24, 0x01	; 1
    3bd2:	48 c0       	rjmp	.+144    	; 0x3c64 <dir_sdi+0x170>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    3bd4:	42 30       	cpi	r20, 0x02	; 2
    3bd6:	51 05       	cpc	r21, r1
    3bd8:	61 05       	cpc	r22, r1
    3bda:	71 05       	cpc	r23, r1
    3bdc:	08 f4       	brcc	.+2      	; 0x3be0 <dir_sdi+0xec>
    3bde:	41 c0       	rjmp	.+130    	; 0x3c62 <dir_sdi+0x16e>
    3be0:	d8 01       	movw	r26, r16
    3be2:	ed 91       	ld	r30, X+
    3be4:	fc 91       	ld	r31, X
    3be6:	82 85       	ldd	r24, Z+10	; 0x0a
    3be8:	93 85       	ldd	r25, Z+11	; 0x0b
    3bea:	a4 85       	ldd	r26, Z+12	; 0x0c
    3bec:	b5 85       	ldd	r27, Z+13	; 0x0d
    3bee:	48 17       	cp	r20, r24
    3bf0:	59 07       	cpc	r21, r25
    3bf2:	6a 07       	cpc	r22, r26
    3bf4:	7b 07       	cpc	r23, r27
    3bf6:	a8 f5       	brcc	.+106    	; 0x3c62 <dir_sdi+0x16e>
				return FR_INT_ERR;
			idx -= ic;
    3bf8:	ce 19       	sub	r28, r14
    3bfa:	df 09       	sbc	r29, r15
    3bfc:	f8 01       	movw	r30, r16
    3bfe:	80 81       	ld	r24, Z
    3c00:	91 81       	ldd	r25, Z+1	; 0x01
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    3c02:	ce 15       	cp	r28, r14
    3c04:	df 05       	cpc	r29, r15
    3c06:	c8 f6       	brcc	.-78     	; 0x3bba <dir_sdi+0xc6>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    3c08:	d8 01       	movw	r26, r16
    3c0a:	1a 96       	adiw	r26, 0x0a	; 10
    3c0c:	4d 93       	st	X+, r20
    3c0e:	5d 93       	st	X+, r21
    3c10:	6d 93       	st	X+, r22
    3c12:	7c 93       	st	X, r23
    3c14:	1d 97       	sbiw	r26, 0x0d	; 13
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
    3c16:	87 dc       	rcall	.-1778   	; 0x3526 <clust2sect>
    3c18:	9e 01       	movw	r18, r28
    3c1a:	44 e0       	ldi	r20, 0x04	; 4
    3c1c:	36 95       	lsr	r19
    3c1e:	27 95       	ror	r18
    3c20:	4a 95       	dec	r20
    3c22:	e1 f7       	brne	.-8      	; 0x3c1c <dir_sdi+0x128>
    3c24:	40 e0       	ldi	r20, 0x00	; 0
    3c26:	50 e0       	ldi	r21, 0x00	; 0
    3c28:	26 0f       	add	r18, r22
    3c2a:	37 1f       	adc	r19, r23
    3c2c:	48 1f       	adc	r20, r24
    3c2e:	59 1f       	adc	r21, r25
    3c30:	f8 01       	movw	r30, r16
    3c32:	26 87       	std	Z+14, r18	; 0x0e
    3c34:	37 87       	std	Z+15, r19	; 0x0f
    3c36:	40 8b       	std	Z+16, r20	; 0x10
    3c38:	51 8b       	std	Z+17, r21	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
    3c3a:	cf 70       	andi	r28, 0x0F	; 15
    3c3c:	d0 70       	andi	r29, 0x00	; 0
    3c3e:	b5 e0       	ldi	r27, 0x05	; 5
    3c40:	cc 0f       	add	r28, r28
    3c42:	dd 1f       	adc	r29, r29
    3c44:	ba 95       	dec	r27
    3c46:	e1 f7       	brne	.-8      	; 0x3c40 <dir_sdi+0x14c>
    3c48:	a2 96       	adiw	r28, 0x22	; 34
    3c4a:	d8 01       	movw	r26, r16
    3c4c:	8d 91       	ld	r24, X+
    3c4e:	9c 91       	ld	r25, X
    3c50:	11 97       	sbiw	r26, 0x01	; 1
    3c52:	8c 0f       	add	r24, r28
    3c54:	9d 1f       	adc	r25, r29
    3c56:	53 96       	adiw	r26, 0x13	; 19
    3c58:	9c 93       	st	X, r25
    3c5a:	8e 93       	st	-X, r24
    3c5c:	52 97       	sbiw	r26, 0x12	; 18
    3c5e:	80 e0       	ldi	r24, 0x00	; 0
    3c60:	01 c0       	rjmp	.+2      	; 0x3c64 <dir_sdi+0x170>

	return FR_OK;	/* Seek succeeded */
    3c62:	82 e0       	ldi	r24, 0x02	; 2
}
    3c64:	df 91       	pop	r29
    3c66:	cf 91       	pop	r28
    3c68:	1f 91       	pop	r17
    3c6a:	0f 91       	pop	r16
    3c6c:	ff 90       	pop	r15
    3c6e:	ef 90       	pop	r14
    3c70:	08 95       	ret

00003c72 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    3c72:	2f 92       	push	r2
    3c74:	3f 92       	push	r3
    3c76:	4f 92       	push	r4
    3c78:	5f 92       	push	r5
    3c7a:	6f 92       	push	r6
    3c7c:	7f 92       	push	r7
    3c7e:	8f 92       	push	r8
    3c80:	9f 92       	push	r9
    3c82:	af 92       	push	r10
    3c84:	bf 92       	push	r11
    3c86:	cf 92       	push	r12
    3c88:	df 92       	push	r13
    3c8a:	ef 92       	push	r14
    3c8c:	ff 92       	push	r15
    3c8e:	0f 93       	push	r16
    3c90:	1f 93       	push	r17
    3c92:	cf 93       	push	r28
    3c94:	df 93       	push	r29
    3c96:	ec 01       	movw	r28, r24
    3c98:	16 2f       	mov	r17, r22
    3c9a:	07 2f       	mov	r16, r23
    3c9c:	3a 01       	movw	r6, r20
    3c9e:	19 01       	movw	r2, r18
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
    3ca0:	f9 01       	movw	r30, r18
    3ca2:	11 82       	std	Z+1, r1	; 0x01
    3ca4:	10 82       	st	Z, r1

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
    3ca6:	6a 81       	ldd	r22, Y+2	; 0x02
    3ca8:	7b 81       	ldd	r23, Y+3	; 0x03
    3caa:	88 81       	ld	r24, Y
    3cac:	99 81       	ldd	r25, Y+1	; 0x01
    3cae:	8d dc       	rcall	.-1766   	; 0x35ca <validate>
    3cb0:	88 2e       	mov	r8, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3cb2:	88 23       	and	r24, r24
    3cb4:	09 f0       	breq	.+2      	; 0x3cb8 <f_read+0x46>
    3cb6:	07 c1       	rjmp	.+526    	; 0x3ec6 <f_read+0x254>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
    3cb8:	8c 81       	ldd	r24, Y+4	; 0x04
    3cba:	87 fd       	sbrc	r24, 7
    3cbc:	54 c0       	rjmp	.+168    	; 0x3d66 <f_read+0xf4>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
    3cbe:	80 fd       	sbrc	r24, 0
    3cc0:	03 c0       	rjmp	.+6      	; 0x3cc8 <f_read+0x56>
    3cc2:	77 e0       	ldi	r23, 0x07	; 7
    3cc4:	87 2e       	mov	r8, r23
    3cc6:	ff c0       	rjmp	.+510    	; 0x3ec6 <f_read+0x254>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    3cc8:	2a 85       	ldd	r18, Y+10	; 0x0a
    3cca:	3b 85       	ldd	r19, Y+11	; 0x0b
    3ccc:	4c 85       	ldd	r20, Y+12	; 0x0c
    3cce:	5d 85       	ldd	r21, Y+13	; 0x0d
    3cd0:	8e 81       	ldd	r24, Y+6	; 0x06
    3cd2:	9f 81       	ldd	r25, Y+7	; 0x07
    3cd4:	a8 85       	ldd	r26, Y+8	; 0x08
    3cd6:	b9 85       	ldd	r27, Y+9	; 0x09
    3cd8:	28 1b       	sub	r18, r24
    3cda:	39 0b       	sbc	r19, r25
    3cdc:	4a 0b       	sbc	r20, r26
    3cde:	5b 0b       	sbc	r21, r27
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
    3ce0:	c3 01       	movw	r24, r6
    3ce2:	a0 e0       	ldi	r26, 0x00	; 0
    3ce4:	b0 e0       	ldi	r27, 0x00	; 0
    3ce6:	28 17       	cp	r18, r24
    3ce8:	39 07       	cpc	r19, r25
    3cea:	4a 07       	cpc	r20, r26
    3cec:	5b 07       	cpc	r21, r27
    3cee:	08 f4       	brcc	.+2      	; 0x3cf2 <f_read+0x80>
    3cf0:	39 01       	movw	r6, r18
)
{
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
    3cf2:	81 2f       	mov	r24, r17
    3cf4:	90 2f       	mov	r25, r16
    3cf6:	9c 01       	movw	r18, r24
    3cf8:	29 01       	movw	r4, r18
    3cfa:	e1 c0       	rjmp	.+450    	; 0x3ebe <f_read+0x24c>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
    3cfc:	2e 81       	ldd	r18, Y+6	; 0x06
    3cfe:	3f 81       	ldd	r19, Y+7	; 0x07
    3d00:	48 85       	ldd	r20, Y+8	; 0x08
    3d02:	59 85       	ldd	r21, Y+9	; 0x09
    3d04:	da 01       	movw	r26, r20
    3d06:	c9 01       	movw	r24, r18
    3d08:	91 70       	andi	r25, 0x01	; 1
    3d0a:	a0 70       	andi	r26, 0x00	; 0
    3d0c:	b0 70       	andi	r27, 0x00	; 0
    3d0e:	00 97       	sbiw	r24, 0x00	; 0
    3d10:	a1 05       	cpc	r26, r1
    3d12:	b1 05       	cpc	r27, r1
    3d14:	09 f0       	breq	.+2      	; 0x3d18 <f_read+0xa6>
    3d16:	72 c0       	rjmp	.+228    	; 0x3dfc <f_read+0x18a>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3d18:	e8 81       	ld	r30, Y
    3d1a:	f9 81       	ldd	r31, Y+1	; 0x01
    3d1c:	da 01       	movw	r26, r20
    3d1e:	c9 01       	movw	r24, r18
    3d20:	69 e0       	ldi	r22, 0x09	; 9
    3d22:	b6 95       	lsr	r27
    3d24:	a7 95       	ror	r26
    3d26:	97 95       	ror	r25
    3d28:	87 95       	ror	r24
    3d2a:	6a 95       	dec	r22
    3d2c:	d1 f7       	brne	.-12     	; 0x3d22 <f_read+0xb0>
    3d2e:	92 80       	ldd	r9, Z+2	; 0x02
    3d30:	9a 94       	dec	r9
    3d32:	98 22       	and	r9, r24
			if (!csect) {							/* On the cluster boundary? */
    3d34:	41 f5       	brne	.+80     	; 0x3d86 <f_read+0x114>
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
    3d36:	21 15       	cp	r18, r1
    3d38:	31 05       	cpc	r19, r1
    3d3a:	41 05       	cpc	r20, r1
    3d3c:	51 05       	cpc	r21, r1
    3d3e:	29 f4       	brne	.+10     	; 0x3d4a <f_read+0xd8>
    3d40:	6e 85       	ldd	r22, Y+14	; 0x0e
    3d42:	7f 85       	ldd	r23, Y+15	; 0x0f
    3d44:	88 89       	ldd	r24, Y+16	; 0x10
    3d46:	99 89       	ldd	r25, Y+17	; 0x11
    3d48:	06 c0       	rjmp	.+12     	; 0x3d56 <f_read+0xe4>
    3d4a:	4a 89       	ldd	r20, Y+18	; 0x12
    3d4c:	5b 89       	ldd	r21, Y+19	; 0x13
    3d4e:	6c 89       	ldd	r22, Y+20	; 0x14
    3d50:	7d 89       	ldd	r23, Y+21	; 0x15
    3d52:	cf 01       	movw	r24, r30
    3d54:	8f dc       	rcall	.-1762   	; 0x3674 <get_fat>
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
    3d56:	62 30       	cpi	r22, 0x02	; 2
    3d58:	71 05       	cpc	r23, r1
    3d5a:	81 05       	cpc	r24, r1
    3d5c:	91 05       	cpc	r25, r1
    3d5e:	30 f4       	brcc	.+12     	; 0x3d6c <f_read+0xfa>
    3d60:	8c 81       	ldd	r24, Y+4	; 0x04
    3d62:	80 68       	ori	r24, 0x80	; 128
    3d64:	8c 83       	std	Y+4, r24	; 0x04
    3d66:	92 e0       	ldi	r25, 0x02	; 2
    3d68:	89 2e       	mov	r8, r25
    3d6a:	ad c0       	rjmp	.+346    	; 0x3ec6 <f_read+0x254>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3d6c:	6f 3f       	cpi	r22, 0xFF	; 255
    3d6e:	ff ef       	ldi	r31, 0xFF	; 255
    3d70:	7f 07       	cpc	r23, r31
    3d72:	ff ef       	ldi	r31, 0xFF	; 255
    3d74:	8f 07       	cpc	r24, r31
    3d76:	ff ef       	ldi	r31, 0xFF	; 255
    3d78:	9f 07       	cpc	r25, r31
    3d7a:	09 f4       	brne	.+2      	; 0x3d7e <f_read+0x10c>
    3d7c:	4c c0       	rjmp	.+152    	; 0x3e16 <f_read+0x1a4>
				fp->curr_clust = clst;				/* Update current cluster */
    3d7e:	6a 8b       	std	Y+18, r22	; 0x12
    3d80:	7b 8b       	std	Y+19, r23	; 0x13
    3d82:	8c 8b       	std	Y+20, r24	; 0x14
    3d84:	9d 8b       	std	Y+21, r25	; 0x15
			}
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
    3d86:	08 81       	ld	r16, Y
    3d88:	19 81       	ldd	r17, Y+1	; 0x01
    3d8a:	4a 89       	ldd	r20, Y+18	; 0x12
    3d8c:	5b 89       	ldd	r21, Y+19	; 0x13
    3d8e:	6c 89       	ldd	r22, Y+20	; 0x14
    3d90:	7d 89       	ldd	r23, Y+21	; 0x15
    3d92:	c8 01       	movw	r24, r16
    3d94:	c8 db       	rcall	.-2160   	; 0x3526 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3d96:	61 15       	cp	r22, r1
    3d98:	71 05       	cpc	r23, r1
    3d9a:	81 05       	cpc	r24, r1
    3d9c:	91 05       	cpc	r25, r1
    3d9e:	01 f3       	breq	.-64     	; 0x3d60 <f_read+0xee>
			sect += csect;
    3da0:	5b 01       	movw	r10, r22
    3da2:	6c 01       	movw	r12, r24
    3da4:	a9 0c       	add	r10, r9
    3da6:	b1 1c       	adc	r11, r1
    3da8:	c1 1c       	adc	r12, r1
    3daa:	d1 1c       	adc	r13, r1
			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
    3dac:	73 01       	movw	r14, r6
    3dae:	ef 2c       	mov	r14, r15
    3db0:	ff 24       	eor	r15, r15
    3db2:	e6 94       	lsr	r14
			if (cc) {								/* Read maximum contiguous sectors directly */
    3db4:	e1 14       	cp	r14, r1
    3db6:	f1 04       	cpc	r15, r1
    3db8:	e9 f0       	breq	.+58     	; 0x3df4 <f_read+0x182>
				if (csect + cc > fp->fs->csize)		/* Clip at cluster boundary */
    3dba:	f8 01       	movw	r30, r16
    3dbc:	22 81       	ldd	r18, Z+2	; 0x02
    3dbe:	e9 2d       	mov	r30, r9
    3dc0:	f0 e0       	ldi	r31, 0x00	; 0
    3dc2:	c7 01       	movw	r24, r14
    3dc4:	8e 0f       	add	r24, r30
    3dc6:	9f 1f       	adc	r25, r31
    3dc8:	62 2f       	mov	r22, r18
    3dca:	70 e0       	ldi	r23, 0x00	; 0
    3dcc:	68 17       	cp	r22, r24
    3dce:	79 07       	cpc	r23, r25
    3dd0:	18 f4       	brcc	.+6      	; 0x3dd8 <f_read+0x166>
					cc = fp->fs->csize - csect;
    3dd2:	7b 01       	movw	r14, r22
    3dd4:	ee 1a       	sub	r14, r30
    3dd6:	ff 0a       	sbc	r15, r31
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    3dd8:	f8 01       	movw	r30, r16
    3dda:	81 81       	ldd	r24, Z+1	; 0x01
    3ddc:	b2 01       	movw	r22, r4
    3dde:	a6 01       	movw	r20, r12
    3de0:	95 01       	movw	r18, r10
    3de2:	0e 2d       	mov	r16, r14
    3de4:	94 db       	rcall	.-2264   	; 0x350e <disk_read>
    3de6:	88 23       	and	r24, r24
    3de8:	b1 f4       	brne	.+44     	; 0x3e16 <f_read+0x1a4>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
    3dea:	b7 01       	movw	r22, r14
    3dec:	76 2f       	mov	r23, r22
    3dee:	66 27       	eor	r22, r22
    3df0:	77 0f       	add	r23, r23
    3df2:	4b c0       	rjmp	.+150    	; 0x3e8a <f_read+0x218>
			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    3df4:	ae 8a       	std	Y+22, r10	; 0x16
    3df6:	bf 8a       	std	Y+23, r11	; 0x17
    3df8:	c8 8e       	std	Y+24, r12	; 0x18
    3dfa:	d9 8e       	std	Y+25, r13	; 0x19
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3dfc:	ee 80       	ldd	r14, Y+6	; 0x06
    3dfe:	ff 80       	ldd	r15, Y+7	; 0x07
    3e00:	08 85       	ldd	r16, Y+8	; 0x08
    3e02:	19 85       	ldd	r17, Y+9	; 0x09
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
    3e04:	4e 89       	ldd	r20, Y+22	; 0x16
    3e06:	5f 89       	ldd	r21, Y+23	; 0x17
    3e08:	68 8d       	ldd	r22, Y+24	; 0x18
    3e0a:	79 8d       	ldd	r23, Y+25	; 0x19
    3e0c:	88 81       	ld	r24, Y
    3e0e:	99 81       	ldd	r25, Y+1	; 0x01
    3e10:	00 dc       	rcall	.-2048   	; 0x3612 <move_window>
    3e12:	88 23       	and	r24, r24
    3e14:	31 f0       	breq	.+12     	; 0x3e22 <f_read+0x1b0>
			ABORT(fp->fs, FR_DISK_ERR);
    3e16:	8c 81       	ldd	r24, Y+4	; 0x04
    3e18:	80 68       	ori	r24, 0x80	; 128
    3e1a:	8c 83       	std	Y+4, r24	; 0x04
    3e1c:	88 24       	eor	r8, r8
    3e1e:	83 94       	inc	r8
    3e20:	52 c0       	rjmp	.+164    	; 0x3ec6 <f_read+0x254>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3e22:	c7 01       	movw	r24, r14
    3e24:	91 70       	andi	r25, 0x01	; 1
    3e26:	20 e0       	ldi	r18, 0x00	; 0
    3e28:	32 e0       	ldi	r19, 0x02	; 2
    3e2a:	28 1b       	sub	r18, r24
    3e2c:	39 0b       	sbc	r19, r25
    3e2e:	b3 01       	movw	r22, r6
    3e30:	26 15       	cp	r18, r6
    3e32:	37 05       	cpc	r19, r7
    3e34:	08 f4       	brcc	.+2      	; 0x3e38 <f_read+0x1c6>
    3e36:	b9 01       	movw	r22, r18

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, int cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
    3e38:	8e 81       	ldd	r24, Y+6	; 0x06
    3e3a:	9f 81       	ldd	r25, Y+7	; 0x07
    3e3c:	91 70       	andi	r25, 0x01	; 1
    3e3e:	82 96       	adiw	r24, 0x22	; 34
    3e40:	48 81       	ld	r20, Y
    3e42:	59 81       	ldd	r21, Y+1	; 0x01
    3e44:	48 0f       	add	r20, r24
    3e46:	59 1f       	adc	r21, r25
    3e48:	da 01       	movw	r26, r20
    3e4a:	f2 01       	movw	r30, r4
    3e4c:	9b 01       	movw	r18, r22
    3e4e:	06 c0       	rjmp	.+12     	; 0x3e5c <f_read+0x1ea>

#if _WORD_ACCESS == 1
	while (cnt >= sizeof(int)) {
		*(int*)d = *(int*)s;
    3e50:	8d 91       	ld	r24, X+
    3e52:	9d 91       	ld	r25, X+
    3e54:	81 93       	st	Z+, r24
    3e56:	91 93       	st	Z+, r25
		d += sizeof(int); s += sizeof(int);
    3e58:	22 50       	subi	r18, 0x02	; 2
    3e5a:	30 40       	sbci	r19, 0x00	; 0
void mem_cpy (void* dst, const void* src, int cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof(int)) {
    3e5c:	22 30       	cpi	r18, 0x02	; 2
    3e5e:	31 05       	cpc	r19, r1
    3e60:	b8 f7       	brcc	.-18     	; 0x3e50 <f_read+0x1de>
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    3e62:	cb 01       	movw	r24, r22
    3e64:	8e 7f       	andi	r24, 0xFE	; 254
    3e66:	9b 01       	movw	r18, r22
    3e68:	28 1b       	sub	r18, r24
    3e6a:	39 0b       	sbc	r19, r25
    3e6c:	da 01       	movw	r26, r20
    3e6e:	a8 0f       	add	r26, r24
    3e70:	b9 1f       	adc	r27, r25
    3e72:	f2 01       	movw	r30, r4
    3e74:	e8 0f       	add	r30, r24
    3e76:	f9 1f       	adc	r31, r25
    3e78:	02 c0       	rjmp	.+4      	; 0x3e7e <f_read+0x20c>
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    3e7a:	8d 91       	ld	r24, X+
    3e7c:	81 93       	st	Z+, r24
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    3e7e:	21 50       	subi	r18, 0x01	; 1
    3e80:	30 40       	sbci	r19, 0x00	; 0
    3e82:	8f ef       	ldi	r24, 0xFF	; 255
    3e84:	2f 3f       	cpi	r18, 0xFF	; 255
    3e86:	38 07       	cpc	r19, r24
    3e88:	c1 f7       	brne	.-16     	; 0x3e7a <f_read+0x208>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3e8a:	46 0e       	add	r4, r22
    3e8c:	57 1e       	adc	r5, r23
    3e8e:	cb 01       	movw	r24, r22
    3e90:	a0 e0       	ldi	r26, 0x00	; 0
    3e92:	b0 e0       	ldi	r27, 0x00	; 0
    3e94:	2e 81       	ldd	r18, Y+6	; 0x06
    3e96:	3f 81       	ldd	r19, Y+7	; 0x07
    3e98:	48 85       	ldd	r20, Y+8	; 0x08
    3e9a:	59 85       	ldd	r21, Y+9	; 0x09
    3e9c:	28 0f       	add	r18, r24
    3e9e:	39 1f       	adc	r19, r25
    3ea0:	4a 1f       	adc	r20, r26
    3ea2:	5b 1f       	adc	r21, r27
    3ea4:	2e 83       	std	Y+6, r18	; 0x06
    3ea6:	3f 83       	std	Y+7, r19	; 0x07
    3ea8:	48 87       	std	Y+8, r20	; 0x08
    3eaa:	59 87       	std	Y+9, r21	; 0x09
    3eac:	f1 01       	movw	r30, r2
    3eae:	80 81       	ld	r24, Z
    3eb0:	91 81       	ldd	r25, Z+1	; 0x01
    3eb2:	86 0f       	add	r24, r22
    3eb4:	97 1f       	adc	r25, r23
    3eb6:	91 83       	std	Z+1, r25	; 0x01
    3eb8:	80 83       	st	Z, r24
    3eba:	66 1a       	sub	r6, r22
    3ebc:	77 0a       	sbc	r7, r23
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
    3ebe:	61 14       	cp	r6, r1
    3ec0:	71 04       	cpc	r7, r1
    3ec2:	09 f0       	breq	.+2      	; 0x3ec6 <f_read+0x254>
    3ec4:	1b cf       	rjmp	.-458    	; 0x3cfc <f_read+0x8a>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3ec6:	88 2d       	mov	r24, r8
    3ec8:	df 91       	pop	r29
    3eca:	cf 91       	pop	r28
    3ecc:	1f 91       	pop	r17
    3ece:	0f 91       	pop	r16
    3ed0:	ff 90       	pop	r15
    3ed2:	ef 90       	pop	r14
    3ed4:	df 90       	pop	r13
    3ed6:	cf 90       	pop	r12
    3ed8:	bf 90       	pop	r11
    3eda:	af 90       	pop	r10
    3edc:	9f 90       	pop	r9
    3ede:	8f 90       	pop	r8
    3ee0:	7f 90       	pop	r7
    3ee2:	6f 90       	pop	r6
    3ee4:	5f 90       	pop	r5
    3ee6:	4f 90       	pop	r4
    3ee8:	3f 90       	pop	r3
    3eea:	2f 90       	pop	r2
    3eec:	08 95       	ret

00003eee <check_fs>:
static
BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    3eee:	0f 93       	push	r16
    3ef0:	cf 93       	push	r28
    3ef2:	df 93       	push	r29
    3ef4:	ec 01       	movw	r28, r24
    3ef6:	9a 01       	movw	r18, r20
    3ef8:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    3efa:	bc 01       	movw	r22, r24
    3efc:	6e 5d       	subi	r22, 0xDE	; 222
    3efe:	7f 4f       	sbci	r23, 0xFF	; 255
    3f00:	89 81       	ldd	r24, Y+1	; 0x01
    3f02:	01 e0       	ldi	r16, 0x01	; 1
    3f04:	04 db       	rcall	.-2552   	; 0x350e <disk_read>
    3f06:	88 23       	and	r24, r24
    3f08:	11 f0       	breq	.+4      	; 0x3f0e <check_fs+0x20>
    3f0a:	23 e0       	ldi	r18, 0x03	; 3
    3f0c:	29 c0       	rjmp	.+82     	; 0x3f60 <check_fs+0x72>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    3f0e:	c0 5e       	subi	r28, 0xE0	; 224
    3f10:	dd 4f       	sbci	r29, 0xFD	; 253
    3f12:	88 81       	ld	r24, Y
    3f14:	99 81       	ldd	r25, Y+1	; 0x01
    3f16:	c0 52       	subi	r28, 0x20	; 32
    3f18:	d2 40       	sbci	r29, 0x02	; 2
    3f1a:	85 55       	subi	r24, 0x55	; 85
    3f1c:	9a 4a       	sbci	r25, 0xAA	; 170
    3f1e:	11 f0       	breq	.+4      	; 0x3f24 <check_fs+0x36>
    3f20:	22 e0       	ldi	r18, 0x02	; 2
    3f22:	1e c0       	rjmp	.+60     	; 0x3f60 <check_fs+0x72>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    3f24:	c8 5a       	subi	r28, 0xA8	; 168
    3f26:	df 4f       	sbci	r29, 0xFF	; 255
    3f28:	88 81       	ld	r24, Y
    3f2a:	99 81       	ldd	r25, Y+1	; 0x01
    3f2c:	aa 81       	ldd	r26, Y+2	; 0x02
    3f2e:	bb 81       	ldd	r27, Y+3	; 0x03
    3f30:	c8 55       	subi	r28, 0x58	; 88
    3f32:	d0 40       	sbci	r29, 0x00	; 0
    3f34:	b0 70       	andi	r27, 0x00	; 0
    3f36:	86 54       	subi	r24, 0x46	; 70
    3f38:	91 44       	sbci	r25, 0x41	; 65
    3f3a:	a4 45       	sbci	r26, 0x54	; 84
    3f3c:	b0 40       	sbci	r27, 0x00	; 0
    3f3e:	11 f4       	brne	.+4      	; 0x3f44 <check_fs+0x56>
    3f40:	20 e0       	ldi	r18, 0x00	; 0
    3f42:	0e c0       	rjmp	.+28     	; 0x3f60 <check_fs+0x72>
    3f44:	20 e0       	ldi	r18, 0x00	; 0
    3f46:	cc 58       	subi	r28, 0x8C	; 140
    3f48:	df 4f       	sbci	r29, 0xFF	; 255
    3f4a:	88 81       	ld	r24, Y
    3f4c:	99 81       	ldd	r25, Y+1	; 0x01
    3f4e:	aa 81       	ldd	r26, Y+2	; 0x02
    3f50:	bb 81       	ldd	r27, Y+3	; 0x03
    3f52:	b0 70       	andi	r27, 0x00	; 0
    3f54:	86 54       	subi	r24, 0x46	; 70
    3f56:	91 44       	sbci	r25, 0x41	; 65
    3f58:	a4 45       	sbci	r26, 0x54	; 84
    3f5a:	b0 40       	sbci	r27, 0x00	; 0
    3f5c:	09 f0       	breq	.+2      	; 0x3f60 <check_fs+0x72>
    3f5e:	21 e0       	ldi	r18, 0x01	; 1
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    3f60:	82 2f       	mov	r24, r18
    3f62:	df 91       	pop	r29
    3f64:	cf 91       	pop	r28
    3f66:	0f 91       	pop	r16
    3f68:	08 95       	ret

00003f6a <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3f6a:	2f 92       	push	r2
    3f6c:	3f 92       	push	r3
    3f6e:	4f 92       	push	r4
    3f70:	5f 92       	push	r5
    3f72:	6f 92       	push	r6
    3f74:	7f 92       	push	r7
    3f76:	8f 92       	push	r8
    3f78:	9f 92       	push	r9
    3f7a:	af 92       	push	r10
    3f7c:	bf 92       	push	r11
    3f7e:	cf 92       	push	r12
    3f80:	df 92       	push	r13
    3f82:	ef 92       	push	r14
    3f84:	ff 92       	push	r15
    3f86:	0f 93       	push	r16
    3f88:	1f 93       	push	r17
    3f8a:	df 93       	push	r29
    3f8c:	cf 93       	push	r28
    3f8e:	cd b7       	in	r28, 0x3d	; 61
    3f90:	de b7       	in	r29, 0x3e	; 62
    3f92:	af 97       	sbiw	r28, 0x2f	; 47
    3f94:	0f b6       	in	r0, 0x3f	; 63
    3f96:	f8 94       	cli
    3f98:	de bf       	out	0x3e, r29	; 62
    3f9a:	0f be       	out	0x3f, r0	; 63
    3f9c:	cd bf       	out	0x3d, r28	; 61
    3f9e:	9c a7       	std	Y+44, r25	; 0x2c
    3fa0:	8b a7       	std	Y+43, r24	; 0x2b
    3fa2:	7e a7       	std	Y+46, r23	; 0x2e
    3fa4:	6d a7       	std	Y+45, r22	; 0x2d
    3fa6:	4f a7       	std	Y+47, r20	; 0x2f
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
    3fa8:	dc 01       	movw	r26, r24
    3faa:	1d 92       	st	X+, r1
    3fac:	1c 92       	st	X, r1
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';				/* Is there a drive number? */
    3fae:	ed a5       	ldd	r30, Y+45	; 0x2d
    3fb0:	fe a5       	ldd	r31, Y+46	; 0x2e
    3fb2:	80 81       	ld	r24, Z
    3fb4:	28 2f       	mov	r18, r24
    3fb6:	30 e0       	ldi	r19, 0x00	; 0
    3fb8:	20 53       	subi	r18, 0x30	; 48
    3fba:	30 40       	sbci	r19, 0x00	; 0
	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
    3fbc:	2a 30       	cpi	r18, 0x0A	; 10
    3fbe:	31 05       	cpc	r19, r1
    3fc0:	50 f4       	brcc	.+20     	; 0x3fd6 <f_open+0x6c>
    3fc2:	81 81       	ldd	r24, Z+1	; 0x01
    3fc4:	8a 33       	cpi	r24, 0x3A	; 58
    3fc6:	39 f4       	brne	.+14     	; 0x3fd6 <f_open+0x6c>
		p += 2; *path = p;			/* Return pointer to the path name */
    3fc8:	32 96       	adiw	r30, 0x02	; 2
    3fca:	fe a7       	std	Y+46, r31	; 0x2e
    3fcc:	ed a7       	std	Y+45, r30	; 0x2d
		vol = 0;					/* Use drive 0 */
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _DRIVES) 			/* Is the drive number valid? */
    3fce:	23 2b       	or	r18, r19
    3fd0:	11 f0       	breq	.+4      	; 0x3fd6 <f_open+0x6c>
    3fd2:	6b e0       	ldi	r22, 0x0B	; 11
    3fd4:	bd c1       	rjmp	.+890    	; 0x4350 <f_open+0x3e6>
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];			/* Return pointer to the corresponding file system object */
    3fd6:	80 90 12 03 	lds	r8, 0x0312
    3fda:	90 90 13 03 	lds	r9, 0x0313
    3fde:	9e 86       	std	Y+14, r9	; 0x0e
    3fe0:	8d 86       	std	Y+13, r8	; 0x0d
	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */
    3fe2:	81 14       	cp	r8, r1
    3fe4:	91 04       	cpc	r9, r1
    3fe6:	11 f4       	brne	.+4      	; 0x3fec <f_open+0x82>
    3fe8:	6c e0       	ldi	r22, 0x0C	; 12
    3fea:	b2 c1       	rjmp	.+868    	; 0x4350 <f_open+0x3e6>

	ENTER_FF(fs);					/* Lock file system */

	if (fs->fs_type) {				/* If the logical drive has been mounted */
    3fec:	d4 01       	movw	r26, r8
    3fee:	8c 91       	ld	r24, X
    3ff0:	88 23       	and	r24, r24
    3ff2:	29 f0       	breq	.+10     	; 0x3ffe <f_open+0x94>
		stat = disk_status(fs->drv);
    3ff4:	11 96       	adiw	r26, 0x01	; 1
    3ff6:	8c 91       	ld	r24, X
    3ff8:	88 da       	rcall	.-2800   	; 0x350a <disk_status>
		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
    3ffa:	80 ff       	sbrs	r24, 0
    3ffc:	a6 c1       	rjmp	.+844    	; 0x434a <f_open+0x3e0>
		}
	}

	/* The logical drive must be mounted. Following code attempts to mount the volume (initialize the file system object) */

	fs->fs_type = 0;					/* Clear the file system object */
    3ffe:	f4 01       	movw	r30, r8
    4000:	10 82       	st	Z, r1
	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
    4002:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    4004:	80 e0       	ldi	r24, 0x00	; 0
    4006:	7f da       	rcall	.-2818   	; 0x3506 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the drive is ready */
    4008:	80 ff       	sbrs	r24, 0
    400a:	02 c0       	rjmp	.+4      	; 0x4010 <f_open+0xa6>
    400c:	63 e0       	ldi	r22, 0x03	; 3
    400e:	a0 c1       	rjmp	.+832    	; 0x4350 <f_open+0x3e6>
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive (Supports only generic partitions, FDISK and SFD) */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
    4010:	c4 01       	movw	r24, r8
    4012:	40 e0       	ldi	r20, 0x00	; 0
    4014:	50 e0       	ldi	r21, 0x00	; 0
    4016:	60 e0       	ldi	r22, 0x00	; 0
    4018:	70 e0       	ldi	r23, 0x00	; 0
    401a:	69 df       	rcall	.-302    	; 0x3eee <check_fs>
	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
    401c:	81 30       	cpi	r24, 0x01	; 1
    401e:	29 f0       	breq	.+10     	; 0x402a <f_open+0xc0>
    4020:	1f a2       	std	Y+39, r1	; 0x27
    4022:	18 a6       	std	Y+40, r1	; 0x28
    4024:	19 a6       	std	Y+41, r1	; 0x29
    4026:	1a a6       	std	Y+42, r1	; 0x2a
    4028:	15 c0       	rjmp	.+42     	; 0x4054 <f_open+0xea>
		/* Check the partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
    402a:	f4 01       	movw	r30, r8
    402c:	e0 52       	subi	r30, 0x20	; 32
    402e:	fe 4f       	sbci	r31, 0xFE	; 254
		if (tbl[4]) {									/* Is the partition existing? */
    4030:	84 81       	ldd	r24, Z+4	; 0x04
    4032:	88 23       	and	r24, r24
    4034:	09 f4       	brne	.+2      	; 0x4038 <f_open+0xce>
    4036:	8b c1       	rjmp	.+790    	; 0x434e <f_open+0x3e4>
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
    4038:	80 85       	ldd	r24, Z+8	; 0x08
    403a:	91 85       	ldd	r25, Z+9	; 0x09
    403c:	a2 85       	ldd	r26, Z+10	; 0x0a
    403e:	b3 85       	ldd	r27, Z+11	; 0x0b
    4040:	8f a3       	std	Y+39, r24	; 0x27
    4042:	98 a7       	std	Y+40, r25	; 0x28
    4044:	a9 a7       	std	Y+41, r26	; 0x29
    4046:	ba a7       	std	Y+42, r27	; 0x2a
			fmt = check_fs(fs, bsect);					/* Check the partition */
    4048:	c4 01       	movw	r24, r8
    404a:	4f a1       	ldd	r20, Y+39	; 0x27
    404c:	58 a5       	ldd	r21, Y+40	; 0x28
    404e:	69 a5       	ldd	r22, Y+41	; 0x29
    4050:	7a a5       	ldd	r23, Y+42	; 0x2a
    4052:	4d df       	rcall	.-358    	; 0x3eee <check_fs>
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    4054:	83 30       	cpi	r24, 0x03	; 3
    4056:	11 f4       	brne	.+4      	; 0x405c <f_open+0xf2>
    4058:	61 e0       	ldi	r22, 0x01	; 1
    405a:	7a c1       	rjmp	.+756    	; 0x4350 <f_open+0x3e6>
	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
    405c:	88 23       	and	r24, r24
    405e:	09 f0       	breq	.+2      	; 0x4062 <f_open+0xf8>
    4060:	76 c1       	rjmp	.+748    	; 0x434e <f_open+0x3e4>

	/* Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    4062:	d4 01       	movw	r26, r8
    4064:	9d 96       	adiw	r26, 0x2d	; 45
    4066:	8d 91       	ld	r24, X+
    4068:	9c 91       	ld	r25, X
    406a:	9e 97       	sbiw	r26, 0x2e	; 46
    406c:	80 50       	subi	r24, 0x00	; 0
    406e:	92 40       	sbci	r25, 0x02	; 2
    4070:	09 f0       	breq	.+2      	; 0x4074 <f_open+0x10a>
    4072:	6d c1       	rjmp	.+730    	; 0x434e <f_open+0x3e4>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    4074:	f4 01       	movw	r30, r8
    4076:	80 ad       	ldd	r24, Z+56	; 0x38
    4078:	91 ad       	ldd	r25, Z+57	; 0x39
    407a:	5c 01       	movw	r10, r24
    407c:	cc 24       	eor	r12, r12
    407e:	dd 24       	eor	r13, r13
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    4080:	a1 14       	cp	r10, r1
    4082:	b1 04       	cpc	r11, r1
    4084:	c1 04       	cpc	r12, r1
    4086:	d1 04       	cpc	r13, r1
    4088:	69 f4       	brne	.+26     	; 0x40a4 <f_open+0x13a>
    408a:	86 e4       	ldi	r24, 0x46	; 70
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	88 0e       	add	r8, r24
    4090:	99 1e       	adc	r9, r25
    4092:	d4 01       	movw	r26, r8
    4094:	ad 90       	ld	r10, X+
    4096:	bd 90       	ld	r11, X+
    4098:	cd 90       	ld	r12, X+
    409a:	dc 90       	ld	r13, X
    409c:	ea eb       	ldi	r30, 0xBA	; 186
    409e:	ff ef       	ldi	r31, 0xFF	; 255
    40a0:	8e 0e       	add	r8, r30
    40a2:	9f 1e       	adc	r9, r31
	fs->fsize = fasize;
    40a4:	d4 01       	movw	r26, r8
    40a6:	1e 96       	adiw	r26, 0x0e	; 14
    40a8:	ad 92       	st	X+, r10
    40aa:	bd 92       	st	X+, r11
    40ac:	cd 92       	st	X+, r12
    40ae:	dc 92       	st	X, r13
    40b0:	51 97       	sbiw	r26, 0x11	; 17

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    40b2:	d2 96       	adiw	r26, 0x32	; 50
    40b4:	4c 91       	ld	r20, X
    40b6:	d2 97       	sbiw	r26, 0x32	; 50
    40b8:	13 96       	adiw	r26, 0x03	; 3
    40ba:	4c 93       	st	X, r20
    40bc:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    40be:	84 2f       	mov	r24, r20
    40c0:	81 50       	subi	r24, 0x01	; 1
    40c2:	82 30       	cpi	r24, 0x02	; 2
    40c4:	08 f0       	brcs	.+2      	; 0x40c8 <f_open+0x15e>
    40c6:	43 c1       	rjmp	.+646    	; 0x434e <f_open+0x3e4>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    40c8:	9f 96       	adiw	r26, 0x2f	; 47
    40ca:	2c 91       	ld	r18, X
    40cc:	9f 97       	sbiw	r26, 0x2f	; 47
    40ce:	12 96       	adiw	r26, 0x02	; 2
    40d0:	2c 93       	st	X, r18
    40d2:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be 1,2,4...128) */
    40d4:	22 23       	and	r18, r18
    40d6:	09 f4       	brne	.+2      	; 0x40da <f_open+0x170>
    40d8:	3a c1       	rjmp	.+628    	; 0x434e <f_open+0x3e4>
    40da:	30 e0       	ldi	r19, 0x00	; 0
    40dc:	c9 01       	movw	r24, r18
    40de:	01 97       	sbiw	r24, 0x01	; 1
    40e0:	82 23       	and	r24, r18
    40e2:	93 23       	and	r25, r19
    40e4:	89 2b       	or	r24, r25
    40e6:	09 f0       	breq	.+2      	; 0x40ea <f_open+0x180>
    40e8:	32 c1       	rjmp	.+612    	; 0x434e <f_open+0x3e4>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    40ea:	d3 96       	adiw	r26, 0x33	; 51
    40ec:	6d 90       	ld	r6, X+
    40ee:	7c 90       	ld	r7, X
    40f0:	d4 97       	sbiw	r26, 0x34	; 52
    40f2:	19 96       	adiw	r26, 0x09	; 9
    40f4:	7c 92       	st	X, r7
    40f6:	6e 92       	st	-X, r6
    40f8:	18 97       	sbiw	r26, 0x08	; 8
	if (fs->n_rootdir % (SS(fs) / 32)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    40fa:	c3 01       	movw	r24, r6
    40fc:	8f 70       	andi	r24, 0x0F	; 15
    40fe:	90 70       	andi	r25, 0x00	; 0
    4100:	89 2b       	or	r24, r25
    4102:	09 f0       	breq	.+2      	; 0x4106 <f_open+0x19c>
    4104:	24 c1       	rjmp	.+584    	; 0x434e <f_open+0x3e4>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    4106:	d5 96       	adiw	r26, 0x35	; 53
    4108:	8d 91       	ld	r24, X+
    410a:	9c 91       	ld	r25, X
    410c:	d6 97       	sbiw	r26, 0x36	; 54
    410e:	7c 01       	movw	r14, r24
    4110:	00 e0       	ldi	r16, 0x00	; 0
    4112:	10 e0       	ldi	r17, 0x00	; 0
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    4114:	e1 14       	cp	r14, r1
    4116:	f1 04       	cpc	r15, r1
    4118:	01 05       	cpc	r16, r1
    411a:	11 05       	cpc	r17, r1
    411c:	69 f4       	brne	.+26     	; 0x4138 <f_open+0x1ce>
    411e:	e2 e4       	ldi	r30, 0x42	; 66
    4120:	f0 e0       	ldi	r31, 0x00	; 0
    4122:	8e 0e       	add	r8, r30
    4124:	9f 1e       	adc	r9, r31
    4126:	d4 01       	movw	r26, r8
    4128:	ed 90       	ld	r14, X+
    412a:	fd 90       	ld	r15, X+
    412c:	0d 91       	ld	r16, X+
    412e:	1c 91       	ld	r17, X
    4130:	ee eb       	ldi	r30, 0xBE	; 190
    4132:	ff ef       	ldi	r31, 0xFF	; 255
    4134:	8e 0e       	add	r8, r30
    4136:	9f 1e       	adc	r9, r31

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    4138:	d4 01       	movw	r26, r8
    413a:	d0 96       	adiw	r26, 0x30	; 48
    413c:	4d 90       	ld	r4, X+
    413e:	5c 90       	ld	r5, X
    4140:	d1 97       	sbiw	r26, 0x31	; 49
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    4142:	41 14       	cp	r4, r1
    4144:	51 04       	cpc	r5, r1
    4146:	09 f4       	brne	.+2      	; 0x414a <f_open+0x1e0>
    4148:	02 c1       	rjmp	.+516    	; 0x434e <f_open+0x3e4>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    414a:	24 2f       	mov	r18, r20
    414c:	30 e0       	ldi	r19, 0x00	; 0
    414e:	40 e0       	ldi	r20, 0x00	; 0
    4150:	50 e0       	ldi	r21, 0x00	; 0
    4152:	c6 01       	movw	r24, r12
    4154:	b5 01       	movw	r22, r10
    4156:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__mulsi3>
    415a:	6b a3       	std	Y+35, r22	; 0x23
    415c:	7c a3       	std	Y+36, r23	; 0x24
    415e:	8d a3       	std	Y+37, r24	; 0x25
    4160:	9e a3       	std	Y+38, r25	; 0x26

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / 32);	/* RSV+FAT+DIR */
    4162:	12 01       	movw	r2, r4
    4164:	44 24       	eor	r4, r4
    4166:	55 24       	eor	r5, r5
    4168:	e4 e0       	ldi	r30, 0x04	; 4
    416a:	76 94       	lsr	r7
    416c:	67 94       	ror	r6
    416e:	ea 95       	dec	r30
    4170:	e1 f7       	brne	.-8      	; 0x416a <f_open+0x200>
    4172:	53 01       	movw	r10, r6
    4174:	cc 24       	eor	r12, r12
    4176:	dd 24       	eor	r13, r13
    4178:	a2 0c       	add	r10, r2
    417a:	b3 1c       	adc	r11, r3
    417c:	c4 1c       	adc	r12, r4
    417e:	d5 1c       	adc	r13, r5
    4180:	a6 0e       	add	r10, r22
    4182:	b7 1e       	adc	r11, r23
    4184:	c8 1e       	adc	r12, r24
    4186:	d9 1e       	adc	r13, r25
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    4188:	ea 14       	cp	r14, r10
    418a:	fb 04       	cpc	r15, r11
    418c:	0c 05       	cpc	r16, r12
    418e:	1d 05       	cpc	r17, r13
    4190:	08 f4       	brcc	.+2      	; 0x4194 <f_open+0x22a>
    4192:	dd c0       	rjmp	.+442    	; 0x434e <f_open+0x3e4>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    4194:	ea 18       	sub	r14, r10
    4196:	fb 08       	sbc	r15, r11
    4198:	0c 09       	sbc	r16, r12
    419a:	1d 09       	sbc	r17, r13
    419c:	f4 01       	movw	r30, r8
    419e:	22 81       	ldd	r18, Z+2	; 0x02
    41a0:	30 e0       	ldi	r19, 0x00	; 0
    41a2:	40 e0       	ldi	r20, 0x00	; 0
    41a4:	50 e0       	ldi	r21, 0x00	; 0
    41a6:	c8 01       	movw	r24, r16
    41a8:	b7 01       	movw	r22, r14
    41aa:	0e 94 73 36 	call	0x6ce6	; 0x6ce6 <__udivmodsi4>
    41ae:	c9 01       	movw	r24, r18
    41b0:	da 01       	movw	r26, r20
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    41b2:	00 97       	sbiw	r24, 0x00	; 0
    41b4:	a1 05       	cpc	r26, r1
    41b6:	b1 05       	cpc	r27, r1
    41b8:	09 f4       	brne	.+2      	; 0x41bc <f_open+0x252>
    41ba:	c9 c0       	rjmp	.+402    	; 0x434e <f_open+0x3e4>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    41bc:	86 3f       	cpi	r24, 0xF6	; 246
    41be:	ff e0       	ldi	r31, 0x0F	; 15
    41c0:	9f 07       	cpc	r25, r31
    41c2:	f0 e0       	ldi	r31, 0x00	; 0
    41c4:	af 07       	cpc	r26, r31
    41c6:	f0 e0       	ldi	r31, 0x00	; 0
    41c8:	bf 07       	cpc	r27, r31
    41ca:	10 f4       	brcc	.+4      	; 0x41d0 <f_open+0x266>
    41cc:	e1 e0       	ldi	r30, 0x01	; 1
    41ce:	0b c0       	rjmp	.+22     	; 0x41e6 <f_open+0x27c>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    41d0:	86 3f       	cpi	r24, 0xF6	; 246
    41d2:	2f ef       	ldi	r18, 0xFF	; 255
    41d4:	92 07       	cpc	r25, r18
    41d6:	20 e0       	ldi	r18, 0x00	; 0
    41d8:	a2 07       	cpc	r26, r18
    41da:	20 e0       	ldi	r18, 0x00	; 0
    41dc:	b2 07       	cpc	r27, r18
    41de:	10 f0       	brcs	.+4      	; 0x41e4 <f_open+0x27a>
    41e0:	e3 e0       	ldi	r30, 0x03	; 3
    41e2:	01 c0       	rjmp	.+2      	; 0x41e6 <f_open+0x27c>
    41e4:	e2 e0       	ldi	r30, 0x02	; 2

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    41e6:	72 e0       	ldi	r23, 0x02	; 2
    41e8:	e7 2e       	mov	r14, r23
    41ea:	f1 2c       	mov	r15, r1
    41ec:	01 2d       	mov	r16, r1
    41ee:	11 2d       	mov	r17, r1
    41f0:	e8 0e       	add	r14, r24
    41f2:	f9 1e       	adc	r15, r25
    41f4:	0a 1f       	adc	r16, r26
    41f6:	1b 1f       	adc	r17, r27
    41f8:	d4 01       	movw	r26, r8
    41fa:	1a 96       	adiw	r26, 0x0a	; 10
    41fc:	ed 92       	st	X+, r14
    41fe:	fd 92       	st	X+, r15
    4200:	0d 93       	st	X+, r16
    4202:	1c 93       	st	X, r17
    4204:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->database = bsect + sysect;						/* Data start sector */
    4206:	8f a1       	ldd	r24, Y+39	; 0x27
    4208:	98 a5       	ldd	r25, Y+40	; 0x28
    420a:	a9 a5       	ldd	r26, Y+41	; 0x29
    420c:	ba a5       	ldd	r27, Y+42	; 0x2a
    420e:	a8 0e       	add	r10, r24
    4210:	b9 1e       	adc	r11, r25
    4212:	ca 1e       	adc	r12, r26
    4214:	db 1e       	adc	r13, r27
    4216:	d4 01       	movw	r26, r8
    4218:	5a 96       	adiw	r26, 0x1a	; 26
    421a:	ad 92       	st	X+, r10
    421c:	bd 92       	st	X+, r11
    421e:	cd 92       	st	X+, r12
    4220:	dc 92       	st	X, r13
    4222:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    4224:	4f a1       	ldd	r20, Y+39	; 0x27
    4226:	58 a5       	ldd	r21, Y+40	; 0x28
    4228:	69 a5       	ldd	r22, Y+41	; 0x29
    422a:	7a a5       	ldd	r23, Y+42	; 0x2a
    422c:	42 0d       	add	r20, r2
    422e:	53 1d       	adc	r21, r3
    4230:	64 1d       	adc	r22, r4
    4232:	75 1d       	adc	r23, r5
    4234:	52 96       	adiw	r26, 0x12	; 18
    4236:	4d 93       	st	X+, r20
    4238:	5d 93       	st	X+, r21
    423a:	6d 93       	st	X+, r22
    423c:	7c 93       	st	X, r23
    423e:	55 97       	sbiw	r26, 0x15	; 21
    4240:	18 96       	adiw	r26, 0x08	; 8
    4242:	8d 91       	ld	r24, X+
    4244:	9c 91       	ld	r25, X
    4246:	19 97       	sbiw	r26, 0x09	; 9
	if (fmt == FS_FAT32) {
    4248:	e3 30       	cpi	r30, 0x03	; 3
    424a:	09 f5       	brne	.+66     	; 0x428e <f_open+0x324>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    424c:	89 2b       	or	r24, r25
    424e:	09 f0       	breq	.+2      	; 0x4252 <f_open+0x2e8>
    4250:	7e c0       	rjmp	.+252    	; 0x434e <f_open+0x3e4>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    4252:	8e e4       	ldi	r24, 0x4E	; 78
    4254:	90 e0       	ldi	r25, 0x00	; 0
    4256:	88 0e       	add	r8, r24
    4258:	99 1e       	adc	r9, r25
    425a:	d4 01       	movw	r26, r8
    425c:	2d 91       	ld	r18, X+
    425e:	3d 91       	ld	r19, X+
    4260:	4d 91       	ld	r20, X+
    4262:	5c 91       	ld	r21, X
    4264:	82 eb       	ldi	r24, 0xB2	; 178
    4266:	9f ef       	ldi	r25, 0xFF	; 255
    4268:	88 0e       	add	r8, r24
    426a:	99 1e       	adc	r9, r25
    426c:	d4 01       	movw	r26, r8
    426e:	56 96       	adiw	r26, 0x16	; 22
    4270:	2d 93       	st	X+, r18
    4272:	3d 93       	st	X+, r19
    4274:	4d 93       	st	X+, r20
    4276:	5c 93       	st	X, r21
    4278:	59 97       	sbiw	r26, 0x19	; 25
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    427a:	a8 01       	movw	r20, r16
    427c:	97 01       	movw	r18, r14
    427e:	62 e0       	ldi	r22, 0x02	; 2
    4280:	22 0f       	add	r18, r18
    4282:	33 1f       	adc	r19, r19
    4284:	44 1f       	adc	r20, r20
    4286:	55 1f       	adc	r21, r21
    4288:	6a 95       	dec	r22
    428a:	d1 f7       	brne	.-12     	; 0x4280 <f_open+0x316>
    428c:	33 c0       	rjmp	.+102    	; 0x42f4 <f_open+0x38a>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    428e:	89 2b       	or	r24, r25
    4290:	09 f4       	brne	.+2      	; 0x4294 <f_open+0x32a>
    4292:	5d c0       	rjmp	.+186    	; 0x434e <f_open+0x3e4>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    4294:	8b a1       	ldd	r24, Y+35	; 0x23
    4296:	9c a1       	ldd	r25, Y+36	; 0x24
    4298:	ad a1       	ldd	r26, Y+37	; 0x25
    429a:	be a1       	ldd	r27, Y+38	; 0x26
    429c:	48 0f       	add	r20, r24
    429e:	59 1f       	adc	r21, r25
    42a0:	6a 1f       	adc	r22, r26
    42a2:	7b 1f       	adc	r23, r27
    42a4:	d4 01       	movw	r26, r8
    42a6:	56 96       	adiw	r26, 0x16	; 22
    42a8:	4d 93       	st	X+, r20
    42aa:	5d 93       	st	X+, r21
    42ac:	6d 93       	st	X+, r22
    42ae:	7c 93       	st	X, r23
    42b0:	59 97       	sbiw	r26, 0x19	; 25
    42b2:	d8 01       	movw	r26, r16
    42b4:	c7 01       	movw	r24, r14
    42b6:	88 0f       	add	r24, r24
    42b8:	99 1f       	adc	r25, r25
    42ba:	aa 1f       	adc	r26, r26
    42bc:	bb 1f       	adc	r27, r27
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    42be:	e2 30       	cpi	r30, 0x02	; 2
    42c0:	19 f4       	brne	.+6      	; 0x42c8 <f_open+0x35e>
    42c2:	9c 01       	movw	r18, r24
    42c4:	ad 01       	movw	r20, r26
    42c6:	16 c0       	rjmp	.+44     	; 0x42f4 <f_open+0x38a>
    42c8:	9c 01       	movw	r18, r24
    42ca:	ad 01       	movw	r20, r26
    42cc:	2e 0d       	add	r18, r14
    42ce:	3f 1d       	adc	r19, r15
    42d0:	40 1f       	adc	r20, r16
    42d2:	51 1f       	adc	r21, r17
    42d4:	56 95       	lsr	r21
    42d6:	47 95       	ror	r20
    42d8:	37 95       	ror	r19
    42da:	27 95       	ror	r18
    42dc:	81 e0       	ldi	r24, 0x01	; 1
    42de:	90 e0       	ldi	r25, 0x00	; 0
    42e0:	a0 e0       	ldi	r26, 0x00	; 0
    42e2:	b0 e0       	ldi	r27, 0x00	; 0
    42e4:	e8 22       	and	r14, r24
    42e6:	f9 22       	and	r15, r25
    42e8:	0a 23       	and	r16, r26
    42ea:	1b 23       	and	r17, r27
    42ec:	2e 0d       	add	r18, r14
    42ee:	3f 1d       	adc	r19, r15
    42f0:	40 1f       	adc	r20, r16
    42f2:	51 1f       	adc	r21, r17
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (FAT size must not be less than FAT sectors */
    42f4:	21 50       	subi	r18, 0x01	; 1
    42f6:	3e 4f       	sbci	r19, 0xFE	; 254
    42f8:	4f 4f       	sbci	r20, 0xFF	; 255
    42fa:	5f 4f       	sbci	r21, 0xFF	; 255
    42fc:	a9 e0       	ldi	r26, 0x09	; 9
    42fe:	56 95       	lsr	r21
    4300:	47 95       	ror	r20
    4302:	37 95       	ror	r19
    4304:	27 95       	ror	r18
    4306:	aa 95       	dec	r26
    4308:	d1 f7       	brne	.-12     	; 0x42fe <f_open+0x394>
    430a:	d4 01       	movw	r26, r8
    430c:	1e 96       	adiw	r26, 0x0e	; 14
    430e:	ed 90       	ld	r14, X+
    4310:	fd 90       	ld	r15, X+
    4312:	0d 91       	ld	r16, X+
    4314:	1c 91       	ld	r17, X
    4316:	51 97       	sbiw	r26, 0x11	; 17
    4318:	e2 16       	cp	r14, r18
    431a:	f3 06       	cpc	r15, r19
    431c:	04 07       	cpc	r16, r20
    431e:	15 07       	cpc	r17, r21
    4320:	b0 f0       	brcs	.+44     	; 0x434e <f_open+0x3e4>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    4322:	ec 93       	st	X, r30
	fs->id = ++Fsid;		/* File system mount ID */
    4324:	80 91 10 03 	lds	r24, 0x0310
    4328:	90 91 11 03 	lds	r25, 0x0311
    432c:	01 96       	adiw	r24, 0x01	; 1
    432e:	90 93 11 03 	sts	0x0311, r25
    4332:	80 93 10 03 	sts	0x0310, r24
    4336:	17 96       	adiw	r26, 0x07	; 7
    4338:	9c 93       	st	X, r25
    433a:	8e 93       	st	-X, r24
    433c:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    433e:	f4 01       	movw	r30, r8
    4340:	16 8e       	std	Z+30, r1	; 0x1e
    4342:	17 8e       	std	Z+31, r1	; 0x1f
    4344:	10 a2       	std	Z+32, r1	; 0x20
    4346:	11 a2       	std	Z+33, r1	; 0x21
	fs->wflag = 0;
    4348:	14 82       	std	Z+4, r1	; 0x04
    434a:	60 e0       	ldi	r22, 0x00	; 0
    434c:	01 c0       	rjmp	.+2      	; 0x4350 <f_open+0x3e6>
    434e:	6d e0       	ldi	r22, 0x0D	; 13
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
    4350:	ce 01       	movw	r24, r28
    4352:	01 96       	adiw	r24, 0x01	; 1
    4354:	9a a3       	std	Y+34, r25	; 0x22
    4356:	89 a3       	std	Y+33, r24	; 0x21
	if (res == FR_OK)
    4358:	66 23       	and	r22, r22
    435a:	09 f0       	breq	.+2      	; 0x435e <f_open+0x3f4>
    435c:	a9 c1       	rjmp	.+850    	; 0x46b0 <f_open+0x746>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    435e:	ad a5       	ldd	r26, Y+45	; 0x2d
    4360:	be a5       	ldd	r27, Y+46	; 0x2e
    4362:	8c 91       	ld	r24, X
    4364:	8f 32       	cpi	r24, 0x2F	; 47
    4366:	11 f0       	breq	.+4      	; 0x436c <f_open+0x402>
    4368:	8c 35       	cpi	r24, 0x5C	; 92
    436a:	29 f4       	brne	.+10     	; 0x4376 <f_open+0x40c>
		path++;
    436c:	ed a5       	ldd	r30, Y+45	; 0x2d
    436e:	fe a5       	ldd	r31, Y+46	; 0x2e
    4370:	31 96       	adiw	r30, 0x01	; 1
    4372:	fe a7       	std	Y+46, r31	; 0x2e
    4374:	ed a7       	std	Y+45, r30	; 0x2d
	dj->sclust = 0;						/* Start from the root dir */
    4376:	1b 8a       	std	Y+19, r1	; 0x13
    4378:	1c 8a       	std	Y+20, r1	; 0x14
    437a:	1d 8a       	std	Y+21, r1	; 0x15
    437c:	1e 8a       	std	Y+22, r1	; 0x16
#endif

	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
    437e:	ad a5       	ldd	r26, Y+45	; 0x2d
    4380:	be a5       	ldd	r27, Y+46	; 0x2e
    4382:	8c 91       	ld	r24, X
    4384:	80 32       	cpi	r24, 0x20	; 32
    4386:	48 f4       	brcc	.+18     	; 0x439a <f_open+0x430>
		res = dir_sdi(dj, 0);
    4388:	ce 01       	movw	r24, r28
    438a:	0d 96       	adiw	r24, 0x0d	; 13
    438c:	60 e0       	ldi	r22, 0x00	; 0
    438e:	70 e0       	ldi	r23, 0x00	; 0
    4390:	b1 db       	rcall	.-2206   	; 0x3af4 <dir_sdi>
    4392:	68 2f       	mov	r22, r24
		dj->dir = 0;
    4394:	18 a2       	std	Y+32, r1	; 0x20
    4396:	1f 8e       	std	Y+31, r1	; 0x1f
    4398:	8b c1       	rjmp	.+790    	; 0x46b0 <f_open+0x746>
static
void mem_set (void* dst, int val, int cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    439a:	f0 e2       	ldi	r31, 0x20	; 32
    439c:	9f 2e       	mov	r9, r31
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject null string */
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
    439e:	e5 e0       	ldi	r30, 0x05	; 5
    43a0:	8e 2e       	mov	r8, r30
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    43a2:	7d e0       	ldi	r23, 0x0D	; 13
    43a4:	a7 2e       	mov	r10, r23
    43a6:	b1 2c       	mov	r11, r1
    43a8:	ac 0e       	add	r10, r28
    43aa:	bd 1e       	adc	r11, r29
	BYTE b, c, d, *sfn;
	int ni, si, i;
	const char *p;

	/* Create file name in directory form */
	sfn = dj->fn;
    43ac:	a9 a1       	ldd	r26, Y+33	; 0x21
    43ae:	ba a1       	ldd	r27, Y+34	; 0x22
    43b0:	fd 01       	movw	r30, r26
    43b2:	8b e0       	ldi	r24, 0x0B	; 11
    43b4:	90 e0       	ldi	r25, 0x00	; 0
    43b6:	01 c0       	rjmp	.+2      	; 0x43ba <f_open+0x450>
static
void mem_set (void* dst, int val, int cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    43b8:	91 92       	st	Z+, r9
/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    43ba:	01 97       	sbiw	r24, 0x01	; 1
    43bc:	2f ef       	ldi	r18, 0xFF	; 255
    43be:	8f 3f       	cpi	r24, 0xFF	; 255
    43c0:	92 07       	cpc	r25, r18
    43c2:	d1 f7       	brne	.-12     	; 0x43b8 <f_open+0x44e>
    43c4:	40 e0       	ldi	r20, 0x00	; 0
    43c6:	50 e0       	ldi	r21, 0x00	; 0
    43c8:	cc 24       	eor	r12, r12
    43ca:	dd 24       	eor	r13, r13
    43cc:	68 e0       	ldi	r22, 0x08	; 8
    43ce:	e6 2e       	mov	r14, r22
    43d0:	f1 2c       	mov	r15, r1
    43d2:	10 e0       	ldi	r17, 0x00	; 0
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    43d4:	ed a5       	ldd	r30, Y+45	; 0x2d
    43d6:	fe a5       	ldd	r31, Y+46	; 0x2e
    43d8:	ec 0d       	add	r30, r12
    43da:	fd 1d       	adc	r31, r13
    43dc:	20 81       	ld	r18, Z
    43de:	08 94       	sec
    43e0:	c1 1c       	adc	r12, r1
    43e2:	d1 1c       	adc	r13, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    43e4:	21 32       	cpi	r18, 0x21	; 33
    43e6:	08 f4       	brcc	.+2      	; 0x43ea <f_open+0x480>
    43e8:	67 c0       	rjmp	.+206    	; 0x44b8 <f_open+0x54e>
    43ea:	2f 32       	cpi	r18, 0x2F	; 47
    43ec:	09 f4       	brne	.+2      	; 0x43f0 <f_open+0x486>
    43ee:	ca c1       	rjmp	.+916    	; 0x4784 <f_open+0x81a>
    43f0:	2c 35       	cpi	r18, 0x5C	; 92
    43f2:	09 f4       	brne	.+2      	; 0x43f6 <f_open+0x48c>
    43f4:	c7 c1       	rjmp	.+910    	; 0x4784 <f_open+0x81a>
		if (c == '.' || i >= ni) {
    43f6:	2e 32       	cpi	r18, 0x2E	; 46
    43f8:	19 f0       	breq	.+6      	; 0x4400 <f_open+0x496>
    43fa:	4e 15       	cp	r20, r14
    43fc:	5f 05       	cpc	r21, r15
    43fe:	84 f0       	brlt	.+32     	; 0x4420 <f_open+0x4b6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    4400:	88 e0       	ldi	r24, 0x08	; 8
    4402:	e8 16       	cp	r14, r24
    4404:	f1 04       	cpc	r15, r1
    4406:	09 f0       	breq	.+2      	; 0x440a <f_open+0x4a0>
    4408:	4e c1       	rjmp	.+668    	; 0x46a6 <f_open+0x73c>
    440a:	2e 32       	cpi	r18, 0x2E	; 46
    440c:	09 f0       	breq	.+2      	; 0x4410 <f_open+0x4a6>
    440e:	4b c1       	rjmp	.+662    	; 0x46a6 <f_open+0x73c>
			i = 8; ni = 11;
			b <<= 2; continue;
    4410:	11 0f       	add	r17, r17
    4412:	11 0f       	add	r17, r17
    4414:	48 e0       	ldi	r20, 0x08	; 8
    4416:	50 e0       	ldi	r21, 0x00	; 0
    4418:	3b e0       	ldi	r19, 0x0B	; 11
    441a:	e3 2e       	mov	r14, r19
    441c:	f1 2c       	mov	r15, r1
    441e:	da cf       	rjmp	.-76     	; 0x43d4 <f_open+0x46a>
		}
		if (c >= 0x80) {				/* Extended char */
    4420:	27 fd       	sbrc	r18, 7
#ifdef _EXCVT
			c = excvt[c - 0x80];		/* Convert extend char (SBCS) */
#else
			b |= 3;						/* Eliminate NT flag if extended char is exist */
    4422:	13 60       	ori	r17, 0x03	; 3
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* DBC 1st byte? */
    4424:	82 2f       	mov	r24, r18
    4426:	81 58       	subi	r24, 0x81	; 129
    4428:	8f 31       	cpi	r24, 0x1F	; 31
    442a:	18 f0       	brcs	.+6      	; 0x4432 <f_open+0x4c8>
    442c:	8f 55       	subi	r24, 0x5F	; 95
    442e:	8d 31       	cpi	r24, 0x1D	; 29
    4430:	10 f5       	brcc	.+68     	; 0x4476 <f_open+0x50c>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    4432:	ed a5       	ldd	r30, Y+45	; 0x2d
    4434:	fe a5       	ldd	r31, Y+46	; 0x2e
    4436:	ec 0d       	add	r30, r12
    4438:	fd 1d       	adc	r31, r13
    443a:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    443c:	83 2f       	mov	r24, r19
    443e:	80 54       	subi	r24, 0x40	; 64
    4440:	8f 33       	cpi	r24, 0x3F	; 63
    4442:	20 f0       	brcs	.+8      	; 0x444c <f_open+0x4e2>
    4444:	80 54       	subi	r24, 0x40	; 64
    4446:	8d 37       	cpi	r24, 0x7D	; 125
    4448:	08 f0       	brcs	.+2      	; 0x444c <f_open+0x4e2>
    444a:	2d c1       	rjmp	.+602    	; 0x46a6 <f_open+0x73c>
    444c:	c7 01       	movw	r24, r14
    444e:	01 97       	sbiw	r24, 0x01	; 1
    4450:	48 17       	cp	r20, r24
    4452:	59 07       	cpc	r21, r25
    4454:	0c f0       	brlt	.+2      	; 0x4458 <f_open+0x4ee>
    4456:	27 c1       	rjmp	.+590    	; 0x46a6 <f_open+0x73c>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* DBC 1st byte? */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    4458:	08 94       	sec
    445a:	c1 1c       	adc	r12, r1
    445c:	d1 1c       	adc	r13, r1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    445e:	fd 01       	movw	r30, r26
    4460:	e4 0f       	add	r30, r20
    4462:	f5 1f       	adc	r31, r21
    4464:	20 83       	st	Z, r18
    4466:	ca 01       	movw	r24, r20
    4468:	01 96       	adiw	r24, 0x01	; 1
			sfn[i++] = d;
    446a:	fd 01       	movw	r30, r26
    446c:	e8 0f       	add	r30, r24
    446e:	f9 1f       	adc	r31, r25
    4470:	30 83       	st	Z, r19
    4472:	ac 01       	movw	r20, r24
    4474:	1e c0       	rjmp	.+60     	; 0x44b2 <f_open+0x548>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    4476:	62 2f       	mov	r22, r18
    4478:	70 e0       	ldi	r23, 0x00	; 0
    447a:	e5 e7       	ldi	r30, 0x75	; 117
    447c:	f2 e0       	ldi	r31, 0x02	; 2
    447e:	01 c0       	rjmp	.+2      	; 0x4482 <f_open+0x518>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    4480:	31 96       	adiw	r30, 0x01	; 1
    4482:	80 81       	ld	r24, Z
    4484:	88 23       	and	r24, r24
    4486:	29 f0       	breq	.+10     	; 0x4492 <f_open+0x528>
    4488:	90 e0       	ldi	r25, 0x00	; 0
    448a:	86 17       	cp	r24, r22
    448c:	97 07       	cpc	r25, r23
    448e:	c1 f7       	brne	.-16     	; 0x4480 <f_open+0x516>
    4490:	0a c1       	rjmp	.+532    	; 0x46a6 <f_open+0x73c>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    4492:	82 2f       	mov	r24, r18
    4494:	81 54       	subi	r24, 0x41	; 65
    4496:	8a 31       	cpi	r24, 0x1A	; 26
    4498:	10 f4       	brcc	.+4      	; 0x449e <f_open+0x534>
				b |= 2;
    449a:	12 60       	ori	r17, 0x02	; 2
    449c:	06 c0       	rjmp	.+12     	; 0x44aa <f_open+0x540>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    449e:	82 2f       	mov	r24, r18
    44a0:	81 56       	subi	r24, 0x61	; 97
    44a2:	8a 31       	cpi	r24, 0x1A	; 26
    44a4:	10 f4       	brcc	.+4      	; 0x44aa <f_open+0x540>
					b |= 1; c -= 0x20;
    44a6:	11 60       	ori	r17, 0x01	; 1
    44a8:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    44aa:	fd 01       	movw	r30, r26
    44ac:	e4 0f       	add	r30, r20
    44ae:	f5 1f       	adc	r31, r21
    44b0:	20 83       	st	Z, r18
    44b2:	4f 5f       	subi	r20, 0xFF	; 255
    44b4:	5f 4f       	sbci	r21, 0xFF	; 255
    44b6:	8e cf       	rjmp	.-228    	; 0x43d4 <f_open+0x46a>
    44b8:	91 2f       	mov	r25, r17
    44ba:	64 e0       	ldi	r22, 0x04	; 4
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject null string */
    44bc:	45 2b       	or	r20, r21
    44be:	09 f4       	brne	.+2      	; 0x44c2 <f_open+0x558>
    44c0:	f2 c0       	rjmp	.+484    	; 0x46a6 <f_open+0x73c>
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
    44c2:	8c 91       	ld	r24, X
    44c4:	85 3e       	cpi	r24, 0xE5	; 229
    44c6:	09 f4       	brne	.+2      	; 0x44ca <f_open+0x560>
    44c8:	8c 92       	st	X, r8

	if (ni == 8) b <<= 2;
    44ca:	e8 e0       	ldi	r30, 0x08	; 8
    44cc:	ee 16       	cp	r14, r30
    44ce:	f1 04       	cpc	r15, r1
    44d0:	19 f4       	brne	.+6      	; 0x44d8 <f_open+0x56e>
    44d2:	91 2f       	mov	r25, r17
    44d4:	99 0f       	add	r25, r25
    44d6:	99 0f       	add	r25, r25
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    44d8:	29 2f       	mov	r18, r25
    44da:	30 e0       	ldi	r19, 0x00	; 0
    44dc:	c9 01       	movw	r24, r18
    44de:	83 70       	andi	r24, 0x03	; 3
    44e0:	90 70       	andi	r25, 0x00	; 0
    44e2:	01 97       	sbiw	r24, 0x01	; 1
    44e4:	09 f4       	brne	.+2      	; 0x44e8 <f_open+0x57e>
    44e6:	60 61       	ori	r22, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    44e8:	2c 70       	andi	r18, 0x0C	; 12
    44ea:	30 70       	andi	r19, 0x00	; 0
    44ec:	24 30       	cpi	r18, 0x04	; 4
    44ee:	31 05       	cpc	r19, r1
    44f0:	09 f4       	brne	.+2      	; 0x44f4 <f_open+0x58a>
    44f2:	68 60       	ori	r22, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    44f4:	1b 96       	adiw	r26, 0x0b	; 11
    44f6:	6c 93       	st	X, r22
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    44f8:	c5 01       	movw	r24, r10
    44fa:	60 e0       	ldi	r22, 0x00	; 0
    44fc:	70 e0       	ldi	r23, 0x00	; 0
    44fe:	fa da       	rcall	.-2572   	; 0x3af4 <dir_sdi>
    4500:	48 2f       	mov	r20, r24
	if (res != FR_OK) return res;
    4502:	88 23       	and	r24, r24
    4504:	09 f0       	breq	.+2      	; 0x4508 <f_open+0x59e>
    4506:	a3 c0       	rjmp	.+326    	; 0x464e <f_open+0x6e4>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    4508:	4b 8d       	ldd	r20, Y+27	; 0x1b
    450a:	5c 8d       	ldd	r21, Y+28	; 0x1c
    450c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    450e:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4510:	8d 85       	ldd	r24, Y+13	; 0x0d
    4512:	9e 85       	ldd	r25, Y+14	; 0x0e
    4514:	7e d8       	rcall	.-3844   	; 0x3612 <move_window>
    4516:	48 2f       	mov	r20, r24
		if (res != FR_OK) break;
    4518:	88 23       	and	r24, r24
    451a:	09 f0       	breq	.+2      	; 0x451e <f_open+0x5b4>
    451c:	98 c0       	rjmp	.+304    	; 0x464e <f_open+0x6e4>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    451e:	ef 8d       	ldd	r30, Y+31	; 0x1f
    4520:	f8 a1       	ldd	r31, Y+32	; 0x20
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    4522:	80 81       	ld	r24, Z
    4524:	88 23       	and	r24, r24
    4526:	09 f4       	brne	.+2      	; 0x452a <f_open+0x5c0>
    4528:	91 c0       	rjmp	.+290    	; 0x464c <f_open+0x6e2>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    452a:	83 85       	ldd	r24, Z+11	; 0x0b
    452c:	83 fd       	sbrc	r24, 3
    452e:	14 c0       	rjmp	.+40     	; 0x4558 <f_open+0x5ee>
    4530:	89 a1       	ldd	r24, Y+33	; 0x21
    4532:	9a a1       	ldd	r25, Y+34	; 0x22
    4534:	9c 01       	movw	r18, r24
    4536:	d9 01       	movw	r26, r18
    4538:	2b e0       	ldi	r18, 0x0B	; 11
    453a:	30 e0       	ldi	r19, 0x00	; 0
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    453c:	21 50       	subi	r18, 0x01	; 1
    453e:	30 40       	sbci	r19, 0x00	; 0
    4540:	8f ef       	ldi	r24, 0xFF	; 255
    4542:	2f 3f       	cpi	r18, 0xFF	; 255
    4544:	38 07       	cpc	r19, r24
    4546:	09 f4       	brne	.+2      	; 0x454a <f_open+0x5e0>
    4548:	82 c0       	rjmp	.+260    	; 0x464e <f_open+0x6e4>
    454a:	90 81       	ld	r25, Z
    454c:	8c 91       	ld	r24, X
    454e:	98 17       	cp	r25, r24
    4550:	19 f4       	brne	.+6      	; 0x4558 <f_open+0x5ee>
    4552:	31 96       	adiw	r30, 0x01	; 1
    4554:	11 96       	adiw	r26, 0x01	; 1
    4556:	f2 cf       	rjmp	.-28     	; 0x453c <f_open+0x5d2>
{
	DWORD clst;
	WORD i;


	i = dj->index + 1;
    4558:	09 89       	ldd	r16, Y+17	; 0x11
    455a:	1a 89       	ldd	r17, Y+18	; 0x12
    455c:	0f 5f       	subi	r16, 0xFF	; 255
    455e:	1f 4f       	sbci	r17, 0xFF	; 255
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    4560:	09 f4       	brne	.+2      	; 0x4564 <f_open+0x5fa>
    4562:	74 c0       	rjmp	.+232    	; 0x464c <f_open+0x6e2>
    4564:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4566:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4568:	ad 8d       	ldd	r26, Y+29	; 0x1d
    456a:	be 8d       	ldd	r27, Y+30	; 0x1e
    456c:	00 97       	sbiw	r24, 0x00	; 0
    456e:	a1 05       	cpc	r26, r1
    4570:	b1 05       	cpc	r27, r1
    4572:	09 f4       	brne	.+2      	; 0x4576 <f_open+0x60c>
    4574:	6b c0       	rjmp	.+214    	; 0x464c <f_open+0x6e2>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
    4576:	2f e0       	ldi	r18, 0x0F	; 15
    4578:	e2 2e       	mov	r14, r18
    457a:	f1 2c       	mov	r15, r1
    457c:	e0 22       	and	r14, r16
    457e:	f1 22       	and	r15, r17
    4580:	e1 14       	cp	r14, r1
    4582:	f1 04       	cpc	r15, r1
    4584:	09 f0       	breq	.+2      	; 0x4588 <f_open+0x61e>
    4586:	50 c0       	rjmp	.+160    	; 0x4628 <f_open+0x6be>
		dj->sect++;					/* Next sector */
    4588:	01 96       	adiw	r24, 0x01	; 1
    458a:	a1 1d       	adc	r26, r1
    458c:	b1 1d       	adc	r27, r1
    458e:	8b 8f       	std	Y+27, r24	; 0x1b
    4590:	9c 8f       	std	Y+28, r25	; 0x1c
    4592:	ad 8f       	std	Y+29, r26	; 0x1d
    4594:	be 8f       	std	Y+30, r27	; 0x1e

		if (dj->clust == 0) {	/* Static table */
    4596:	4f 89       	ldd	r20, Y+23	; 0x17
    4598:	58 8d       	ldd	r21, Y+24	; 0x18
    459a:	69 8d       	ldd	r22, Y+25	; 0x19
    459c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    459e:	ed 85       	ldd	r30, Y+13	; 0x0d
    45a0:	fe 85       	ldd	r31, Y+14	; 0x0e
    45a2:	41 15       	cp	r20, r1
    45a4:	51 05       	cpc	r21, r1
    45a6:	61 05       	cpc	r22, r1
    45a8:	71 05       	cpc	r23, r1
    45aa:	31 f4       	brne	.+12     	; 0x45b8 <f_open+0x64e>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    45ac:	80 85       	ldd	r24, Z+8	; 0x08
    45ae:	91 85       	ldd	r25, Z+9	; 0x09
    45b0:	08 17       	cp	r16, r24
    45b2:	19 07       	cpc	r17, r25
    45b4:	c8 f1       	brcs	.+114    	; 0x4628 <f_open+0x6be>
    45b6:	4a c0       	rjmp	.+148    	; 0x464c <f_open+0x6e2>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    45b8:	82 81       	ldd	r24, Z+2	; 0x02
    45ba:	90 e0       	ldi	r25, 0x00	; 0
    45bc:	01 97       	sbiw	r24, 0x01	; 1
    45be:	98 01       	movw	r18, r16
    45c0:	a4 e0       	ldi	r26, 0x04	; 4
    45c2:	36 95       	lsr	r19
    45c4:	27 95       	ror	r18
    45c6:	aa 95       	dec	r26
    45c8:	e1 f7       	brne	.-8      	; 0x45c2 <f_open+0x658>
    45ca:	82 23       	and	r24, r18
    45cc:	93 23       	and	r25, r19
    45ce:	89 2b       	or	r24, r25
    45d0:	59 f5       	brne	.+86     	; 0x4628 <f_open+0x6be>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    45d2:	cf 01       	movw	r24, r30
    45d4:	4f d8       	rcall	.-3938   	; 0x3674 <get_fat>
    45d6:	ab 01       	movw	r20, r22
    45d8:	bc 01       	movw	r22, r24
				if (clst <= 1) return FR_INT_ERR;
    45da:	42 30       	cpi	r20, 0x02	; 2
    45dc:	51 05       	cpc	r21, r1
    45de:	61 05       	cpc	r22, r1
    45e0:	71 05       	cpc	r23, r1
    45e2:	10 f4       	brcc	.+4      	; 0x45e8 <f_open+0x67e>
    45e4:	42 e0       	ldi	r20, 0x02	; 2
    45e6:	33 c0       	rjmp	.+102    	; 0x464e <f_open+0x6e4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    45e8:	4f 3f       	cpi	r20, 0xFF	; 255
    45ea:	9f ef       	ldi	r25, 0xFF	; 255
    45ec:	59 07       	cpc	r21, r25
    45ee:	9f ef       	ldi	r25, 0xFF	; 255
    45f0:	69 07       	cpc	r22, r25
    45f2:	9f ef       	ldi	r25, 0xFF	; 255
    45f4:	79 07       	cpc	r23, r25
    45f6:	11 f4       	brne	.+4      	; 0x45fc <f_open+0x692>
    45f8:	41 e0       	ldi	r20, 0x01	; 1
    45fa:	29 c0       	rjmp	.+82     	; 0x464e <f_open+0x6e4>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    45fc:	ed 85       	ldd	r30, Y+13	; 0x0d
    45fe:	fe 85       	ldd	r31, Y+14	; 0x0e
    4600:	82 85       	ldd	r24, Z+10	; 0x0a
    4602:	93 85       	ldd	r25, Z+11	; 0x0b
    4604:	a4 85       	ldd	r26, Z+12	; 0x0c
    4606:	b5 85       	ldd	r27, Z+13	; 0x0d
    4608:	48 17       	cp	r20, r24
    460a:	59 07       	cpc	r21, r25
    460c:	6a 07       	cpc	r22, r26
    460e:	7b 07       	cpc	r23, r27
    4610:	e8 f4       	brcc	.+58     	; 0x464c <f_open+0x6e2>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    4612:	4f 8b       	std	Y+23, r20	; 0x17
    4614:	58 8f       	std	Y+24, r21	; 0x18
    4616:	69 8f       	std	Y+25, r22	; 0x19
    4618:	7a 8f       	std	Y+26, r23	; 0x1a
				dj->sect = clust2sect(dj->fs, clst);
    461a:	cf 01       	movw	r24, r30
    461c:	0e 94 93 1a 	call	0x3526	; 0x3526 <clust2sect>
    4620:	6b 8f       	std	Y+27, r22	; 0x1b
    4622:	7c 8f       	std	Y+28, r23	; 0x1c
    4624:	8d 8f       	std	Y+29, r24	; 0x1d
    4626:	9e 8f       	std	Y+30, r25	; 0x1e
			}
		}
	}

	dj->index = i;
    4628:	1a 8b       	std	Y+18, r17	; 0x12
    462a:	09 8b       	std	Y+17, r16	; 0x11
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
    462c:	85 e0       	ldi	r24, 0x05	; 5
    462e:	ee 0c       	add	r14, r14
    4630:	ff 1c       	adc	r15, r15
    4632:	8a 95       	dec	r24
    4634:	e1 f7       	brne	.-8      	; 0x462e <f_open+0x6c4>
    4636:	a2 e2       	ldi	r26, 0x22	; 34
    4638:	b0 e0       	ldi	r27, 0x00	; 0
    463a:	ea 0e       	add	r14, r26
    463c:	fb 1e       	adc	r15, r27
    463e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4640:	9e 85       	ldd	r25, Y+14	; 0x0e
    4642:	8e 0d       	add	r24, r14
    4644:	9f 1d       	adc	r25, r15
    4646:	98 a3       	std	Y+32, r25	; 0x20
    4648:	8f 8f       	std	Y+31, r24	; 0x1f
    464a:	5e cf       	rjmp	.-324    	; 0x4508 <f_open+0x59e>
    464c:	44 e0       	ldi	r20, 0x04	; 4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    464e:	e9 a1       	ldd	r30, Y+33	; 0x21
    4650:	fa a1       	ldd	r31, Y+34	; 0x22
    4652:	83 85       	ldd	r24, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
    4654:	44 23       	and	r20, r20
    4656:	31 f0       	breq	.+12     	; 0x4664 <f_open+0x6fa>
    4658:	64 2f       	mov	r22, r20
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    465a:	44 30       	cpi	r20, 0x04	; 4
    465c:	31 f5       	brne	.+76     	; 0x46aa <f_open+0x740>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    465e:	82 ff       	sbrs	r24, 2
    4660:	26 c0       	rjmp	.+76     	; 0x46ae <f_open+0x744>
    4662:	26 c0       	rjmp	.+76     	; 0x46b0 <f_open+0x746>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    4664:	82 fd       	sbrc	r24, 2
    4666:	21 c0       	rjmp	.+66     	; 0x46aa <f_open+0x740>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    4668:	ef 8d       	ldd	r30, Y+31	; 0x1f
    466a:	f8 a1       	ldd	r31, Y+32	; 0x20
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    466c:	83 85       	ldd	r24, Z+11	; 0x0b
    466e:	84 ff       	sbrs	r24, 4
    4670:	1e c0       	rjmp	.+60     	; 0x46ae <f_open+0x744>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    4672:	8d a5       	ldd	r24, Y+45	; 0x2d
    4674:	9e a5       	ldd	r25, Y+46	; 0x2e
    4676:	8c 0d       	add	r24, r12
    4678:	9d 1d       	adc	r25, r13
    467a:	9e a7       	std	Y+46, r25	; 0x2e
    467c:	8d a7       	std	Y+45, r24	; 0x2d
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
    467e:	84 89       	ldd	r24, Z+20	; 0x14
    4680:	95 89       	ldd	r25, Z+21	; 0x15
    4682:	a0 e0       	ldi	r26, 0x00	; 0
    4684:	b0 e0       	ldi	r27, 0x00	; 0
    4686:	dc 01       	movw	r26, r24
    4688:	99 27       	eor	r25, r25
    468a:	88 27       	eor	r24, r24
    468c:	22 8d       	ldd	r18, Z+26	; 0x1a
    468e:	33 8d       	ldd	r19, Z+27	; 0x1b
    4690:	40 e0       	ldi	r20, 0x00	; 0
    4692:	50 e0       	ldi	r21, 0x00	; 0
    4694:	82 2b       	or	r24, r18
    4696:	93 2b       	or	r25, r19
    4698:	a4 2b       	or	r26, r20
    469a:	b5 2b       	or	r27, r21
    469c:	8b 8b       	std	Y+19, r24	; 0x13
    469e:	9c 8b       	std	Y+20, r25	; 0x14
    46a0:	ad 8b       	std	Y+21, r26	; 0x15
    46a2:	be 8b       	std	Y+22, r27	; 0x16
    46a4:	83 ce       	rjmp	.-762    	; 0x43ac <f_open+0x442>
    46a6:	66 e0       	ldi	r22, 0x06	; 6
    46a8:	03 c0       	rjmp	.+6      	; 0x46b0 <f_open+0x746>
    46aa:	64 2f       	mov	r22, r20
    46ac:	01 c0       	rjmp	.+2      	; 0x46b0 <f_open+0x746>
    46ae:	65 e0       	ldi	r22, 0x05	; 5
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
    46b0:	ef 8d       	ldd	r30, Y+31	; 0x1f
    46b2:	f8 a1       	ldd	r31, Y+32	; 0x20
		if (!fp->lockid) res = FR_INT_ERR;
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
    46b4:	66 23       	and	r22, r22
    46b6:	09 f0       	breq	.+2      	; 0x46ba <f_open+0x750>
    46b8:	49 c0       	rjmp	.+146    	; 0x474c <f_open+0x7e2>
		if (!dir) {						/* Current dir itself */
    46ba:	30 97       	sbiw	r30, 0x00	; 0
    46bc:	11 f4       	brne	.+4      	; 0x46c2 <f_open+0x758>
    46be:	66 e0       	ldi	r22, 0x06	; 6
    46c0:	45 c0       	rjmp	.+138    	; 0x474c <f_open+0x7e2>
			res = FR_INVALID_NAME;
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
    46c2:	83 85       	ldd	r24, Z+11	; 0x0b
    46c4:	84 fd       	sbrc	r24, 4
    46c6:	5c c0       	rjmp	.+184    	; 0x4780 <f_open+0x816>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
    46c8:	9f a5       	ldd	r25, Y+47	; 0x2f
    46ca:	91 70       	andi	r25, 0x01	; 1
    46cc:	ab a5       	ldd	r26, Y+43	; 0x2b
    46ce:	bc a5       	ldd	r27, Y+44	; 0x2c
    46d0:	14 96       	adiw	r26, 0x04	; 4
    46d2:	9c 93       	st	X, r25
		fp->org_clust =						/* File start cluster */
    46d4:	84 89       	ldd	r24, Z+20	; 0x14
    46d6:	95 89       	ldd	r25, Z+21	; 0x15
    46d8:	a0 e0       	ldi	r26, 0x00	; 0
    46da:	b0 e0       	ldi	r27, 0x00	; 0
    46dc:	8c 01       	movw	r16, r24
    46de:	ff 24       	eor	r15, r15
    46e0:	ee 24       	eor	r14, r14
    46e2:	22 8d       	ldd	r18, Z+26	; 0x1a
    46e4:	33 8d       	ldd	r19, Z+27	; 0x1b
    46e6:	40 e0       	ldi	r20, 0x00	; 0
    46e8:	50 e0       	ldi	r21, 0x00	; 0
    46ea:	e2 2a       	or	r14, r18
    46ec:	f3 2a       	or	r15, r19
    46ee:	04 2b       	or	r16, r20
    46f0:	15 2b       	or	r17, r21
    46f2:	ab a5       	ldd	r26, Y+43	; 0x2b
    46f4:	bc a5       	ldd	r27, Y+44	; 0x2c
    46f6:	1e 96       	adiw	r26, 0x0e	; 14
    46f8:	ed 92       	st	X+, r14
    46fa:	fd 92       	st	X+, r15
    46fc:	0d 93       	st	X+, r16
    46fe:	1c 93       	st	X, r17
    4700:	51 97       	sbiw	r26, 0x11	; 17
			((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    4702:	84 8d       	ldd	r24, Z+28	; 0x1c
    4704:	95 8d       	ldd	r25, Z+29	; 0x1d
    4706:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4708:	b7 8d       	ldd	r27, Z+31	; 0x1f
    470a:	eb a5       	ldd	r30, Y+43	; 0x2b
    470c:	fc a5       	ldd	r31, Y+44	; 0x2c
    470e:	82 87       	std	Z+10, r24	; 0x0a
    4710:	93 87       	std	Z+11, r25	; 0x0b
    4712:	a4 87       	std	Z+12, r26	; 0x0c
    4714:	b5 87       	std	Z+13, r27	; 0x0d
		fp->fptr = 0;						/* File pointer */
    4716:	ab a5       	ldd	r26, Y+43	; 0x2b
    4718:	bc a5       	ldd	r27, Y+44	; 0x2c
    471a:	16 96       	adiw	r26, 0x06	; 6
    471c:	1d 92       	st	X+, r1
    471e:	1d 92       	st	X+, r1
    4720:	1d 92       	st	X+, r1
    4722:	1c 92       	st	X, r1
    4724:	19 97       	sbiw	r26, 0x09	; 9
		fp->dsect = 0;
    4726:	eb a5       	ldd	r30, Y+43	; 0x2b
    4728:	fc a5       	ldd	r31, Y+44	; 0x2c
    472a:	16 8a       	std	Z+22, r1	; 0x16
    472c:	17 8a       	std	Z+23, r1	; 0x17
    472e:	10 8e       	std	Z+24, r1	; 0x18
    4730:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* No cluster link map table */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    4732:	ed 85       	ldd	r30, Y+13	; 0x0d
    4734:	fe 85       	ldd	r31, Y+14	; 0x0e
    4736:	ab a5       	ldd	r26, Y+43	; 0x2b
    4738:	bc a5       	ldd	r27, Y+44	; 0x2c
    473a:	11 96       	adiw	r26, 0x01	; 1
    473c:	fc 93       	st	X, r31
    473e:	ee 93       	st	-X, r30
    4740:	86 81       	ldd	r24, Z+6	; 0x06
    4742:	97 81       	ldd	r25, Z+7	; 0x07
    4744:	13 96       	adiw	r26, 0x03	; 3
    4746:	9c 93       	st	X, r25
    4748:	8e 93       	st	-X, r24
    474a:	12 97       	sbiw	r26, 0x02	; 2
	}

	LEAVE_FF(dj.fs, res);
}
    474c:	86 2f       	mov	r24, r22
    474e:	af 96       	adiw	r28, 0x2f	; 47
    4750:	0f b6       	in	r0, 0x3f	; 63
    4752:	f8 94       	cli
    4754:	de bf       	out	0x3e, r29	; 62
    4756:	0f be       	out	0x3f, r0	; 63
    4758:	cd bf       	out	0x3d, r28	; 61
    475a:	cf 91       	pop	r28
    475c:	df 91       	pop	r29
    475e:	1f 91       	pop	r17
    4760:	0f 91       	pop	r16
    4762:	ff 90       	pop	r15
    4764:	ef 90       	pop	r14
    4766:	df 90       	pop	r13
    4768:	cf 90       	pop	r12
    476a:	bf 90       	pop	r11
    476c:	af 90       	pop	r10
    476e:	9f 90       	pop	r9
    4770:	8f 90       	pop	r8
    4772:	7f 90       	pop	r7
    4774:	6f 90       	pop	r6
    4776:	5f 90       	pop	r5
    4778:	4f 90       	pop	r4
    477a:	3f 90       	pop	r3
    477c:	2f 90       	pop	r2
    477e:	08 95       	ret
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* No cluster link map table */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    4780:	64 e0       	ldi	r22, 0x04	; 4
    4782:	e4 cf       	rjmp	.-56     	; 0x474c <f_open+0x7e2>
    4784:	91 2f       	mov	r25, r17
    4786:	60 e0       	ldi	r22, 0x00	; 0
    4788:	99 ce       	rjmp	.-718    	; 0x44bc <f_open+0x552>

0000478a <Endpoint_ConfigureEndpoint_Prv>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    478a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    478e:	80 91 eb 00 	lds	r24, 0x00EB
    4792:	81 60       	ori	r24, 0x01	; 1
    4794:	80 93 eb 00 	sts	0x00EB, r24
                                    const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
    4798:	10 92 ed 00 	sts	0x00ED, r1
	UECFG0X = UECFG0XData;
    479c:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
    47a0:	40 93 ed 00 	sts	0x00ED, r20
			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    47a4:	80 91 ee 00 	lds	r24, 0x00EE

	return Endpoint_IsConfigured();
}
    47a8:	88 1f       	adc	r24, r24
    47aa:	88 27       	eor	r24, r24
    47ac:	88 1f       	adc	r24, r24
    47ae:	08 95       	ret

000047b0 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    47b0:	80 91 d6 0c 	lds	r24, 0x0CD6
    47b4:	88 23       	and	r24, r24
    47b6:	9c f4       	brge	.+38     	; 0x47de <Endpoint_ClearStatusStage+0x2e>
    47b8:	04 c0       	rjmp	.+8      	; 0x47c2 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    47ba:	80 91 d5 0c 	lds	r24, 0x0CD5
    47be:	88 23       	and	r24, r24
    47c0:	b9 f0       	breq	.+46     	; 0x47f0 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    47c2:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    47c6:	82 ff       	sbrs	r24, 2
    47c8:	f8 cf       	rjmp	.-16     	; 0x47ba <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    47ca:	80 91 e8 00 	lds	r24, 0x00E8
    47ce:	8b 77       	andi	r24, 0x7B	; 123
    47d0:	80 93 e8 00 	sts	0x00E8, r24
    47d4:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    47d6:	80 91 d5 0c 	lds	r24, 0x0CD5
    47da:	88 23       	and	r24, r24
    47dc:	49 f0       	breq	.+18     	; 0x47f0 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    47de:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    47e2:	80 ff       	sbrs	r24, 0
    47e4:	f8 cf       	rjmp	.-16     	; 0x47d6 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    47e6:	80 91 e8 00 	lds	r24, 0x00E8
    47ea:	8e 77       	andi	r24, 0x7E	; 126
    47ec:	80 93 e8 00 	sts	0x00E8, r24
    47f0:	08 95       	ret

000047f2 <Endpoint_WaitUntilReady>:
			/** Returns the current USB frame number, when in device mode. Every millisecond the USB bus is active (i.e. enumerated to a host)
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    47f2:	40 91 e4 00 	lds	r20, 0x00E4
    47f6:	50 91 e5 00 	lds	r21, 0x00E5
    47fa:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    47fc:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    4800:	80 ff       	sbrs	r24, 0
    4802:	05 c0       	rjmp	.+10     	; 0x480e <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4804:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    4808:	80 ff       	sbrs	r24, 0
    480a:	05 c0       	rjmp	.+10     	; 0x4816 <Endpoint_WaitUntilReady+0x24>
    480c:	22 c0       	rjmp	.+68     	; 0x4852 <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    480e:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    4812:	82 fd       	sbrc	r24, 2
    4814:	1e c0       	rjmp	.+60     	; 0x4852 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4816:	80 91 d5 0c 	lds	r24, 0x0CD5

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    481a:	88 23       	and	r24, r24
    481c:	11 f4       	brne	.+4      	; 0x4822 <Endpoint_WaitUntilReady+0x30>
    481e:	82 e0       	ldi	r24, 0x02	; 2
    4820:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4822:	85 30       	cpi	r24, 0x05	; 5
    4824:	11 f4       	brne	.+4      	; 0x482a <Endpoint_WaitUntilReady+0x38>
    4826:	83 e0       	ldi	r24, 0x03	; 3
    4828:	08 95       	ret
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    482a:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    482e:	85 ff       	sbrs	r24, 5
    4830:	02 c0       	rjmp	.+4      	; 0x4836 <Endpoint_WaitUntilReady+0x44>
    4832:	81 e0       	ldi	r24, 0x01	; 1
    4834:	08 95       	ret
    4836:	80 91 e4 00 	lds	r24, 0x00E4
    483a:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    483e:	84 17       	cp	r24, r20
    4840:	95 07       	cpc	r25, r21
    4842:	e1 f2       	breq	.-72     	; 0x47fc <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    4844:	22 23       	and	r18, r18
    4846:	11 f4       	brne	.+4      	; 0x484c <Endpoint_WaitUntilReady+0x5a>
    4848:	84 e0       	ldi	r24, 0x04	; 4
    484a:	08 95       	ret
    484c:	21 50       	subi	r18, 0x01	; 1
    484e:	ac 01       	movw	r20, r24
    4850:	d5 cf       	rjmp	.-86     	; 0x47fc <Endpoint_WaitUntilReady+0xa>
    4852:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    4854:	08 95       	ret

00004856 <USB_Host_WaitMS>:
		USB_ResetInterface();
	}
}

uint8_t USB_Host_WaitMS(uint8_t MS)
{
    4856:	98 2f       	mov	r25, r24
			 *  \return Boolean true if the bus is currently suspended, false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    4858:	20 91 9e 00 	lds	r18, 0x009E
	bool    BusSuspended = USB_Host_IsBusSuspended();
	uint8_t ErrorCode    = HOST_WAITERROR_Successful;
	bool    HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);
    485c:	30 91 a0 00 	lds	r19, 0x00A0

	USB_INT_Disable(USB_INT_HSOFI);
    4860:	80 91 a0 00 	lds	r24, 0x00A0
    4864:	8f 7d       	andi	r24, 0xDF	; 223
    4866:	80 93 a0 00 	sts	0x00A0, r24
	USB_INT_Clear(USB_INT_HSOFI);
    486a:	80 91 9f 00 	lds	r24, 0x009F
    486e:	8f 7d       	andi	r24, 0xDF	; 223
    4870:	80 93 9f 00 	sts	0x009F, r24
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4874:	80 91 9e 00 	lds	r24, 0x009E
    4878:	81 60       	ori	r24, 0x01	; 1
    487a:	80 93 9e 00 	sts	0x009E, r24
    487e:	28 c0       	rjmp	.+80     	; 0x48d0 <USB_Host_WaitMS+0x7a>

	USB_Host_ResumeBus();

	while (MS)
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4880:	80 91 9f 00 	lds	r24, 0x009F
    4884:	85 ff       	sbrs	r24, 5
    4886:	06 c0       	rjmp	.+12     	; 0x4894 <USB_Host_WaitMS+0x3e>
		{
			USB_INT_Clear(USB_INT_HSOFI);
    4888:	80 91 9f 00 	lds	r24, 0x009F
    488c:	8f 7d       	andi	r24, 0xDF	; 223
    488e:	80 93 9f 00 	sts	0x009F, r24
			MS--;
    4892:	91 50       	subi	r25, 0x01	; 1
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
    4894:	80 91 de 0c 	lds	r24, 0x0CDE
    4898:	82 30       	cpi	r24, 0x02	; 2
    489a:	e9 f0       	breq	.+58     	; 0x48d6 <USB_Host_WaitMS+0x80>
    489c:	80 91 17 03 	lds	r24, 0x0317
    48a0:	82 30       	cpi	r24, 0x02	; 2
    48a2:	c9 f4       	brne	.+50     	; 0x48d6 <USB_Host_WaitMS+0x80>
			 *  \return Boolean true if an error has occurred on the selected pipe, false otherwise.
			 */
			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsError(void)
			{
				return ((UPINTX & (1 << PERRI)) ? true : false);
    48a4:	80 91 a6 00 	lds	r24, 0x00A6
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;

			break;
		}

		if (Pipe_IsError() == true)
    48a8:	84 ff       	sbrs	r24, 4
    48aa:	07 c0       	rjmp	.+14     	; 0x48ba <USB_Host_WaitMS+0x64>

			/** Clears the master pipe error flag. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPINTX &= ~(1 << PERRI);
    48ac:	80 91 a6 00 	lds	r24, 0x00A6
    48b0:	8f 7e       	andi	r24, 0xEF	; 239
    48b2:	80 93 a6 00 	sts	0x00A6, r24
    48b6:	92 e0       	ldi	r25, 0x02	; 2
    48b8:	0f c0       	rjmp	.+30     	; 0x48d8 <USB_Host_WaitMS+0x82>
			 *  \return Boolean true if the current pipe has been stalled by the attached device, false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    48ba:	80 91 a6 00 	lds	r24, 0x00A6
			ErrorCode = HOST_WAITERROR_PipeError;

			break;
		}

		if (Pipe_IsStalled() == true)
    48be:	81 ff       	sbrs	r24, 1
    48c0:	07 c0       	rjmp	.+14     	; 0x48d0 <USB_Host_WaitMS+0x7a>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearStall(void)
			{
				UPINTX &= ~(1 << RXSTALLI);
    48c2:	80 91 a6 00 	lds	r24, 0x00A6
    48c6:	8d 7f       	andi	r24, 0xFD	; 253
    48c8:	80 93 a6 00 	sts	0x00A6, r24
    48cc:	93 e0       	ldi	r25, 0x03	; 3
    48ce:	04 c0       	rjmp	.+8      	; 0x48d8 <USB_Host_WaitMS+0x82>
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    48d0:	99 23       	and	r25, r25
    48d2:	b1 f6       	brne	.-84     	; 0x4880 <USB_Host_WaitMS+0x2a>
    48d4:	01 c0       	rjmp	.+2      	; 0x48d8 <USB_Host_WaitMS+0x82>
    48d6:	91 e0       	ldi	r25, 0x01	; 1

			break;
		}
	}

	if (BusSuspended)
    48d8:	20 fd       	sbrc	r18, 0
    48da:	05 c0       	rjmp	.+10     	; 0x48e6 <USB_Host_WaitMS+0x90>
			 *  messages to the device.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    48dc:	80 91 9e 00 	lds	r24, 0x009E
    48e0:	8e 7f       	andi	r24, 0xFE	; 254
    48e2:	80 93 9e 00 	sts	0x009E, r24
	  USB_Host_SuspendBus();

	if (HSOFIEnabled)
    48e6:	35 ff       	sbrs	r19, 5
    48e8:	05 c0       	rjmp	.+10     	; 0x48f4 <USB_Host_WaitMS+0x9e>
	  USB_INT_Enable(USB_INT_HSOFI);
    48ea:	80 91 a0 00 	lds	r24, 0x00A0
    48ee:	80 62       	ori	r24, 0x20	; 32
    48f0:	80 93 a0 00 	sts	0x00A0, r24

	return ErrorCode;
}
    48f4:	89 2f       	mov	r24, r25
    48f6:	08 95       	ret

000048f8 <USB_Host_ResetDevice>:
			 *  \return Boolean true if the bus is currently suspended, false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    48f8:	60 91 9e 00 	lds	r22, 0x009E

static void USB_Host_ResetDevice(void)
{
	bool BusSuspended = USB_Host_IsBusSuspended();

	USB_INT_Disable(USB_INT_DDISCI);
    48fc:	80 91 a0 00 	lds	r24, 0x00A0
    4900:	8d 7f       	andi	r24, 0xFD	; 253
    4902:	80 93 a0 00 	sts	0x00A0, r24
			 *  woken up automatically and the bus resumed after the reset has been correctly issued.
			 */
			static inline void USB_Host_ResetBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResetBus(void)
			{
				UHCON |=  (1 << RESET);
    4906:	80 91 9e 00 	lds	r24, 0x009E
    490a:	82 60       	ori	r24, 0x02	; 2
    490c:	80 93 9e 00 	sts	0x009E, r24
			 *  \return Boolean true if no bus reset is currently being sent, false otherwise.
			 */
			static inline bool USB_Host_IsBusResetComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusResetComplete(void)
			{
				return ((UHCON & (1 << RESET)) ? false : true);
    4910:	80 91 9e 00 	lds	r24, 0x009E

	USB_Host_ResetBus();
	while (!(USB_Host_IsBusResetComplete()));
    4914:	81 fd       	sbrc	r24, 1
    4916:	fc cf       	rjmp	.-8      	; 0x4910 <USB_Host_ResetDevice+0x18>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4918:	80 91 9e 00 	lds	r24, 0x009E
    491c:	81 60       	ori	r24, 0x01	; 1
    491e:	80 93 9e 00 	sts	0x009E, r24
	USB_Host_ResumeBus();

	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);
    4922:	30 91 a0 00 	lds	r19, 0x00A0

	USB_INT_Disable(USB_INT_HSOFI);
    4926:	80 91 a0 00 	lds	r24, 0x00A0
    492a:	8f 7d       	andi	r24, 0xDF	; 223
    492c:	80 93 a0 00 	sts	0x00A0, r24
	USB_INT_Clear(USB_INT_HSOFI);
    4930:	80 91 9f 00 	lds	r24, 0x009F
    4934:	8f 7d       	andi	r24, 0xDF	; 223
    4936:	80 93 9f 00 	sts	0x009F, r24
    493a:	2a e0       	ldi	r18, 0x0A	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    493c:	40 ed       	ldi	r20, 0xD0	; 208
    493e:	57 e0       	ldi	r21, 0x07	; 7
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4940:	80 91 9f 00 	lds	r24, 0x009F
    4944:	85 ff       	sbrs	r24, 5
    4946:	0b c0       	rjmp	.+22     	; 0x495e <USB_Host_ResetDevice+0x66>
		{
			USB_INT_Clear(USB_INT_HSOFI);
    4948:	80 91 9f 00 	lds	r24, 0x009F
    494c:	8f 7d       	andi	r24, 0xDF	; 223
    494e:	80 93 9f 00 	sts	0x009F, r24
			USB_INT_Clear(USB_INT_DDISCI);
    4952:	80 91 9f 00 	lds	r24, 0x009F
    4956:	8d 7f       	andi	r24, 0xFD	; 253
    4958:	80 93 9f 00 	sts	0x009F, r24
    495c:	05 c0       	rjmp	.+10     	; 0x4968 <USB_Host_ResetDevice+0x70>
    495e:	ca 01       	movw	r24, r20
    4960:	01 97       	sbiw	r24, 0x01	; 1
    4962:	f1 f7       	brne	.-4      	; 0x4960 <USB_Host_ResetDevice+0x68>
	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);

	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    4964:	21 50       	subi	r18, 0x01	; 1
    4966:	61 f7       	brne	.-40     	; 0x4940 <USB_Host_ResetDevice+0x48>
		}

		_delay_ms(1);
	}

	if (HSOFIEnabled)
    4968:	35 ff       	sbrs	r19, 5
    496a:	05 c0       	rjmp	.+10     	; 0x4976 <USB_Host_ResetDevice+0x7e>
	  USB_INT_Enable(USB_INT_HSOFI);
    496c:	80 91 a0 00 	lds	r24, 0x00A0
    4970:	80 62       	ori	r24, 0x20	; 32
    4972:	80 93 a0 00 	sts	0x00A0, r24

	if (BusSuspended)
    4976:	60 fd       	sbrc	r22, 0
    4978:	05 c0       	rjmp	.+10     	; 0x4984 <USB_Host_ResetDevice+0x8c>
			 *  messages to the device.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    497a:	80 91 9e 00 	lds	r24, 0x009E
    497e:	8e 7f       	andi	r24, 0xFE	; 254
    4980:	80 93 9e 00 	sts	0x009E, r24
	  USB_Host_SuspendBus();

	USB_INT_Enable(USB_INT_DDISCI);
    4984:	80 91 a0 00 	lds	r24, 0x00A0
    4988:	82 60       	ori	r24, 0x02	; 2
    498a:	80 93 a0 00 	sts	0x00A0, r24
}
    498e:	08 95       	ret

00004990 <USB_Host_SetDeviceConfiguration>:

uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber)
{
	USB_ControlRequest = (USB_Request_Header_t)
    4990:	10 92 d6 0c 	sts	0x0CD6, r1
    4994:	99 e0       	ldi	r25, 0x09	; 9
    4996:	90 93 d7 0c 	sts	0x0CD7, r25
    499a:	80 93 d8 0c 	sts	0x0CD8, r24
    499e:	10 92 d9 0c 	sts	0x0CD9, r1
    49a2:	10 92 db 0c 	sts	0x0CDB, r1
    49a6:	10 92 da 0c 	sts	0x0CDA, r1
    49aa:	10 92 dd 0c 	sts	0x0CDD, r1
    49ae:	10 92 dc 0c 	sts	0x0CDC, r1
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    49b2:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = 0,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(NULL);
    49b6:	80 e0       	ldi	r24, 0x00	; 0
    49b8:	90 e0       	ldi	r25, 0x00	; 0
    49ba:	0c 94 e4 2d 	jmp	0x5bc8	; 0x5bc8 <USB_Host_SendControlRequest>

000049be <USB_Host_ProcessNextHostState>:

#define  __INCLUDE_FROM_HOST_C
#include "Host.h"

void USB_Host_ProcessNextHostState(void)
{
    49be:	ef 92       	push	r14
    49c0:	0f 93       	push	r16
    49c2:	1f 93       	push	r17
    49c4:	df 93       	push	r29
    49c6:	cf 93       	push	r28
    49c8:	cd b7       	in	r28, 0x3d	; 61
    49ca:	de b7       	in	r29, 0x3e	; 62
    49cc:	28 97       	sbiw	r28, 0x08	; 8
    49ce:	0f b6       	in	r0, 0x3f	; 63
    49d0:	f8 94       	cli
    49d2:	de bf       	out	0x3e, r29	; 62
    49d4:	0f be       	out	0x3f, r0	; 63
    49d6:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    49d8:	80 91 de 0c 	lds	r24, 0x0CDE
    49dc:	86 30       	cpi	r24, 0x06	; 6
    49de:	09 f4       	brne	.+2      	; 0x49e2 <USB_Host_ProcessNextHostState+0x24>
    49e0:	94 c0       	rjmp	.+296    	; 0x4b0a <USB_Host_ProcessNextHostState+0x14c>
    49e2:	87 30       	cpi	r24, 0x07	; 7
    49e4:	70 f4       	brcc	.+28     	; 0x4a02 <USB_Host_ProcessNextHostState+0x44>
    49e6:	83 30       	cpi	r24, 0x03	; 3
    49e8:	c1 f1       	breq	.+112    	; 0x4a5a <USB_Host_ProcessNextHostState+0x9c>
    49ea:	84 30       	cpi	r24, 0x04	; 4
    49ec:	20 f4       	brcc	.+8      	; 0x49f6 <USB_Host_ProcessNextHostState+0x38>
    49ee:	81 30       	cpi	r24, 0x01	; 1
    49f0:	09 f0       	breq	.+2      	; 0x49f4 <USB_Host_ProcessNextHostState+0x36>
    49f2:	0c c1       	rjmp	.+536    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
    49f4:	13 c0       	rjmp	.+38     	; 0x4a1c <USB_Host_ProcessNextHostState+0x5e>
    49f6:	84 30       	cpi	r24, 0x04	; 4
    49f8:	c1 f1       	breq	.+112    	; 0x4a6a <USB_Host_ProcessNextHostState+0xac>
    49fa:	85 30       	cpi	r24, 0x05	; 5
    49fc:	09 f0       	breq	.+2      	; 0x4a00 <USB_Host_ProcessNextHostState+0x42>
    49fe:	06 c1       	rjmp	.+524    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
    4a00:	5b c0       	rjmp	.+182    	; 0x4ab8 <USB_Host_ProcessNextHostState+0xfa>
    4a02:	88 30       	cpi	r24, 0x08	; 8
    4a04:	09 f4       	brne	.+2      	; 0x4a08 <USB_Host_ProcessNextHostState+0x4a>
    4a06:	9b c0       	rjmp	.+310    	; 0x4b3e <USB_Host_ProcessNextHostState+0x180>
    4a08:	88 30       	cpi	r24, 0x08	; 8
    4a0a:	08 f4       	brcc	.+2      	; 0x4a0e <USB_Host_ProcessNextHostState+0x50>
    4a0c:	8a c0       	rjmp	.+276    	; 0x4b22 <USB_Host_ProcessNextHostState+0x164>
    4a0e:	89 30       	cpi	r24, 0x09	; 9
    4a10:	09 f4       	brne	.+2      	; 0x4a14 <USB_Host_ProcessNextHostState+0x56>
    4a12:	b5 c0       	rjmp	.+362    	; 0x4b7e <USB_Host_ProcessNextHostState+0x1c0>
    4a14:	8a 30       	cpi	r24, 0x0A	; 10
    4a16:	09 f0       	breq	.+2      	; 0x4a1a <USB_Host_ProcessNextHostState+0x5c>
    4a18:	f9 c0       	rjmp	.+498    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
    4a1a:	db c0       	rjmp	.+438    	; 0x4bd2 <USB_Host_ProcessNextHostState+0x214>
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    4a1c:	00 91 15 03 	lds	r16, 0x0315
    4a20:	10 91 16 03 	lds	r17, 0x0316
    4a24:	01 15       	cp	r16, r1
    4a26:	11 05       	cpc	r17, r1
    4a28:	09 f4       	brne	.+2      	; 0x4a2c <USB_Host_ProcessNextHostState+0x6e>
    4a2a:	f0 c0       	rjmp	.+480    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    4a2c:	81 e0       	ldi	r24, 0x01	; 1
    4a2e:	13 df       	rcall	.-474    	; 0x4856 <USB_Host_WaitMS>
    4a30:	68 2f       	mov	r22, r24
    4a32:	88 23       	and	r24, r24
    4a34:	31 f0       	breq	.+12     	; 0x4a42 <USB_Host_ProcessNextHostState+0x84>
				{
					USB_HostState = PostWaitState;
    4a36:	80 91 14 03 	lds	r24, 0x0314
    4a3a:	80 93 de 0c 	sts	0x0CDE, r24
    4a3e:	91 e0       	ldi	r25, 0x01	; 1
    4a40:	e1 c0       	rjmp	.+450    	; 0x4c04 <USB_Host_ProcessNextHostState+0x246>
					ErrorCode     = HOST_ENUMERROR_WaitStage;
					break;
				}

				if (!(--WaitMSRemaining))
    4a42:	c8 01       	movw	r24, r16
    4a44:	01 97       	sbiw	r24, 0x01	; 1
    4a46:	90 93 16 03 	sts	0x0316, r25
    4a4a:	80 93 15 03 	sts	0x0315, r24
    4a4e:	89 2b       	or	r24, r25
    4a50:	09 f0       	breq	.+2      	; 0x4a54 <USB_Host_ProcessNextHostState+0x96>
    4a52:	dc c0       	rjmp	.+440    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
				  USB_HostState = PostWaitState;
    4a54:	80 91 14 03 	lds	r24, 0x0314
    4a58:	c2 c0       	rjmp	.+388    	; 0x4bde <USB_Host_ProcessNextHostState+0x220>
			}

			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    4a5a:	88 ee       	ldi	r24, 0xE8	; 232
    4a5c:	93 e0       	ldi	r25, 0x03	; 3
    4a5e:	90 93 16 03 	sts	0x0316, r25
    4a62:	80 93 15 03 	sts	0x0315, r24

			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    4a66:	84 e0       	ldi	r24, 0x04	; 4
    4a68:	ba c0       	rjmp	.+372    	; 0x4bde <USB_Host_ProcessNextHostState+0x220>
			break;
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    4a6a:	80 91 15 03 	lds	r24, 0x0315
    4a6e:	90 91 16 03 	lds	r25, 0x0316
    4a72:	01 97       	sbiw	r24, 0x01	; 1
    4a74:	90 93 16 03 	sts	0x0316, r25
    4a78:	80 93 15 03 	sts	0x0315, r24
    4a7c:	01 96       	adiw	r24, 0x01	; 1
    4a7e:	29 f0       	breq	.+10     	; 0x4a8a <USB_Host_ProcessNextHostState+0xcc>
    4a80:	80 ed       	ldi	r24, 0xD0	; 208
    4a82:	97 e0       	ldi	r25, 0x07	; 7
    4a84:	01 97       	sbiw	r24, 0x01	; 1
    4a86:	f1 f7       	brne	.-4      	; 0x4a84 <USB_Host_ProcessNextHostState+0xc6>
    4a88:	c1 c0       	rjmp	.+386    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
			}

			static inline void USB_Host_VBUS_Manual_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				PORTE  &= ~(1 << 7);
    4a8a:	77 98       	cbi	0x0e, 7	; 14

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    4a8c:	80 91 d8 00 	lds	r24, 0x00D8
    4a90:	80 61       	ori	r24, 0x10	; 16
    4a92:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_Host_VBUS_Auto_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Enable(void)
			{
				OTGCON &= ~(1 << VBUSHWC);
    4a96:	80 91 dd 00 	lds	r24, 0x00DD
    4a9a:	8b 7f       	andi	r24, 0xFB	; 251
    4a9c:	80 93 dd 00 	sts	0x00DD, r24
				UHWCON |=  (1 << UVCONE);
    4aa0:	80 91 d7 00 	lds	r24, 0x00D7
    4aa4:	80 61       	ori	r24, 0x10	; 16
    4aa6:	80 93 d7 00 	sts	0x00D7, r24
			}

			static inline void USB_Host_VBUS_Auto_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_On(void)
			{
				OTGCON |=  (1 << VBUSREQ);
    4aaa:	80 91 dd 00 	lds	r24, 0x00DD
    4aae:	82 60       	ori	r24, 0x02	; 2
    4ab0:	80 93 dd 00 	sts	0x00DD, r24

				USB_OTGPAD_On();
				USB_Host_VBUS_Auto_Enable();
				USB_Host_VBUS_Auto_On();

				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    4ab4:	85 e0       	ldi	r24, 0x05	; 5
    4ab6:	93 c0       	rjmp	.+294    	; 0x4bde <USB_Host_ProcessNextHostState+0x220>
			}

			break;
		case HOST_STATE_Powered_WaitForConnect:
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    4ab8:	80 91 9f 00 	lds	r24, 0x009F
    4abc:	80 ff       	sbrs	r24, 0
    4abe:	a6 c0       	rjmp	.+332    	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
			{
				USB_INT_Clear(USB_INT_DCONNI);
    4ac0:	80 91 9f 00 	lds	r24, 0x009F
    4ac4:	8e 7f       	andi	r24, 0xFE	; 254
    4ac6:	80 93 9f 00 	sts	0x009F, r24
				USB_INT_Clear(USB_INT_DDISCI);
    4aca:	80 91 9f 00 	lds	r24, 0x009F
    4ace:	8d 7f       	andi	r24, 0xFD	; 253
    4ad0:	80 93 9f 00 	sts	0x009F, r24

				USB_INT_Clear(USB_INT_VBERRI);
    4ad4:	80 91 df 00 	lds	r24, 0x00DF
    4ad8:	8d 7f       	andi	r24, 0xFD	; 253
    4ada:	80 93 df 00 	sts	0x00DF, r24
				USB_INT_Enable(USB_INT_VBERRI);
    4ade:	80 91 de 00 	lds	r24, 0x00DE
    4ae2:	82 60       	ori	r24, 0x02	; 2
    4ae4:	80 93 de 00 	sts	0x00DE, r24
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4ae8:	80 91 9e 00 	lds	r24, 0x009E
    4aec:	81 60       	ori	r24, 0x01	; 1
    4aee:	80 93 9e 00 	sts	0x009E, r24

				USB_Host_ResumeBus();
				Pipe_ClearPipes();
    4af2:	ce d0       	rcall	.+412    	; 0x4c90 <Pipe_ClearPipes>

				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    4af4:	81 e0       	ldi	r24, 0x01	; 1
    4af6:	80 93 de 0c 	sts	0x0CDE, r24
    4afa:	84 e6       	ldi	r24, 0x64	; 100
    4afc:	90 e0       	ldi	r25, 0x00	; 0
    4afe:	90 93 16 03 	sts	0x0316, r25
    4b02:	80 93 15 03 	sts	0x0315, r24
    4b06:	86 e0       	ldi	r24, 0x06	; 6
    4b08:	61 c0       	rjmp	.+194    	; 0x4bcc <USB_Host_ProcessNextHostState+0x20e>
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    4b0a:	f6 de       	rcall	.-532    	; 0x48f8 <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    4b0c:	81 e0       	ldi	r24, 0x01	; 1
    4b0e:	80 93 de 0c 	sts	0x0CDE, r24
    4b12:	88 ec       	ldi	r24, 0xC8	; 200
    4b14:	90 e0       	ldi	r25, 0x00	; 0
    4b16:	90 93 16 03 	sts	0x0316, r25
    4b1a:	80 93 15 03 	sts	0x0315, r24
    4b1e:	87 e0       	ldi	r24, 0x07	; 7
    4b20:	55 c0       	rjmp	.+170    	; 0x4bcc <USB_Host_ProcessNextHostState+0x20e>
			break;
		case HOST_STATE_Powered_ConfigPipe:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    4b22:	80 e0       	ldi	r24, 0x00	; 0
    4b24:	60 e0       	ldi	r22, 0x00	; 0
    4b26:	40 e0       	ldi	r20, 0x00	; 0
    4b28:	20 e0       	ldi	r18, 0x00	; 0
    4b2a:	00 e4       	ldi	r16, 0x40	; 64
    4b2c:	10 e0       	ldi	r17, 0x00	; 0
    4b2e:	ee 24       	eor	r14, r14
    4b30:	79 d0       	rcall	.+242    	; 0x4c24 <Pipe_ConfigurePipe>
			 *  \return Boolean true if the selected pipe is configured, false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    4b32:	80 91 ac 00 	lds	r24, 0x00AC
							   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
							   PIPE_CONTROLPIPE_DEFAULT_SIZE, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    4b36:	87 ff       	sbrs	r24, 7
    4b38:	63 c0       	rjmp	.+198    	; 0x4c00 <USB_Host_ProcessNextHostState+0x242>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    4b3a:	88 e0       	ldi	r24, 0x08	; 8
    4b3c:	50 c0       	rjmp	.+160    	; 0x4bde <USB_Host_ProcessNextHostState+0x220>
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    4b3e:	a6 ed       	ldi	r26, 0xD6	; 214
    4b40:	bc e0       	ldi	r27, 0x0C	; 12
    4b42:	e3 e9       	ldi	r30, 0x93	; 147
    4b44:	f2 e0       	ldi	r31, 0x02	; 2
    4b46:	88 e0       	ldi	r24, 0x08	; 8
    4b48:	01 90       	ld	r0, Z+
    4b4a:	0d 92       	st	X+, r0
    4b4c:	81 50       	subi	r24, 0x01	; 1
    4b4e:	e1 f7       	brne	.-8      	; 0x4b48 <USB_Host_ProcessNextHostState+0x18a>
					.wLength       = 8,
				};

			uint8_t DataBuffer[8];

			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    4b50:	ce 01       	movw	r24, r28
    4b52:	01 96       	adiw	r24, 0x01	; 1
    4b54:	0e 94 e4 2d 	call	0x5bc8	; 0x5bc8 <USB_Host_SendControlRequest>
    4b58:	68 2f       	mov	r22, r24
    4b5a:	88 23       	and	r24, r24
    4b5c:	09 f0       	breq	.+2      	; 0x4b60 <USB_Host_ProcessNextHostState+0x1a2>
    4b5e:	4e c0       	rjmp	.+156    	; 0x4bfc <USB_Host_ProcessNextHostState+0x23e>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    4b60:	88 85       	ldd	r24, Y+8	; 0x08
    4b62:	80 93 9b 02 	sts	0x029B, r24

			USB_Host_ResetDevice();
    4b66:	c8 de       	rcall	.-624    	; 0x48f8 <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    4b68:	81 e0       	ldi	r24, 0x01	; 1
    4b6a:	80 93 de 0c 	sts	0x0CDE, r24
    4b6e:	88 ec       	ldi	r24, 0xC8	; 200
    4b70:	90 e0       	ldi	r25, 0x00	; 0
    4b72:	90 93 16 03 	sts	0x0316, r25
    4b76:	80 93 15 03 	sts	0x0315, r24
    4b7a:	89 e0       	ldi	r24, 0x09	; 9
    4b7c:	27 c0       	rjmp	.+78     	; 0x4bcc <USB_Host_ProcessNextHostState+0x20e>
			break;
		case HOST_STATE_Default_PostReset:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    4b7e:	00 91 9b 02 	lds	r16, 0x029B
    4b82:	80 e0       	ldi	r24, 0x00	; 0
    4b84:	60 e0       	ldi	r22, 0x00	; 0
    4b86:	40 e0       	ldi	r20, 0x00	; 0
    4b88:	20 e0       	ldi	r18, 0x00	; 0
    4b8a:	10 e0       	ldi	r17, 0x00	; 0
    4b8c:	ee 24       	eor	r14, r14
    4b8e:	4a d0       	rcall	.+148    	; 0x4c24 <Pipe_ConfigurePipe>
    4b90:	80 91 ac 00 	lds	r24, 0x00AC
			                   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
			                   USB_ControlPipeSize, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    4b94:	87 ff       	sbrs	r24, 7
    4b96:	34 c0       	rjmp	.+104    	; 0x4c00 <USB_Host_ProcessNextHostState+0x242>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    4b98:	a6 ed       	ldi	r26, 0xD6	; 214
    4b9a:	bc e0       	ldi	r27, 0x0C	; 12
    4b9c:	eb e8       	ldi	r30, 0x8B	; 139
    4b9e:	f2 e0       	ldi	r31, 0x02	; 2
    4ba0:	88 e0       	ldi	r24, 0x08	; 8
    4ba2:	01 90       	ld	r0, Z+
    4ba4:	0d 92       	st	X+, r0
    4ba6:	81 50       	subi	r24, 0x01	; 1
    4ba8:	e1 f7       	brne	.-8      	; 0x4ba2 <USB_Host_ProcessNextHostState+0x1e4>
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    4baa:	80 e0       	ldi	r24, 0x00	; 0
    4bac:	90 e0       	ldi	r25, 0x00	; 0
    4bae:	0e 94 e4 2d 	call	0x5bc8	; 0x5bc8 <USB_Host_SendControlRequest>
    4bb2:	68 2f       	mov	r22, r24
    4bb4:	88 23       	and	r24, r24
    4bb6:	11 f5       	brne	.+68     	; 0x4bfc <USB_Host_ProcessNextHostState+0x23e>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    4bb8:	81 e0       	ldi	r24, 0x01	; 1
    4bba:	80 93 de 0c 	sts	0x0CDE, r24
    4bbe:	84 e6       	ldi	r24, 0x64	; 100
    4bc0:	90 e0       	ldi	r25, 0x00	; 0
    4bc2:	90 93 16 03 	sts	0x0316, r25
    4bc6:	80 93 15 03 	sts	0x0315, r24
    4bca:	8a e0       	ldi	r24, 0x0A	; 10
    4bcc:	80 93 14 03 	sts	0x0314, r24
    4bd0:	1d c0       	rjmp	.+58     	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
			}

			static inline void USB_Host_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SetDeviceAddress(const uint8_t Address)
			{
				UHADDR  =  (Address & 0x7F);
    4bd2:	81 e0       	ldi	r24, 0x01	; 1
    4bd4:	80 93 a1 00 	sts	0x00A1, r24
			break;
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);

			EVENT_USB_Host_DeviceEnumerationComplete();
    4bd8:	0e 94 79 02 	call	0x4f2	; 0x4f2 <EVENT_USB_Host_DeviceEnumerationComplete>
			USB_HostState = HOST_STATE_Addressed;
    4bdc:	8b e0       	ldi	r24, 0x0B	; 11
    4bde:	80 93 de 0c 	sts	0x0CDE, r24
    4be2:	14 c0       	rjmp	.+40     	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    4be4:	89 2f       	mov	r24, r25
    4be6:	0e 94 7e 02 	call	0x4fc	; 0x4fc <EVENT_USB_Host_DeviceEnumerationFailed>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    4bea:	80 91 dd 00 	lds	r24, 0x00DD
    4bee:	81 60       	ori	r24, 0x01	; 1
    4bf0:	80 93 dd 00 	sts	0x00DD, r24

		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_DeviceUnattached();
    4bf4:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    4bf8:	d4 d0       	rcall	.+424    	; 0x4da2 <USB_ResetInterface>
    4bfa:	08 c0       	rjmp	.+16     	; 0x4c0c <USB_Host_ProcessNextHostState+0x24e>
	}
}
    4bfc:	93 e0       	ldi	r25, 0x03	; 3
    4bfe:	02 c0       	rjmp	.+4      	; 0x4c04 <USB_Host_ProcessNextHostState+0x246>
    4c00:	94 e0       	ldi	r25, 0x04	; 4
    4c02:	60 e0       	ldi	r22, 0x00	; 0
			EVENT_USB_Host_DeviceEnumerationComplete();
			USB_HostState = HOST_STATE_Addressed;
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    4c04:	80 91 de 0c 	lds	r24, 0x0CDE
    4c08:	82 30       	cpi	r24, 0x02	; 2
    4c0a:	61 f7       	brne	.-40     	; 0x4be4 <USB_Host_ProcessNextHostState+0x226>

		EVENT_USB_Host_DeviceUnattached();

		USB_ResetInterface();
	}
}
    4c0c:	28 96       	adiw	r28, 0x08	; 8
    4c0e:	0f b6       	in	r0, 0x3f	; 63
    4c10:	f8 94       	cli
    4c12:	de bf       	out	0x3e, r29	; 62
    4c14:	0f be       	out	0x3f, r0	; 63
    4c16:	cd bf       	out	0x3d, r28	; 61
    4c18:	cf 91       	pop	r28
    4c1a:	df 91       	pop	r29
    4c1c:	1f 91       	pop	r17
    4c1e:	0f 91       	pop	r16
    4c20:	ef 90       	pop	r14
    4c22:	08 95       	ret

00004c24 <Pipe_ConfigurePipe>:
                        const uint8_t Type,
                        const uint8_t Token,
                        const uint8_t EndpointNumber,
                        const uint16_t Size,
                        const uint8_t Banks)
{
    4c24:	ef 92       	push	r14
    4c26:	0f 93       	push	r16
    4c28:	1f 93       	push	r17
    4c2a:	9e 2d       	mov	r25, r14
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4c2c:	80 93 a7 00 	sts	0x00A7, r24
			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePipe().
			 */
			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_EnablePipe(void)
			{
				UPCONX |= (1 << PEN);
    4c30:	80 91 a9 00 	lds	r24, 0x00A9
    4c34:	81 60       	ori	r24, 0x01	; 1
    4c36:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_SelectPipe(Number);
	Pipe_EnablePipe();

	UPCFG1X = 0;
    4c3a:	10 92 ab 00 	sts	0x00AB, r1

	UPCFG0X = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
    4c3e:	62 95       	swap	r22
    4c40:	66 0f       	add	r22, r22
    4c42:	66 0f       	add	r22, r22
    4c44:	60 7c       	andi	r22, 0xC0	; 192
    4c46:	64 2b       	or	r22, r20
    4c48:	2f 70       	andi	r18, 0x0F	; 15
    4c4a:	62 2b       	or	r22, r18
    4c4c:	60 93 aa 00 	sts	0x00AA, r22
    4c50:	28 e0       	ldi	r18, 0x08	; 8
    4c52:	30 e0       	ldi	r19, 0x00	; 0
    4c54:	80 e0       	ldi	r24, 0x00	; 0
    4c56:	03 c0       	rjmp	.+6      	; 0x4c5e <Pipe_ConfigurePipe+0x3a>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
				{
					MaskVal++;
    4c58:	8f 5f       	subi	r24, 0xFF	; 255
					CheckBytes <<= 1;
    4c5a:	22 0f       	add	r18, r18
    4c5c:	33 1f       	adc	r19, r19
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    4c5e:	20 17       	cp	r18, r16
    4c60:	31 07       	cpc	r19, r17
    4c62:	10 f4       	brcc	.+4      	; 0x4c68 <Pipe_ConfigurePipe+0x44>
    4c64:	85 30       	cpi	r24, 0x05	; 5
    4c66:	c1 f7       	brne	.-16     	; 0x4c58 <Pipe_ConfigurePipe+0x34>
	UPCFG1X = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    4c68:	92 60       	ori	r25, 0x02	; 2
    4c6a:	82 95       	swap	r24
    4c6c:	80 7f       	andi	r24, 0xF0	; 240
    4c6e:	89 2b       	or	r24, r25
    4c70:	80 93 ab 00 	sts	0x00AB, r24

			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInfiniteINRequests(void)
			{
				UPCONX |= (1 << INMODE);
    4c74:	80 91 a9 00 	lds	r24, 0x00A9
    4c78:	80 62       	ori	r24, 0x20	; 32
    4c7a:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean true if the selected pipe is configured, false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    4c7e:	80 91 ac 00 	lds	r24, 0x00AC

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
}
    4c82:	88 1f       	adc	r24, r24
    4c84:	88 27       	eor	r24, r24
    4c86:	88 1f       	adc	r24, r24
    4c88:	1f 91       	pop	r17
    4c8a:	0f 91       	pop	r16
    4c8c:	ef 90       	pop	r14
    4c8e:	08 95       	ret

00004c90 <Pipe_ClearPipes>:

void Pipe_ClearPipes(void)
{
	UPINT = 0;
    4c90:	10 92 f8 00 	sts	0x00F8, r1
    4c94:	90 e0       	ldi	r25, 0x00	; 0
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4c96:	90 93 a7 00 	sts	0x00A7, r25

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_SelectPipe(PNum);
		UPIENX  = 0;
    4c9a:	10 92 ae 00 	sts	0x00AE, r1
		UPINTX  = 0;
    4c9e:	10 92 a6 00 	sts	0x00A6, r1
		UPCFG1X = 0;
    4ca2:	10 92 ab 00 	sts	0x00AB, r1
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    4ca6:	80 91 a9 00 	lds	r24, 0x00A9
    4caa:	8e 7f       	andi	r24, 0xFE	; 254
    4cac:	80 93 a9 00 	sts	0x00A9, r24

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    4cb0:	9f 5f       	subi	r25, 0xFF	; 255
    4cb2:	97 30       	cpi	r25, 0x07	; 7
    4cb4:	81 f7       	brne	.-32     	; 0x4c96 <Pipe_ClearPipes+0x6>
		UPIENX  = 0;
		UPINTX  = 0;
		UPCFG1X = 0;
		Pipe_DisablePipe();
	}
}
    4cb6:	08 95       	ret

00004cb8 <Pipe_IsEndpointBound>:

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
    4cb8:	e8 2f       	mov	r30, r24
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    4cba:	70 91 a7 00 	lds	r23, 0x00A7
    4cbe:	60 e0       	ldi	r22, 0x00	; 0
		bool    PipeTokenCorrect = true;

		if (PipeToken != PIPE_TOKEN_SETUP)
		  PipeTokenCorrect = (PipeToken == ((EndpointAddress & PIPE_EPDIR_MASK) ? PIPE_TOKEN_IN : PIPE_TOKEN_OUT));

		if (PipeTokenCorrect && (Pipe_BoundEndpointNumber() == (EndpointAddress & PIPE_EPNUM_MASK)))
    4cc0:	48 2f       	mov	r20, r24
    4cc2:	50 e0       	ldi	r21, 0x00	; 0
    4cc4:	4f 70       	andi	r20, 0x0F	; 15
    4cc6:	50 70       	andi	r21, 0x00	; 0
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4cc8:	60 93 a7 00 	sts	0x00A7, r22
			 *  \return Boolean true if the selected pipe is configured, false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    4ccc:	80 91 ac 00 	lds	r24, 0x00AC

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_SelectPipe(PNum);

		if (!(Pipe_IsConfigured()))
    4cd0:	87 ff       	sbrs	r24, 7
    4cd2:	18 c0       	rjmp	.+48     	; 0x4d04 <Pipe_IsEndpointBound+0x4c>
			 *  \return The current pipe token, as a PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    4cd4:	80 91 aa 00 	lds	r24, 0x00AA
    4cd8:	80 73       	andi	r24, 0x30	; 48
		  continue;

		uint8_t PipeToken        = Pipe_GetPipeToken();
		bool    PipeTokenCorrect = true;

		if (PipeToken != PIPE_TOKEN_SETUP)
    4cda:	59 f0       	breq	.+22     	; 0x4cf2 <Pipe_IsEndpointBound+0x3a>
		  PipeTokenCorrect = (PipeToken == ((EndpointAddress & PIPE_EPDIR_MASK) ? PIPE_TOKEN_IN : PIPE_TOKEN_OUT));
    4cdc:	e7 fd       	sbrc	r30, 7
    4cde:	03 c0       	rjmp	.+6      	; 0x4ce6 <Pipe_IsEndpointBound+0x2e>
    4ce0:	20 e2       	ldi	r18, 0x20	; 32
    4ce2:	30 e0       	ldi	r19, 0x00	; 0
    4ce4:	02 c0       	rjmp	.+4      	; 0x4cea <Pipe_IsEndpointBound+0x32>
    4ce6:	20 e1       	ldi	r18, 0x10	; 16
    4ce8:	30 e0       	ldi	r19, 0x00	; 0

		if (PipeTokenCorrect && (Pipe_BoundEndpointNumber() == (EndpointAddress & PIPE_EPNUM_MASK)))
    4cea:	90 e0       	ldi	r25, 0x00	; 0
    4cec:	82 17       	cp	r24, r18
    4cee:	93 07       	cpc	r25, r19
    4cf0:	49 f4       	brne	.+18     	; 0x4d04 <Pipe_IsEndpointBound+0x4c>
			 *  \return Endpoint number the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_BoundEndpointNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_BoundEndpointNumber(void)
			{
				return ((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK);
    4cf2:	80 91 aa 00 	lds	r24, 0x00AA
    4cf6:	8f 70       	andi	r24, 0x0F	; 15
    4cf8:	90 e0       	ldi	r25, 0x00	; 0
    4cfa:	84 17       	cp	r24, r20
    4cfc:	95 07       	cpc	r25, r21
    4cfe:	11 f4       	brne	.+4      	; 0x4d04 <Pipe_IsEndpointBound+0x4c>
    4d00:	81 e0       	ldi	r24, 0x01	; 1
    4d02:	08 95       	ret

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    4d04:	6f 5f       	subi	r22, 0xFF	; 255
    4d06:	67 30       	cpi	r22, 0x07	; 7
    4d08:	f9 f6       	brne	.-66     	; 0x4cc8 <Pipe_IsEndpointBound+0x10>
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    4d0a:	77 70       	andi	r23, 0x07	; 7
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4d0c:	70 93 a7 00 	sts	0x00A7, r23
    4d10:	80 e0       	ldi	r24, 0x00	; 0
		  return true;
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
}
    4d12:	08 95       	ret

00004d14 <Pipe_WaitUntilReady>:
			/** Returns the current USB frame number, when in host mode. Every millisecond the USB bus is active (i.e. not suspended)
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Host_GetFrameNumber(void)
			{
				return UHFNUM;
    4d14:	40 91 a2 00 	lds	r20, 0x00A2
    4d18:	50 91 a3 00 	lds	r21, 0x00A3
    4d1c:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The current pipe token, as a PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    4d1e:	80 91 aa 00 	lds	r24, 0x00AA

	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();

	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    4d22:	80 73       	andi	r24, 0x30	; 48
    4d24:	80 31       	cpi	r24, 0x10	; 16
    4d26:	29 f4       	brne	.+10     	; 0x4d32 <Pipe_WaitUntilReady+0x1e>
			 *  \return Boolean true if the current pipe has received an IN packet, false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    4d28:	80 91 a6 00 	lds	r24, 0x00A6
		{
			if (Pipe_IsINReceived())
    4d2c:	80 ff       	sbrs	r24, 0
    4d2e:	05 c0       	rjmp	.+10     	; 0x4d3a <Pipe_WaitUntilReady+0x26>
    4d30:	1c c0       	rjmp	.+56     	; 0x4d6a <Pipe_WaitUntilReady+0x56>
			 *  \return Boolean true if the current pipe is ready for an OUT packet, false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    4d32:	80 91 a6 00 	lds	r24, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    4d36:	82 fd       	sbrc	r24, 2
    4d38:	18 c0       	rjmp	.+48     	; 0x4d6a <Pipe_WaitUntilReady+0x56>
			 *  \return Boolean true if the current pipe has been stalled by the attached device, false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    4d3a:	80 91 a6 00 	lds	r24, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
    4d3e:	81 ff       	sbrs	r24, 1
    4d40:	02 c0       	rjmp	.+4      	; 0x4d46 <Pipe_WaitUntilReady+0x32>
    4d42:	81 e0       	ldi	r24, 0x01	; 1
    4d44:	08 95       	ret
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    4d46:	80 91 de 0c 	lds	r24, 0x0CDE
    4d4a:	82 30       	cpi	r24, 0x02	; 2
    4d4c:	79 f0       	breq	.+30     	; 0x4d6c <Pipe_WaitUntilReady+0x58>
    4d4e:	80 91 a2 00 	lds	r24, 0x00A2
    4d52:	90 91 a3 00 	lds	r25, 0x00A3
		  return PIPE_READYWAIT_DeviceDisconnected;

		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    4d56:	84 17       	cp	r24, r20
    4d58:	95 07       	cpc	r25, r21
    4d5a:	09 f3       	breq	.-62     	; 0x4d1e <Pipe_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    4d5c:	22 23       	and	r18, r18
    4d5e:	11 f4       	brne	.+4      	; 0x4d64 <Pipe_WaitUntilReady+0x50>
    4d60:	83 e0       	ldi	r24, 0x03	; 3
    4d62:	08 95       	ret
    4d64:	21 50       	subi	r18, 0x01	; 1
    4d66:	ac 01       	movw	r20, r24
    4d68:	da cf       	rjmp	.-76     	; 0x4d1e <Pipe_WaitUntilReady+0xa>
    4d6a:	80 e0       	ldi	r24, 0x00	; 0
			  return PIPE_READYWAIT_Timeout;
		}
	}
}
    4d6c:	08 95       	ret

00004d6e <USB_ShutDown>:
	USB_ResetInterface();
}

void USB_ShutDown(void)
{
	USB_INT_DisableAllInterrupts();
    4d6e:	cb d0       	rcall	.+406    	; 0x4f06 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    4d70:	d6 d0       	rcall	.+428    	; 0x4f1e <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    4d72:	e0 ee       	ldi	r30, 0xE0	; 224
    4d74:	f0 e0       	ldi	r31, 0x00	; 0
    4d76:	80 81       	ld	r24, Z
    4d78:	81 60       	ori	r24, 0x01	; 1
    4d7a:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON  &= ~(1 << USBE);
    4d7c:	a8 ed       	ldi	r26, 0xD8	; 216
    4d7e:	b0 e0       	ldi	r27, 0x00	; 0
    4d80:	8c 91       	ld	r24, X
    4d82:	8f 77       	andi	r24, 0x7F	; 127
    4d84:	8c 93       	st	X, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    4d86:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  &= ~(1 << UVREGE);
    4d88:	e7 ed       	ldi	r30, 0xD7	; 215
    4d8a:	f0 e0       	ldi	r31, 0x00	; 0
    4d8c:	80 81       	ld	r24, Z
    4d8e:	8e 7f       	andi	r24, 0xFE	; 254
    4d90:	80 83       	st	Z, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON  &= ~(1 << OTGPADE);
    4d92:	8c 91       	ld	r24, X
    4d94:	8f 7e       	andi	r24, 0xEF	; 239
    4d96:	8c 93       	st	X, r24
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
    4d98:	10 92 17 03 	sts	0x0317, r1
	#endif

	USB_IsInitialized = false;
    4d9c:	10 92 d4 0c 	sts	0x0CD4, r1
}
    4da0:	08 95       	ret

00004da2 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    4da2:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
    4da4:	10 91 d7 00 	lds	r17, 0x00D7
	#endif

	USB_INT_DisableAllInterrupts();
    4da8:	ae d0       	rcall	.+348    	; 0x4f06 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    4daa:	b9 d0       	rcall	.+370    	; 0x4f1e <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
    4dac:	80 91 d8 00 	lds	r24, 0x00D8

				USBCON = (Temp & ~(1 << USBE));
    4db0:	98 2f       	mov	r25, r24
    4db2:	9f 77       	andi	r25, 0x7F	; 127
    4db4:	90 93 d8 00 	sts	0x00D8, r25
				USBCON = (Temp |  (1 << USBE));
    4db8:	80 68       	ori	r24, 0x80	; 128
    4dba:	80 93 d8 00 	sts	0x00D8, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    4dbe:	8c e0       	ldi	r24, 0x0C	; 12
    4dc0:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    4dc2:	89 b5       	in	r24, 0x29	; 41
    4dc4:	82 60       	ori	r24, 0x02	; 2
    4dc6:	89 bd       	out	0x29, r24	; 41
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
    4dc8:	09 b4       	in	r0, 0x29	; 41
    4dca:	00 fe       	sbrs	r0, 0
    4dcc:	fd cf       	rjmp	.-6      	; 0x4dc8 <USB_ResetInterface+0x26>
	}

	#if defined(USB_CAN_BE_BOTH)
	if (UIDModeSelectEnabled)
    4dce:	16 ff       	sbrs	r17, 6
    4dd0:	0a c0       	rjmp	.+20     	; 0x4de6 <USB_ResetInterface+0x44>
	{
		UHWCON |= (1 << UIDE);
    4dd2:	80 91 d7 00 	lds	r24, 0x00D7
    4dd6:	80 64       	ori	r24, 0x40	; 64
    4dd8:	80 93 d7 00 	sts	0x00D7, r24
		USB_INT_Enable(USB_INT_IDTI);
    4ddc:	80 91 d8 00 	lds	r24, 0x00D8
    4de0:	82 60       	ori	r24, 0x02	; 2
    4de2:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    4de6:	80 91 d8 00 	lds	r24, 0x00D8
    4dea:	8f 7d       	andi	r24, 0xDF	; 223
    4dec:	80 93 d8 00 	sts	0x00D8, r24
	}
	#endif

	USB_CLK_Unfreeze();

	if (USB_CurrentMode == USB_MODE_Device)
    4df0:	80 91 17 03 	lds	r24, 0x0317
    4df4:	81 30       	cpi	r24, 0x01	; 1
    4df6:	59 f5       	brne	.+86     	; 0x4e4e <USB_ResetInterface+0xac>
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    4df8:	80 91 d7 00 	lds	r24, 0x00D7
    4dfc:	80 68       	ori	r24, 0x80	; 128
    4dfe:	80 93 d7 00 	sts	0x00D7, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
    4e02:	10 92 d5 0c 	sts	0x0CD5, r1
	USB_ConfigurationNumber  = 0;
    4e06:	10 92 d3 0c 	sts	0x0CD3, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
    4e0a:	10 92 d2 0c 	sts	0x0CD2, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
    4e0e:	10 92 d1 0c 	sts	0x0CD1, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    4e12:	80 91 e0 00 	lds	r24, 0x00E0
    4e16:	8b 7f       	andi	r24, 0xFB	; 251
    4e18:	80 93 e0 00 	sts	0x00E0, r24
	if (USB_Options & USB_DEVICE_OPT_LOWSPEED)
	  USB_Device_SetLowSpeed();
	else
	  USB_Device_SetFullSpeed();

	USB_INT_Enable(USB_INT_VBUS);
    4e1c:	80 91 d8 00 	lds	r24, 0x00D8
    4e20:	81 60       	ori	r24, 0x01	; 1
    4e22:	80 93 d8 00 	sts	0x00D8, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    4e26:	80 e0       	ldi	r24, 0x00	; 0
    4e28:	60 e0       	ldi	r22, 0x00	; 0
    4e2a:	42 e0       	ldi	r20, 0x02	; 2
    4e2c:	ae dc       	rcall	.-1700   	; 0x478a <Endpoint_ConfigureEndpoint_Prv>

	Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
							   ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
							   ENDPOINT_BANK_SINGLE);

	USB_INT_Clear(USB_INT_SUSPI);
    4e2e:	80 91 e1 00 	lds	r24, 0x00E1
    4e32:	8e 7f       	andi	r24, 0xFE	; 254
    4e34:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_SUSPI);
    4e38:	80 91 e2 00 	lds	r24, 0x00E2
    4e3c:	81 60       	ori	r24, 0x01	; 1
    4e3e:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Enable(USB_INT_EORSTI);
    4e42:	80 91 e2 00 	lds	r24, 0x00E2
    4e46:	88 60       	ori	r24, 0x08	; 8
    4e48:	80 93 e2 00 	sts	0x00E2, r24
    4e4c:	2e c0       	rjmp	.+92     	; 0x4eaa <USB_ResetInterface+0x108>
		#endif

		USB_Init_Device();
		#endif
	}
	else if (USB_CurrentMode == USB_MODE_Host)
    4e4e:	90 91 17 03 	lds	r25, 0x0317
    4e52:	92 30       	cpi	r25, 0x02	; 2
    4e54:	79 f5       	brne	.+94     	; 0x4eb4 <USB_ResetInterface+0x112>
	{
		#if defined(USB_CAN_BE_HOST)
		UHWCON &= ~(1 << UIMOD);
    4e56:	80 91 d7 00 	lds	r24, 0x00D7
    4e5a:	8f 77       	andi	r24, 0x7F	; 127
    4e5c:	80 93 d7 00 	sts	0x00D7, r24
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_Init_Host(void)
{
	USB_HostState       = HOST_STATE_Unattached;
    4e60:	90 93 de 0c 	sts	0x0CDE, r25
	USB_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    4e64:	80 e4       	ldi	r24, 0x40	; 64
    4e66:	80 93 9b 02 	sts	0x029B, r24
	#if !defined(__DOXYGEN__)
		/* Macros: */
			static inline void USB_Host_HostMode_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_HostMode_On(void)
			{
				USBCON |=  (1 << HOST);
    4e6a:	80 91 d8 00 	lds	r24, 0x00D8
    4e6e:	80 64       	ori	r24, 0x40	; 64
    4e70:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    4e74:	80 91 dd 00 	lds	r24, 0x00DD
    4e78:	81 60       	ori	r24, 0x01	; 1
    4e7a:	80 93 dd 00 	sts	0x00DD, r24
			}

			static inline void USB_Host_VBUS_Manual_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Enable(void)
			{
				OTGCON |=  (1 << VBUSHWC);
    4e7e:	80 91 dd 00 	lds	r24, 0x00DD
    4e82:	84 60       	ori	r24, 0x04	; 4
    4e84:	80 93 dd 00 	sts	0x00DD, r24
				UHWCON &= ~(1 << UVCONE);
    4e88:	80 91 d7 00 	lds	r24, 0x00D7
    4e8c:	8f 7e       	andi	r24, 0xEF	; 239
    4e8e:	80 93 d7 00 	sts	0x00D7, r24

				DDRE   |=  (1 << 7);
    4e92:	6f 9a       	sbi	0x0d, 7	; 13
			}

			static inline void USB_Host_VBUS_Manual_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_On(void)
			{
				PORTE  |=  (1 << 7);
    4e94:	77 9a       	sbi	0x0e, 7	; 14

	USB_Host_VBUS_Auto_Off();
	USB_Host_VBUS_Manual_Enable();
	USB_Host_VBUS_Manual_On();

	USB_INT_Enable(USB_INT_SRPI);
    4e96:	80 91 de 00 	lds	r24, 0x00DE
    4e9a:	81 60       	ori	r24, 0x01	; 1
    4e9c:	80 93 de 00 	sts	0x00DE, r24
	USB_INT_Enable(USB_INT_BCERRI);
    4ea0:	80 91 de 00 	lds	r24, 0x00DE
    4ea4:	84 60       	ori	r24, 0x04	; 4
    4ea6:	80 93 de 00 	sts	0x00DE, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    4eaa:	80 91 e0 00 	lds	r24, 0x00E0
    4eae:	8e 7f       	andi	r24, 0xFE	; 254
    4eb0:	80 93 e0 00 	sts	0x00E0, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    4eb4:	80 91 d8 00 	lds	r24, 0x00D8
    4eb8:	80 61       	ori	r24, 0x10	; 16
    4eba:	80 93 d8 00 	sts	0x00D8, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    4ebe:	1f 91       	pop	r17
    4ec0:	08 95       	ret

00004ec2 <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    4ec2:	98 2f       	mov	r25, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    4ec4:	80 91 d7 00 	lds	r24, 0x00D7
    4ec8:	81 60       	ori	r24, 0x01	; 1
    4eca:	80 93 d7 00 	sts	0x00D7, r24
	  USB_REG_On();
	else
	  USB_REG_Off();

	#if defined(USB_CAN_BE_BOTH)
	if (Mode == USB_MODE_UID)
    4ece:	93 30       	cpi	r25, 0x03	; 3
    4ed0:	a1 f4       	brne	.+40     	; 0x4efa <USB_Init+0x38>
	{
		UHWCON |= (1 << UIDE);
    4ed2:	80 91 d7 00 	lds	r24, 0x00D7
    4ed6:	80 64       	ori	r24, 0x40	; 64
    4ed8:	80 93 d7 00 	sts	0x00D7, r24
		USB_INT_Enable(USB_INT_IDTI);
    4edc:	80 91 d8 00 	lds	r24, 0x00D8
    4ee0:	82 60       	ori	r24, 0x02	; 2
    4ee2:	80 93 d8 00 	sts	0x00D8, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    4ee6:	80 91 d9 00 	lds	r24, 0x00D9
    4eea:	81 fd       	sbrc	r24, 1
    4eec:	02 c0       	rjmp	.+4      	; 0x4ef2 <USB_Init+0x30>
    4eee:	82 e0       	ldi	r24, 0x02	; 2
    4ef0:	01 c0       	rjmp	.+2      	; 0x4ef4 <USB_Init+0x32>
    4ef2:	81 e0       	ldi	r24, 0x01	; 1
		USB_CurrentMode = USB_GetUSBModeFromUID();
    4ef4:	80 93 17 03 	sts	0x0317, r24
    4ef8:	02 c0       	rjmp	.+4      	; 0x4efe <USB_Init+0x3c>
	}
	else
	{
		USB_CurrentMode = Mode;
    4efa:	90 93 17 03 	sts	0x0317, r25
	}
	#endif

	USB_IsInitialized = true;
    4efe:	81 e0       	ldi	r24, 0x01	; 1
    4f00:	80 93 d4 0c 	sts	0x0CD4, r24

	USB_ResetInterface();
}
    4f04:	4e cf       	rjmp	.-356    	; 0x4da2 <USB_ResetInterface>

00004f06 <USB_INT_DisableAllInterrupts>:
#include "USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    4f06:	e8 ed       	ldi	r30, 0xD8	; 216
    4f08:	f0 e0       	ldi	r31, 0x00	; 0
    4f0a:	80 81       	ld	r24, Z
    4f0c:	8c 7f       	andi	r24, 0xFC	; 252
    4f0e:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGIEN  = 0;
    4f10:	10 92 de 00 	sts	0x00DE, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    4f14:	10 92 a0 00 	sts	0x00A0, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    4f18:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    4f1c:	08 95       	ret

00004f1e <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT  = 0;
    4f1e:	10 92 da 00 	sts	0x00DA, r1
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGINT  = 0;
    4f22:	10 92 df 00 	sts	0x00DF, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHINT   = 0;
    4f26:	10 92 9f 00 	sts	0x009F, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
    4f2a:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    4f2e:	08 95       	ret

00004f30 <__vector_11>:
	#endif
}

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    4f30:	1f 92       	push	r1
    4f32:	0f 92       	push	r0
    4f34:	0f b6       	in	r0, 0x3f	; 63
    4f36:	0f 92       	push	r0
    4f38:	0b b6       	in	r0, 0x3b	; 59
    4f3a:	0f 92       	push	r0
    4f3c:	11 24       	eor	r1, r1
    4f3e:	1f 93       	push	r17
    4f40:	2f 93       	push	r18
    4f42:	3f 93       	push	r19
    4f44:	4f 93       	push	r20
    4f46:	5f 93       	push	r21
    4f48:	6f 93       	push	r22
    4f4a:	7f 93       	push	r23
    4f4c:	8f 93       	push	r24
    4f4e:	9f 93       	push	r25
    4f50:	af 93       	push	r26
    4f52:	bf 93       	push	r27
    4f54:	ef 93       	push	r30
    4f56:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    4f58:	e9 ee       	ldi	r30, 0xE9	; 233
    4f5a:	f0 e0       	ldi	r31, 0x00	; 0
    4f5c:	10 81       	ld	r17, Z
    4f5e:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    4f60:	10 82       	st	Z, r1
	uint8_t PrevSelectedEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);
    4f62:	e0 ef       	ldi	r30, 0xF0	; 240
    4f64:	f0 e0       	ldi	r31, 0x00	; 0
    4f66:	80 81       	ld	r24, Z
    4f68:	87 7f       	andi	r24, 0xF7	; 247
    4f6a:	80 83       	st	Z, r24

#if !defined(__DOXYGEN__)
/* Internal helper functions. */
static __inline__ uint8_t __iSeiRetVal(void)
{
    sei();
    4f6c:	78 94       	sei

	NONATOMIC_BLOCK(NONATOMIC_FORCEOFF)
	{
		USB_Device_ProcessControlRequest();
    4f6e:	1d d2       	rcall	.+1082   	; 0x53aa <USB_Device_ProcessControlRequest>
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    cli();
    4f70:	f8 94       	cli
    4f72:	a9 ee       	ldi	r26, 0xE9	; 233
    4f74:	b0 e0       	ldi	r27, 0x00	; 0
    4f76:	1c 92       	st	X, r1
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
    4f78:	e0 ef       	ldi	r30, 0xF0	; 240
    4f7a:	f0 e0       	ldi	r31, 0x00	; 0
    4f7c:	80 81       	ld	r24, Z
    4f7e:	88 60       	ori	r24, 0x08	; 8
    4f80:	80 83       	st	Z, r24
    4f82:	1c 93       	st	X, r17
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    4f84:	ff 91       	pop	r31
    4f86:	ef 91       	pop	r30
    4f88:	bf 91       	pop	r27
    4f8a:	af 91       	pop	r26
    4f8c:	9f 91       	pop	r25
    4f8e:	8f 91       	pop	r24
    4f90:	7f 91       	pop	r23
    4f92:	6f 91       	pop	r22
    4f94:	5f 91       	pop	r21
    4f96:	4f 91       	pop	r20
    4f98:	3f 91       	pop	r19
    4f9a:	2f 91       	pop	r18
    4f9c:	1f 91       	pop	r17
    4f9e:	0f 90       	pop	r0
    4fa0:	0b be       	out	0x3b, r0	; 59
    4fa2:	0f 90       	pop	r0
    4fa4:	0f be       	out	0x3f, r0	; 63
    4fa6:	0f 90       	pop	r0
    4fa8:	1f 90       	pop	r1
    4faa:	18 95       	reti

00004fac <__vector_10>:
	UDINT   = 0;
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    4fac:	1f 92       	push	r1
    4fae:	0f 92       	push	r0
    4fb0:	0f b6       	in	r0, 0x3f	; 63
    4fb2:	0f 92       	push	r0
    4fb4:	0b b6       	in	r0, 0x3b	; 59
    4fb6:	0f 92       	push	r0
    4fb8:	11 24       	eor	r1, r1
    4fba:	2f 93       	push	r18
    4fbc:	3f 93       	push	r19
    4fbe:	4f 93       	push	r20
    4fc0:	5f 93       	push	r21
    4fc2:	6f 93       	push	r22
    4fc4:	7f 93       	push	r23
    4fc6:	8f 93       	push	r24
    4fc8:	9f 93       	push	r25
    4fca:	af 93       	push	r26
    4fcc:	bf 93       	push	r27
    4fce:	ef 93       	push	r30
    4fd0:	ff 93       	push	r31
	#if defined(USB_CAN_BE_DEVICE)
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUS) && USB_INT_IsEnabled(USB_INT_VBUS))
    4fd2:	80 91 da 00 	lds	r24, 0x00DA
    4fd6:	80 ff       	sbrs	r24, 0
    4fd8:	17 c0       	rjmp	.+46     	; 0x5008 <__vector_10+0x5c>
    4fda:	80 91 d8 00 	lds	r24, 0x00D8
    4fde:	80 ff       	sbrs	r24, 0
    4fe0:	13 c0       	rjmp	.+38     	; 0x5008 <__vector_10+0x5c>
	{
		USB_INT_Clear(USB_INT_VBUS);
    4fe2:	80 91 da 00 	lds	r24, 0x00DA
    4fe6:	8e 7f       	andi	r24, 0xFE	; 254
    4fe8:	80 93 da 00 	sts	0x00DA, r24
				 *  \note This function is not available on some AVR models which do not support hardware VBUS monitoring.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    4fec:	80 91 d9 00 	lds	r24, 0x00D9

		if (USB_VBUS_GetStatus())
    4ff0:	80 ff       	sbrs	r24, 0
    4ff2:	06 c0       	rjmp	.+12     	; 0x5000 <__vector_10+0x54>
		{
			USB_DeviceState = DEVICE_STATE_Powered;
    4ff4:	81 e0       	ldi	r24, 0x01	; 1
    4ff6:	80 93 d5 0c 	sts	0x0CD5, r24
			EVENT_USB_Device_Connect();
    4ffa:	0e 94 40 02 	call	0x480	; 0x480 <EVENT_USB_Device_Connect>
    4ffe:	04 c0       	rjmp	.+8      	; 0x5008 <__vector_10+0x5c>
		}
		else
		{
			USB_DeviceState = DEVICE_STATE_Unattached;
    5000:	10 92 d5 0c 	sts	0x0CD5, r1
			EVENT_USB_Device_Disconnect();
    5004:	0e 94 45 02 	call	0x48a	; 0x48a <EVENT_USB_Device_Disconnect>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5008:	80 91 e1 00 	lds	r24, 0x00E1
    500c:	80 ff       	sbrs	r24, 0
    500e:	1d c0       	rjmp	.+58     	; 0x504a <__vector_10+0x9e>
    5010:	80 91 e2 00 	lds	r24, 0x00E2
    5014:	80 ff       	sbrs	r24, 0
    5016:	19 c0       	rjmp	.+50     	; 0x504a <__vector_10+0x9e>
	{
		USB_INT_Clear(USB_INT_SUSPI);
    5018:	80 91 e1 00 	lds	r24, 0x00E1
    501c:	8e 7f       	andi	r24, 0xFE	; 254
    501e:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPI);
    5022:	80 91 e2 00 	lds	r24, 0x00E2
    5026:	8e 7f       	andi	r24, 0xFE	; 254
    5028:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
    502c:	80 91 e2 00 	lds	r24, 0x00E2
    5030:	80 61       	ori	r24, 0x10	; 16
    5032:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    5036:	80 91 d8 00 	lds	r24, 0x00D8
    503a:	80 62       	ori	r24, 0x20	; 32
    503c:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    5040:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    5042:	85 e0       	ldi	r24, 0x05	; 5
    5044:	80 93 d5 0c 	sts	0x0CD5, r24
		EVENT_USB_Device_Suspend();
    5048:	1f d3       	rcall	.+1598   	; 0x5688 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    504a:	80 91 e1 00 	lds	r24, 0x00E1
    504e:	84 ff       	sbrs	r24, 4
    5050:	2e c0       	rjmp	.+92     	; 0x50ae <__vector_10+0x102>
    5052:	80 91 e2 00 	lds	r24, 0x00E2
    5056:	84 ff       	sbrs	r24, 4
    5058:	2a c0       	rjmp	.+84     	; 0x50ae <__vector_10+0x102>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    505a:	8c e0       	ldi	r24, 0x0C	; 12
    505c:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    505e:	89 b5       	in	r24, 0x29	; 41
    5060:	82 60       	ori	r24, 0x02	; 2
    5062:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    5064:	09 b4       	in	r0, 0x29	; 41
    5066:	00 fe       	sbrs	r0, 0
    5068:	fd cf       	rjmp	.-6      	; 0x5064 <__vector_10+0xb8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    506a:	80 91 d8 00 	lds	r24, 0x00D8
    506e:	8f 7d       	andi	r24, 0xDF	; 223
    5070:	80 93 d8 00 	sts	0x00D8, r24
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUPI);
    5074:	80 91 e1 00 	lds	r24, 0x00E1
    5078:	8f 7e       	andi	r24, 0xEF	; 239
    507a:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUPI);
    507e:	80 91 e2 00 	lds	r24, 0x00E2
    5082:	8f 7e       	andi	r24, 0xEF	; 239
    5084:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPI);
    5088:	80 91 e2 00 	lds	r24, 0x00E2
    508c:	81 60       	ori	r24, 0x01	; 1
    508e:	80 93 e2 00 	sts	0x00E2, r24

		if (USB_ConfigurationNumber)
    5092:	80 91 d3 0c 	lds	r24, 0x0CD3
    5096:	88 23       	and	r24, r24
    5098:	31 f4       	brne	.+12     	; 0x50a6 <__vector_10+0xfa>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    509a:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    509e:	87 fd       	sbrc	r24, 7
    50a0:	02 c0       	rjmp	.+4      	; 0x50a6 <__vector_10+0xfa>
    50a2:	81 e0       	ldi	r24, 0x01	; 1
    50a4:	01 c0       	rjmp	.+2      	; 0x50a8 <__vector_10+0xfc>
    50a6:	84 e0       	ldi	r24, 0x04	; 4
    50a8:	80 93 d5 0c 	sts	0x0CD5, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    50ac:	ed d2       	rcall	.+1498   	; 0x5688 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    50ae:	80 91 e1 00 	lds	r24, 0x00E1
    50b2:	83 ff       	sbrs	r24, 3
    50b4:	27 c0       	rjmp	.+78     	; 0x5104 <__vector_10+0x158>
    50b6:	80 91 e2 00 	lds	r24, 0x00E2
    50ba:	83 ff       	sbrs	r24, 3
    50bc:	23 c0       	rjmp	.+70     	; 0x5104 <__vector_10+0x158>
	{
		USB_INT_Clear(USB_INT_EORSTI);
    50be:	80 91 e1 00 	lds	r24, 0x00E1
    50c2:	87 7f       	andi	r24, 0xF7	; 247
    50c4:	80 93 e1 00 	sts	0x00E1, r24

		USB_DeviceState         = DEVICE_STATE_Default;
    50c8:	82 e0       	ldi	r24, 0x02	; 2
    50ca:	80 93 d5 0c 	sts	0x0CD5, r24
		USB_ConfigurationNumber = 0;
    50ce:	10 92 d3 0c 	sts	0x0CD3, r1

		USB_INT_Clear(USB_INT_SUSPI);
    50d2:	80 91 e1 00 	lds	r24, 0x00E1
    50d6:	8e 7f       	andi	r24, 0xFE	; 254
    50d8:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPI);
    50dc:	80 91 e2 00 	lds	r24, 0x00E2
    50e0:	8e 7f       	andi	r24, 0xFE	; 254
    50e2:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
    50e6:	80 91 e2 00 	lds	r24, 0x00E2
    50ea:	80 61       	ori	r24, 0x10	; 16
    50ec:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    50f0:	80 e0       	ldi	r24, 0x00	; 0
    50f2:	60 e0       	ldi	r22, 0x00	; 0
    50f4:	42 e0       	ldi	r20, 0x02	; 2
    50f6:	49 db       	rcall	.-2414   	; 0x478a <Endpoint_ConfigureEndpoint_Prv>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
		                           ENDPOINT_BANK_SINGLE);

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
    50f8:	80 91 f0 00 	lds	r24, 0x00F0
    50fc:	88 60       	ori	r24, 0x08	; 8
    50fe:	80 93 f0 00 	sts	0x00F0, r24
		#endif

		EVENT_USB_Device_Reset();
    5102:	c2 d2       	rcall	.+1412   	; 0x5688 <USB_Event_Stub>
	}

	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    5104:	80 91 e1 00 	lds	r24, 0x00E1
    5108:	82 ff       	sbrs	r24, 2
    510a:	0a c0       	rjmp	.+20     	; 0x5120 <__vector_10+0x174>
    510c:	80 91 e2 00 	lds	r24, 0x00E2
    5110:	82 ff       	sbrs	r24, 2
    5112:	06 c0       	rjmp	.+12     	; 0x5120 <__vector_10+0x174>
	{
		USB_INT_Clear(USB_INT_SOFI);
    5114:	80 91 e1 00 	lds	r24, 0x00E1
    5118:	8b 7f       	andi	r24, 0xFB	; 251
    511a:	80 93 e1 00 	sts	0x00E1, r24

		EVENT_USB_Device_StartOfFrame();
    511e:	b4 d2       	rcall	.+1384   	; 0x5688 <USB_Event_Stub>
	}
	#endif
	#endif

	#if defined(USB_CAN_BE_HOST)
	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    5120:	80 91 9f 00 	lds	r24, 0x009F
    5124:	81 ff       	sbrs	r24, 1
    5126:	16 c0       	rjmp	.+44     	; 0x5154 <__vector_10+0x1a8>
    5128:	80 91 a0 00 	lds	r24, 0x00A0
    512c:	81 ff       	sbrs	r24, 1
    512e:	12 c0       	rjmp	.+36     	; 0x5154 <__vector_10+0x1a8>
	{
		USB_INT_Clear(USB_INT_DDISCI);
    5130:	80 91 9f 00 	lds	r24, 0x009F
    5134:	8d 7f       	andi	r24, 0xFD	; 253
    5136:	80 93 9f 00 	sts	0x009F, r24
		USB_INT_Clear(USB_INT_DCONNI);
    513a:	80 91 9f 00 	lds	r24, 0x009F
    513e:	8e 7f       	andi	r24, 0xFE	; 254
    5140:	80 93 9f 00 	sts	0x009F, r24
		USB_INT_Disable(USB_INT_DDISCI);
    5144:	80 91 a0 00 	lds	r24, 0x00A0
    5148:	8d 7f       	andi	r24, 0xFD	; 253
    514a:	80 93 a0 00 	sts	0x00A0, r24

		EVENT_USB_Host_DeviceUnattached();
    514e:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    5152:	27 de       	rcall	.-946    	; 0x4da2 <USB_ResetInterface>
	}

	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    5154:	80 91 df 00 	lds	r24, 0x00DF
    5158:	81 ff       	sbrs	r24, 1
    515a:	17 c0       	rjmp	.+46     	; 0x518a <__vector_10+0x1de>
    515c:	80 91 de 00 	lds	r24, 0x00DE
    5160:	81 ff       	sbrs	r24, 1
    5162:	13 c0       	rjmp	.+38     	; 0x518a <__vector_10+0x1de>
	{
		USB_INT_Clear(USB_INT_VBERRI);
    5164:	80 91 df 00 	lds	r24, 0x00DF
    5168:	8d 7f       	andi	r24, 0xFD	; 253
    516a:	80 93 df 00 	sts	0x00DF, r24
			}

			static inline void USB_Host_VBUS_Manual_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				PORTE  &= ~(1 << 7);
    516e:	77 98       	cbi	0x0e, 7	; 14
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5170:	80 91 dd 00 	lds	r24, 0x00DD
    5174:	81 60       	ori	r24, 0x01	; 1
    5176:	80 93 dd 00 	sts	0x00DD, r24

		USB_Host_VBUS_Manual_Off();
		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    517a:	80 e0       	ldi	r24, 0x00	; 0
    517c:	0e 94 83 02 	call	0x506	; 0x506 <EVENT_USB_Host_HostError>
		EVENT_USB_Host_DeviceUnattached();
    5180:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Host_DeviceUnattached>

		USB_HostState = HOST_STATE_Unattached;
    5184:	82 e0       	ldi	r24, 0x02	; 2
    5186:	80 93 de 0c 	sts	0x0CDE, r24
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    518a:	80 91 df 00 	lds	r24, 0x00DF
    518e:	80 ff       	sbrs	r24, 0
    5190:	18 c0       	rjmp	.+48     	; 0x51c2 <__vector_10+0x216>
    5192:	80 91 de 00 	lds	r24, 0x00DE
    5196:	80 ff       	sbrs	r24, 0
    5198:	14 c0       	rjmp	.+40     	; 0x51c2 <__vector_10+0x216>
	{
		USB_INT_Clear(USB_INT_SRPI);
    519a:	80 91 df 00 	lds	r24, 0x00DF
    519e:	8e 7f       	andi	r24, 0xFE	; 254
    51a0:	80 93 df 00 	sts	0x00DF, r24
		USB_INT_Disable(USB_INT_SRPI);
    51a4:	80 91 de 00 	lds	r24, 0x00DE
    51a8:	8e 7f       	andi	r24, 0xFE	; 254
    51aa:	80 93 de 00 	sts	0x00DE, r24

		EVENT_USB_Host_DeviceAttached();
    51ae:	0e 94 6f 02 	call	0x4de	; 0x4de <EVENT_USB_Host_DeviceAttached>

		USB_INT_Enable(USB_INT_DDISCI);
    51b2:	80 91 a0 00 	lds	r24, 0x00A0
    51b6:	82 60       	ori	r24, 0x02	; 2
    51b8:	80 93 a0 00 	sts	0x00A0, r24

		USB_HostState = HOST_STATE_Powered;
    51bc:	83 e0       	ldi	r24, 0x03	; 3
    51be:	80 93 de 0c 	sts	0x0CDE, r24
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    51c2:	80 91 df 00 	lds	r24, 0x00DF
    51c6:	82 ff       	sbrs	r24, 2
    51c8:	10 c0       	rjmp	.+32     	; 0x51ea <__vector_10+0x23e>
    51ca:	80 91 de 00 	lds	r24, 0x00DE
    51ce:	82 ff       	sbrs	r24, 2
    51d0:	0c c0       	rjmp	.+24     	; 0x51ea <__vector_10+0x23e>
	{
		USB_INT_Clear(USB_INT_BCERRI);
    51d2:	80 91 df 00 	lds	r24, 0x00DF
    51d6:	8b 7f       	andi	r24, 0xFB	; 251
    51d8:	80 93 df 00 	sts	0x00DF, r24

		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    51dc:	82 e0       	ldi	r24, 0x02	; 2
    51de:	60 e0       	ldi	r22, 0x00	; 0
    51e0:	0e 94 7e 02 	call	0x4fc	; 0x4fc <EVENT_USB_Host_DeviceEnumerationFailed>
		EVENT_USB_Host_DeviceUnattached();
    51e4:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    51e8:	dc dd       	rcall	.-1096   	; 0x4da2 <USB_ResetInterface>
	}

	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_HSOFI) && USB_INT_IsEnabled(USB_INT_HSOFI))
    51ea:	80 91 9f 00 	lds	r24, 0x009F
    51ee:	85 ff       	sbrs	r24, 5
    51f0:	0a c0       	rjmp	.+20     	; 0x5206 <__vector_10+0x25a>
    51f2:	80 91 a0 00 	lds	r24, 0x00A0
    51f6:	85 ff       	sbrs	r24, 5
    51f8:	06 c0       	rjmp	.+12     	; 0x5206 <__vector_10+0x25a>
	{
		USB_INT_Clear(USB_INT_HSOFI);
    51fa:	80 91 9f 00 	lds	r24, 0x009F
    51fe:	8f 7d       	andi	r24, 0xDF	; 223
    5200:	80 93 9f 00 	sts	0x009F, r24

		EVENT_USB_Host_StartOfFrame();
    5204:	41 d2       	rcall	.+1154   	; 0x5688 <USB_Event_Stub>
	}
	#endif
	#endif

	#if defined(USB_CAN_BE_BOTH)
	if (USB_INT_HasOccurred(USB_INT_IDTI) && USB_INT_IsEnabled(USB_INT_IDTI))
    5206:	80 91 da 00 	lds	r24, 0x00DA
    520a:	81 ff       	sbrs	r24, 1
    520c:	20 c0       	rjmp	.+64     	; 0x524e <__vector_10+0x2a2>
    520e:	80 91 d8 00 	lds	r24, 0x00D8
    5212:	81 ff       	sbrs	r24, 1
    5214:	1c c0       	rjmp	.+56     	; 0x524e <__vector_10+0x2a2>
	{
		USB_INT_Clear(USB_INT_IDTI);
    5216:	80 91 da 00 	lds	r24, 0x00DA
    521a:	8d 7f       	andi	r24, 0xFD	; 253
    521c:	80 93 da 00 	sts	0x00DA, r24

		if (USB_DeviceState != DEVICE_STATE_Unattached)
    5220:	80 91 d5 0c 	lds	r24, 0x0CD5
    5224:	88 23       	and	r24, r24
    5226:	11 f0       	breq	.+4      	; 0x522c <__vector_10+0x280>
		  EVENT_USB_Device_Disconnect();
    5228:	0e 94 45 02 	call	0x48a	; 0x48a <EVENT_USB_Device_Disconnect>

		if (USB_HostState != HOST_STATE_Unattached)
    522c:	80 91 de 0c 	lds	r24, 0x0CDE
    5230:	82 30       	cpi	r24, 0x02	; 2
    5232:	11 f0       	breq	.+4      	; 0x5238 <__vector_10+0x28c>
		  EVENT_USB_Host_DeviceUnattached();
    5234:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Host_DeviceUnattached>

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5238:	80 91 d9 00 	lds	r24, 0x00D9
    523c:	81 fd       	sbrc	r24, 1
    523e:	02 c0       	rjmp	.+4      	; 0x5244 <__vector_10+0x298>
    5240:	82 e0       	ldi	r24, 0x02	; 2
    5242:	01 c0       	rjmp	.+2      	; 0x5246 <__vector_10+0x29a>
    5244:	81 e0       	ldi	r24, 0x01	; 1

		USB_CurrentMode = USB_GetUSBModeFromUID();
    5246:	80 93 17 03 	sts	0x0317, r24
		USB_ResetInterface();
    524a:	ab dd       	rcall	.-1194   	; 0x4da2 <USB_ResetInterface>

		EVENT_USB_UIDChange();
    524c:	1d d2       	rcall	.+1082   	; 0x5688 <USB_Event_Stub>
	}
	#endif
}
    524e:	ff 91       	pop	r31
    5250:	ef 91       	pop	r30
    5252:	bf 91       	pop	r27
    5254:	af 91       	pop	r26
    5256:	9f 91       	pop	r25
    5258:	8f 91       	pop	r24
    525a:	7f 91       	pop	r23
    525c:	6f 91       	pop	r22
    525e:	5f 91       	pop	r21
    5260:	4f 91       	pop	r20
    5262:	3f 91       	pop	r19
    5264:	2f 91       	pop	r18
    5266:	0f 90       	pop	r0
    5268:	0b be       	out	0x3b, r0	; 59
    526a:	0f 90       	pop	r0
    526c:	0f be       	out	0x3f, r0	; 63
    526e:	0f 90       	pop	r0
    5270:	1f 90       	pop	r1
    5272:	18 95       	reti

00005274 <USB_GetNextDescriptorComp>:

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem, void** const CurrConfigLoc, ConfigComparatorPtr_t const ComparatorRoutine)
{
    5274:	af 92       	push	r10
    5276:	bf 92       	push	r11
    5278:	cf 92       	push	r12
    527a:	df 92       	push	r13
    527c:	ef 92       	push	r14
    527e:	ff 92       	push	r15
    5280:	0f 93       	push	r16
    5282:	1f 93       	push	r17
    5284:	cf 93       	push	r28
    5286:	df 93       	push	r29
    5288:	7c 01       	movw	r14, r24
    528a:	8b 01       	movw	r16, r22
    528c:	5a 01       	movw	r10, r20
    528e:	21 c0       	rjmp	.+66     	; 0x52d2 <USB_GetNextDescriptorComp+0x5e>
	uint8_t ErrorCode;

	while (*BytesRem)
	{
		uint8_t* PrevDescLoc  = *CurrConfigLoc;
    5290:	f8 01       	movw	r30, r16
    5292:	c0 81       	ld	r28, Z
    5294:	d1 81       	ldd	r29, Z+1	; 0x01
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc)
			{
				uint16_t CurrDescriptorSize = DESCRIPTOR_CAST(*CurrConfigLoc, USB_Descriptor_Header_t).Size;
    5296:	88 81       	ld	r24, Y
    5298:	90 e0       	ldi	r25, 0x00	; 0

				*CurrConfigLoc  = ((uint8_t*)*CurrConfigLoc) + CurrDescriptorSize;
    529a:	9e 01       	movw	r18, r28
    529c:	28 0f       	add	r18, r24
    529e:	39 1f       	adc	r19, r25
    52a0:	31 83       	std	Z+1, r19	; 0x01
    52a2:	20 83       	st	Z, r18
				*BytesRem      -= CurrDescriptorSize;
    52a4:	f7 01       	movw	r30, r14
    52a6:	20 81       	ld	r18, Z
    52a8:	31 81       	ldd	r19, Z+1	; 0x01
    52aa:	28 1b       	sub	r18, r24
    52ac:	39 0b       	sbc	r19, r25
    52ae:	31 83       	std	Z+1, r19	; 0x01
    52b0:	20 83       	st	Z, r18
		uint16_t PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    52b2:	f8 01       	movw	r30, r16
    52b4:	80 81       	ld	r24, Z
    52b6:	91 81       	ldd	r25, Z+1	; 0x01
    52b8:	f5 01       	movw	r30, r10
    52ba:	09 95       	icall
    52bc:	82 30       	cpi	r24, 0x02	; 2
    52be:	49 f0       	breq	.+18     	; 0x52d2 <USB_GetNextDescriptorComp+0x5e>
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    52c0:	81 30       	cpi	r24, 0x01	; 1
    52c2:	71 f4       	brne	.+28     	; 0x52e0 <USB_GetNextDescriptorComp+0x6c>
			{
				*CurrConfigLoc = PrevDescLoc;
    52c4:	f8 01       	movw	r30, r16
    52c6:	c0 83       	st	Z, r28
    52c8:	d1 83       	std	Z+1, r29	; 0x01
				*BytesRem      = PrevBytesRem;
    52ca:	f7 01       	movw	r30, r14
    52cc:	d1 82       	std	Z+1, r13	; 0x01
    52ce:	c0 82       	st	Z, r12
    52d0:	07 c0       	rjmp	.+14     	; 0x52e0 <USB_GetNextDescriptorComp+0x6c>

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem, void** const CurrConfigLoc, ConfigComparatorPtr_t const ComparatorRoutine)
{
	uint8_t ErrorCode;

	while (*BytesRem)
    52d2:	f7 01       	movw	r30, r14
    52d4:	c0 80       	ld	r12, Z
    52d6:	d1 80       	ldd	r13, Z+1	; 0x01
    52d8:	c1 14       	cp	r12, r1
    52da:	d1 04       	cpc	r13, r1
    52dc:	c9 f6       	brne	.-78     	; 0x5290 <USB_GetNextDescriptorComp+0x1c>
    52de:	82 e0       	ldi	r24, 0x02	; 2
			return ErrorCode;
		}
	}

	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
}
    52e0:	df 91       	pop	r29
    52e2:	cf 91       	pop	r28
    52e4:	1f 91       	pop	r17
    52e6:	0f 91       	pop	r16
    52e8:	ff 90       	pop	r15
    52ea:	ef 90       	pop	r14
    52ec:	df 90       	pop	r13
    52ee:	cf 90       	pop	r12
    52f0:	bf 90       	pop	r11
    52f2:	af 90       	pop	r10
    52f4:	08 95       	ret

000052f6 <USB_Host_GetDeviceConfigDescriptor>:
#include "ConfigDescriptor.h"

#if defined(USB_CAN_BE_HOST)
uint8_t USB_Host_GetDeviceConfigDescriptor(uint8_t ConfigNumber, uint16_t* const ConfigSizePtr,
                                           void* BufferPtr, uint16_t BufferSize)
{
    52f6:	cf 92       	push	r12
    52f8:	df 92       	push	r13
    52fa:	ef 92       	push	r14
    52fc:	ff 92       	push	r15
    52fe:	0f 93       	push	r16
    5300:	1f 93       	push	r17
    5302:	df 93       	push	r29
    5304:	cf 93       	push	r28
    5306:	cd b7       	in	r28, 0x3d	; 61
    5308:	de b7       	in	r29, 0x3e	; 62
    530a:	29 97       	sbiw	r28, 0x09	; 9
    530c:	0f b6       	in	r0, 0x3f	; 63
    530e:	f8 94       	cli
    5310:	de bf       	out	0x3e, r29	; 62
    5312:	0f be       	out	0x3f, r0	; 63
    5314:	cd bf       	out	0x3d, r28	; 61
    5316:	6b 01       	movw	r12, r22
    5318:	8a 01       	movw	r16, r20
    531a:	79 01       	movw	r14, r18
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    531c:	90 e8       	ldi	r25, 0x80	; 128
    531e:	90 93 d6 0c 	sts	0x0CD6, r25
    5322:	96 e0       	ldi	r25, 0x06	; 6
    5324:	90 93 d7 0c 	sts	0x0CD7, r25
    5328:	90 e0       	ldi	r25, 0x00	; 0
    532a:	01 97       	sbiw	r24, 0x01	; 1
    532c:	92 60       	ori	r25, 0x02	; 2
    532e:	90 93 d9 0c 	sts	0x0CD9, r25
    5332:	80 93 d8 0c 	sts	0x0CD8, r24
    5336:	10 92 db 0c 	sts	0x0CDB, r1
    533a:	10 92 da 0c 	sts	0x0CDA, r1
    533e:	89 e0       	ldi	r24, 0x09	; 9
    5340:	90 e0       	ldi	r25, 0x00	; 0
    5342:	90 93 dd 0c 	sts	0x0CDD, r25
    5346:	80 93 dc 0c 	sts	0x0CDC, r24
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    534a:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = sizeof(USB_Descriptor_Configuration_Header_t),
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) != HOST_SENDCONTROL_Successful)
    534e:	ce 01       	movw	r24, r28
    5350:	01 96       	adiw	r24, 0x01	; 1
    5352:	3a d4       	rcall	.+2164   	; 0x5bc8 <USB_Host_SendControlRequest>
    5354:	28 2f       	mov	r18, r24
    5356:	88 23       	and	r24, r24
    5358:	c1 f4       	brne	.+48     	; 0x538a <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return ErrorCode;

	*ConfigSizePtr = DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize;
    535a:	8b 81       	ldd	r24, Y+3	; 0x03
    535c:	9c 81       	ldd	r25, Y+4	; 0x04
    535e:	f6 01       	movw	r30, r12
    5360:	91 83       	std	Z+1, r25	; 0x01
    5362:	80 83       	st	Z, r24

	if (*ConfigSizePtr > BufferSize)
    5364:	e8 16       	cp	r14, r24
    5366:	f9 06       	cpc	r15, r25
    5368:	10 f4       	brcc	.+4      	; 0x536e <USB_Host_GetDeviceConfigDescriptor+0x78>
    536a:	25 e0       	ldi	r18, 0x05	; 5
    536c:	0e c0       	rjmp	.+28     	; 0x538a <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return HOST_GETCONFIG_BuffOverflow;

	USB_ControlRequest.wLength = *ConfigSizePtr;
    536e:	90 93 dd 0c 	sts	0x0CDD, r25
    5372:	80 93 dc 0c 	sts	0x0CDC, r24

	if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) != HOST_SENDCONTROL_Successful)
    5376:	c8 01       	movw	r24, r16
    5378:	27 d4       	rcall	.+2126   	; 0x5bc8 <USB_Host_SendControlRequest>
    537a:	28 2f       	mov	r18, r24
    537c:	88 23       	and	r24, r24
    537e:	29 f4       	brne	.+10     	; 0x538a <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    5380:	f8 01       	movw	r30, r16
    5382:	81 81       	ldd	r24, Z+1	; 0x01
    5384:	82 30       	cpi	r24, 0x02	; 2
    5386:	09 f0       	breq	.+2      	; 0x538a <USB_Host_GetDeviceConfigDescriptor+0x94>
    5388:	26 e0       	ldi	r18, 0x06	; 6
	  return HOST_GETCONFIG_InvalidData;

	return HOST_GETCONFIG_Successful;
}
    538a:	82 2f       	mov	r24, r18
    538c:	29 96       	adiw	r28, 0x09	; 9
    538e:	0f b6       	in	r0, 0x3f	; 63
    5390:	f8 94       	cli
    5392:	de bf       	out	0x3e, r29	; 62
    5394:	0f be       	out	0x3f, r0	; 63
    5396:	cd bf       	out	0x3d, r28	; 61
    5398:	cf 91       	pop	r28
    539a:	df 91       	pop	r29
    539c:	1f 91       	pop	r17
    539e:	0f 91       	pop	r16
    53a0:	ff 90       	pop	r15
    53a2:	ef 90       	pop	r14
    53a4:	df 90       	pop	r13
    53a6:	cf 90       	pop	r12
    53a8:	08 95       	ret

000053aa <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    53aa:	0f 93       	push	r16
    53ac:	1f 93       	push	r17
    53ae:	df 93       	push	r29
    53b0:	cf 93       	push	r28
    53b2:	cd b7       	in	r28, 0x3d	; 61
    53b4:	de b7       	in	r29, 0x3e	; 62
    53b6:	ac 97       	sbiw	r28, 0x2c	; 44
    53b8:	0f b6       	in	r0, 0x3f	; 63
    53ba:	f8 94       	cli
    53bc:	de bf       	out	0x3e, r29	; 62
    53be:	0f be       	out	0x3f, r0	; 63
    53c0:	cd bf       	out	0x3d, r28	; 61
    53c2:	e6 ed       	ldi	r30, 0xD6	; 214
    53c4:	fc e0       	ldi	r31, 0x0C	; 12
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    53c6:	80 91 f1 00 	lds	r24, 0x00F1
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
    53ca:	81 93       	st	Z+, r24

void USB_Device_ProcessControlRequest(void)
{
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    53cc:	2c e0       	ldi	r18, 0x0C	; 12
    53ce:	ee 3d       	cpi	r30, 0xDE	; 222
    53d0:	f2 07       	cpc	r31, r18
    53d2:	c9 f7       	brne	.-14     	; 0x53c6 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_Byte();

	EVENT_USB_Device_ControlRequest();
    53d4:	0e 94 54 02 	call	0x4a8	; 0x4a8 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    53d8:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    53dc:	83 ff       	sbrs	r24, 3
    53de:	3b c1       	rjmp	.+630    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    53e0:	80 91 d6 0c 	lds	r24, 0x0CD6

		switch (USB_ControlRequest.bRequest)
    53e4:	30 91 d7 0c 	lds	r19, 0x0CD7
    53e8:	35 30       	cpi	r19, 0x05	; 5
    53ea:	09 f4       	brne	.+2      	; 0x53ee <USB_Device_ProcessControlRequest+0x44>
    53ec:	87 c0       	rjmp	.+270    	; 0x54fc <USB_Device_ProcessControlRequest+0x152>
    53ee:	36 30       	cpi	r19, 0x06	; 6
    53f0:	40 f4       	brcc	.+16     	; 0x5402 <USB_Device_ProcessControlRequest+0x58>
    53f2:	31 30       	cpi	r19, 0x01	; 1
    53f4:	c9 f1       	breq	.+114    	; 0x5468 <USB_Device_ProcessControlRequest+0xbe>
    53f6:	31 30       	cpi	r19, 0x01	; 1
    53f8:	70 f0       	brcs	.+28     	; 0x5416 <USB_Device_ProcessControlRequest+0x6c>
    53fa:	33 30       	cpi	r19, 0x03	; 3
    53fc:	09 f0       	breq	.+2      	; 0x5400 <USB_Device_ProcessControlRequest+0x56>
    53fe:	2b c1       	rjmp	.+598    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
    5400:	33 c0       	rjmp	.+102    	; 0x5468 <USB_Device_ProcessControlRequest+0xbe>
    5402:	38 30       	cpi	r19, 0x08	; 8
    5404:	09 f4       	brne	.+2      	; 0x5408 <USB_Device_ProcessControlRequest+0x5e>
    5406:	f8 c0       	rjmp	.+496    	; 0x55f8 <USB_Device_ProcessControlRequest+0x24e>
    5408:	39 30       	cpi	r19, 0x09	; 9
    540a:	09 f4       	brne	.+2      	; 0x540e <USB_Device_ProcessControlRequest+0x64>
    540c:	07 c1       	rjmp	.+526    	; 0x561c <USB_Device_ProcessControlRequest+0x272>
    540e:	36 30       	cpi	r19, 0x06	; 6
    5410:	09 f0       	breq	.+2      	; 0x5414 <USB_Device_ProcessControlRequest+0x6a>
    5412:	21 c1       	rjmp	.+578    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
    5414:	99 c0       	rjmp	.+306    	; 0x5548 <USB_Device_ProcessControlRequest+0x19e>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5416:	80 38       	cpi	r24, 0x80	; 128
    5418:	21 f0       	breq	.+8      	; 0x5422 <USB_Device_ProcessControlRequest+0x78>
    541a:	82 38       	cpi	r24, 0x82	; 130
    541c:	09 f0       	breq	.+2      	; 0x5420 <USB_Device_ProcessControlRequest+0x76>
    541e:	1b c1       	rjmp	.+566    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
    5420:	08 c0       	rjmp	.+16     	; 0x5432 <USB_Device_ProcessControlRequest+0x88>
    5422:	90 91 d1 0c 	lds	r25, 0x0CD1
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
    5426:	80 91 d2 0c 	lds	r24, 0x0CD2
    542a:	88 23       	and	r24, r24
    542c:	99 f0       	breq	.+38     	; 0x5454 <USB_Device_ProcessControlRequest+0xaa>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    542e:	92 60       	ori	r25, 0x02	; 2
    5430:	11 c0       	rjmp	.+34     	; 0x5454 <USB_Device_ProcessControlRequest+0xaa>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5432:	80 91 da 0c 	lds	r24, 0x0CDA
    5436:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5438:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    543c:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    5440:	90 e0       	ldi	r25, 0x00	; 0
    5442:	25 e0       	ldi	r18, 0x05	; 5
    5444:	96 95       	lsr	r25
    5446:	87 95       	ror	r24
    5448:	2a 95       	dec	r18
    544a:	e1 f7       	brne	.-8      	; 0x5444 <USB_Device_ProcessControlRequest+0x9a>
    544c:	98 2f       	mov	r25, r24
    544e:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5450:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5454:	80 91 e8 00 	lds	r24, 0x00E8
    5458:	87 7f       	andi	r24, 0xF7	; 247
    545a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    545e:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Word >> 8);
    5462:	10 92 f1 00 	sts	0x00F1, r1
    5466:	d3 c0       	rjmp	.+422    	; 0x560e <USB_Device_ProcessControlRequest+0x264>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5468:	88 23       	and	r24, r24
    546a:	19 f0       	breq	.+6      	; 0x5472 <USB_Device_ProcessControlRequest+0xc8>
    546c:	82 30       	cpi	r24, 0x02	; 2
    546e:	09 f0       	breq	.+2      	; 0x5472 <USB_Device_ProcessControlRequest+0xc8>
    5470:	f2 c0       	rjmp	.+484    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    5472:	90 e0       	ldi	r25, 0x00	; 0
    5474:	8f 71       	andi	r24, 0x1F	; 31
    5476:	90 70       	andi	r25, 0x00	; 0
    5478:	00 97       	sbiw	r24, 0x00	; 0
    547a:	21 f0       	breq	.+8      	; 0x5484 <USB_Device_ProcessControlRequest+0xda>
    547c:	02 97       	sbiw	r24, 0x02	; 2
    547e:	09 f0       	breq	.+2      	; 0x5482 <USB_Device_ProcessControlRequest+0xd8>
    5480:	ea c0       	rjmp	.+468    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
    5482:	0c c0       	rjmp	.+24     	; 0x549c <USB_Device_ProcessControlRequest+0xf2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    5484:	80 91 d8 0c 	lds	r24, 0x0CD8
    5488:	81 30       	cpi	r24, 0x01	; 1
    548a:	09 f0       	breq	.+2      	; 0x548e <USB_Device_ProcessControlRequest+0xe4>
    548c:	e4 c0       	rjmp	.+456    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    548e:	10 92 d2 0c 	sts	0x0CD2, r1
    5492:	33 30       	cpi	r19, 0x03	; 3
    5494:	69 f5       	brne	.+90     	; 0x54f0 <USB_Device_ProcessControlRequest+0x146>
    5496:	80 93 d2 0c 	sts	0x0CD2, r24
    549a:	2a c0       	rjmp	.+84     	; 0x54f0 <USB_Device_ProcessControlRequest+0x146>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    549c:	80 91 d8 0c 	lds	r24, 0x0CD8
    54a0:	88 23       	and	r24, r24
    54a2:	31 f5       	brne	.+76     	; 0x54f0 <USB_Device_ProcessControlRequest+0x146>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    54a4:	20 91 da 0c 	lds	r18, 0x0CDA
    54a8:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    54aa:	09 f4       	brne	.+2      	; 0x54ae <USB_Device_ProcessControlRequest+0x104>
    54ac:	d4 c0       	rjmp	.+424    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    54ae:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    54b2:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    54b6:	80 ff       	sbrs	r24, 0
    54b8:	1b c0       	rjmp	.+54     	; 0x54f0 <USB_Device_ProcessControlRequest+0x146>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    54ba:	33 30       	cpi	r19, 0x03	; 3
    54bc:	21 f4       	brne	.+8      	; 0x54c6 <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    54be:	80 91 eb 00 	lds	r24, 0x00EB
    54c2:	80 62       	ori	r24, 0x20	; 32
    54c4:	13 c0       	rjmp	.+38     	; 0x54ec <USB_Device_ProcessControlRequest+0x142>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    54c6:	80 91 eb 00 	lds	r24, 0x00EB
    54ca:	80 61       	ori	r24, 0x10	; 16
    54cc:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    54d0:	81 e0       	ldi	r24, 0x01	; 1
    54d2:	90 e0       	ldi	r25, 0x00	; 0
    54d4:	02 c0       	rjmp	.+4      	; 0x54da <USB_Device_ProcessControlRequest+0x130>
    54d6:	88 0f       	add	r24, r24
    54d8:	99 1f       	adc	r25, r25
    54da:	2a 95       	dec	r18
    54dc:	e2 f7       	brpl	.-8      	; 0x54d6 <USB_Device_ProcessControlRequest+0x12c>
    54de:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    54e2:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    54e6:	80 91 eb 00 	lds	r24, 0x00EB
    54ea:	88 60       	ori	r24, 0x08	; 8
    54ec:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    54f0:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    54f4:	80 91 e8 00 	lds	r24, 0x00E8
    54f8:	87 7f       	andi	r24, 0xF7	; 247
    54fa:	8c c0       	rjmp	.+280    	; 0x5614 <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    54fc:	88 23       	and	r24, r24
    54fe:	09 f0       	breq	.+2      	; 0x5502 <USB_Device_ProcessControlRequest+0x158>
    5500:	aa c0       	rjmp	.+340    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    5502:	10 91 d8 0c 	lds	r17, 0x0CD8
    5506:	1f 77       	andi	r17, 0x7F	; 127

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    5508:	0f b7       	in	r16, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    550a:	f8 94       	cli
    550c:	80 91 e8 00 	lds	r24, 0x00E8
    5510:	87 7f       	andi	r24, 0xF7	; 247
    5512:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_ClearSETUP();

		Endpoint_ClearStatusStage();
    5516:	4c d9       	rcall	.-3432   	; 0x47b0 <Endpoint_ClearStatusStage>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5518:	80 91 e8 00 	lds	r24, 0x00E8

		while (!(Endpoint_IsINReady()));
    551c:	80 ff       	sbrs	r24, 0
    551e:	fc cf       	rjmp	.-8      	; 0x5518 <USB_Device_ProcessControlRequest+0x16e>

		USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    5520:	11 23       	and	r17, r17
    5522:	11 f4       	brne	.+4      	; 0x5528 <USB_Device_ProcessControlRequest+0x17e>
    5524:	82 e0       	ldi	r24, 0x02	; 2
    5526:	01 c0       	rjmp	.+2      	; 0x552a <USB_Device_ProcessControlRequest+0x180>
    5528:	83 e0       	ldi	r24, 0x03	; 3
    552a:	80 93 d5 0c 	sts	0x0CD5, r24
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR  = ((UDADDR & (1 << ADDEN)) | (Address & 0x7F));
    552e:	80 91 e3 00 	lds	r24, 0x00E3
    5532:	80 78       	andi	r24, 0x80	; 128
    5534:	18 2b       	or	r17, r24
    5536:	10 93 e3 00 	sts	0x00E3, r17
				UDADDR |= (1 << ADDEN);
    553a:	80 91 e3 00 	lds	r24, 0x00E3
    553e:	80 68       	ori	r24, 0x80	; 128
    5540:	80 93 e3 00 	sts	0x00E3, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    5544:	0f bf       	out	0x3f, r16	; 63
    __asm__ volatile ("" ::: "memory");
    5546:	87 c0       	rjmp	.+270    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5548:	80 58       	subi	r24, 0x80	; 128
    554a:	82 30       	cpi	r24, 0x02	; 2
    554c:	08 f0       	brcs	.+2      	; 0x5550 <USB_Device_ProcessControlRequest+0x1a6>
    554e:	83 c0       	rjmp	.+262    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
	#if !defined(USE_FLASH_DESCRIPTORS) && !defined(USE_EEPROM_DESCRIPTORS) && !defined(USE_RAM_DESCRIPTORS)
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    5550:	80 91 d8 0c 	lds	r24, 0x0CD8
    5554:	90 91 d9 0c 	lds	r25, 0x0CD9
    5558:	23 e0       	ldi	r18, 0x03	; 3
    555a:	8c 3d       	cpi	r24, 0xDC	; 220
    555c:	92 07       	cpc	r25, r18
    555e:	99 f5       	brne	.+102    	; 0x55c6 <USB_Device_ProcessControlRequest+0x21c>
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    5560:	7f b7       	in	r23, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    5562:	f8 94       	cli
    5564:	de 01       	movw	r26, r28
    5566:	15 96       	adiw	r26, 0x05	; 5
    5568:	6e e0       	ldi	r22, 0x0E	; 14
    556a:	40 e0       	ldi	r20, 0x00	; 0
    556c:	50 e0       	ldi	r21, 0x00	; 0
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
		{
			uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    556e:	11 e2       	ldi	r17, 0x21	; 33
    5570:	e6 2f       	mov	r30, r22
    5572:	f0 e0       	ldi	r31, 0x00	; 0
    5574:	10 93 57 00 	sts	0x0057, r17
    5578:	84 91       	lpm	r24, Z+

			if (SerialCharNum & 0x01)
    557a:	40 ff       	sbrs	r20, 0
    557c:	03 c0       	rjmp	.+6      	; 0x5584 <USB_Device_ProcessControlRequest+0x1da>
			{
				SerialByte >>= 4;
    557e:	82 95       	swap	r24
    5580:	8f 70       	andi	r24, 0x0F	; 15
				SigReadAddress++;
    5582:	6f 5f       	subi	r22, 0xFF	; 255
			}

			SerialByte &= 0x0F;
    5584:	8f 70       	andi	r24, 0x0F	; 15
    5586:	28 2f       	mov	r18, r24
    5588:	30 e0       	ldi	r19, 0x00	; 0

			SignatureDescriptor.UnicodeString[SerialCharNum] = (SerialByte >= 10) ?
    558a:	8a 30       	cpi	r24, 0x0A	; 10
    558c:	18 f0       	brcs	.+6      	; 0x5594 <USB_Device_ProcessControlRequest+0x1ea>
    558e:	c9 01       	movw	r24, r18
    5590:	c7 96       	adiw	r24, 0x37	; 55
    5592:	02 c0       	rjmp	.+4      	; 0x5598 <USB_Device_ProcessControlRequest+0x1ee>
    5594:	c9 01       	movw	r24, r18
    5596:	c0 96       	adiw	r24, 0x30	; 48
    5598:	8d 93       	st	X+, r24
    559a:	9d 93       	st	X+, r25
    559c:	4f 5f       	subi	r20, 0xFF	; 255
    559e:	5f 4f       	sbci	r21, 0xFF	; 255

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
    55a0:	44 31       	cpi	r20, 0x14	; 20
    55a2:	51 05       	cpc	r21, r1
    55a4:	29 f7       	brne	.-54     	; 0x5570 <USB_Device_ProcessControlRequest+0x1c6>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    55a6:	7f bf       	out	0x3f, r23	; 63
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);
    55a8:	8a e2       	ldi	r24, 0x2A	; 42
    55aa:	8b 83       	std	Y+3, r24	; 0x03
	{
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    55ac:	83 e0       	ldi	r24, 0x03	; 3
    55ae:	8c 83       	std	Y+4, r24	; 0x04
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    55b0:	80 91 e8 00 	lds	r24, 0x00E8
    55b4:	87 7f       	andi	r24, 0xF7	; 247
    55b6:	80 93 e8 00 	sts	0x00E8, r24
		}
	}

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    55ba:	ce 01       	movw	r24, r28
    55bc:	03 96       	adiw	r24, 0x03	; 3
    55be:	6a e2       	ldi	r22, 0x2A	; 42
    55c0:	70 e0       	ldi	r23, 0x00	; 0
    55c2:	63 d0       	rcall	.+198    	; 0x568a <Endpoint_Write_Control_Stream_LE>
    55c4:	13 c0       	rjmp	.+38     	; 0x55ec <USB_Device_ProcessControlRequest+0x242>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    55c6:	60 91 da 0c 	lds	r22, 0x0CDA
    55ca:	ae 01       	movw	r20, r28
    55cc:	4f 5f       	subi	r20, 0xFF	; 255
    55ce:	5f 4f       	sbci	r21, 0xFF	; 255
    55d0:	0e 94 12 02 	call	0x424	; 0x424 <CALLBACK_USB_GetDescriptor>
    55d4:	bc 01       	movw	r22, r24
    55d6:	00 97       	sbiw	r24, 0x00	; 0
    55d8:	09 f4       	brne	.+2      	; 0x55dc <USB_Device_ProcessControlRequest+0x232>
    55da:	3d c0       	rjmp	.+122    	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
    55dc:	80 91 e8 00 	lds	r24, 0x00E8
    55e0:	87 7f       	andi	r24, 0xF7	; 247
    55e2:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    55e6:	89 81       	ldd	r24, Y+1	; 0x01
    55e8:	9a 81       	ldd	r25, Y+2	; 0x02
    55ea:	ad d0       	rcall	.+346    	; 0x5746 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    55ec:	80 91 e8 00 	lds	r24, 0x00E8
    55f0:	8b 77       	andi	r24, 0x7B	; 123
    55f2:	80 93 e8 00 	sts	0x00E8, r24
    55f6:	2f c0       	rjmp	.+94     	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    55f8:	80 38       	cpi	r24, 0x80	; 128
    55fa:	69 f5       	brne	.+90     	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    55fc:	80 91 e8 00 	lds	r24, 0x00E8
    5600:	87 7f       	andi	r24, 0xF7	; 247
    5602:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
    5606:	80 91 d3 0c 	lds	r24, 0x0CD3
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    560a:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    560e:	80 91 e8 00 	lds	r24, 0x00E8
    5612:	8e 77       	andi	r24, 0x7E	; 126
    5614:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    5618:	cb d8       	rcall	.-3690   	; 0x47b0 <Endpoint_ClearStatusStage>
    561a:	1d c0       	rjmp	.+58     	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    561c:	88 23       	and	r24, r24
    561e:	d9 f4       	brne	.+54     	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    5620:	90 91 d8 0c 	lds	r25, 0x0CD8
    5624:	92 30       	cpi	r25, 0x02	; 2
    5626:	b8 f4       	brcc	.+46     	; 0x5656 <USB_Device_ProcessControlRequest+0x2ac>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5628:	80 91 e8 00 	lds	r24, 0x00E8
    562c:	87 7f       	andi	r24, 0xF7	; 247
    562e:	80 93 e8 00 	sts	0x00E8, r24
	}
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    5632:	90 93 d3 0c 	sts	0x0CD3, r25

	Endpoint_ClearStatusStage();
    5636:	bc d8       	rcall	.-3720   	; 0x47b0 <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
    5638:	80 91 d3 0c 	lds	r24, 0x0CD3
    563c:	88 23       	and	r24, r24
    563e:	31 f4       	brne	.+12     	; 0x564c <USB_Device_ProcessControlRequest+0x2a2>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5640:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    5644:	87 fd       	sbrc	r24, 7
    5646:	02 c0       	rjmp	.+4      	; 0x564c <USB_Device_ProcessControlRequest+0x2a2>
    5648:	81 e0       	ldi	r24, 0x01	; 1
    564a:	01 c0       	rjmp	.+2      	; 0x564e <USB_Device_ProcessControlRequest+0x2a4>
    564c:	84 e0       	ldi	r24, 0x04	; 4
    564e:	80 93 d5 0c 	sts	0x0CD5, r24

	EVENT_USB_Device_ConfigurationChanged();
    5652:	0e 94 58 02 	call	0x4b0	; 0x4b0 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5656:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    565a:	83 ff       	sbrs	r24, 3
    565c:	0a c0       	rjmp	.+20     	; 0x5672 <USB_Device_ProcessControlRequest+0x2c8>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    565e:	80 91 eb 00 	lds	r24, 0x00EB
    5662:	80 62       	ori	r24, 0x20	; 32
    5664:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5668:	80 91 e8 00 	lds	r24, 0x00E8
    566c:	87 7f       	andi	r24, 0xF7	; 247
    566e:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    5672:	ac 96       	adiw	r28, 0x2c	; 44
    5674:	0f b6       	in	r0, 0x3f	; 63
    5676:	f8 94       	cli
    5678:	de bf       	out	0x3e, r29	; 62
    567a:	0f be       	out	0x3f, r0	; 63
    567c:	cd bf       	out	0x3d, r28	; 61
    567e:	cf 91       	pop	r28
    5680:	df 91       	pop	r29
    5682:	1f 91       	pop	r17
    5684:	0f 91       	pop	r16
    5686:	08 95       	ret

00005688 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    5688:	08 95       	ret

0000568a <Endpoint_Write_Control_Stream_LE>:
    568a:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    568c:	40 91 dc 0c 	lds	r20, 0x0CDC
    5690:	50 91 dd 0c 	lds	r21, 0x0CDD
    5694:	46 17       	cp	r20, r22
    5696:	57 07       	cpc	r21, r23
    5698:	18 f4       	brcc	.+6      	; 0x56a0 <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    569a:	f9 01       	movw	r30, r18
    569c:	90 e0       	ldi	r25, 0x00	; 0
    569e:	3d c0       	rjmp	.+122    	; 0x571a <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    56a0:	61 15       	cp	r22, r1
    56a2:	71 05       	cpc	r23, r1
    56a4:	11 f0       	breq	.+4      	; 0x56aa <Endpoint_Write_Control_Stream_LE+0x20>
    56a6:	ab 01       	movw	r20, r22
    56a8:	f8 cf       	rjmp	.-16     	; 0x569a <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    56aa:	80 91 e8 00 	lds	r24, 0x00E8
    56ae:	8e 77       	andi	r24, 0x7E	; 126
    56b0:	80 93 e8 00 	sts	0x00E8, r24
    56b4:	40 e0       	ldi	r20, 0x00	; 0
    56b6:	50 e0       	ldi	r21, 0x00	; 0
    56b8:	f0 cf       	rjmp	.-32     	; 0x569a <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    56ba:	80 91 d5 0c 	lds	r24, 0x0CD5

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    56be:	88 23       	and	r24, r24
    56c0:	f1 f1       	breq	.+124    	; 0x573e <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    56c2:	85 30       	cpi	r24, 0x05	; 5
    56c4:	f1 f1       	breq	.+124    	; 0x5742 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    56c6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    56ca:	83 ff       	sbrs	r24, 3
    56cc:	02 c0       	rjmp	.+4      	; 0x56d2 <Endpoint_Write_Control_Stream_LE+0x48>
    56ce:	81 e0       	ldi	r24, 0x01	; 1
    56d0:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    56d2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    56d6:	82 fd       	sbrc	r24, 2
    56d8:	2c c0       	rjmp	.+88     	; 0x5732 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    56da:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    56de:	80 ff       	sbrs	r24, 0
    56e0:	1c c0       	rjmp	.+56     	; 0x571a <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    56e2:	20 91 f2 00 	lds	r18, 0x00F2
    56e6:	30 91 f3 00 	lds	r19, 0x00F3
    56ea:	07 c0       	rjmp	.+14     	; 0x56fa <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    56ec:	81 91       	ld	r24, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    56ee:	80 93 f1 00 	sts	0x00F1, r24
				Length--;
    56f2:	41 50       	subi	r20, 0x01	; 1
    56f4:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    56f6:	2f 5f       	subi	r18, 0xFF	; 255
    56f8:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    56fa:	41 15       	cp	r20, r1
    56fc:	51 05       	cpc	r21, r1
    56fe:	19 f0       	breq	.+6      	; 0x5706 <Endpoint_Write_Control_Stream_LE+0x7c>
    5700:	28 30       	cpi	r18, 0x08	; 8
    5702:	31 05       	cpc	r19, r1
    5704:	98 f3       	brcs	.-26     	; 0x56ec <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    5706:	90 e0       	ldi	r25, 0x00	; 0
    5708:	28 30       	cpi	r18, 0x08	; 8
    570a:	31 05       	cpc	r19, r1
    570c:	09 f4       	brne	.+2      	; 0x5710 <Endpoint_Write_Control_Stream_LE+0x86>
    570e:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5710:	80 91 e8 00 	lds	r24, 0x00E8
    5714:	8e 77       	andi	r24, 0x7E	; 126
    5716:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    571a:	41 15       	cp	r20, r1
    571c:	51 05       	cpc	r21, r1
    571e:	69 f6       	brne	.-102    	; 0x56ba <Endpoint_Write_Control_Stream_LE+0x30>
    5720:	99 23       	and	r25, r25
    5722:	59 f6       	brne	.-106    	; 0x56ba <Endpoint_Write_Control_Stream_LE+0x30>
    5724:	06 c0       	rjmp	.+12     	; 0x5732 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    5726:	80 91 d5 0c 	lds	r24, 0x0CD5

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    572a:	88 23       	and	r24, r24
    572c:	41 f0       	breq	.+16     	; 0x573e <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    572e:	85 30       	cpi	r24, 0x05	; 5
    5730:	41 f0       	breq	.+16     	; 0x5742 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5732:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    5736:	82 ff       	sbrs	r24, 2
    5738:	f6 cf       	rjmp	.-20     	; 0x5726 <Endpoint_Write_Control_Stream_LE+0x9c>
    573a:	80 e0       	ldi	r24, 0x00	; 0
    573c:	08 95       	ret
    573e:	82 e0       	ldi	r24, 0x02	; 2
    5740:	08 95       	ret
    5742:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    5744:	08 95       	ret

00005746 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
    5746:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    5748:	40 91 dc 0c 	lds	r20, 0x0CDC
    574c:	50 91 dd 0c 	lds	r21, 0x0CDD
    5750:	46 17       	cp	r20, r22
    5752:	57 07       	cpc	r21, r23
    5754:	10 f4       	brcc	.+4      	; 0x575a <Endpoint_Write_Control_PStream_LE+0x14>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5756:	60 e0       	ldi	r22, 0x00	; 0
    5758:	40 c0       	rjmp	.+128    	; 0x57da <Endpoint_Write_Control_PStream_LE+0x94>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    575a:	61 15       	cp	r22, r1
    575c:	71 05       	cpc	r23, r1
    575e:	11 f0       	breq	.+4      	; 0x5764 <Endpoint_Write_Control_PStream_LE+0x1e>
    5760:	ab 01       	movw	r20, r22
    5762:	f9 cf       	rjmp	.-14     	; 0x5756 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5764:	80 91 e8 00 	lds	r24, 0x00E8
    5768:	8e 77       	andi	r24, 0x7E	; 126
    576a:	80 93 e8 00 	sts	0x00E8, r24
    576e:	40 e0       	ldi	r20, 0x00	; 0
    5770:	50 e0       	ldi	r21, 0x00	; 0
    5772:	f1 cf       	rjmp	.-30     	; 0x5756 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    5774:	80 91 d5 0c 	lds	r24, 0x0CD5

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    5778:	88 23       	and	r24, r24
    577a:	09 f4       	brne	.+2      	; 0x577e <Endpoint_Write_Control_PStream_LE+0x38>
    577c:	40 c0       	rjmp	.+128    	; 0x57fe <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    577e:	85 30       	cpi	r24, 0x05	; 5
    5780:	09 f4       	brne	.+2      	; 0x5784 <Endpoint_Write_Control_PStream_LE+0x3e>
    5782:	3f c0       	rjmp	.+126    	; 0x5802 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5784:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    5788:	83 ff       	sbrs	r24, 3
    578a:	02 c0       	rjmp	.+4      	; 0x5790 <Endpoint_Write_Control_PStream_LE+0x4a>
    578c:	81 e0       	ldi	r24, 0x01	; 1
    578e:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5790:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    5794:	82 fd       	sbrc	r24, 2
    5796:	2d c0       	rjmp	.+90     	; 0x57f2 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5798:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    579c:	80 ff       	sbrs	r24, 0
    579e:	1d c0       	rjmp	.+58     	; 0x57da <Endpoint_Write_Control_PStream_LE+0x94>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    57a0:	80 91 f2 00 	lds	r24, 0x00F2
    57a4:	90 91 f3 00 	lds	r25, 0x00F3
    57a8:	09 c0       	rjmp	.+18     	; 0x57bc <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    57aa:	f9 01       	movw	r30, r18
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    57ac:	2f 5f       	subi	r18, 0xFF	; 255
    57ae:	3f 4f       	sbci	r19, 0xFF	; 255
    57b0:	e4 91       	lpm	r30, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    57b2:	e0 93 f1 00 	sts	0x00F1, r30
				Length--;
    57b6:	41 50       	subi	r20, 0x01	; 1
    57b8:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    57ba:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    57bc:	41 15       	cp	r20, r1
    57be:	51 05       	cpc	r21, r1
    57c0:	19 f0       	breq	.+6      	; 0x57c8 <Endpoint_Write_Control_PStream_LE+0x82>
    57c2:	88 30       	cpi	r24, 0x08	; 8
    57c4:	91 05       	cpc	r25, r1
    57c6:	88 f3       	brcs	.-30     	; 0x57aa <Endpoint_Write_Control_PStream_LE+0x64>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    57c8:	60 e0       	ldi	r22, 0x00	; 0
    57ca:	08 97       	sbiw	r24, 0x08	; 8
    57cc:	09 f4       	brne	.+2      	; 0x57d0 <Endpoint_Write_Control_PStream_LE+0x8a>
    57ce:	61 e0       	ldi	r22, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    57d0:	80 91 e8 00 	lds	r24, 0x00E8
    57d4:	8e 77       	andi	r24, 0x7E	; 126
    57d6:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    57da:	41 15       	cp	r20, r1
    57dc:	51 05       	cpc	r21, r1
    57de:	51 f6       	brne	.-108    	; 0x5774 <Endpoint_Write_Control_PStream_LE+0x2e>
    57e0:	66 23       	and	r22, r22
    57e2:	41 f6       	brne	.-112    	; 0x5774 <Endpoint_Write_Control_PStream_LE+0x2e>
    57e4:	06 c0       	rjmp	.+12     	; 0x57f2 <Endpoint_Write_Control_PStream_LE+0xac>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    57e6:	80 91 d5 0c 	lds	r24, 0x0CD5

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    57ea:	88 23       	and	r24, r24
    57ec:	41 f0       	breq	.+16     	; 0x57fe <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    57ee:	85 30       	cpi	r24, 0x05	; 5
    57f0:	41 f0       	breq	.+16     	; 0x5802 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    57f2:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    57f6:	82 ff       	sbrs	r24, 2
    57f8:	f6 cf       	rjmp	.-20     	; 0x57e6 <Endpoint_Write_Control_PStream_LE+0xa0>
    57fa:	80 e0       	ldi	r24, 0x00	; 0
    57fc:	08 95       	ret
    57fe:	82 e0       	ldi	r24, 0x02	; 2
    5800:	08 95       	ret
    5802:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    5804:	08 95       	ret

00005806 <Endpoint_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    5806:	bf 92       	push	r11
    5808:	cf 92       	push	r12
    580a:	df 92       	push	r13
    580c:	ef 92       	push	r14
    580e:	ff 92       	push	r15
    5810:	0f 93       	push	r16
    5812:	1f 93       	push	r17
    5814:	cf 93       	push	r28
    5816:	df 93       	push	r29
    5818:	d8 2e       	mov	r13, r24
    581a:	c9 2e       	mov	r12, r25
    581c:	8b 01       	movw	r16, r22
    581e:	7a 01       	movw	r14, r20
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    5820:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    5824:	b8 2e       	mov	r11, r24
    5826:	88 23       	and	r24, r24
    5828:	09 f0       	breq	.+2      	; 0x582c <Endpoint_Read_Stream_LE+0x26>
    582a:	70 c0       	rjmp	.+224    	; 0x590c <Endpoint_Read_Stream_LE+0x106>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    582c:	8d 2d       	mov	r24, r13
    582e:	9c 2d       	mov	r25, r12
    5830:	9c 01       	movw	r18, r24
    5832:	e9 01       	movw	r28, r18
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    5834:	80 91 f2 00 	lds	r24, 0x00F2
    5838:	90 91 f3 00 	lds	r25, 0x00F3
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Endpoint_BytesInEndpoint() & 0x07);

	if (Length >= 8)
    583c:	08 30       	cpi	r16, 0x08	; 8
    583e:	11 05       	cpc	r17, r1
    5840:	08 f4       	brcc	.+2      	; 0x5844 <Endpoint_Read_Stream_LE+0x3e>
    5842:	61 c0       	rjmp	.+194    	; 0x5906 <Endpoint_Read_Stream_LE+0x100>

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Endpoint_BytesInEndpoint() & 0x07);
    5844:	87 70       	andi	r24, 0x07	; 7

	if (Length >= 8)
	{
		Length -= BytesRemToAlignment;
    5846:	08 1b       	sub	r16, r24
    5848:	11 09       	sbc	r17, r1

		switch (BytesRemToAlignment)
    584a:	84 30       	cpi	r24, 0x04	; 4
    584c:	91 f1       	breq	.+100    	; 0x58b2 <Endpoint_Read_Stream_LE+0xac>
    584e:	85 30       	cpi	r24, 0x05	; 5
    5850:	38 f4       	brcc	.+14     	; 0x5860 <Endpoint_Read_Stream_LE+0x5a>
    5852:	82 30       	cpi	r24, 0x02	; 2
    5854:	a1 f1       	breq	.+104    	; 0x58be <Endpoint_Read_Stream_LE+0xb8>
    5856:	83 30       	cpi	r24, 0x03	; 3
    5858:	78 f5       	brcc	.+94     	; 0x58b8 <Endpoint_Read_Stream_LE+0xb2>
    585a:	81 30       	cpi	r24, 0x01	; 1
    585c:	39 f4       	brne	.+14     	; 0x586c <Endpoint_Read_Stream_LE+0x66>
    585e:	32 c0       	rjmp	.+100    	; 0x58c4 <Endpoint_Read_Stream_LE+0xbe>
    5860:	86 30       	cpi	r24, 0x06	; 6
    5862:	09 f1       	breq	.+66     	; 0x58a6 <Endpoint_Read_Stream_LE+0xa0>
    5864:	86 30       	cpi	r24, 0x06	; 6
    5866:	10 f1       	brcs	.+68     	; 0x58ac <Endpoint_Read_Stream_LE+0xa6>
    5868:	87 30       	cpi	r24, 0x07	; 7
    586a:	d1 f0       	breq	.+52     	; 0x58a0 <Endpoint_Read_Stream_LE+0x9a>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    586c:	80 91 e8 00 	lds	r24, 0x00E8
		{
			default:
				do
				{
					if (!(Endpoint_IsReadWriteAllowed()))
    5870:	85 fd       	sbrc	r24, 5
    5872:	11 c0       	rjmp	.+34     	; 0x5896 <Endpoint_Read_Stream_LE+0x90>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5874:	80 91 e8 00 	lds	r24, 0x00E8
    5878:	8b 77       	andi	r24, 0x7B	; 123
    587a:	80 93 e8 00 	sts	0x00E8, r24
					{
						TEMPLATE_CLEAR_ENDPOINT();

						#if !defined(NO_STREAM_CALLBACKS)
						if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    587e:	e1 14       	cp	r14, r1
    5880:	f1 04       	cpc	r15, r1
    5882:	29 f0       	breq	.+10     	; 0x588e <Endpoint_Read_Stream_LE+0x88>
    5884:	f7 01       	movw	r30, r14
    5886:	09 95       	icall
    5888:	81 30       	cpi	r24, 0x01	; 1
    588a:	09 f4       	brne	.+2      	; 0x588e <Endpoint_Read_Stream_LE+0x88>
    588c:	41 c0       	rjmp	.+130    	; 0x5910 <Endpoint_Read_Stream_LE+0x10a>
						  return ENDPOINT_RWSTREAM_CallbackAborted;
						#endif

						if ((ErrorCode = Endpoint_WaitUntilReady()))
    588e:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    5892:	88 23       	and	r24, r24
    5894:	f1 f5       	brne	.+124    	; 0x5912 <Endpoint_Read_Stream_LE+0x10c>
						  return ErrorCode;
					}

					Length -= 8;
    5896:	08 50       	subi	r16, 0x08	; 8
    5898:	10 40       	sbci	r17, 0x00	; 0
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    589a:	80 91 f1 00 	lds	r24, 0x00F1

					TEMPLATE_TRANSFER_BYTE(DataStream);
    589e:	89 93       	st	Y+, r24
    58a0:	80 91 f1 00 	lds	r24, 0x00F1
			case 7: TEMPLATE_TRANSFER_BYTE(DataStream);
    58a4:	89 93       	st	Y+, r24
    58a6:	80 91 f1 00 	lds	r24, 0x00F1
			case 6: TEMPLATE_TRANSFER_BYTE(DataStream);
    58aa:	89 93       	st	Y+, r24
    58ac:	80 91 f1 00 	lds	r24, 0x00F1
			case 5: TEMPLATE_TRANSFER_BYTE(DataStream);
    58b0:	89 93       	st	Y+, r24
    58b2:	80 91 f1 00 	lds	r24, 0x00F1
			case 4: TEMPLATE_TRANSFER_BYTE(DataStream);
    58b6:	89 93       	st	Y+, r24
    58b8:	80 91 f1 00 	lds	r24, 0x00F1
			case 3: TEMPLATE_TRANSFER_BYTE(DataStream);
    58bc:	89 93       	st	Y+, r24
    58be:	80 91 f1 00 	lds	r24, 0x00F1
			case 2: TEMPLATE_TRANSFER_BYTE(DataStream);
    58c2:	89 93       	st	Y+, r24
    58c4:	80 91 f1 00 	lds	r24, 0x00F1
			case 1:	TEMPLATE_TRANSFER_BYTE(DataStream);
    58c8:	89 93       	st	Y+, r24
				} while (Length >= 8);
    58ca:	08 30       	cpi	r16, 0x08	; 8
    58cc:	11 05       	cpc	r17, r1
    58ce:	70 f6       	brcc	.-100    	; 0x586c <Endpoint_Read_Stream_LE+0x66>
    58d0:	1a c0       	rjmp	.+52     	; 0x5906 <Endpoint_Read_Stream_LE+0x100>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    58d2:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    58d6:	85 fd       	sbrc	r24, 5
    58d8:	11 c0       	rjmp	.+34     	; 0x58fc <Endpoint_Read_Stream_LE+0xf6>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    58da:	80 91 e8 00 	lds	r24, 0x00E8
    58de:	8b 77       	andi	r24, 0x7B	; 123
    58e0:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    58e4:	e1 14       	cp	r14, r1
    58e6:	f1 04       	cpc	r15, r1
    58e8:	21 f0       	breq	.+8      	; 0x58f2 <Endpoint_Read_Stream_LE+0xec>
    58ea:	f7 01       	movw	r30, r14
    58ec:	09 95       	icall
    58ee:	81 30       	cpi	r24, 0x01	; 1
    58f0:	79 f0       	breq	.+30     	; 0x5910 <Endpoint_Read_Stream_LE+0x10a>
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    58f2:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    58f6:	88 23       	and	r24, r24
    58f8:	31 f0       	breq	.+12     	; 0x5906 <Endpoint_Read_Stream_LE+0x100>
    58fa:	0b c0       	rjmp	.+22     	; 0x5912 <Endpoint_Read_Stream_LE+0x10c>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    58fc:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5900:	89 93       	st	Y+, r24
			Length--;
    5902:	01 50       	subi	r16, 0x01	; 1
    5904:	10 40       	sbci	r17, 0x00	; 0
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    5906:	01 15       	cp	r16, r1
    5908:	11 05       	cpc	r17, r1
    590a:	19 f7       	brne	.-58     	; 0x58d2 <Endpoint_Read_Stream_LE+0xcc>
    590c:	8b 2d       	mov	r24, r11
    590e:	01 c0       	rjmp	.+2      	; 0x5912 <Endpoint_Read_Stream_LE+0x10c>
    5910:	85 e0       	ldi	r24, 0x05	; 5
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    5912:	df 91       	pop	r29
    5914:	cf 91       	pop	r28
    5916:	1f 91       	pop	r17
    5918:	0f 91       	pop	r16
    591a:	ff 90       	pop	r15
    591c:	ef 90       	pop	r14
    591e:	df 90       	pop	r13
    5920:	cf 90       	pop	r12
    5922:	bf 90       	pop	r11
    5924:	08 95       	ret

00005926 <Endpoint_Write_Stream_BE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    5926:	df 92       	push	r13
    5928:	ef 92       	push	r14
    592a:	ff 92       	push	r15
    592c:	0f 93       	push	r16
    592e:	1f 93       	push	r17
    5930:	cf 93       	push	r28
    5932:	df 93       	push	r29
    5934:	ec 01       	movw	r28, r24
    5936:	8b 01       	movw	r16, r22
    5938:	7a 01       	movw	r14, r20
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    593a:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    593e:	d8 2e       	mov	r13, r24
    5940:	88 23       	and	r24, r24
    5942:	09 f0       	breq	.+2      	; 0x5946 <Endpoint_Write_Stream_BE+0x20>
    5944:	7c c0       	rjmp	.+248    	; 0x5a3e <Endpoint_Write_Stream_BE+0x118>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5946:	01 50       	subi	r16, 0x01	; 1
    5948:	10 40       	sbci	r17, 0x00	; 0
    594a:	c0 0f       	add	r28, r16
    594c:	d1 1f       	adc	r29, r17
    594e:	0f 5f       	subi	r16, 0xFF	; 255
    5950:	1f 4f       	sbci	r17, 0xFF	; 255
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    5952:	80 91 f2 00 	lds	r24, 0x00F2
    5956:	90 91 f3 00 	lds	r25, 0x00F3
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Endpoint_BytesInEndpoint() & 0x07);

	if (Length >= 8)
    595a:	08 30       	cpi	r16, 0x08	; 8
    595c:	11 05       	cpc	r17, r1
    595e:	08 f4       	brcc	.+2      	; 0x5962 <Endpoint_Write_Stream_BE+0x3c>
    5960:	6b c0       	rjmp	.+214    	; 0x5a38 <Endpoint_Write_Stream_BE+0x112>

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Endpoint_BytesInEndpoint() & 0x07);
    5962:	87 70       	andi	r24, 0x07	; 7

	if (Length >= 8)
	{
		Length -= BytesRemToAlignment;
    5964:	08 1b       	sub	r16, r24
    5966:	11 09       	sbc	r17, r1

		switch (BytesRemToAlignment)
    5968:	84 30       	cpi	r24, 0x04	; 4
    596a:	b9 f1       	breq	.+110    	; 0x59da <Endpoint_Write_Stream_BE+0xb4>
    596c:	85 30       	cpi	r24, 0x05	; 5
    596e:	38 f4       	brcc	.+14     	; 0x597e <Endpoint_Write_Stream_BE+0x58>
    5970:	82 30       	cpi	r24, 0x02	; 2
    5972:	d9 f1       	breq	.+118    	; 0x59ea <Endpoint_Write_Stream_BE+0xc4>
    5974:	83 30       	cpi	r24, 0x03	; 3
    5976:	a8 f5       	brcc	.+106    	; 0x59e2 <Endpoint_Write_Stream_BE+0xbc>
    5978:	81 30       	cpi	r24, 0x01	; 1
    597a:	39 f4       	brne	.+14     	; 0x598a <Endpoint_Write_Stream_BE+0x64>
    597c:	3a c0       	rjmp	.+116    	; 0x59f2 <Endpoint_Write_Stream_BE+0xcc>
    597e:	86 30       	cpi	r24, 0x06	; 6
    5980:	21 f1       	breq	.+72     	; 0x59ca <Endpoint_Write_Stream_BE+0xa4>
    5982:	86 30       	cpi	r24, 0x06	; 6
    5984:	30 f1       	brcs	.+76     	; 0x59d2 <Endpoint_Write_Stream_BE+0xac>
    5986:	87 30       	cpi	r24, 0x07	; 7
    5988:	e1 f0       	breq	.+56     	; 0x59c2 <Endpoint_Write_Stream_BE+0x9c>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    598a:	80 91 e8 00 	lds	r24, 0x00E8
		{
			default:
				do
				{
					if (!(Endpoint_IsReadWriteAllowed()))
    598e:	85 fd       	sbrc	r24, 5
    5990:	12 c0       	rjmp	.+36     	; 0x59b6 <Endpoint_Write_Stream_BE+0x90>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5992:	80 91 e8 00 	lds	r24, 0x00E8
    5996:	8e 77       	andi	r24, 0x7E	; 126
    5998:	80 93 e8 00 	sts	0x00E8, r24
					{
						TEMPLATE_CLEAR_ENDPOINT();

						#if !defined(NO_STREAM_CALLBACKS)
						if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    599c:	e1 14       	cp	r14, r1
    599e:	f1 04       	cpc	r15, r1
    59a0:	29 f0       	breq	.+10     	; 0x59ac <Endpoint_Write_Stream_BE+0x86>
    59a2:	f7 01       	movw	r30, r14
    59a4:	09 95       	icall
    59a6:	81 30       	cpi	r24, 0x01	; 1
    59a8:	09 f4       	brne	.+2      	; 0x59ac <Endpoint_Write_Stream_BE+0x86>
    59aa:	4b c0       	rjmp	.+150    	; 0x5a42 <Endpoint_Write_Stream_BE+0x11c>
						  return ENDPOINT_RWSTREAM_CallbackAborted;
						#endif

						if ((ErrorCode = Endpoint_WaitUntilReady()))
    59ac:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    59b0:	88 23       	and	r24, r24
    59b2:	09 f0       	breq	.+2      	; 0x59b6 <Endpoint_Write_Stream_BE+0x90>
    59b4:	47 c0       	rjmp	.+142    	; 0x5a44 <Endpoint_Write_Stream_BE+0x11e>
						  return ErrorCode;
					}

					Length -= 8;
    59b6:	08 50       	subi	r16, 0x08	; 8
    59b8:	10 40       	sbci	r17, 0x00	; 0

					TEMPLATE_TRANSFER_BYTE(DataStream);
    59ba:	88 81       	ld	r24, Y
    59bc:	21 97       	sbiw	r28, 0x01	; 1
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    59be:	80 93 f1 00 	sts	0x00F1, r24
			case 7: TEMPLATE_TRANSFER_BYTE(DataStream);
    59c2:	88 81       	ld	r24, Y
    59c4:	21 97       	sbiw	r28, 0x01	; 1
    59c6:	80 93 f1 00 	sts	0x00F1, r24
			case 6: TEMPLATE_TRANSFER_BYTE(DataStream);
    59ca:	88 81       	ld	r24, Y
    59cc:	21 97       	sbiw	r28, 0x01	; 1
    59ce:	80 93 f1 00 	sts	0x00F1, r24
			case 5: TEMPLATE_TRANSFER_BYTE(DataStream);
    59d2:	88 81       	ld	r24, Y
    59d4:	21 97       	sbiw	r28, 0x01	; 1
    59d6:	80 93 f1 00 	sts	0x00F1, r24
			case 4: TEMPLATE_TRANSFER_BYTE(DataStream);
    59da:	88 81       	ld	r24, Y
    59dc:	21 97       	sbiw	r28, 0x01	; 1
    59de:	80 93 f1 00 	sts	0x00F1, r24
			case 3: TEMPLATE_TRANSFER_BYTE(DataStream);
    59e2:	88 81       	ld	r24, Y
    59e4:	21 97       	sbiw	r28, 0x01	; 1
    59e6:	80 93 f1 00 	sts	0x00F1, r24
			case 2: TEMPLATE_TRANSFER_BYTE(DataStream);
    59ea:	88 81       	ld	r24, Y
    59ec:	21 97       	sbiw	r28, 0x01	; 1
    59ee:	80 93 f1 00 	sts	0x00F1, r24
			case 1:	TEMPLATE_TRANSFER_BYTE(DataStream);
    59f2:	88 81       	ld	r24, Y
    59f4:	21 97       	sbiw	r28, 0x01	; 1
    59f6:	80 93 f1 00 	sts	0x00F1, r24
				} while (Length >= 8);
    59fa:	08 30       	cpi	r16, 0x08	; 8
    59fc:	11 05       	cpc	r17, r1
    59fe:	28 f6       	brcc	.-118    	; 0x598a <Endpoint_Write_Stream_BE+0x64>
    5a00:	1b c0       	rjmp	.+54     	; 0x5a38 <Endpoint_Write_Stream_BE+0x112>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5a02:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    5a06:	85 fd       	sbrc	r24, 5
    5a08:	11 c0       	rjmp	.+34     	; 0x5a2c <Endpoint_Write_Stream_BE+0x106>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5a0a:	80 91 e8 00 	lds	r24, 0x00E8
    5a0e:	8e 77       	andi	r24, 0x7E	; 126
    5a10:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5a14:	e1 14       	cp	r14, r1
    5a16:	f1 04       	cpc	r15, r1
    5a18:	21 f0       	breq	.+8      	; 0x5a22 <Endpoint_Write_Stream_BE+0xfc>
    5a1a:	f7 01       	movw	r30, r14
    5a1c:	09 95       	icall
    5a1e:	81 30       	cpi	r24, 0x01	; 1
    5a20:	81 f0       	breq	.+32     	; 0x5a42 <Endpoint_Write_Stream_BE+0x11c>
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    5a22:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    5a26:	88 23       	and	r24, r24
    5a28:	39 f0       	breq	.+14     	; 0x5a38 <Endpoint_Write_Stream_BE+0x112>
    5a2a:	0c c0       	rjmp	.+24     	; 0x5a44 <Endpoint_Write_Stream_BE+0x11e>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5a2c:	88 81       	ld	r24, Y
    5a2e:	21 97       	sbiw	r28, 0x01	; 1
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    5a30:	80 93 f1 00 	sts	0x00F1, r24
			Length--;
    5a34:	01 50       	subi	r16, 0x01	; 1
    5a36:	10 40       	sbci	r17, 0x00	; 0
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    5a38:	01 15       	cp	r16, r1
    5a3a:	11 05       	cpc	r17, r1
    5a3c:	11 f7       	brne	.-60     	; 0x5a02 <Endpoint_Write_Stream_BE+0xdc>
    5a3e:	8d 2d       	mov	r24, r13
    5a40:	01 c0       	rjmp	.+2      	; 0x5a44 <Endpoint_Write_Stream_BE+0x11e>
    5a42:	85 e0       	ldi	r24, 0x05	; 5
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    5a44:	df 91       	pop	r29
    5a46:	cf 91       	pop	r28
    5a48:	1f 91       	pop	r17
    5a4a:	0f 91       	pop	r16
    5a4c:	ff 90       	pop	r15
    5a4e:	ef 90       	pop	r14
    5a50:	df 90       	pop	r13
    5a52:	08 95       	ret

00005a54 <Endpoint_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    5a54:	bf 92       	push	r11
    5a56:	cf 92       	push	r12
    5a58:	df 92       	push	r13
    5a5a:	ef 92       	push	r14
    5a5c:	ff 92       	push	r15
    5a5e:	0f 93       	push	r16
    5a60:	1f 93       	push	r17
    5a62:	cf 93       	push	r28
    5a64:	df 93       	push	r29
    5a66:	d8 2e       	mov	r13, r24
    5a68:	c9 2e       	mov	r12, r25
    5a6a:	8b 01       	movw	r16, r22
    5a6c:	7a 01       	movw	r14, r20
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    5a6e:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    5a72:	b8 2e       	mov	r11, r24
    5a74:	88 23       	and	r24, r24
    5a76:	09 f0       	breq	.+2      	; 0x5a7a <Endpoint_Write_Stream_LE+0x26>
    5a78:	70 c0       	rjmp	.+224    	; 0x5b5a <Endpoint_Write_Stream_LE+0x106>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5a7a:	8d 2d       	mov	r24, r13
    5a7c:	9c 2d       	mov	r25, r12
    5a7e:	9c 01       	movw	r18, r24
    5a80:	e9 01       	movw	r28, r18
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    5a82:	80 91 f2 00 	lds	r24, 0x00F2
    5a86:	90 91 f3 00 	lds	r25, 0x00F3
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Endpoint_BytesInEndpoint() & 0x07);

	if (Length >= 8)
    5a8a:	08 30       	cpi	r16, 0x08	; 8
    5a8c:	11 05       	cpc	r17, r1
    5a8e:	08 f4       	brcc	.+2      	; 0x5a92 <Endpoint_Write_Stream_LE+0x3e>
    5a90:	61 c0       	rjmp	.+194    	; 0x5b54 <Endpoint_Write_Stream_LE+0x100>

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Endpoint_BytesInEndpoint() & 0x07);
    5a92:	87 70       	andi	r24, 0x07	; 7

	if (Length >= 8)
	{
		Length -= BytesRemToAlignment;
    5a94:	08 1b       	sub	r16, r24
    5a96:	11 09       	sbc	r17, r1

		switch (BytesRemToAlignment)
    5a98:	84 30       	cpi	r24, 0x04	; 4
    5a9a:	91 f1       	breq	.+100    	; 0x5b00 <Endpoint_Write_Stream_LE+0xac>
    5a9c:	85 30       	cpi	r24, 0x05	; 5
    5a9e:	38 f4       	brcc	.+14     	; 0x5aae <Endpoint_Write_Stream_LE+0x5a>
    5aa0:	82 30       	cpi	r24, 0x02	; 2
    5aa2:	a1 f1       	breq	.+104    	; 0x5b0c <Endpoint_Write_Stream_LE+0xb8>
    5aa4:	83 30       	cpi	r24, 0x03	; 3
    5aa6:	78 f5       	brcc	.+94     	; 0x5b06 <Endpoint_Write_Stream_LE+0xb2>
    5aa8:	81 30       	cpi	r24, 0x01	; 1
    5aaa:	39 f4       	brne	.+14     	; 0x5aba <Endpoint_Write_Stream_LE+0x66>
    5aac:	32 c0       	rjmp	.+100    	; 0x5b12 <Endpoint_Write_Stream_LE+0xbe>
    5aae:	86 30       	cpi	r24, 0x06	; 6
    5ab0:	09 f1       	breq	.+66     	; 0x5af4 <Endpoint_Write_Stream_LE+0xa0>
    5ab2:	86 30       	cpi	r24, 0x06	; 6
    5ab4:	10 f1       	brcs	.+68     	; 0x5afa <Endpoint_Write_Stream_LE+0xa6>
    5ab6:	87 30       	cpi	r24, 0x07	; 7
    5ab8:	d1 f0       	breq	.+52     	; 0x5aee <Endpoint_Write_Stream_LE+0x9a>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5aba:	80 91 e8 00 	lds	r24, 0x00E8
		{
			default:
				do
				{
					if (!(Endpoint_IsReadWriteAllowed()))
    5abe:	85 fd       	sbrc	r24, 5
    5ac0:	11 c0       	rjmp	.+34     	; 0x5ae4 <Endpoint_Write_Stream_LE+0x90>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5ac2:	80 91 e8 00 	lds	r24, 0x00E8
    5ac6:	8e 77       	andi	r24, 0x7E	; 126
    5ac8:	80 93 e8 00 	sts	0x00E8, r24
					{
						TEMPLATE_CLEAR_ENDPOINT();

						#if !defined(NO_STREAM_CALLBACKS)
						if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5acc:	e1 14       	cp	r14, r1
    5ace:	f1 04       	cpc	r15, r1
    5ad0:	29 f0       	breq	.+10     	; 0x5adc <Endpoint_Write_Stream_LE+0x88>
    5ad2:	f7 01       	movw	r30, r14
    5ad4:	09 95       	icall
    5ad6:	81 30       	cpi	r24, 0x01	; 1
    5ad8:	09 f4       	brne	.+2      	; 0x5adc <Endpoint_Write_Stream_LE+0x88>
    5ada:	41 c0       	rjmp	.+130    	; 0x5b5e <Endpoint_Write_Stream_LE+0x10a>
						  return ENDPOINT_RWSTREAM_CallbackAborted;
						#endif

						if ((ErrorCode = Endpoint_WaitUntilReady()))
    5adc:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    5ae0:	88 23       	and	r24, r24
    5ae2:	f1 f5       	brne	.+124    	; 0x5b60 <Endpoint_Write_Stream_LE+0x10c>
						  return ErrorCode;
					}

					Length -= 8;
    5ae4:	08 50       	subi	r16, 0x08	; 8
    5ae6:	10 40       	sbci	r17, 0x00	; 0

					TEMPLATE_TRANSFER_BYTE(DataStream);
    5ae8:	89 91       	ld	r24, Y+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    5aea:	80 93 f1 00 	sts	0x00F1, r24
			case 7: TEMPLATE_TRANSFER_BYTE(DataStream);
    5aee:	89 91       	ld	r24, Y+
    5af0:	80 93 f1 00 	sts	0x00F1, r24
			case 6: TEMPLATE_TRANSFER_BYTE(DataStream);
    5af4:	89 91       	ld	r24, Y+
    5af6:	80 93 f1 00 	sts	0x00F1, r24
			case 5: TEMPLATE_TRANSFER_BYTE(DataStream);
    5afa:	89 91       	ld	r24, Y+
    5afc:	80 93 f1 00 	sts	0x00F1, r24
			case 4: TEMPLATE_TRANSFER_BYTE(DataStream);
    5b00:	89 91       	ld	r24, Y+
    5b02:	80 93 f1 00 	sts	0x00F1, r24
			case 3: TEMPLATE_TRANSFER_BYTE(DataStream);
    5b06:	89 91       	ld	r24, Y+
    5b08:	80 93 f1 00 	sts	0x00F1, r24
			case 2: TEMPLATE_TRANSFER_BYTE(DataStream);
    5b0c:	89 91       	ld	r24, Y+
    5b0e:	80 93 f1 00 	sts	0x00F1, r24
			case 1:	TEMPLATE_TRANSFER_BYTE(DataStream);
    5b12:	89 91       	ld	r24, Y+
    5b14:	80 93 f1 00 	sts	0x00F1, r24
				} while (Length >= 8);
    5b18:	08 30       	cpi	r16, 0x08	; 8
    5b1a:	11 05       	cpc	r17, r1
    5b1c:	70 f6       	brcc	.-100    	; 0x5aba <Endpoint_Write_Stream_LE+0x66>
    5b1e:	1a c0       	rjmp	.+52     	; 0x5b54 <Endpoint_Write_Stream_LE+0x100>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5b20:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    5b24:	85 fd       	sbrc	r24, 5
    5b26:	11 c0       	rjmp	.+34     	; 0x5b4a <Endpoint_Write_Stream_LE+0xf6>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5b28:	80 91 e8 00 	lds	r24, 0x00E8
    5b2c:	8e 77       	andi	r24, 0x7E	; 126
    5b2e:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5b32:	e1 14       	cp	r14, r1
    5b34:	f1 04       	cpc	r15, r1
    5b36:	21 f0       	breq	.+8      	; 0x5b40 <Endpoint_Write_Stream_LE+0xec>
    5b38:	f7 01       	movw	r30, r14
    5b3a:	09 95       	icall
    5b3c:	81 30       	cpi	r24, 0x01	; 1
    5b3e:	79 f0       	breq	.+30     	; 0x5b5e <Endpoint_Write_Stream_LE+0x10a>
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    5b40:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <Endpoint_WaitUntilReady>
    5b44:	88 23       	and	r24, r24
    5b46:	31 f0       	breq	.+12     	; 0x5b54 <Endpoint_Write_Stream_LE+0x100>
    5b48:	0b c0       	rjmp	.+22     	; 0x5b60 <Endpoint_Write_Stream_LE+0x10c>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5b4a:	89 91       	ld	r24, Y+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    5b4c:	80 93 f1 00 	sts	0x00F1, r24
			Length--;
    5b50:	01 50       	subi	r16, 0x01	; 1
    5b52:	10 40       	sbci	r17, 0x00	; 0
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    5b54:	01 15       	cp	r16, r1
    5b56:	11 05       	cpc	r17, r1
    5b58:	19 f7       	brne	.-58     	; 0x5b20 <Endpoint_Write_Stream_LE+0xcc>
    5b5a:	8b 2d       	mov	r24, r11
    5b5c:	01 c0       	rjmp	.+2      	; 0x5b60 <Endpoint_Write_Stream_LE+0x10c>
    5b5e:	85 e0       	ldi	r24, 0x05	; 5
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    5b60:	df 91       	pop	r29
    5b62:	cf 91       	pop	r28
    5b64:	1f 91       	pop	r17
    5b66:	0f 91       	pop	r16
    5b68:	ff 90       	pop	r15
    5b6a:	ef 90       	pop	r14
    5b6c:	df 90       	pop	r13
    5b6e:	cf 90       	pop	r12
    5b70:	bf 90       	pop	r11
    5b72:	08 95       	ret

00005b74 <USB_Host_WaitForIOS>:

	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    5b74:	1f 93       	push	r17
    5b76:	cf 93       	push	r28
    5b78:	df 93       	push	r29
    5b7a:	18 2f       	mov	r17, r24
    5b7c:	c8 ee       	ldi	r28, 0xE8	; 232
    5b7e:	d3 e0       	ldi	r29, 0x03	; 3
    5b80:	0a c0       	rjmp	.+20     	; 0x5b96 <USB_Host_WaitForIOS+0x22>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5b82:	81 e0       	ldi	r24, 0x01	; 1
    5b84:	0e 94 2b 24 	call	0x4856	; 0x4856 <USB_Host_WaitMS>
    5b88:	88 23       	and	r24, r24
    5b8a:	d1 f4       	brne	.+52     	; 0x5bc0 <USB_Host_WaitForIOS+0x4c>
		  return ErrorCode;

		if (!(TimeoutCounter--))
    5b8c:	20 97       	sbiw	r28, 0x00	; 0
    5b8e:	11 f4       	brne	.+4      	; 0x5b94 <USB_Host_WaitForIOS+0x20>
    5b90:	84 e0       	ldi	r24, 0x04	; 4
    5b92:	16 c0       	rjmp	.+44     	; 0x5bc0 <USB_Host_WaitForIOS+0x4c>
    5b94:	21 97       	sbiw	r28, 0x01	; 1
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5b96:	11 23       	and	r17, r17
    5b98:	29 f4       	brne	.+10     	; 0x5ba4 <USB_Host_WaitForIOS+0x30>
			 *  \return Boolean true if the current pipe is ready for a SETUP packet, false otherwise.
			 */
			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsSETUPSent(void)
			{
				return ((UPINTX & (1 << TXSTPI)) ? true : false);
    5b9a:	80 91 a6 00 	lds	r24, 0x00A6
    5b9e:	83 ff       	sbrs	r24, 3
    5ba0:	f0 cf       	rjmp	.-32     	; 0x5b82 <USB_Host_WaitForIOS+0xe>
    5ba2:	0d c0       	rjmp	.+26     	; 0x5bbe <USB_Host_WaitForIOS+0x4a>
    5ba4:	11 30       	cpi	r17, 0x01	; 1
    5ba6:	29 f4       	brne	.+10     	; 0x5bb2 <USB_Host_WaitForIOS+0x3e>
			 *  \return Boolean true if the current pipe has received an IN packet, false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    5ba8:	80 91 a6 00 	lds	r24, 0x00A6
    5bac:	80 ff       	sbrs	r24, 0
    5bae:	e9 cf       	rjmp	.-46     	; 0x5b82 <USB_Host_WaitForIOS+0xe>
    5bb0:	06 c0       	rjmp	.+12     	; 0x5bbe <USB_Host_WaitForIOS+0x4a>
    5bb2:	12 30       	cpi	r17, 0x02	; 2
    5bb4:	31 f7       	brne	.-52     	; 0x5b82 <USB_Host_WaitForIOS+0xe>
			 *  \return Boolean true if the current pipe is ready for an OUT packet, false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    5bb6:	80 91 a6 00 	lds	r24, 0x00A6
    5bba:	82 ff       	sbrs	r24, 2
    5bbc:	e2 cf       	rjmp	.-60     	; 0x5b82 <USB_Host_WaitForIOS+0xe>
    5bbe:	80 e0       	ldi	r24, 0x00	; 0
		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
}
    5bc0:	df 91       	pop	r29
    5bc2:	cf 91       	pop	r28
    5bc4:	1f 91       	pop	r17
    5bc6:	08 95       	ret

00005bc8 <USB_Host_SendControlRequest>:

#define  __INCLUDE_FROM_HOSTSTDREQ_C
#include "HostStandardReq.h"

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
    5bc8:	ff 92       	push	r15
    5bca:	0f 93       	push	r16
    5bcc:	1f 93       	push	r17
    5bce:	cf 93       	push	r28
    5bd0:	df 93       	push	r29
    5bd2:	18 2f       	mov	r17, r24
    5bd4:	09 2f       	mov	r16, r25
			 *  \return Boolean true if the bus is currently suspended, false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    5bd6:	f0 90 9e 00 	lds	r15, 0x009E
	uint8_t* HeaderStream   = (uint8_t*)&USB_ControlRequest;
	uint8_t* DataStream     = (uint8_t*)BufferPtr;
	bool     BusSuspended   = USB_Host_IsBusSuspended();
	uint8_t  ReturnStatus   = HOST_SENDCONTROL_Successful;
	uint16_t DataLen        = USB_ControlRequest.wLength;
    5bda:	c0 91 dc 0c 	lds	r28, 0x0CDC
    5bde:	d0 91 dd 0c 	lds	r29, 0x0CDD
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5be2:	80 91 9e 00 	lds	r24, 0x009E
    5be6:	81 60       	ori	r24, 0x01	; 1
    5be8:	80 93 9e 00 	sts	0x009E, r24

	USB_Host_ResumeBus();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5bec:	81 e0       	ldi	r24, 0x01	; 1
    5bee:	0e 94 2b 24 	call	0x4856	; 0x4856 <USB_Host_WaitMS>
    5bf2:	98 2f       	mov	r25, r24
    5bf4:	88 23       	and	r24, r24
    5bf6:	09 f0       	breq	.+2      	; 0x5bfa <USB_Host_SendControlRequest+0x32>
    5bf8:	d3 c0       	rjmp	.+422    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5bfa:	80 91 aa 00 	lds	r24, 0x00AA
    5bfe:	8f 7c       	andi	r24, 0xCF	; 207
    5c00:	80 93 aa 00 	sts	0x00AA, r24
			 *  flag for the pipe.
			 */
			static inline void Pipe_ClearErrorFlags(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearErrorFlags(void)
			{
				UPERRX = 0;
    5c04:	10 92 f5 00 	sts	0x00F5, r1

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5c08:	80 91 a9 00 	lds	r24, 0x00A9
    5c0c:	8f 7b       	andi	r24, 0xBF	; 191
    5c0e:	80 93 a9 00 	sts	0x00A9, r24
    5c12:	e6 ed       	ldi	r30, 0xD6	; 214
    5c14:	fc e0       	ldi	r31, 0x0C	; 12
	Pipe_ClearErrorFlags();

	Pipe_Unfreeze();

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
	  Pipe_Write_Byte(*(HeaderStream++));
    5c16:	81 91       	ld	r24, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    5c18:	80 93 af 00 	sts	0x00AF, r24
	Pipe_SetPipeToken(PIPE_TOKEN_SETUP);
	Pipe_ClearErrorFlags();

	Pipe_Unfreeze();

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
    5c1c:	8c e0       	ldi	r24, 0x0C	; 12
    5c1e:	ee 3d       	cpi	r30, 0xDE	; 222
    5c20:	f8 07       	cpc	r31, r24
    5c22:	c9 f7       	brne	.-14     	; 0x5c16 <USB_Host_SendControlRequest+0x4e>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearSETUP(void)
			{
				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
    5c24:	80 91 a6 00 	lds	r24, 0x00A6
    5c28:	87 77       	andi	r24, 0x77	; 119
    5c2a:	80 93 a6 00 	sts	0x00A6, r24
	  Pipe_Write_Byte(*(HeaderStream++));

	Pipe_ClearSETUP();

	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    5c2e:	80 e0       	ldi	r24, 0x00	; 0
    5c30:	a1 df       	rcall	.-190    	; 0x5b74 <USB_Host_WaitForIOS>
    5c32:	98 2f       	mov	r25, r24
    5c34:	88 23       	and	r24, r24
    5c36:	09 f0       	breq	.+2      	; 0x5c3a <USB_Host_SendControlRequest+0x72>
    5c38:	b3 c0       	rjmp	.+358    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5c3a:	80 91 a9 00 	lds	r24, 0x00A9
    5c3e:	80 64       	ori	r24, 0x40	; 64
    5c40:	80 93 a9 00 	sts	0x00A9, r24
	  goto End_Of_Control_Send;

	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5c44:	81 e0       	ldi	r24, 0x01	; 1
    5c46:	0e 94 2b 24 	call	0x4856	; 0x4856 <USB_Host_WaitMS>
    5c4a:	98 2f       	mov	r25, r24
    5c4c:	88 23       	and	r24, r24
    5c4e:	09 f0       	breq	.+2      	; 0x5c52 <USB_Host_SendControlRequest+0x8a>
    5c50:	a7 c0       	rjmp	.+334    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
#include "HostStandardReq.h"

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
	uint8_t* HeaderStream   = (uint8_t*)&USB_ControlRequest;
	uint8_t* DataStream     = (uint8_t*)BufferPtr;
    5c52:	21 2f       	mov	r18, r17
    5c54:	30 2f       	mov	r19, r16
    5c56:	c9 01       	movw	r24, r18
    5c58:	8c 01       	movw	r16, r24
	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
	  goto End_Of_Control_Send;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    5c5a:	80 91 d6 0c 	lds	r24, 0x0CD6
    5c5e:	87 ff       	sbrs	r24, 7
    5c60:	52 c0       	rjmp	.+164    	; 0x5d06 <USB_Host_SendControlRequest+0x13e>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5c62:	80 91 aa 00 	lds	r24, 0x00AA
    5c66:	8f 7c       	andi	r24, 0xCF	; 207
    5c68:	80 61       	ori	r24, 0x10	; 16
    5c6a:	80 93 aa 00 	sts	0x00AA, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
    5c6e:	01 15       	cp	r16, r1
    5c70:	11 05       	cpc	r17, r1
    5c72:	69 f5       	brne	.+90     	; 0x5cce <USB_Host_SendControlRequest+0x106>
    5c74:	2e c0       	rjmp	.+92     	; 0x5cd2 <USB_Host_SendControlRequest+0x10a>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5c76:	80 91 a9 00 	lds	r24, 0x00A9
    5c7a:	8f 7b       	andi	r24, 0xBF	; 191
    5c7c:	80 93 a9 00 	sts	0x00A9, r24
		{
			while (DataLen)
			{
				Pipe_Unfreeze();

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    5c80:	81 e0       	ldi	r24, 0x01	; 1
    5c82:	78 df       	rcall	.-272    	; 0x5b74 <USB_Host_WaitForIOS>
    5c84:	98 2f       	mov	r25, r24
    5c86:	88 23       	and	r24, r24
    5c88:	09 f0       	breq	.+2      	; 0x5c8c <USB_Host_SendControlRequest+0xc4>
    5c8a:	8a c0       	rjmp	.+276    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5c8c:	80 91 f6 00 	lds	r24, 0x00F6
    5c90:	90 91 f7 00 	lds	r25, 0x00F7
				  goto End_Of_Control_Send;

				if (!(Pipe_BytesInPipe()))
    5c94:	89 2b       	or	r24, r25
    5c96:	49 f4       	brne	.+18     	; 0x5caa <USB_Host_SendControlRequest+0xe2>
    5c98:	c0 e0       	ldi	r28, 0x00	; 0
    5c9a:	d0 e0       	ldi	r29, 0x00	; 0
    5c9c:	06 c0       	rjmp	.+12     	; 0x5caa <USB_Host_SendControlRequest+0xe2>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_Byte(void)
			{
				return UPDATX;
    5c9e:	80 91 af 00 	lds	r24, 0x00AF
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
				{
					*(DataStream++) = Pipe_Read_Byte();
    5ca2:	f8 01       	movw	r30, r16
    5ca4:	81 93       	st	Z+, r24
    5ca6:	8f 01       	movw	r16, r30
					DataLen--;
    5ca8:	21 97       	sbiw	r28, 0x01	; 1
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5caa:	80 91 f6 00 	lds	r24, 0x00F6
    5cae:	90 91 f7 00 	lds	r25, 0x00F7
				  goto End_Of_Control_Send;

				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
    5cb2:	89 2b       	or	r24, r25
    5cb4:	11 f0       	breq	.+4      	; 0x5cba <USB_Host_SendControlRequest+0xf2>
    5cb6:	20 97       	sbiw	r28, 0x00	; 0
    5cb8:	91 f7       	brne	.-28     	; 0x5c9e <USB_Host_SendControlRequest+0xd6>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5cba:	80 91 a9 00 	lds	r24, 0x00A9
    5cbe:	80 64       	ori	r24, 0x40	; 64
    5cc0:	80 93 a9 00 	sts	0x00A9, r24
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5cc4:	80 91 a6 00 	lds	r24, 0x00A6
    5cc8:	8e 77       	andi	r24, 0x7E	; 126
    5cca:	80 93 a6 00 	sts	0x00A6, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
		{
			while (DataLen)
    5cce:	20 97       	sbiw	r28, 0x00	; 0
    5cd0:	91 f6       	brne	.-92     	; 0x5c76 <USB_Host_SendControlRequest+0xae>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5cd2:	80 91 aa 00 	lds	r24, 0x00AA
    5cd6:	8f 7c       	andi	r24, 0xCF	; 207
    5cd8:	80 62       	ori	r24, 0x20	; 32
    5cda:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5cde:	80 91 a9 00 	lds	r24, 0x00A9
    5ce2:	8f 7b       	andi	r24, 0xBF	; 191
    5ce4:	80 93 a9 00 	sts	0x00A9, r24
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5ce8:	82 e0       	ldi	r24, 0x02	; 2
    5cea:	44 df       	rcall	.-376    	; 0x5b74 <USB_Host_WaitForIOS>
    5cec:	98 2f       	mov	r25, r24
    5cee:	88 23       	and	r24, r24
    5cf0:	09 f0       	breq	.+2      	; 0x5cf4 <USB_Host_SendControlRequest+0x12c>
    5cf2:	56 c0       	rjmp	.+172    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5cf4:	80 91 a6 00 	lds	r24, 0x00A6
    5cf8:	8b 77       	andi	r24, 0x7B	; 123
    5cfa:	80 93 a6 00 	sts	0x00A6, r24
		  goto End_Of_Control_Send;

		Pipe_ClearOUT();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5cfe:	82 e0       	ldi	r24, 0x02	; 2
    5d00:	39 df       	rcall	.-398    	; 0x5b74 <USB_Host_WaitForIOS>
    5d02:	98 2f       	mov	r25, r24
    5d04:	4d c0       	rjmp	.+154    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
		  goto End_Of_Control_Send;
	}
	else
	{
		if (DataStream != NULL)
    5d06:	01 15       	cp	r16, r1
    5d08:	11 05       	cpc	r17, r1
    5d0a:	a9 f1       	breq	.+106    	; 0x5d76 <USB_Host_SendControlRequest+0x1ae>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5d0c:	80 91 aa 00 	lds	r24, 0x00AA
    5d10:	8f 7c       	andi	r24, 0xCF	; 207
    5d12:	80 62       	ori	r24, 0x20	; 32
    5d14:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5d18:	80 91 a9 00 	lds	r24, 0x00A9
    5d1c:	8f 7b       	andi	r24, 0xBF	; 191
    5d1e:	80 93 a9 00 	sts	0x00A9, r24
    5d22:	1d c0       	rjmp	.+58     	; 0x5d5e <USB_Host_SendControlRequest+0x196>
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5d24:	82 e0       	ldi	r24, 0x02	; 2
    5d26:	26 df       	rcall	.-436    	; 0x5b74 <USB_Host_WaitForIOS>
    5d28:	98 2f       	mov	r25, r24
    5d2a:	88 23       	and	r24, r24
    5d2c:	c9 f5       	brne	.+114    	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_ControlPipeSize))
    5d2e:	80 91 9b 02 	lds	r24, 0x029B
    5d32:	28 2f       	mov	r18, r24
    5d34:	30 e0       	ldi	r19, 0x00	; 0
    5d36:	07 c0       	rjmp	.+14     	; 0x5d46 <USB_Host_SendControlRequest+0x17e>
				{
					Pipe_Write_Byte(*(DataStream++));
    5d38:	f8 01       	movw	r30, r16
    5d3a:	81 91       	ld	r24, Z+
    5d3c:	8f 01       	movw	r16, r30
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    5d3e:	80 93 af 00 	sts	0x00AF, r24
					DataLen--;
    5d42:	21 97       	sbiw	r28, 0x01	; 1
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_ControlPipeSize))
    5d44:	39 f0       	breq	.+14     	; 0x5d54 <USB_Host_SendControlRequest+0x18c>
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5d46:	80 91 f6 00 	lds	r24, 0x00F6
    5d4a:	90 91 f7 00 	lds	r25, 0x00F7
    5d4e:	82 17       	cp	r24, r18
    5d50:	93 07       	cpc	r25, r19
    5d52:	90 f3       	brcs	.-28     	; 0x5d38 <USB_Host_SendControlRequest+0x170>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5d54:	80 91 a6 00 	lds	r24, 0x00A6
    5d58:	8b 77       	andi	r24, 0x7B	; 123
    5d5a:	80 93 a6 00 	sts	0x00A6, r24
		if (DataStream != NULL)
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
    5d5e:	20 97       	sbiw	r28, 0x00	; 0
    5d60:	09 f7       	brne	.-62     	; 0x5d24 <USB_Host_SendControlRequest+0x15c>
				}

				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5d62:	82 e0       	ldi	r24, 0x02	; 2
    5d64:	07 df       	rcall	.-498    	; 0x5b74 <USB_Host_WaitForIOS>
    5d66:	98 2f       	mov	r25, r24
    5d68:	88 23       	and	r24, r24
    5d6a:	d1 f4       	brne	.+52     	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5d6c:	80 91 a9 00 	lds	r24, 0x00A9
    5d70:	80 64       	ori	r24, 0x40	; 64
    5d72:	80 93 a9 00 	sts	0x00A9, r24
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5d76:	80 91 aa 00 	lds	r24, 0x00AA
    5d7a:	8f 7c       	andi	r24, 0xCF	; 207
    5d7c:	80 61       	ori	r24, 0x10	; 16
    5d7e:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5d82:	80 91 a9 00 	lds	r24, 0x00A9
    5d86:	8f 7b       	andi	r24, 0xBF	; 191
    5d88:	80 93 a9 00 	sts	0x00A9, r24
		}

		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    5d8c:	81 e0       	ldi	r24, 0x01	; 1
    5d8e:	f2 de       	rcall	.-540    	; 0x5b74 <USB_Host_WaitForIOS>
    5d90:	98 2f       	mov	r25, r24
    5d92:	88 23       	and	r24, r24
    5d94:	29 f4       	brne	.+10     	; 0x5da0 <USB_Host_SendControlRequest+0x1d8>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5d96:	80 91 a6 00 	lds	r24, 0x00A6
    5d9a:	8e 77       	andi	r24, 0x7E	; 126
    5d9c:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5da0:	80 91 a9 00 	lds	r24, 0x00A9
    5da4:	80 64       	ori	r24, 0x40	; 64
    5da6:	80 93 a9 00 	sts	0x00A9, r24
	}

End_Of_Control_Send:
	Pipe_Freeze();

	if (BusSuspended)
    5daa:	f0 fc       	sbrc	r15, 0
    5dac:	05 c0       	rjmp	.+10     	; 0x5db8 <USB_Host_SendControlRequest+0x1f0>
			 *  messages to the device.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    5dae:	80 91 9e 00 	lds	r24, 0x009E
    5db2:	8e 7f       	andi	r24, 0xFE	; 254
    5db4:	80 93 9e 00 	sts	0x009E, r24
			 *  \param[in] PipeNumber  Index of the pipe to reset.
			 */
			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
			{
				UPRST = (1 << PipeNumber);
    5db8:	81 e0       	ldi	r24, 0x01	; 1
    5dba:	80 93 a8 00 	sts	0x00A8, r24
				UPRST = 0;
    5dbe:	10 92 a8 00 	sts	0x00A8, r1
	  USB_Host_SuspendBus();

	Pipe_ResetPipe(PIPE_CONTROLPIPE);

	return ReturnStatus;
}
    5dc2:	89 2f       	mov	r24, r25
    5dc4:	df 91       	pop	r29
    5dc6:	cf 91       	pop	r28
    5dc8:	1f 91       	pop	r17
    5dca:	0f 91       	pop	r16
    5dcc:	ff 90       	pop	r15
    5dce:	08 95       	ret

00005dd0 <Pipe_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    5dd0:	bf 92       	push	r11
    5dd2:	cf 92       	push	r12
    5dd4:	df 92       	push	r13
    5dd6:	ef 92       	push	r14
    5dd8:	ff 92       	push	r15
    5dda:	0f 93       	push	r16
    5ddc:	1f 93       	push	r17
    5dde:	cf 93       	push	r28
    5de0:	df 93       	push	r29
    5de2:	d8 2e       	mov	r13, r24
    5de4:	c9 2e       	mov	r12, r25
    5de6:	8b 01       	movw	r16, r22
    5de8:	7a 01       	movw	r14, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5dea:	80 91 aa 00 	lds	r24, 0x00AA
    5dee:	8f 7c       	andi	r24, 0xCF	; 207
    5df0:	80 61       	ori	r24, 0x10	; 16
    5df2:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5df6:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    5dfa:	b8 2e       	mov	r11, r24
    5dfc:	88 23       	and	r24, r24
    5dfe:	09 f0       	breq	.+2      	; 0x5e02 <Pipe_Read_Stream_LE+0x32>
    5e00:	70 c0       	rjmp	.+224    	; 0x5ee2 <Pipe_Read_Stream_LE+0x112>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5e02:	8d 2d       	mov	r24, r13
    5e04:	9c 2d       	mov	r25, r12
    5e06:	9c 01       	movw	r18, r24
    5e08:	e9 01       	movw	r28, r18
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5e0a:	80 91 f6 00 	lds	r24, 0x00F6
    5e0e:	90 91 f7 00 	lds	r25, 0x00F7
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Pipe_BytesInPipe() & 0x07);

	if (Length >= 8)
    5e12:	08 30       	cpi	r16, 0x08	; 8
    5e14:	11 05       	cpc	r17, r1
    5e16:	08 f4       	brcc	.+2      	; 0x5e1a <Pipe_Read_Stream_LE+0x4a>
    5e18:	61 c0       	rjmp	.+194    	; 0x5edc <Pipe_Read_Stream_LE+0x10c>

	if ((ErrorCode = Pipe_WaitUntilReady()))
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Pipe_BytesInPipe() & 0x07);
    5e1a:	87 70       	andi	r24, 0x07	; 7

	if (Length >= 8)
	{
		Length -= BytesRemToAlignment;
    5e1c:	08 1b       	sub	r16, r24
    5e1e:	11 09       	sbc	r17, r1

		switch (BytesRemToAlignment)
    5e20:	84 30       	cpi	r24, 0x04	; 4
    5e22:	91 f1       	breq	.+100    	; 0x5e88 <Pipe_Read_Stream_LE+0xb8>
    5e24:	85 30       	cpi	r24, 0x05	; 5
    5e26:	38 f4       	brcc	.+14     	; 0x5e36 <Pipe_Read_Stream_LE+0x66>
    5e28:	82 30       	cpi	r24, 0x02	; 2
    5e2a:	a1 f1       	breq	.+104    	; 0x5e94 <Pipe_Read_Stream_LE+0xc4>
    5e2c:	83 30       	cpi	r24, 0x03	; 3
    5e2e:	78 f5       	brcc	.+94     	; 0x5e8e <Pipe_Read_Stream_LE+0xbe>
    5e30:	81 30       	cpi	r24, 0x01	; 1
    5e32:	39 f4       	brne	.+14     	; 0x5e42 <Pipe_Read_Stream_LE+0x72>
    5e34:	32 c0       	rjmp	.+100    	; 0x5e9a <Pipe_Read_Stream_LE+0xca>
    5e36:	86 30       	cpi	r24, 0x06	; 6
    5e38:	09 f1       	breq	.+66     	; 0x5e7c <Pipe_Read_Stream_LE+0xac>
    5e3a:	86 30       	cpi	r24, 0x06	; 6
    5e3c:	10 f1       	brcs	.+68     	; 0x5e82 <Pipe_Read_Stream_LE+0xb2>
    5e3e:	87 30       	cpi	r24, 0x07	; 7
    5e40:	d1 f0       	breq	.+52     	; 0x5e76 <Pipe_Read_Stream_LE+0xa6>
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5e42:	80 91 a6 00 	lds	r24, 0x00A6
		{
			default:
				do
				{
					if (!(Pipe_IsReadWriteAllowed()))
    5e46:	85 fd       	sbrc	r24, 5
    5e48:	11 c0       	rjmp	.+34     	; 0x5e6c <Pipe_Read_Stream_LE+0x9c>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5e4a:	80 91 a6 00 	lds	r24, 0x00A6
    5e4e:	8e 77       	andi	r24, 0x7E	; 126
    5e50:	80 93 a6 00 	sts	0x00A6, r24
					{
						TEMPLATE_CLEAR_PIPE();

						#if !defined(NO_STREAM_CALLBACKS)
						if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5e54:	e1 14       	cp	r14, r1
    5e56:	f1 04       	cpc	r15, r1
    5e58:	29 f0       	breq	.+10     	; 0x5e64 <Pipe_Read_Stream_LE+0x94>
    5e5a:	f7 01       	movw	r30, r14
    5e5c:	09 95       	icall
    5e5e:	81 30       	cpi	r24, 0x01	; 1
    5e60:	09 f4       	brne	.+2      	; 0x5e64 <Pipe_Read_Stream_LE+0x94>
    5e62:	41 c0       	rjmp	.+130    	; 0x5ee6 <Pipe_Read_Stream_LE+0x116>
						  return PIPE_RWSTREAM_CallbackAborted;
						#endif

						if ((ErrorCode = Pipe_WaitUntilReady()))
    5e64:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    5e68:	88 23       	and	r24, r24
    5e6a:	f1 f5       	brne	.+124    	; 0x5ee8 <Pipe_Read_Stream_LE+0x118>
						  return ErrorCode;
					}

					Length -= 8;
    5e6c:	08 50       	subi	r16, 0x08	; 8
    5e6e:	10 40       	sbci	r17, 0x00	; 0
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_Byte(void)
			{
				return UPDATX;
    5e70:	80 91 af 00 	lds	r24, 0x00AF

					TEMPLATE_TRANSFER_BYTE(DataStream);
    5e74:	89 93       	st	Y+, r24
    5e76:	80 91 af 00 	lds	r24, 0x00AF
			case 7: TEMPLATE_TRANSFER_BYTE(DataStream);
    5e7a:	89 93       	st	Y+, r24
    5e7c:	80 91 af 00 	lds	r24, 0x00AF
			case 6: TEMPLATE_TRANSFER_BYTE(DataStream);
    5e80:	89 93       	st	Y+, r24
    5e82:	80 91 af 00 	lds	r24, 0x00AF
			case 5: TEMPLATE_TRANSFER_BYTE(DataStream);
    5e86:	89 93       	st	Y+, r24
    5e88:	80 91 af 00 	lds	r24, 0x00AF
			case 4: TEMPLATE_TRANSFER_BYTE(DataStream);
    5e8c:	89 93       	st	Y+, r24
    5e8e:	80 91 af 00 	lds	r24, 0x00AF
			case 3: TEMPLATE_TRANSFER_BYTE(DataStream);
    5e92:	89 93       	st	Y+, r24
    5e94:	80 91 af 00 	lds	r24, 0x00AF
			case 2: TEMPLATE_TRANSFER_BYTE(DataStream);
    5e98:	89 93       	st	Y+, r24
    5e9a:	80 91 af 00 	lds	r24, 0x00AF
			case 1:	TEMPLATE_TRANSFER_BYTE(DataStream);
    5e9e:	89 93       	st	Y+, r24
				} while (Length >= 8);
    5ea0:	08 30       	cpi	r16, 0x08	; 8
    5ea2:	11 05       	cpc	r17, r1
    5ea4:	70 f6       	brcc	.-100    	; 0x5e42 <Pipe_Read_Stream_LE+0x72>
    5ea6:	1a c0       	rjmp	.+52     	; 0x5edc <Pipe_Read_Stream_LE+0x10c>
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5ea8:	80 91 a6 00 	lds	r24, 0x00A6
	}
	#endif

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5eac:	85 fd       	sbrc	r24, 5
    5eae:	11 c0       	rjmp	.+34     	; 0x5ed2 <Pipe_Read_Stream_LE+0x102>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5eb0:	80 91 a6 00 	lds	r24, 0x00A6
    5eb4:	8e 77       	andi	r24, 0x7E	; 126
    5eb6:	80 93 a6 00 	sts	0x00A6, r24
		{
			TEMPLATE_CLEAR_PIPE();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5eba:	e1 14       	cp	r14, r1
    5ebc:	f1 04       	cpc	r15, r1
    5ebe:	21 f0       	breq	.+8      	; 0x5ec8 <Pipe_Read_Stream_LE+0xf8>
    5ec0:	f7 01       	movw	r30, r14
    5ec2:	09 95       	icall
    5ec4:	81 30       	cpi	r24, 0x01	; 1
    5ec6:	79 f0       	breq	.+30     	; 0x5ee6 <Pipe_Read_Stream_LE+0x116>
			  return PIPE_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5ec8:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    5ecc:	88 23       	and	r24, r24
    5ece:	31 f0       	breq	.+12     	; 0x5edc <Pipe_Read_Stream_LE+0x10c>
    5ed0:	0b c0       	rjmp	.+22     	; 0x5ee8 <Pipe_Read_Stream_LE+0x118>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_Byte(void)
			{
				return UPDATX;
    5ed2:	80 91 af 00 	lds	r24, 0x00AF
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5ed6:	89 93       	st	Y+, r24
			Length--;
    5ed8:	01 50       	subi	r16, 0x01	; 1
    5eda:	10 40       	sbci	r17, 0x00	; 0
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    5edc:	01 15       	cp	r16, r1
    5ede:	11 05       	cpc	r17, r1
    5ee0:	19 f7       	brne	.-58     	; 0x5ea8 <Pipe_Read_Stream_LE+0xd8>
    5ee2:	8b 2d       	mov	r24, r11
    5ee4:	01 c0       	rjmp	.+2      	; 0x5ee8 <Pipe_Read_Stream_LE+0x118>
    5ee6:	84 e0       	ldi	r24, 0x04	; 4
			Length--;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    5ee8:	df 91       	pop	r29
    5eea:	cf 91       	pop	r28
    5eec:	1f 91       	pop	r17
    5eee:	0f 91       	pop	r16
    5ef0:	ff 90       	pop	r15
    5ef2:	ef 90       	pop	r14
    5ef4:	df 90       	pop	r13
    5ef6:	cf 90       	pop	r12
    5ef8:	bf 90       	pop	r11
    5efa:	08 95       	ret

00005efc <Pipe_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    5efc:	bf 92       	push	r11
    5efe:	cf 92       	push	r12
    5f00:	df 92       	push	r13
    5f02:	ef 92       	push	r14
    5f04:	ff 92       	push	r15
    5f06:	0f 93       	push	r16
    5f08:	1f 93       	push	r17
    5f0a:	cf 93       	push	r28
    5f0c:	df 93       	push	r29
    5f0e:	d8 2e       	mov	r13, r24
    5f10:	c9 2e       	mov	r12, r25
    5f12:	8b 01       	movw	r16, r22
    5f14:	7a 01       	movw	r14, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5f16:	80 91 aa 00 	lds	r24, 0x00AA
    5f1a:	8f 7c       	andi	r24, 0xCF	; 207
    5f1c:	80 62       	ori	r24, 0x20	; 32
    5f1e:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5f22:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    5f26:	b8 2e       	mov	r11, r24
    5f28:	88 23       	and	r24, r24
    5f2a:	09 f0       	breq	.+2      	; 0x5f2e <Pipe_Write_Stream_LE+0x32>
    5f2c:	70 c0       	rjmp	.+224    	; 0x600e <Pipe_Write_Stream_LE+0x112>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5f2e:	8d 2d       	mov	r24, r13
    5f30:	9c 2d       	mov	r25, r12
    5f32:	9c 01       	movw	r18, r24
    5f34:	e9 01       	movw	r28, r18
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5f36:	80 91 f6 00 	lds	r24, 0x00F6
    5f3a:	90 91 f7 00 	lds	r25, 0x00F7
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Pipe_BytesInPipe() & 0x07);

	if (Length >= 8)
    5f3e:	08 30       	cpi	r16, 0x08	; 8
    5f40:	11 05       	cpc	r17, r1
    5f42:	08 f4       	brcc	.+2      	; 0x5f46 <Pipe_Write_Stream_LE+0x4a>
    5f44:	61 c0       	rjmp	.+194    	; 0x6008 <Pipe_Write_Stream_LE+0x10c>

	if ((ErrorCode = Pipe_WaitUntilReady()))
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Pipe_BytesInPipe() & 0x07);
    5f46:	87 70       	andi	r24, 0x07	; 7

	if (Length >= 8)
	{
		Length -= BytesRemToAlignment;
    5f48:	08 1b       	sub	r16, r24
    5f4a:	11 09       	sbc	r17, r1

		switch (BytesRemToAlignment)
    5f4c:	84 30       	cpi	r24, 0x04	; 4
    5f4e:	91 f1       	breq	.+100    	; 0x5fb4 <Pipe_Write_Stream_LE+0xb8>
    5f50:	85 30       	cpi	r24, 0x05	; 5
    5f52:	38 f4       	brcc	.+14     	; 0x5f62 <Pipe_Write_Stream_LE+0x66>
    5f54:	82 30       	cpi	r24, 0x02	; 2
    5f56:	a1 f1       	breq	.+104    	; 0x5fc0 <Pipe_Write_Stream_LE+0xc4>
    5f58:	83 30       	cpi	r24, 0x03	; 3
    5f5a:	78 f5       	brcc	.+94     	; 0x5fba <Pipe_Write_Stream_LE+0xbe>
    5f5c:	81 30       	cpi	r24, 0x01	; 1
    5f5e:	39 f4       	brne	.+14     	; 0x5f6e <Pipe_Write_Stream_LE+0x72>
    5f60:	32 c0       	rjmp	.+100    	; 0x5fc6 <Pipe_Write_Stream_LE+0xca>
    5f62:	86 30       	cpi	r24, 0x06	; 6
    5f64:	09 f1       	breq	.+66     	; 0x5fa8 <Pipe_Write_Stream_LE+0xac>
    5f66:	86 30       	cpi	r24, 0x06	; 6
    5f68:	10 f1       	brcs	.+68     	; 0x5fae <Pipe_Write_Stream_LE+0xb2>
    5f6a:	87 30       	cpi	r24, 0x07	; 7
    5f6c:	d1 f0       	breq	.+52     	; 0x5fa2 <Pipe_Write_Stream_LE+0xa6>
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5f6e:	80 91 a6 00 	lds	r24, 0x00A6
		{
			default:
				do
				{
					if (!(Pipe_IsReadWriteAllowed()))
    5f72:	85 fd       	sbrc	r24, 5
    5f74:	11 c0       	rjmp	.+34     	; 0x5f98 <Pipe_Write_Stream_LE+0x9c>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5f76:	80 91 a6 00 	lds	r24, 0x00A6
    5f7a:	8b 77       	andi	r24, 0x7B	; 123
    5f7c:	80 93 a6 00 	sts	0x00A6, r24
					{
						TEMPLATE_CLEAR_PIPE();

						#if !defined(NO_STREAM_CALLBACKS)
						if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5f80:	e1 14       	cp	r14, r1
    5f82:	f1 04       	cpc	r15, r1
    5f84:	29 f0       	breq	.+10     	; 0x5f90 <Pipe_Write_Stream_LE+0x94>
    5f86:	f7 01       	movw	r30, r14
    5f88:	09 95       	icall
    5f8a:	81 30       	cpi	r24, 0x01	; 1
    5f8c:	09 f4       	brne	.+2      	; 0x5f90 <Pipe_Write_Stream_LE+0x94>
    5f8e:	41 c0       	rjmp	.+130    	; 0x6012 <Pipe_Write_Stream_LE+0x116>
						  return PIPE_RWSTREAM_CallbackAborted;
						#endif

						if ((ErrorCode = Pipe_WaitUntilReady()))
    5f90:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    5f94:	88 23       	and	r24, r24
    5f96:	f1 f5       	brne	.+124    	; 0x6014 <Pipe_Write_Stream_LE+0x118>
						  return ErrorCode;
					}

					Length -= 8;
    5f98:	08 50       	subi	r16, 0x08	; 8
    5f9a:	10 40       	sbci	r17, 0x00	; 0

					TEMPLATE_TRANSFER_BYTE(DataStream);
    5f9c:	89 91       	ld	r24, Y+
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    5f9e:	80 93 af 00 	sts	0x00AF, r24
			case 7: TEMPLATE_TRANSFER_BYTE(DataStream);
    5fa2:	89 91       	ld	r24, Y+
    5fa4:	80 93 af 00 	sts	0x00AF, r24
			case 6: TEMPLATE_TRANSFER_BYTE(DataStream);
    5fa8:	89 91       	ld	r24, Y+
    5faa:	80 93 af 00 	sts	0x00AF, r24
			case 5: TEMPLATE_TRANSFER_BYTE(DataStream);
    5fae:	89 91       	ld	r24, Y+
    5fb0:	80 93 af 00 	sts	0x00AF, r24
			case 4: TEMPLATE_TRANSFER_BYTE(DataStream);
    5fb4:	89 91       	ld	r24, Y+
    5fb6:	80 93 af 00 	sts	0x00AF, r24
			case 3: TEMPLATE_TRANSFER_BYTE(DataStream);
    5fba:	89 91       	ld	r24, Y+
    5fbc:	80 93 af 00 	sts	0x00AF, r24
			case 2: TEMPLATE_TRANSFER_BYTE(DataStream);
    5fc0:	89 91       	ld	r24, Y+
    5fc2:	80 93 af 00 	sts	0x00AF, r24
			case 1:	TEMPLATE_TRANSFER_BYTE(DataStream);
    5fc6:	89 91       	ld	r24, Y+
    5fc8:	80 93 af 00 	sts	0x00AF, r24
				} while (Length >= 8);
    5fcc:	08 30       	cpi	r16, 0x08	; 8
    5fce:	11 05       	cpc	r17, r1
    5fd0:	70 f6       	brcc	.-100    	; 0x5f6e <Pipe_Write_Stream_LE+0x72>
    5fd2:	1a c0       	rjmp	.+52     	; 0x6008 <Pipe_Write_Stream_LE+0x10c>
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5fd4:	80 91 a6 00 	lds	r24, 0x00A6
	}
	#endif

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5fd8:	85 fd       	sbrc	r24, 5
    5fda:	11 c0       	rjmp	.+34     	; 0x5ffe <Pipe_Write_Stream_LE+0x102>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5fdc:	80 91 a6 00 	lds	r24, 0x00A6
    5fe0:	8b 77       	andi	r24, 0x7B	; 123
    5fe2:	80 93 a6 00 	sts	0x00A6, r24
		{
			TEMPLATE_CLEAR_PIPE();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    5fe6:	e1 14       	cp	r14, r1
    5fe8:	f1 04       	cpc	r15, r1
    5fea:	21 f0       	breq	.+8      	; 0x5ff4 <Pipe_Write_Stream_LE+0xf8>
    5fec:	f7 01       	movw	r30, r14
    5fee:	09 95       	icall
    5ff0:	81 30       	cpi	r24, 0x01	; 1
    5ff2:	79 f0       	breq	.+30     	; 0x6012 <Pipe_Write_Stream_LE+0x116>
			  return PIPE_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5ff4:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    5ff8:	88 23       	and	r24, r24
    5ffa:	31 f0       	breq	.+12     	; 0x6008 <Pipe_Write_Stream_LE+0x10c>
    5ffc:	0b c0       	rjmp	.+22     	; 0x6014 <Pipe_Write_Stream_LE+0x118>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5ffe:	89 91       	ld	r24, Y+
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    6000:	80 93 af 00 	sts	0x00AF, r24
			Length--;
    6004:	01 50       	subi	r16, 0x01	; 1
    6006:	10 40       	sbci	r17, 0x00	; 0
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    6008:	01 15       	cp	r16, r1
    600a:	11 05       	cpc	r17, r1
    600c:	19 f7       	brne	.-58     	; 0x5fd4 <Pipe_Write_Stream_LE+0xd8>
    600e:	8b 2d       	mov	r24, r11
    6010:	01 c0       	rjmp	.+2      	; 0x6014 <Pipe_Write_Stream_LE+0x118>
    6012:	84 e0       	ldi	r24, 0x04	; 4
			Length--;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    6014:	df 91       	pop	r29
    6016:	cf 91       	pop	r28
    6018:	1f 91       	pop	r17
    601a:	0f 91       	pop	r16
    601c:	ff 90       	pop	r15
    601e:	ef 90       	pop	r14
    6020:	df 90       	pop	r13
    6022:	cf 90       	pop	r12
    6024:	bf 90       	pop	r11
    6026:	08 95       	ret

00006028 <Pipe_Discard_Stream>:

#include "PipeStream.h"

uint8_t Pipe_Discard_Stream(uint16_t Length
                            __CALLBACK_PARAM)
{
    6028:	ff 92       	push	r15
    602a:	0f 93       	push	r16
    602c:	1f 93       	push	r17
    602e:	cf 93       	push	r28
    6030:	df 93       	push	r29
    6032:	ec 01       	movw	r28, r24
    6034:	8b 01       	movw	r16, r22
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6036:	80 91 aa 00 	lds	r24, 0x00AA
    603a:	8f 7c       	andi	r24, 0xCF	; 207
    603c:	80 61       	ori	r24, 0x10	; 16
    603e:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t  ErrorCode;
	
	Pipe_SetPipeToken(PIPE_TOKEN_IN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    6042:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    6046:	f8 2e       	mov	r15, r24
    6048:	88 23       	and	r24, r24
    604a:	09 f0       	breq	.+2      	; 0x604e <Pipe_Discard_Stream+0x26>
    604c:	5f c0       	rjmp	.+190    	; 0x610c <Pipe_Discard_Stream+0xe4>
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    604e:	80 91 f6 00 	lds	r24, 0x00F6
    6052:	90 91 f7 00 	lds	r25, 0x00F7
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Pipe_BytesInPipe() & 0x07);

	if (Length >= 8)
    6056:	c8 30       	cpi	r28, 0x08	; 8
    6058:	d1 05       	cpc	r29, r1
    605a:	08 f4       	brcc	.+2      	; 0x605e <Pipe_Discard_Stream+0x36>
    605c:	55 c0       	rjmp	.+170    	; 0x6108 <Pipe_Discard_Stream+0xe0>

	if ((ErrorCode = Pipe_WaitUntilReady()))
	  return ErrorCode;

	#if defined(FAST_STREAM_TRANSFERS)
	uint8_t BytesRemToAlignment = (Pipe_BytesInPipe() & 0x07);
    605e:	87 70       	andi	r24, 0x07	; 7

	if (Length >= 8)
	{
		Length -= BytesRemToAlignment;
    6060:	c8 1b       	sub	r28, r24
    6062:	d1 09       	sbc	r29, r1

		switch (BytesRemToAlignment)
    6064:	84 30       	cpi	r24, 0x04	; 4
    6066:	61 f1       	breq	.+88     	; 0x60c0 <Pipe_Discard_Stream+0x98>
    6068:	85 30       	cpi	r24, 0x05	; 5
    606a:	38 f4       	brcc	.+14     	; 0x607a <Pipe_Discard_Stream+0x52>
    606c:	82 30       	cpi	r24, 0x02	; 2
    606e:	61 f1       	breq	.+88     	; 0x60c8 <Pipe_Discard_Stream+0xa0>
    6070:	83 30       	cpi	r24, 0x03	; 3
    6072:	40 f5       	brcc	.+80     	; 0x60c4 <Pipe_Discard_Stream+0x9c>
    6074:	81 30       	cpi	r24, 0x01	; 1
    6076:	39 f4       	brne	.+14     	; 0x6086 <Pipe_Discard_Stream+0x5e>
    6078:	29 c0       	rjmp	.+82     	; 0x60cc <Pipe_Discard_Stream+0xa4>
    607a:	86 30       	cpi	r24, 0x06	; 6
    607c:	e9 f0       	breq	.+58     	; 0x60b8 <Pipe_Discard_Stream+0x90>
    607e:	86 30       	cpi	r24, 0x06	; 6
    6080:	e8 f0       	brcs	.+58     	; 0x60bc <Pipe_Discard_Stream+0x94>
    6082:	87 30       	cpi	r24, 0x07	; 7
    6084:	b9 f0       	breq	.+46     	; 0x60b4 <Pipe_Discard_Stream+0x8c>
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    6086:	80 91 a6 00 	lds	r24, 0x00A6
		{
			default:
				do
				{
					if (!(Pipe_IsReadWriteAllowed()))
    608a:	85 fd       	sbrc	r24, 5
    608c:	10 c0       	rjmp	.+32     	; 0x60ae <Pipe_Discard_Stream+0x86>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    608e:	80 91 a6 00 	lds	r24, 0x00A6
    6092:	8e 77       	andi	r24, 0x7E	; 126
    6094:	80 93 a6 00 	sts	0x00A6, r24
					{
						Pipe_ClearIN();
							
						#if !defined(NO_STREAM_CALLBACKS)
						if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    6098:	01 15       	cp	r16, r1
    609a:	11 05       	cpc	r17, r1
    609c:	21 f0       	breq	.+8      	; 0x60a6 <Pipe_Discard_Stream+0x7e>
    609e:	f8 01       	movw	r30, r16
    60a0:	09 95       	icall
    60a2:	81 30       	cpi	r24, 0x01	; 1
    60a4:	a9 f1       	breq	.+106    	; 0x6110 <Pipe_Discard_Stream+0xe8>
						  return PIPE_RWSTREAM_CallbackAborted;
						#endif

						if ((ErrorCode = Pipe_WaitUntilReady()))
    60a6:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    60aa:	88 23       	and	r24, r24
    60ac:	91 f5       	brne	.+100    	; 0x6112 <Pipe_Discard_Stream+0xea>
						  return ErrorCode;
					}

					Length -= 8;
    60ae:	28 97       	sbiw	r28, 0x08	; 8
			static inline void Pipe_Discard_Byte(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Discard_Byte(void)
			{
				uint8_t Dummy;

				Dummy = UPDATX;
    60b0:	80 91 af 00 	lds	r24, 0x00AF
			case 5: Pipe_Discard_Byte();
			case 4: Pipe_Discard_Byte();
			case 3: Pipe_Discard_Byte();
			case 2: Pipe_Discard_Byte();
			case 1:	Pipe_Discard_Byte();
				} while (Length >= 8);	
    60b4:	80 91 af 00 	lds	r24, 0x00AF
    60b8:	80 91 af 00 	lds	r24, 0x00AF
    60bc:	80 91 af 00 	lds	r24, 0x00AF
    60c0:	80 91 af 00 	lds	r24, 0x00AF
    60c4:	80 91 af 00 	lds	r24, 0x00AF
    60c8:	80 91 af 00 	lds	r24, 0x00AF
    60cc:	80 91 af 00 	lds	r24, 0x00AF
    60d0:	c8 30       	cpi	r28, 0x08	; 8
    60d2:	d1 05       	cpc	r29, r1
    60d4:	c0 f6       	brcc	.-80     	; 0x6086 <Pipe_Discard_Stream+0x5e>
    60d6:	18 c0       	rjmp	.+48     	; 0x6108 <Pipe_Discard_Stream+0xe0>
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    60d8:	80 91 a6 00 	lds	r24, 0x00A6
	}
	#endif

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    60dc:	85 fd       	sbrc	r24, 5
    60de:	11 c0       	rjmp	.+34     	; 0x6102 <Pipe_Discard_Stream+0xda>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    60e0:	80 91 a6 00 	lds	r24, 0x00A6
    60e4:	8e 77       	andi	r24, 0x7E	; 126
    60e6:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearIN();
				
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    60ea:	01 15       	cp	r16, r1
    60ec:	11 05       	cpc	r17, r1
    60ee:	21 f0       	breq	.+8      	; 0x60f8 <Pipe_Discard_Stream+0xd0>
    60f0:	f8 01       	movw	r30, r16
    60f2:	09 95       	icall
    60f4:	81 30       	cpi	r24, 0x01	; 1
    60f6:	61 f0       	breq	.+24     	; 0x6110 <Pipe_Discard_Stream+0xe8>
			  return PIPE_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Pipe_WaitUntilReady()))
    60f8:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <Pipe_WaitUntilReady>
    60fc:	88 23       	and	r24, r24
    60fe:	21 f0       	breq	.+8      	; 0x6108 <Pipe_Discard_Stream+0xe0>
    6100:	08 c0       	rjmp	.+16     	; 0x6112 <Pipe_Discard_Stream+0xea>
			static inline void Pipe_Discard_Byte(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Discard_Byte(void)
			{
				uint8_t Dummy;

				Dummy = UPDATX;
    6102:	80 91 af 00 	lds	r24, 0x00AF
			  return ErrorCode;
		}
		else
		{
			Pipe_Discard_Byte();
			Length--;
    6106:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);	
		}
	}
	#endif

	while (Length)
    6108:	20 97       	sbiw	r28, 0x00	; 0
    610a:	31 f7       	brne	.-52     	; 0x60d8 <Pipe_Discard_Stream+0xb0>
    610c:	8f 2d       	mov	r24, r15
    610e:	01 c0       	rjmp	.+2      	; 0x6112 <Pipe_Discard_Stream+0xea>
    6110:	84 e0       	ldi	r24, 0x04	; 4
			Length--;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    6112:	df 91       	pop	r29
    6114:	cf 91       	pop	r28
    6116:	1f 91       	pop	r17
    6118:	0f 91       	pop	r16
    611a:	ff 90       	pop	r15
    611c:	08 95       	ret

0000611e <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    611e:	1f 93       	push	r17
	#if defined(USB_HOST_ONLY)
		USB_HostTask();
	#elif defined(USB_DEVICE_ONLY)
		USB_DeviceTask();
	#else
		if (USB_CurrentMode == USB_MODE_Device)
    6120:	80 91 17 03 	lds	r24, 0x0317
    6124:	81 30       	cpi	r24, 0x01	; 1
    6126:	89 f4       	brne	.+34     	; 0x614a <USB_USBTask+0x2c>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    6128:	80 91 d5 0c 	lds	r24, 0x0CD5
    612c:	88 23       	and	r24, r24
    612e:	d1 f0       	breq	.+52     	; 0x6164 <USB_USBTask+0x46>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    6130:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6134:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6138:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    613c:	83 ff       	sbrs	r24, 3
    613e:	01 c0       	rjmp	.+2      	; 0x6142 <USB_USBTask+0x24>
		  USB_Device_ProcessControlRequest();
    6140:	34 d9       	rcall	.-3480   	; 0x53aa <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    6142:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6144:	10 93 e9 00 	sts	0x00E9, r17
    6148:	0d c0       	rjmp	.+26     	; 0x6164 <USB_USBTask+0x46>
	#elif defined(USB_DEVICE_ONLY)
		USB_DeviceTask();
	#else
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
    614a:	80 91 17 03 	lds	r24, 0x0317
    614e:	82 30       	cpi	r24, 0x02	; 2
    6150:	49 f4       	brne	.+18     	; 0x6164 <USB_USBTask+0x46>
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    6152:	10 91 a7 00 	lds	r17, 0x00A7
    6156:	17 70       	andi	r17, 0x07	; 7
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    6158:	10 92 a7 00 	sts	0x00A7, r1
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	USB_Host_ProcessNextHostState();
    615c:	0e 94 df 24 	call	0x49be	; 0x49be <USB_Host_ProcessNextHostState>
    6160:	10 93 a7 00 	sts	0x00A7, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    6164:	1f 91       	pop	r17
    6166:	08 95       	ret

00006168 <StreamCallback_MS_Device_AbortOnMassStoreReset>:
{
	#if !defined(INTERRUPT_CONTROL_ENDPOINT)
	USB_USBTask();
	#endif

	if (*CallbackIsResetSource)
    6168:	e0 91 18 03 	lds	r30, 0x0318
    616c:	f0 91 19 03 	lds	r31, 0x0319
    6170:	80 81       	ld	r24, Z
	  return STREAMCALLBACK_Abort;
	else
	  return STREAMCALLBACK_Continue;
}
    6172:	08 95       	ret

00006174 <MS_Device_USBTask>:

	return true;
}

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6174:	0f 93       	push	r16
    6176:	1f 93       	push	r17
    6178:	cf 93       	push	r28
    617a:	df 93       	push	r29
    617c:	ec 01       	movw	r28, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    617e:	80 91 d5 0c 	lds	r24, 0x0CD5
    6182:	84 30       	cpi	r24, 0x04	; 4
    6184:	09 f0       	breq	.+2      	; 0x6188 <MS_Device_USBTask+0x14>
    6186:	e1 c0       	rjmp	.+450    	; 0x634a <MS_Device_USBTask+0x1d6>
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    6188:	9d 81       	ldd	r25, Y+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    618a:	90 93 e9 00 	sts	0x00E9, r25
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    618e:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsReadWriteAllowed())
    6192:	85 ff       	sbrs	r24, 5
    6194:	a5 c0       	rjmp	.+330    	; 0x62e0 <MS_Device_USBTask+0x16c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6196:	90 93 e9 00 	sts	0x00E9, r25

static bool MS_Device_ReadInCommandBlock(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);

	CallbackIsResetSource = &MSInterfaceInfo->State.IsMassStoreReset;
    619a:	8e 01       	movw	r16, r28
    619c:	0a 5c       	subi	r16, 0xCA	; 202
    619e:	1f 4f       	sbci	r17, 0xFF	; 255
    61a0:	10 93 19 03 	sts	0x0319, r17
    61a4:	00 93 18 03 	sts	0x0318, r16
	if (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    61a8:	ce 01       	movw	r24, r28
    61aa:	0a 96       	adiw	r24, 0x0a	; 10
    61ac:	6f e0       	ldi	r22, 0x0F	; 15
    61ae:	70 e0       	ldi	r23, 0x00	; 0
    61b0:	44 eb       	ldi	r20, 0xB4	; 180
    61b2:	50 e3       	ldi	r21, 0x30	; 48
    61b4:	28 db       	rcall	.-2480   	; 0x5806 <Endpoint_Read_Stream_LE>
    61b6:	88 23       	and	r24, r24
    61b8:	09 f0       	breq	.+2      	; 0x61bc <MS_Device_USBTask+0x48>
    61ba:	92 c0       	rjmp	.+292    	; 0x62e0 <MS_Device_USBTask+0x16c>
	                            StreamCallback_MS_Device_AbortOnMassStoreReset))
	{
		return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != MS_CBW_SIGNATURE)                  ||
    61bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    61be:	9b 85       	ldd	r25, Y+11	; 0x0b
    61c0:	ac 85       	ldd	r26, Y+12	; 0x0c
    61c2:	bd 85       	ldd	r27, Y+13	; 0x0d
    61c4:	85 55       	subi	r24, 0x55	; 85
    61c6:	93 45       	sbci	r25, 0x53	; 83
    61c8:	a2 44       	sbci	r26, 0x42	; 66
    61ca:	b3 44       	sbci	r27, 0x43	; 67
    61cc:	79 f4       	brne	.+30     	; 0x61ec <MS_Device_USBTask+0x78>
    61ce:	9f 89       	ldd	r25, Y+23	; 0x17
    61d0:	89 85       	ldd	r24, Y+9	; 0x09
    61d2:	98 17       	cp	r25, r24
    61d4:	58 f4       	brcc	.+22     	; 0x61ec <MS_Device_USBTask+0x78>
    61d6:	8e 89       	ldd	r24, Y+22	; 0x16
    61d8:	90 e0       	ldi	r25, 0x00	; 0
    61da:	8f 71       	andi	r24, 0x1F	; 31
    61dc:	90 70       	andi	r25, 0x00	; 0
    61de:	89 2b       	or	r24, r25
    61e0:	29 f4       	brne	.+10     	; 0x61ec <MS_Device_USBTask+0x78>
    61e2:	68 8d       	ldd	r22, Y+24	; 0x18
    61e4:	66 23       	and	r22, r22
    61e6:	11 f0       	breq	.+4      	; 0x61ec <MS_Device_USBTask+0x78>
    61e8:	61 31       	cpi	r22, 0x11	; 17
    61ea:	70 f0       	brcs	.+28     	; 0x6208 <MS_Device_USBTask+0x94>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    61ec:	80 91 eb 00 	lds	r24, 0x00EB
    61f0:	80 62       	ori	r24, 0x20	; 32
    61f2:	80 93 eb 00 	sts	0x00EB, r24
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength >  16))
	{
		Endpoint_StallTransaction();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    61f6:	89 81       	ldd	r24, Y+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    61f8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    61fc:	80 91 eb 00 	lds	r24, 0x00EB
    6200:	80 62       	ori	r24, 0x20	; 32
    6202:	80 93 eb 00 	sts	0x00EB, r24
    6206:	6c c0       	rjmp	.+216    	; 0x62e0 <MS_Device_USBTask+0x16c>
		Endpoint_StallTransaction();

		return false;
	}

	CallbackIsResetSource = &MSInterfaceInfo->State.IsMassStoreReset;
    6208:	10 93 19 03 	sts	0x0319, r17
    620c:	00 93 18 03 	sts	0x0318, r16
	if (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6210:	ce 01       	movw	r24, r28
    6212:	49 96       	adiw	r24, 0x19	; 25
    6214:	70 e0       	ldi	r23, 0x00	; 0
    6216:	44 eb       	ldi	r20, 0xB4	; 180
    6218:	50 e3       	ldi	r21, 0x30	; 48
    621a:	f5 da       	rcall	.-2582   	; 0x5806 <Endpoint_Read_Stream_LE>
    621c:	88 23       	and	r24, r24
    621e:	09 f0       	breq	.+2      	; 0x6222 <MS_Device_USBTask+0xae>
    6220:	5f c0       	rjmp	.+190    	; 0x62e0 <MS_Device_USBTask+0x16c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6222:	80 91 e8 00 	lds	r24, 0x00E8
    6226:	8b 77       	andi	r24, 0x7B	; 123
    6228:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsReadWriteAllowed())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    622c:	8e 89       	ldd	r24, Y+22	; 0x16
    622e:	87 ff       	sbrs	r24, 7
    6230:	03 c0       	rjmp	.+6      	; 0x6238 <MS_Device_USBTask+0xc4>
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    6232:	89 81       	ldd	r24, Y+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6234:	80 93 e9 00 	sts	0x00E9, r24

			MSInterfaceInfo->State.CommandStatus.Status = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo) ?
    6238:	ce 01       	movw	r24, r28
    623a:	0e 94 4a 02 	call	0x494	; 0x494 <CALLBACK_MS_Device_SCSICommandReceived>
    623e:	91 e0       	ldi	r25, 0x01	; 1
    6240:	98 27       	eor	r25, r24
    6242:	9d ab       	std	Y+53, r25	; 0x35
			                                               MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
			MSInterfaceInfo->State.CommandStatus.Signature           = MS_CSW_SIGNATURE;
    6244:	25 e5       	ldi	r18, 0x55	; 85
    6246:	33 e5       	ldi	r19, 0x53	; 83
    6248:	42 e4       	ldi	r20, 0x42	; 66
    624a:	53 e5       	ldi	r21, 0x53	; 83
    624c:	29 a7       	std	Y+41, r18	; 0x29
    624e:	3a a7       	std	Y+42, r19	; 0x2a
    6250:	4b a7       	std	Y+43, r20	; 0x2b
    6252:	5c a7       	std	Y+44, r21	; 0x2c
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    6254:	2e 85       	ldd	r18, Y+14	; 0x0e
    6256:	3f 85       	ldd	r19, Y+15	; 0x0f
    6258:	48 89       	ldd	r20, Y+16	; 0x10
    625a:	59 89       	ldd	r21, Y+17	; 0x11
    625c:	2d a7       	std	Y+45, r18	; 0x2d
    625e:	3e a7       	std	Y+46, r19	; 0x2e
    6260:	4f a7       	std	Y+47, r20	; 0x2f
    6262:	58 ab       	std	Y+48, r21	; 0x30
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    6264:	2a 89       	ldd	r18, Y+18	; 0x12
    6266:	3b 89       	ldd	r19, Y+19	; 0x13
    6268:	4c 89       	ldd	r20, Y+20	; 0x14
    626a:	5d 89       	ldd	r21, Y+21	; 0x15
    626c:	29 ab       	std	Y+49, r18	; 0x31
    626e:	3a ab       	std	Y+50, r19	; 0x32
    6270:	4b ab       	std	Y+51, r20	; 0x33
    6272:	5c ab       	std	Y+52, r21	; 0x34

			if ((MSInterfaceInfo->State.CommandStatus.Status == MS_SCSI_COMMAND_Fail) &&
    6274:	91 30       	cpi	r25, 0x01	; 1
    6276:	51 f4       	brne	.+20     	; 0x628c <MS_Device_USBTask+0x118>
    6278:	21 15       	cp	r18, r1
    627a:	31 05       	cpc	r19, r1
    627c:	41 05       	cpc	r20, r1
    627e:	51 05       	cpc	r21, r1
    6280:	29 f0       	breq	.+10     	; 0x628c <MS_Device_USBTask+0x118>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6282:	80 91 eb 00 	lds	r24, 0x00EB
    6286:	80 62       	ori	r24, 0x20	; 32
    6288:	80 93 eb 00 	sts	0x00EB, r24
	return true;
}

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    628c:	8d 81       	ldd	r24, Y+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    628e:	80 93 e9 00 	sts	0x00E9, r24
    6292:	03 c0       	rjmp	.+6      	; 0x629a <MS_Device_USBTask+0x126>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    6294:	8e a9       	ldd	r24, Y+54	; 0x36
    6296:	88 23       	and	r24, r24
    6298:	19 f5       	brne	.+70     	; 0x62e0 <MS_Device_USBTask+0x16c>
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    629a:	80 91 eb 00 	lds	r24, 0x00EB

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);

	while (Endpoint_IsStalled())
    629e:	85 fd       	sbrc	r24, 5
    62a0:	f9 cf       	rjmp	.-14     	; 0x6294 <MS_Device_USBTask+0x120>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    62a2:	89 81       	ldd	r24, Y+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    62a4:	80 93 e9 00 	sts	0x00E9, r24
    62a8:	03 c0       	rjmp	.+6      	; 0x62b0 <MS_Device_USBTask+0x13c>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    62aa:	8e a9       	ldd	r24, Y+54	; 0x36
    62ac:	88 23       	and	r24, r24
    62ae:	c1 f4       	brne	.+48     	; 0x62e0 <MS_Device_USBTask+0x16c>
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    62b0:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);

	while (Endpoint_IsStalled())
    62b4:	85 fd       	sbrc	r24, 5
    62b6:	f9 cf       	rjmp	.-14     	; 0x62aa <MS_Device_USBTask+0x136>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	CallbackIsResetSource = &MSInterfaceInfo->State.IsMassStoreReset;
    62b8:	e6 96       	adiw	r28, 0x36	; 54
    62ba:	d0 93 19 03 	sts	0x0319, r29
    62be:	c0 93 18 03 	sts	0x0318, r28
    62c2:	e6 97       	sbiw	r28, 0x36	; 54
	if (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus, sizeof(MS_CommandStatusWrapper_t),
    62c4:	ce 01       	movw	r24, r28
    62c6:	89 96       	adiw	r24, 0x29	; 41
    62c8:	6d e0       	ldi	r22, 0x0D	; 13
    62ca:	70 e0       	ldi	r23, 0x00	; 0
    62cc:	44 eb       	ldi	r20, 0xB4	; 180
    62ce:	50 e3       	ldi	r21, 0x30	; 48
    62d0:	c1 db       	rcall	.-2174   	; 0x5a54 <Endpoint_Write_Stream_LE>
    62d2:	88 23       	and	r24, r24
    62d4:	29 f4       	brne	.+10     	; 0x62e0 <MS_Device_USBTask+0x16c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    62d6:	80 91 e8 00 	lds	r24, 0x00E8
    62da:	8e 77       	andi	r24, 0x7E	; 126
    62dc:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    62e0:	8e a9       	ldd	r24, Y+54	; 0x36
    62e2:	88 23       	and	r24, r24
    62e4:	91 f1       	breq	.+100    	; 0x634a <MS_Device_USBTask+0x1d6>
	{
		Endpoint_ResetFIFO(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    62e6:	4d 81       	ldd	r20, Y+5	; 0x05
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    62e8:	21 e0       	ldi	r18, 0x01	; 1
    62ea:	30 e0       	ldi	r19, 0x00	; 0
    62ec:	c9 01       	movw	r24, r18
    62ee:	04 2e       	mov	r0, r20
    62f0:	02 c0       	rjmp	.+4      	; 0x62f6 <MS_Device_USBTask+0x182>
    62f2:	88 0f       	add	r24, r24
    62f4:	99 1f       	adc	r25, r25
    62f6:	0a 94       	dec	r0
    62f8:	e2 f7       	brpl	.-8      	; 0x62f2 <MS_Device_USBTask+0x17e>
    62fa:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    62fe:	10 92 ea 00 	sts	0x00EA, r1
		Endpoint_ResetFIFO(MSInterfaceInfo->Config.DataINEndpointNumber);
    6302:	99 81       	ldd	r25, Y+1	; 0x01
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    6304:	09 2e       	mov	r0, r25
    6306:	02 c0       	rjmp	.+4      	; 0x630c <MS_Device_USBTask+0x198>
    6308:	22 0f       	add	r18, r18
    630a:	33 1f       	adc	r19, r19
    630c:	0a 94       	dec	r0
    630e:	e2 f7       	brpl	.-8      	; 0x6308 <MS_Device_USBTask+0x194>
    6310:	20 93 ea 00 	sts	0x00EA, r18
				UERST = 0;
    6314:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6318:	40 93 e9 00 	sts	0x00E9, r20
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    631c:	80 91 eb 00 	lds	r24, 0x00EB
    6320:	80 61       	ori	r24, 0x10	; 16
    6322:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6326:	80 91 eb 00 	lds	r24, 0x00EB
    632a:	88 60       	ori	r24, 0x08	; 8
    632c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6330:	90 93 e9 00 	sts	0x00E9, r25
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6334:	80 91 eb 00 	lds	r24, 0x00EB
    6338:	80 61       	ori	r24, 0x10	; 16
    633a:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    633e:	80 91 eb 00 	lds	r24, 0x00EB
    6342:	88 60       	ori	r24, 0x08	; 8
    6344:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    6348:	1e aa       	std	Y+54, r1	; 0x36
	}
}
    634a:	df 91       	pop	r29
    634c:	cf 91       	pop	r28
    634e:	1f 91       	pop	r17
    6350:	0f 91       	pop	r16
    6352:	08 95       	ret

00006354 <MS_Device_ConfigureEndpoints>:
			break;
	}
}

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6354:	1f 93       	push	r17
    6356:	cf 93       	push	r28
    6358:	df 93       	push	r29
    635a:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    635c:	0a 96       	adiw	r24, 0x0a	; 10
    635e:	fc 01       	movw	r30, r24
    6360:	8d e2       	ldi	r24, 0x2D	; 45
    6362:	df 01       	movw	r26, r30
    6364:	1d 92       	st	X+, r1
    6366:	8a 95       	dec	r24
    6368:	e9 f7       	brne	.-6      	; 0x6364 <MS_Device_ConfigureEndpoints+0x10>
    636a:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == MSInterfaceInfo->Config.DataINEndpointNumber)
    636c:	89 81       	ldd	r24, Y+1	; 0x01
    636e:	18 17       	cp	r17, r24
    6370:	29 f4       	brne	.+10     	; 0x637c <MS_Device_ConfigureEndpoints+0x28>
		{
			Size         = MSInterfaceInfo->Config.DataINEndpointSize;
    6372:	ea 81       	ldd	r30, Y+2	; 0x02
    6374:	fb 81       	ldd	r31, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataINEndpointDoubleBank;
    6376:	8c 81       	ldd	r24, Y+4	; 0x04
    6378:	61 e0       	ldi	r22, 0x01	; 1
    637a:	07 c0       	rjmp	.+14     	; 0x638a <MS_Device_ConfigureEndpoints+0x36>
		}
		else if (EndpointNum == MSInterfaceInfo->Config.DataOUTEndpointNumber)
    637c:	8d 81       	ldd	r24, Y+5	; 0x05
    637e:	18 17       	cp	r17, r24
    6380:	e9 f4       	brne	.+58     	; 0x63bc <MS_Device_ConfigureEndpoints+0x68>
		{
			Size         = MSInterfaceInfo->Config.DataOUTEndpointSize;
    6382:	ee 81       	ldd	r30, Y+6	; 0x06
    6384:	ff 81       	ldd	r31, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    6386:	88 85       	ldd	r24, Y+8	; 0x08
    6388:	60 e0       	ldi	r22, 0x00	; 0
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    638a:	88 23       	and	r24, r24
    638c:	11 f4       	brne	.+4      	; 0x6392 <MS_Device_ConfigureEndpoints+0x3e>
    638e:	40 e0       	ldi	r20, 0x00	; 0
    6390:	01 c0       	rjmp	.+2      	; 0x6394 <MS_Device_ConfigureEndpoints+0x40>
    6392:	44 e0       	ldi	r20, 0x04	; 4
    6394:	20 e0       	ldi	r18, 0x00	; 0
    6396:	88 e0       	ldi	r24, 0x08	; 8
    6398:	90 e0       	ldi	r25, 0x00	; 0
    639a:	03 c0       	rjmp	.+6      	; 0x63a2 <MS_Device_ConfigureEndpoints+0x4e>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    639c:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    639e:	88 0f       	add	r24, r24
    63a0:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    63a2:	8e 17       	cp	r24, r30
    63a4:	9f 07       	cpc	r25, r31
    63a6:	d0 f3       	brcs	.-12     	; 0x639c <MS_Device_ConfigureEndpoints+0x48>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    63a8:	60 68       	ori	r22, 0x80	; 128
    63aa:	42 60       	ori	r20, 0x02	; 2
    63ac:	22 95       	swap	r18
    63ae:	20 7f       	andi	r18, 0xF0	; 240
    63b0:	42 2b       	or	r20, r18
    63b2:	81 2f       	mov	r24, r17
    63b4:	0e 94 c5 23 	call	0x478a	; 0x478a <Endpoint_ConfigureEndpoint_Prv>
    63b8:	88 23       	and	r24, r24
    63ba:	21 f0       	breq	.+8      	; 0x63c4 <MS_Device_ConfigureEndpoints+0x70>

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    63bc:	1f 5f       	subi	r17, 0xFF	; 255
    63be:	17 30       	cpi	r17, 0x07	; 7
    63c0:	a9 f6       	brne	.-86     	; 0x636c <MS_Device_ConfigureEndpoints+0x18>
    63c2:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    63c4:	df 91       	pop	r29
    63c6:	cf 91       	pop	r28
    63c8:	1f 91       	pop	r17
    63ca:	08 95       	ret

000063cc <MS_Device_ProcessControlRequest>:
#include "MassStorage.h"

static volatile bool* CallbackIsResetSource;

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    63cc:	cf 93       	push	r28
    63ce:	df 93       	push	r29
    63d0:	ec 01       	movw	r28, r24
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    63d2:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    63d6:	83 ff       	sbrs	r24, 3
    63d8:	31 c0       	rjmp	.+98     	; 0x643c <MS_Device_ProcessControlRequest+0x70>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    63da:	88 81       	ld	r24, Y
    63dc:	90 e0       	ldi	r25, 0x00	; 0
    63de:	20 91 da 0c 	lds	r18, 0x0CDA
    63e2:	30 91 db 0c 	lds	r19, 0x0CDB
    63e6:	28 17       	cp	r18, r24
    63e8:	39 07       	cpc	r19, r25
    63ea:	41 f5       	brne	.+80     	; 0x643c <MS_Device_ProcessControlRequest+0x70>
	  return;

	switch (USB_ControlRequest.bRequest)
    63ec:	80 91 d7 0c 	lds	r24, 0x0CD7
    63f0:	8e 3f       	cpi	r24, 0xFE	; 254
    63f2:	81 f0       	breq	.+32     	; 0x6414 <MS_Device_ProcessControlRequest+0x48>
    63f4:	8f 3f       	cpi	r24, 0xFF	; 255
    63f6:	11 f5       	brne	.+68     	; 0x643c <MS_Device_ProcessControlRequest+0x70>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    63f8:	80 91 d6 0c 	lds	r24, 0x0CD6
    63fc:	81 32       	cpi	r24, 0x21	; 33
    63fe:	f1 f4       	brne	.+60     	; 0x643c <MS_Device_ProcessControlRequest+0x70>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6400:	80 91 e8 00 	lds	r24, 0x00E8
    6404:	87 7f       	andi	r24, 0xF7	; 247
    6406:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    640a:	0e 94 d8 23 	call	0x47b0	; 0x47b0 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    640e:	81 e0       	ldi	r24, 0x01	; 1
    6410:	8e ab       	std	Y+54, r24	; 0x36
    6412:	14 c0       	rjmp	.+40     	; 0x643c <MS_Device_ProcessControlRequest+0x70>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6414:	80 91 d6 0c 	lds	r24, 0x0CD6
    6418:	81 3a       	cpi	r24, 0xA1	; 161
    641a:	81 f4       	brne	.+32     	; 0x643c <MS_Device_ProcessControlRequest+0x70>
    641c:	80 91 e8 00 	lds	r24, 0x00E8
    6420:	87 7f       	andi	r24, 0xF7	; 247
    6422:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Write_Byte(MSInterfaceInfo->Config.TotalLUNs - 1);
    6426:	89 85       	ldd	r24, Y+9	; 0x09
    6428:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    642a:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    642e:	80 91 e8 00 	lds	r24, 0x00E8
    6432:	8e 77       	andi	r24, 0x7E	; 126
    6434:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    6438:	0e 94 d8 23 	call	0x47b0	; 0x47b0 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    643c:	df 91       	pop	r29
    643e:	cf 91       	pop	r28
    6440:	08 95       	ret

00006442 <DCOMP_RNDIS_Host_NextRNDISControlInterface>:

	return RNDIS_ENUMERROR_NoError;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISControlInterface(void* const CurrentDescriptor)
{
    6442:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    6444:	81 81       	ldd	r24, Z+1	; 0x01
    6446:	84 30       	cpi	r24, 0x04	; 4
    6448:	59 f4       	brne	.+22     	; 0x6460 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
    644a:	85 81       	ldd	r24, Z+5	; 0x05
    644c:	82 30       	cpi	r24, 0x02	; 2
    644e:	41 f4       	brne	.+16     	; 0x6460 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    6450:	86 81       	ldd	r24, Z+6	; 0x06
    6452:	82 30       	cpi	r24, 0x02	; 2
    6454:	29 f4       	brne	.+10     	; 0x6460 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    6456:	87 81       	ldd	r24, Z+7	; 0x07
    6458:	8f 3f       	cpi	r24, 0xFF	; 255
    645a:	11 f4       	brne	.+4      	; 0x6460 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    645c:	80 e0       	ldi	r24, 0x00	; 0
    645e:	08 95       	ret
    6460:	82 e0       	ldi	r24, 0x02	; 2
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    6462:	08 95       	ret

00006464 <DCOMP_RNDIS_Host_NextRNDISDataInterface>:

static uint8_t DCOMP_RNDIS_Host_NextRNDISDataInterface(void* const CurrentDescriptor)
{
    6464:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    6466:	81 81       	ldd	r24, Z+1	; 0x01
    6468:	84 30       	cpi	r24, 0x04	; 4
    646a:	41 f4       	brne	.+16     	; 0x647c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x18>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor,
		                                                         USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
    646c:	85 81       	ldd	r24, Z+5	; 0x05
    646e:	8a 30       	cpi	r24, 0x0A	; 10
    6470:	29 f4       	brne	.+10     	; 0x647c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x18>
    6472:	86 81       	ldd	r24, Z+6	; 0x06
    6474:	88 23       	and	r24, r24
    6476:	11 f4       	brne	.+4      	; 0x647c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x18>
    6478:	87 81       	ldd	r24, Z+7	; 0x07
    647a:	81 11       	cpse	r24, r1
    647c:	82 e0       	ldi	r24, 0x02	; 2
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    647e:	08 95       	ret

00006480 <RNDIS_Host_IsPacketReceived>:

	return HOST_SENDCONTROL_Successful;
}

bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    6480:	fc 01       	movw	r30, r24
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    6482:	80 91 de 0c 	lds	r24, 0x0CDE
    6486:	8c 30       	cpi	r24, 0x0C	; 12
    6488:	a1 f4       	brne	.+40     	; 0x64b2 <RNDIS_Host_IsPacketReceived+0x32>
    648a:	82 85       	ldd	r24, Z+10	; 0x0a
    648c:	88 23       	and	r24, r24
    648e:	89 f0       	breq	.+34     	; 0x64b2 <RNDIS_Host_IsPacketReceived+0x32>
	  return false;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipeNumber);
    6490:	80 81       	ld	r24, Z
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    6492:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6496:	80 91 a9 00 	lds	r24, 0x00A9
    649a:	8f 7b       	andi	r24, 0xBF	; 191
    649c:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean true if the current pipe has received an IN packet, false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    64a0:	90 91 a6 00 	lds	r25, 0x00A6
    64a4:	91 70       	andi	r25, 0x01	; 1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    64a6:	80 91 a9 00 	lds	r24, 0x00A9
    64aa:	80 64       	ori	r24, 0x40	; 64
    64ac:	80 93 a9 00 	sts	0x00A9, r24
    64b0:	01 c0       	rjmp	.+2      	; 0x64b4 <RNDIS_Host_IsPacketReceived+0x34>

	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
    64b2:	90 e0       	ldi	r25, 0x00	; 0
}
    64b4:	89 2f       	mov	r24, r25
    64b6:	08 95       	ret

000064b8 <RNDIS_Host_SendPacket>:
}

uint8_t RNDIS_Host_SendPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              const uint16_t PacketLength)
{
    64b8:	cf 92       	push	r12
    64ba:	df 92       	push	r13
    64bc:	ff 92       	push	r15
    64be:	0f 93       	push	r16
    64c0:	1f 93       	push	r17
    64c2:	df 93       	push	r29
    64c4:	cf 93       	push	r28
    64c6:	cd b7       	in	r28, 0x3d	; 61
    64c8:	de b7       	in	r29, 0x3e	; 62
    64ca:	ac 97       	sbiw	r28, 0x2c	; 44
    64cc:	0f b6       	in	r0, 0x3f	; 63
    64ce:	f8 94       	cli
    64d0:	de bf       	out	0x3e, r29	; 62
    64d2:	0f be       	out	0x3f, r0	; 63
    64d4:	cd bf       	out	0x3d, r28	; 61
    64d6:	9c 01       	movw	r18, r24
    64d8:	6b 01       	movw	r12, r22
    64da:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    64dc:	80 91 de 0c 	lds	r24, 0x0CDE
    64e0:	8c 30       	cpi	r24, 0x0C	; 12
    64e2:	09 f0       	breq	.+2      	; 0x64e6 <RNDIS_Host_SendPacket+0x2e>
    64e4:	52 c0       	rjmp	.+164    	; 0x658a <RNDIS_Host_SendPacket+0xd2>
    64e6:	d9 01       	movw	r26, r18
    64e8:	1a 96       	adiw	r26, 0x0a	; 10
    64ea:	8c 91       	ld	r24, X
    64ec:	88 23       	and	r24, r24
    64ee:	09 f4       	brne	.+2      	; 0x64f2 <RNDIS_Host_SendPacket+0x3a>
    64f0:	4c c0       	rjmp	.+152    	; 0x658a <RNDIS_Host_SendPacket+0xd2>
	  return PIPE_READYWAIT_DeviceDisconnected;

	RNDIS_Packet_Message_t DeviceMessage;

	memset(&DeviceMessage, 0, sizeof(RNDIS_Packet_Message_t));
    64f2:	fe 01       	movw	r30, r28
    64f4:	31 96       	adiw	r30, 0x01	; 1
    64f6:	8c e2       	ldi	r24, 0x2C	; 44
    64f8:	df 01       	movw	r26, r30
    64fa:	1d 92       	st	X+, r1
    64fc:	8a 95       	dec	r24
    64fe:	e9 f7       	brne	.-6      	; 0x64fa <RNDIS_Host_SendPacket+0x42>
	DeviceMessage.MessageType   = REMOTE_NDIS_PACKET_MSG;
    6500:	81 e0       	ldi	r24, 0x01	; 1
    6502:	90 e0       	ldi	r25, 0x00	; 0
    6504:	a0 e0       	ldi	r26, 0x00	; 0
    6506:	b0 e0       	ldi	r27, 0x00	; 0
    6508:	89 83       	std	Y+1, r24	; 0x01
    650a:	9a 83       	std	Y+2, r25	; 0x02
    650c:	ab 83       	std	Y+3, r26	; 0x03
    650e:	bc 83       	std	Y+4, r27	; 0x04
	DeviceMessage.MessageLength = (sizeof(RNDIS_Packet_Message_t) + PacketLength);
    6510:	04 5d       	subi	r16, 0xD4	; 212
    6512:	1f 4f       	sbci	r17, 0xFF	; 255
    6514:	c8 01       	movw	r24, r16
    6516:	a0 e0       	ldi	r26, 0x00	; 0
    6518:	b0 e0       	ldi	r27, 0x00	; 0
    651a:	0c 52       	subi	r16, 0x2C	; 44
    651c:	10 40       	sbci	r17, 0x00	; 0
    651e:	8d 83       	std	Y+5, r24	; 0x05
    6520:	9e 83       	std	Y+6, r25	; 0x06
    6522:	af 83       	std	Y+7, r26	; 0x07
    6524:	b8 87       	std	Y+8, r27	; 0x08
	DeviceMessage.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    6526:	84 e2       	ldi	r24, 0x24	; 36
    6528:	90 e0       	ldi	r25, 0x00	; 0
    652a:	a0 e0       	ldi	r26, 0x00	; 0
    652c:	b0 e0       	ldi	r27, 0x00	; 0
    652e:	89 87       	std	Y+9, r24	; 0x09
    6530:	9a 87       	std	Y+10, r25	; 0x0a
    6532:	ab 87       	std	Y+11, r26	; 0x0b
    6534:	bc 87       	std	Y+12, r27	; 0x0c
	DeviceMessage.DataLength    = PacketLength;
    6536:	c8 01       	movw	r24, r16
    6538:	a0 e0       	ldi	r26, 0x00	; 0
    653a:	b0 e0       	ldi	r27, 0x00	; 0
    653c:	8d 87       	std	Y+13, r24	; 0x0d
    653e:	9e 87       	std	Y+14, r25	; 0x0e
    6540:	af 87       	std	Y+15, r26	; 0x0f
    6542:	b8 8b       	std	Y+16, r27	; 0x10

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataOUTPipeNumber);
    6544:	d9 01       	movw	r26, r18
    6546:	12 96       	adiw	r26, 0x02	; 2
    6548:	8c 91       	ld	r24, X
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    654a:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    654e:	80 91 a9 00 	lds	r24, 0x00A9
    6552:	8f 7b       	andi	r24, 0xBF	; 191
    6554:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_Unfreeze();

	if ((ErrorCode = Pipe_Write_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    6558:	cf 01       	movw	r24, r30
    655a:	6c e2       	ldi	r22, 0x2C	; 44
    655c:	70 e0       	ldi	r23, 0x00	; 0
    655e:	40 e0       	ldi	r20, 0x00	; 0
    6560:	50 e0       	ldi	r21, 0x00	; 0
    6562:	cc dc       	rcall	.-1640   	; 0x5efc <Pipe_Write_Stream_LE>
    6564:	f8 2e       	mov	r15, r24
    6566:	88 23       	and	r24, r24
    6568:	91 f4       	brne	.+36     	; 0x658e <RNDIS_Host_SendPacket+0xd6>
	                                      NO_STREAM_CALLBACK)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	Pipe_Write_Stream_LE(Buffer, PacketLength, NO_STREAM_CALLBACK);
    656a:	c6 01       	movw	r24, r12
    656c:	b8 01       	movw	r22, r16
    656e:	40 e0       	ldi	r20, 0x00	; 0
    6570:	50 e0       	ldi	r21, 0x00	; 0
    6572:	c4 dc       	rcall	.-1656   	; 0x5efc <Pipe_Write_Stream_LE>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    6574:	80 91 a6 00 	lds	r24, 0x00A6
    6578:	8b 77       	andi	r24, 0x7B	; 123
    657a:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    657e:	80 91 a9 00 	lds	r24, 0x00A9
    6582:	80 64       	ori	r24, 0x40	; 64
    6584:	80 93 a9 00 	sts	0x00A9, r24
    6588:	02 c0       	rjmp	.+4      	; 0x658e <RNDIS_Host_SendPacket+0xd6>
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    658a:	82 e0       	ldi	r24, 0x02	; 2
    658c:	f8 2e       	mov	r15, r24
}
    658e:	8f 2d       	mov	r24, r15
    6590:	ac 96       	adiw	r28, 0x2c	; 44
    6592:	0f b6       	in	r0, 0x3f	; 63
    6594:	f8 94       	cli
    6596:	de bf       	out	0x3e, r29	; 62
    6598:	0f be       	out	0x3f, r0	; 63
    659a:	cd bf       	out	0x3d, r28	; 61
    659c:	cf 91       	pop	r28
    659e:	df 91       	pop	r29
    65a0:	1f 91       	pop	r17
    65a2:	0f 91       	pop	r16
    65a4:	ff 90       	pop	r15
    65a6:	df 90       	pop	r13
    65a8:	cf 90       	pop	r12
    65aa:	08 95       	ret

000065ac <RNDIS_Host_ReadPacket>:
}

uint8_t RNDIS_Host_ReadPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              uint16_t* const PacketLength)
{
    65ac:	cf 92       	push	r12
    65ae:	df 92       	push	r13
    65b0:	ff 92       	push	r15
    65b2:	0f 93       	push	r16
    65b4:	1f 93       	push	r17
    65b6:	df 93       	push	r29
    65b8:	cf 93       	push	r28
    65ba:	cd b7       	in	r28, 0x3d	; 61
    65bc:	de b7       	in	r29, 0x3e	; 62
    65be:	ac 97       	sbiw	r28, 0x2c	; 44
    65c0:	0f b6       	in	r0, 0x3f	; 63
    65c2:	f8 94       	cli
    65c4:	de bf       	out	0x3e, r29	; 62
    65c6:	0f be       	out	0x3f, r0	; 63
    65c8:	cd bf       	out	0x3d, r28	; 61
    65ca:	fc 01       	movw	r30, r24
    65cc:	6b 01       	movw	r12, r22
    65ce:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    65d0:	80 91 de 0c 	lds	r24, 0x0CDE
    65d4:	8c 30       	cpi	r24, 0x0C	; 12
    65d6:	09 f0       	breq	.+2      	; 0x65da <RNDIS_Host_ReadPacket+0x2e>
    65d8:	50 c0       	rjmp	.+160    	; 0x667a <RNDIS_Host_ReadPacket+0xce>
    65da:	82 85       	ldd	r24, Z+10	; 0x0a
    65dc:	88 23       	and	r24, r24
    65de:	09 f4       	brne	.+2      	; 0x65e2 <RNDIS_Host_ReadPacket+0x36>
    65e0:	4c c0       	rjmp	.+152    	; 0x667a <RNDIS_Host_ReadPacket+0xce>
	  return PIPE_READYWAIT_DeviceDisconnected;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipeNumber);
    65e2:	80 81       	ld	r24, Z
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    65e4:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    65e8:	80 91 a9 00 	lds	r24, 0x00A9
    65ec:	8f 7b       	andi	r24, 0xBF	; 191
    65ee:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean true if the currently selected pipe may be read from or written to, depending on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    65f2:	80 91 a6 00 	lds	r24, 0x00A6
	Pipe_Unfreeze();

	if (!(Pipe_IsReadWriteAllowed()))
    65f6:	85 fd       	sbrc	r24, 5
    65f8:	13 c0       	rjmp	.+38     	; 0x6620 <RNDIS_Host_ReadPacket+0x74>
			 *  \return Boolean true if the current pipe has received an IN packet, false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    65fa:	80 91 a6 00 	lds	r24, 0x00A6
	{
		if (Pipe_IsINReceived())
    65fe:	80 ff       	sbrs	r24, 0
    6600:	05 c0       	rjmp	.+10     	; 0x660c <RNDIS_Host_ReadPacket+0x60>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    6602:	80 91 a6 00 	lds	r24, 0x00A6
    6606:	8e 77       	andi	r24, 0x7E	; 126
    6608:	80 93 a6 00 	sts	0x00A6, r24
		  Pipe_ClearIN();

		*PacketLength = 0;
    660c:	f8 01       	movw	r30, r16
    660e:	11 82       	std	Z+1, r1	; 0x01
    6610:	10 82       	st	Z, r1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    6612:	80 91 a9 00 	lds	r24, 0x00A9
    6616:	80 64       	ori	r24, 0x40	; 64
    6618:	80 93 a9 00 	sts	0x00A9, r24
    661c:	ff 24       	eor	r15, r15
    661e:	2f c0       	rjmp	.+94     	; 0x667e <RNDIS_Host_ReadPacket+0xd2>
		return PIPE_RWSTREAM_NoError;
	}

	RNDIS_Packet_Message_t DeviceMessage;

	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    6620:	ce 01       	movw	r24, r28
    6622:	01 96       	adiw	r24, 0x01	; 1
    6624:	6c e2       	ldi	r22, 0x2C	; 44
    6626:	70 e0       	ldi	r23, 0x00	; 0
    6628:	40 e0       	ldi	r20, 0x00	; 0
    662a:	50 e0       	ldi	r21, 0x00	; 0
    662c:	d1 db       	rcall	.-2142   	; 0x5dd0 <Pipe_Read_Stream_LE>
    662e:	f8 2e       	mov	r15, r24
    6630:	88 23       	and	r24, r24
    6632:	29 f5       	brne	.+74     	; 0x667e <RNDIS_Host_ReadPacket+0xd2>
	                                     NO_STREAM_CALLBACK)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	*PacketLength = (uint16_t)DeviceMessage.DataLength;
    6634:	8d 85       	ldd	r24, Y+13	; 0x0d
    6636:	9e 85       	ldd	r25, Y+14	; 0x0e
    6638:	f8 01       	movw	r30, r16
    663a:	91 83       	std	Z+1, r25	; 0x01
    663c:	80 83       	st	Z, r24

	Pipe_Discard_Stream(DeviceMessage.DataOffset - (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t)),
    663e:	89 85       	ldd	r24, Y+9	; 0x09
    6640:	9a 85       	ldd	r25, Y+10	; 0x0a
    6642:	84 97       	sbiw	r24, 0x24	; 36
    6644:	60 e0       	ldi	r22, 0x00	; 0
    6646:	70 e0       	ldi	r23, 0x00	; 0
    6648:	ef dc       	rcall	.-1570   	; 0x6028 <Pipe_Discard_Stream>
	                    NO_STREAM_CALLBACK);

	Pipe_Read_Stream_LE(Buffer, *PacketLength, NO_STREAM_CALLBACK);
    664a:	f8 01       	movw	r30, r16
    664c:	60 81       	ld	r22, Z
    664e:	71 81       	ldd	r23, Z+1	; 0x01
    6650:	c6 01       	movw	r24, r12
    6652:	40 e0       	ldi	r20, 0x00	; 0
    6654:	50 e0       	ldi	r21, 0x00	; 0
    6656:	bc db       	rcall	.-2184   	; 0x5dd0 <Pipe_Read_Stream_LE>
			 *  \return Total number of bytes in the currently selected Pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    6658:	80 91 f6 00 	lds	r24, 0x00F6
    665c:	90 91 f7 00 	lds	r25, 0x00F7

	if (!(Pipe_BytesInPipe()))
    6660:	89 2b       	or	r24, r25
    6662:	29 f4       	brne	.+10     	; 0x666e <RNDIS_Host_ReadPacket+0xc2>
			 *  \ingroup Group_PipePacketManagement
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    6664:	80 91 a6 00 	lds	r24, 0x00A6
    6668:	8e 77       	andi	r24, 0x7E	; 126
    666a:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    666e:	80 91 a9 00 	lds	r24, 0x00A9
    6672:	80 64       	ori	r24, 0x40	; 64
    6674:	80 93 a9 00 	sts	0x00A9, r24
    6678:	02 c0       	rjmp	.+4      	; 0x667e <RNDIS_Host_ReadPacket+0xd2>
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    667a:	92 e0       	ldi	r25, 0x02	; 2
    667c:	f9 2e       	mov	r15, r25
}
    667e:	8f 2d       	mov	r24, r15
    6680:	ac 96       	adiw	r28, 0x2c	; 44
    6682:	0f b6       	in	r0, 0x3f	; 63
    6684:	f8 94       	cli
    6686:	de bf       	out	0x3e, r29	; 62
    6688:	0f be       	out	0x3f, r0	; 63
    668a:	cd bf       	out	0x3d, r28	; 61
    668c:	cf 91       	pop	r28
    668e:	df 91       	pop	r29
    6690:	1f 91       	pop	r17
    6692:	0f 91       	pop	r16
    6694:	ff 90       	pop	r15
    6696:	df 90       	pop	r13
    6698:	cf 90       	pop	r12
    669a:	08 95       	ret

0000669c <RNDIS_SendEncapsulatedCommand>:

static uint8_t RNDIS_SendEncapsulatedCommand(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    669c:	fc 01       	movw	r30, r24
    669e:	93 85       	ldd	r25, Z+11	; 0x0b
    66a0:	81 e2       	ldi	r24, 0x21	; 33
    66a2:	80 93 d6 0c 	sts	0x0CD6, r24
    66a6:	10 92 d7 0c 	sts	0x0CD7, r1
    66aa:	10 92 d9 0c 	sts	0x0CD9, r1
    66ae:	10 92 d8 0c 	sts	0x0CD8, r1
    66b2:	90 93 da 0c 	sts	0x0CDA, r25
    66b6:	10 92 db 0c 	sts	0x0CDB, r1
    66ba:	50 93 dd 0c 	sts	0x0CDD, r21
    66be:	40 93 dc 0c 	sts	0x0CDC, r20
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    66c2:	10 92 a7 00 	sts	0x00A7, r1
			.wIndex        = RNDISInterfaceInfo->State.ControlInterfaceNumber,
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	return USB_Host_SendControlRequest(Buffer);
    66c6:	cb 01       	movw	r24, r22
}
    66c8:	7f ca       	rjmp	.-2818   	; 0x5bc8 <USB_Host_SendControlRequest>

000066ca <RNDIS_GetEncapsulatedResponse>:

static uint8_t RNDIS_GetEncapsulatedResponse(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    66ca:	fc 01       	movw	r30, r24
    66cc:	93 85       	ldd	r25, Z+11	; 0x0b
    66ce:	81 ea       	ldi	r24, 0xA1	; 161
    66d0:	80 93 d6 0c 	sts	0x0CD6, r24
    66d4:	81 e0       	ldi	r24, 0x01	; 1
    66d6:	80 93 d7 0c 	sts	0x0CD7, r24
    66da:	10 92 d9 0c 	sts	0x0CD9, r1
    66de:	10 92 d8 0c 	sts	0x0CD8, r1
    66e2:	90 93 da 0c 	sts	0x0CDA, r25
    66e6:	10 92 db 0c 	sts	0x0CDB, r1
    66ea:	50 93 dd 0c 	sts	0x0CDD, r21
    66ee:	40 93 dc 0c 	sts	0x0CDC, r20
    66f2:	10 92 a7 00 	sts	0x00A7, r1
			.wIndex        = RNDISInterfaceInfo->State.ControlInterfaceNumber,
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	return USB_Host_SendControlRequest(Buffer);
    66f6:	cb 01       	movw	r24, r22
}
    66f8:	67 ca       	rjmp	.-2866   	; 0x5bc8 <USB_Host_SendControlRequest>

000066fa <RNDIS_Host_QueryRNDISProperty>:

uint8_t RNDIS_Host_QueryRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                      const uint32_t Oid,
                                      void* Buffer,
                                      const uint16_t MaxLength)
{
    66fa:	4f 92       	push	r4
    66fc:	5f 92       	push	r5
    66fe:	6f 92       	push	r6
    6700:	7f 92       	push	r7
    6702:	8f 92       	push	r8
    6704:	9f 92       	push	r9
    6706:	af 92       	push	r10
    6708:	bf 92       	push	r11
    670a:	cf 92       	push	r12
    670c:	df 92       	push	r13
    670e:	ef 92       	push	r14
    6710:	ff 92       	push	r15
    6712:	0f 93       	push	r16
    6714:	1f 93       	push	r17
    6716:	df 93       	push	r29
    6718:	cf 93       	push	r28
    671a:	cd b7       	in	r28, 0x3d	; 61
    671c:	de b7       	in	r29, 0x3e	; 62
    671e:	6c 97       	sbiw	r28, 0x1c	; 28
    6720:	0f b6       	in	r0, 0x3f	; 63
    6722:	f8 94       	cli
    6724:	de bf       	out	0x3e, r29	; 62
    6726:	0f be       	out	0x3f, r0	; 63
    6728:	cd bf       	out	0x3d, r28	; 61
    672a:	7c 01       	movw	r14, r24
    672c:	52 2e       	mov	r5, r18
    672e:	43 2e       	mov	r4, r19
    6730:	58 01       	movw	r10, r16
	  return RNDIS_COMMAND_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    6732:	6d b6       	in	r6, 0x3d	; 61
    6734:	7e b6       	in	r7, 0x3e	; 62

	struct
	{
		RNDIS_Query_Complete_t QueryMessageResponse;
		uint8_t                ContiguousBuffer[MaxLength];
	} QueryMessageResponseData;
    6736:	28 e1       	ldi	r18, 0x18	; 24
    6738:	82 2e       	mov	r8, r18
    673a:	91 2c       	mov	r9, r1
    673c:	80 0e       	add	r8, r16
    673e:	91 1e       	adc	r9, r17
    6740:	8d b7       	in	r24, 0x3d	; 61
    6742:	9e b7       	in	r25, 0x3e	; 62
    6744:	88 19       	sub	r24, r8
    6746:	99 09       	sbc	r25, r9
    6748:	0f b6       	in	r0, 0x3f	; 63
    674a:	f8 94       	cli
    674c:	9e bf       	out	0x3e, r25	; 62
    674e:	0f be       	out	0x3f, r0	; 63
    6750:	8d bf       	out	0x3d, r24	; 61
    6752:	cd b6       	in	r12, 0x3d	; 61
    6754:	de b6       	in	r13, 0x3e	; 62
    6756:	08 94       	sec
    6758:	c1 1c       	adc	r12, r1
    675a:	d1 1c       	adc	r13, r1

	QueryMessage.MessageType    = REMOTE_NDIS_QUERY_MSG;
    675c:	84 e0       	ldi	r24, 0x04	; 4
    675e:	90 e0       	ldi	r25, 0x00	; 0
    6760:	a0 e0       	ldi	r26, 0x00	; 0
    6762:	b0 e0       	ldi	r27, 0x00	; 0
    6764:	89 83       	std	Y+1, r24	; 0x01
    6766:	9a 83       	std	Y+2, r25	; 0x02
    6768:	ab 83       	std	Y+3, r26	; 0x03
    676a:	bc 83       	std	Y+4, r27	; 0x04
	QueryMessage.MessageLength  = sizeof(RNDIS_Query_Message_t);
    676c:	8c e1       	ldi	r24, 0x1C	; 28
    676e:	90 e0       	ldi	r25, 0x00	; 0
    6770:	a0 e0       	ldi	r26, 0x00	; 0
    6772:	b0 e0       	ldi	r27, 0x00	; 0
    6774:	8d 83       	std	Y+5, r24	; 0x05
    6776:	9e 83       	std	Y+6, r25	; 0x06
    6778:	af 83       	std	Y+7, r26	; 0x07
    677a:	b8 87       	std	Y+8, r27	; 0x08
	QueryMessage.RequestId      = RNDISInterfaceInfo->State.RequestID++;
    677c:	f7 01       	movw	r30, r14
    677e:	86 89       	ldd	r24, Z+22	; 0x16
    6780:	97 89       	ldd	r25, Z+23	; 0x17
    6782:	a0 8d       	ldd	r26, Z+24	; 0x18
    6784:	b1 8d       	ldd	r27, Z+25	; 0x19
    6786:	89 87       	std	Y+9, r24	; 0x09
    6788:	9a 87       	std	Y+10, r25	; 0x0a
    678a:	ab 87       	std	Y+11, r26	; 0x0b
    678c:	bc 87       	std	Y+12, r27	; 0x0c
    678e:	01 96       	adiw	r24, 0x01	; 1
    6790:	a1 1d       	adc	r26, r1
    6792:	b1 1d       	adc	r27, r1
    6794:	86 8b       	std	Z+22, r24	; 0x16
    6796:	97 8b       	std	Z+23, r25	; 0x17
    6798:	a0 8f       	std	Z+24, r26	; 0x18
    679a:	b1 8f       	std	Z+25, r27	; 0x19

	QueryMessage.Oid            = Oid;
    679c:	4d 87       	std	Y+13, r20	; 0x0d
    679e:	5e 87       	std	Y+14, r21	; 0x0e
    67a0:	6f 87       	std	Y+15, r22	; 0x0f
    67a2:	78 8b       	std	Y+16, r23	; 0x10
	QueryMessage.InformationBufferLength = 0;
    67a4:	19 8a       	std	Y+17, r1	; 0x11
    67a6:	1a 8a       	std	Y+18, r1	; 0x12
    67a8:	1b 8a       	std	Y+19, r1	; 0x13
    67aa:	1c 8a       	std	Y+20, r1	; 0x14
	QueryMessage.InformationBufferOffset = 0;
    67ac:	1d 8a       	std	Y+21, r1	; 0x15
    67ae:	1e 8a       	std	Y+22, r1	; 0x16
    67b0:	1f 8a       	std	Y+23, r1	; 0x17
    67b2:	18 8e       	std	Y+24, r1	; 0x18
	QueryMessage.DeviceVcHandle = 0;
    67b4:	19 8e       	std	Y+25, r1	; 0x19
    67b6:	1a 8e       	std	Y+26, r1	; 0x1a
    67b8:	1b 8e       	std	Y+27, r1	; 0x1b
    67ba:	1c 8e       	std	Y+28, r1	; 0x1c

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &QueryMessage,
    67bc:	c7 01       	movw	r24, r14
    67be:	be 01       	movw	r22, r28
    67c0:	6f 5f       	subi	r22, 0xFF	; 255
    67c2:	7f 4f       	sbci	r23, 0xFF	; 255
    67c4:	4c e1       	ldi	r20, 0x1C	; 28
    67c6:	50 e0       	ldi	r21, 0x00	; 0
    67c8:	69 df       	rcall	.-302    	; 0x669c <RNDIS_SendEncapsulatedCommand>
    67ca:	18 2f       	mov	r17, r24
    67cc:	88 23       	and	r24, r24
    67ce:	d1 f4       	brne	.+52     	; 0x6804 <RNDIS_Host_QueryRNDISProperty+0x10a>
	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &QueryMessageResponseData,
    67d0:	c7 01       	movw	r24, r14
    67d2:	b6 01       	movw	r22, r12
    67d4:	a4 01       	movw	r20, r8
    67d6:	79 df       	rcall	.-270    	; 0x66ca <RNDIS_GetEncapsulatedResponse>
    67d8:	18 2f       	mov	r17, r24
    67da:	88 23       	and	r24, r24
    67dc:	99 f4       	brne	.+38     	; 0x6804 <RNDIS_Host_QueryRNDISProperty+0x10a>
	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
    67de:	f6 01       	movw	r30, r12
    67e0:	84 85       	ldd	r24, Z+12	; 0x0c
    67e2:	95 85       	ldd	r25, Z+13	; 0x0d
    67e4:	a6 85       	ldd	r26, Z+14	; 0x0e
    67e6:	b7 85       	ldd	r27, Z+15	; 0x0f
    67e8:	00 97       	sbiw	r24, 0x00	; 0
    67ea:	a1 05       	cpc	r26, r1
    67ec:	b1 05       	cpc	r27, r1
    67ee:	11 f0       	breq	.+4      	; 0x67f4 <RNDIS_Host_QueryRNDISProperty+0xfa>
    67f0:	10 ec       	ldi	r17, 0xC0	; 192
    67f2:	08 c0       	rjmp	.+16     	; 0x6804 <RNDIS_Host_QueryRNDISProperty+0x10a>
	  return RNDIS_COMMAND_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
    67f4:	96 01       	movw	r18, r12
    67f6:	28 5e       	subi	r18, 0xE8	; 232
    67f8:	3f 4f       	sbci	r19, 0xFF	; 255
    67fa:	85 2d       	mov	r24, r5
    67fc:	94 2d       	mov	r25, r4
    67fe:	b9 01       	movw	r22, r18
    6800:	a5 01       	movw	r20, r10
    6802:	b5 d2       	rcall	.+1386   	; 0x6d6e <memcpy>

	return HOST_SENDCONTROL_Successful;
}
    6804:	81 2f       	mov	r24, r17
    6806:	0f b6       	in	r0, 0x3f	; 63
    6808:	f8 94       	cli
    680a:	7e be       	out	0x3e, r7	; 62
    680c:	0f be       	out	0x3f, r0	; 63
    680e:	6d be       	out	0x3d, r6	; 61
    6810:	6c 96       	adiw	r28, 0x1c	; 28
    6812:	0f b6       	in	r0, 0x3f	; 63
    6814:	f8 94       	cli
    6816:	de bf       	out	0x3e, r29	; 62
    6818:	0f be       	out	0x3f, r0	; 63
    681a:	cd bf       	out	0x3d, r28	; 61
    681c:	cf 91       	pop	r28
    681e:	df 91       	pop	r29
    6820:	1f 91       	pop	r17
    6822:	0f 91       	pop	r16
    6824:	ff 90       	pop	r15
    6826:	ef 90       	pop	r14
    6828:	df 90       	pop	r13
    682a:	cf 90       	pop	r12
    682c:	bf 90       	pop	r11
    682e:	af 90       	pop	r10
    6830:	9f 90       	pop	r9
    6832:	8f 90       	pop	r8
    6834:	7f 90       	pop	r7
    6836:	6f 90       	pop	r6
    6838:	5f 90       	pop	r5
    683a:	4f 90       	pop	r4
    683c:	08 95       	ret

0000683e <RNDIS_Host_SetRNDISProperty>:

uint8_t RNDIS_Host_SetRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                    const uint32_t Oid,
                                    void* Buffer,
                                    const uint16_t Length)
{
    683e:	6f 92       	push	r6
    6840:	7f 92       	push	r7
    6842:	8f 92       	push	r8
    6844:	9f 92       	push	r9
    6846:	af 92       	push	r10
    6848:	bf 92       	push	r11
    684a:	cf 92       	push	r12
    684c:	df 92       	push	r13
    684e:	ef 92       	push	r14
    6850:	ff 92       	push	r15
    6852:	0f 93       	push	r16
    6854:	1f 93       	push	r17
    6856:	df 93       	push	r29
    6858:	cf 93       	push	r28
    685a:	cd b7       	in	r28, 0x3d	; 61
    685c:	de b7       	in	r29, 0x3e	; 62
    685e:	60 97       	sbiw	r28, 0x10	; 16
    6860:	0f b6       	in	r0, 0x3f	; 63
    6862:	f8 94       	cli
    6864:	de bf       	out	0x3e, r29	; 62
    6866:	0f be       	out	0x3f, r0	; 63
    6868:	cd bf       	out	0x3d, r28	; 61
    686a:	4c 01       	movw	r8, r24

	if (SetMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
	  return RNDIS_COMMAND_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    686c:	6d b6       	in	r6, 0x3d	; 61
    686e:	7e b6       	in	r7, 0x3e	; 62

	struct
	{
		RNDIS_Set_Message_t SetMessage;
		uint8_t             ContiguousBuffer[Length];
	} SetMessageData;
    6870:	ec e1       	ldi	r30, 0x1C	; 28
    6872:	ce 2e       	mov	r12, r30
    6874:	d1 2c       	mov	r13, r1
    6876:	c0 0e       	add	r12, r16
    6878:	d1 1e       	adc	r13, r17
    687a:	8d b7       	in	r24, 0x3d	; 61
    687c:	9e b7       	in	r25, 0x3e	; 62
    687e:	8c 19       	sub	r24, r12
    6880:	9d 09       	sbc	r25, r13
    6882:	0f b6       	in	r0, 0x3f	; 63
    6884:	f8 94       	cli
    6886:	9e bf       	out	0x3e, r25	; 62
    6888:	0f be       	out	0x3f, r0	; 63
    688a:	8d bf       	out	0x3d, r24	; 61
    688c:	ad b6       	in	r10, 0x3d	; 61
    688e:	be b6       	in	r11, 0x3e	; 62
    6890:	08 94       	sec
    6892:	a1 1c       	adc	r10, r1
    6894:	b1 1c       	adc	r11, r1

	RNDIS_Set_Complete_t SetMessageResponse;

	SetMessageData.SetMessage.MessageType    = REMOTE_NDIS_SET_MSG;
    6896:	85 e0       	ldi	r24, 0x05	; 5
    6898:	90 e0       	ldi	r25, 0x00	; 0
    689a:	a0 e0       	ldi	r26, 0x00	; 0
    689c:	b0 e0       	ldi	r27, 0x00	; 0
    689e:	ed b7       	in	r30, 0x3d	; 61
    68a0:	fe b7       	in	r31, 0x3e	; 62
    68a2:	81 83       	std	Z+1, r24	; 0x01
    68a4:	92 83       	std	Z+2, r25	; 0x02
    68a6:	a3 83       	std	Z+3, r26	; 0x03
    68a8:	b4 83       	std	Z+4, r27	; 0x04
	SetMessageData.SetMessage.MessageLength  = sizeof(RNDIS_Set_Message_t) + Length;
    68aa:	ee 24       	eor	r14, r14
    68ac:	ff 24       	eor	r15, r15
    68ae:	f5 01       	movw	r30, r10
    68b0:	c4 82       	std	Z+4, r12	; 0x04
    68b2:	d5 82       	std	Z+5, r13	; 0x05
    68b4:	e6 82       	std	Z+6, r14	; 0x06
    68b6:	f7 82       	std	Z+7, r15	; 0x07
	SetMessageData.SetMessage.RequestId      = RNDISInterfaceInfo->State.RequestID++;
    68b8:	f4 01       	movw	r30, r8
    68ba:	86 89       	ldd	r24, Z+22	; 0x16
    68bc:	97 89       	ldd	r25, Z+23	; 0x17
    68be:	a0 8d       	ldd	r26, Z+24	; 0x18
    68c0:	b1 8d       	ldd	r27, Z+25	; 0x19
    68c2:	f5 01       	movw	r30, r10
    68c4:	80 87       	std	Z+8, r24	; 0x08
    68c6:	91 87       	std	Z+9, r25	; 0x09
    68c8:	a2 87       	std	Z+10, r26	; 0x0a
    68ca:	b3 87       	std	Z+11, r27	; 0x0b
    68cc:	01 96       	adiw	r24, 0x01	; 1
    68ce:	a1 1d       	adc	r26, r1
    68d0:	b1 1d       	adc	r27, r1
    68d2:	f4 01       	movw	r30, r8
    68d4:	86 8b       	std	Z+22, r24	; 0x16
    68d6:	97 8b       	std	Z+23, r25	; 0x17
    68d8:	a0 8f       	std	Z+24, r26	; 0x18
    68da:	b1 8f       	std	Z+25, r27	; 0x19

	SetMessageData.SetMessage.Oid            = Oid;
    68dc:	f5 01       	movw	r30, r10
    68de:	44 87       	std	Z+12, r20	; 0x0c
    68e0:	55 87       	std	Z+13, r21	; 0x0d
    68e2:	66 87       	std	Z+14, r22	; 0x0e
    68e4:	77 87       	std	Z+15, r23	; 0x0f
	SetMessageData.SetMessage.InformationBufferLength = Length;
    68e6:	c8 01       	movw	r24, r16
    68e8:	a0 e0       	ldi	r26, 0x00	; 0
    68ea:	b0 e0       	ldi	r27, 0x00	; 0
    68ec:	80 8b       	std	Z+16, r24	; 0x10
    68ee:	91 8b       	std	Z+17, r25	; 0x11
    68f0:	a2 8b       	std	Z+18, r26	; 0x12
    68f2:	b3 8b       	std	Z+19, r27	; 0x13
	SetMessageData.SetMessage.InformationBufferOffset = (sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Message_Header_t));
    68f4:	84 e1       	ldi	r24, 0x14	; 20
    68f6:	90 e0       	ldi	r25, 0x00	; 0
    68f8:	a0 e0       	ldi	r26, 0x00	; 0
    68fa:	b0 e0       	ldi	r27, 0x00	; 0
    68fc:	84 8b       	std	Z+20, r24	; 0x14
    68fe:	95 8b       	std	Z+21, r25	; 0x15
    6900:	a6 8b       	std	Z+22, r26	; 0x16
    6902:	b7 8b       	std	Z+23, r27	; 0x17
	SetMessageData.SetMessage.DeviceVcHandle = 0;
    6904:	10 8e       	std	Z+24, r1	; 0x18
    6906:	11 8e       	std	Z+25, r1	; 0x19
    6908:	12 8e       	std	Z+26, r1	; 0x1a
    690a:	13 8e       	std	Z+27, r1	; 0x1b

	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
    690c:	4d b7       	in	r20, 0x3d	; 61
    690e:	5e b7       	in	r21, 0x3e	; 62
    6910:	43 5e       	subi	r20, 0xE3	; 227
    6912:	5f 4f       	sbci	r21, 0xFF	; 255
    6914:	ca 01       	movw	r24, r20
    6916:	b9 01       	movw	r22, r18
    6918:	a8 01       	movw	r20, r16
    691a:	29 d2       	rcall	.+1106   	; 0x6d6e <memcpy>

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &SetMessageData,
    691c:	f5 01       	movw	r30, r10
    691e:	44 81       	ldd	r20, Z+4	; 0x04
    6920:	55 81       	ldd	r21, Z+5	; 0x05
    6922:	c4 01       	movw	r24, r8
    6924:	b5 01       	movw	r22, r10
    6926:	ba de       	rcall	.-652    	; 0x669c <RNDIS_SendEncapsulatedCommand>
    6928:	28 2f       	mov	r18, r24
    692a:	88 23       	and	r24, r24
    692c:	99 f4       	brne	.+38     	; 0x6954 <RNDIS_Host_SetRNDISProperty+0x116>
	                                               SetMessageData.SetMessage.MessageLength)) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &SetMessageResponse,
    692e:	c4 01       	movw	r24, r8
    6930:	be 01       	movw	r22, r28
    6932:	6f 5f       	subi	r22, 0xFF	; 255
    6934:	7f 4f       	sbci	r23, 0xFF	; 255
    6936:	40 e1       	ldi	r20, 0x10	; 16
    6938:	50 e0       	ldi	r21, 0x00	; 0
    693a:	c7 de       	rcall	.-626    	; 0x66ca <RNDIS_GetEncapsulatedResponse>
    693c:	28 2f       	mov	r18, r24
    693e:	88 23       	and	r24, r24
    6940:	49 f4       	brne	.+18     	; 0x6954 <RNDIS_Host_SetRNDISProperty+0x116>
	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
    6942:	8d 85       	ldd	r24, Y+13	; 0x0d
    6944:	9e 85       	ldd	r25, Y+14	; 0x0e
    6946:	af 85       	ldd	r26, Y+15	; 0x0f
    6948:	b8 89       	ldd	r27, Y+16	; 0x10
    694a:	00 97       	sbiw	r24, 0x00	; 0
    694c:	a1 05       	cpc	r26, r1
    694e:	b1 05       	cpc	r27, r1
    6950:	09 f0       	breq	.+2      	; 0x6954 <RNDIS_Host_SetRNDISProperty+0x116>
    6952:	20 ec       	ldi	r18, 0xC0	; 192
	  return RNDIS_COMMAND_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    6954:	82 2f       	mov	r24, r18
    6956:	0f b6       	in	r0, 0x3f	; 63
    6958:	f8 94       	cli
    695a:	7e be       	out	0x3e, r7	; 62
    695c:	0f be       	out	0x3f, r0	; 63
    695e:	6d be       	out	0x3d, r6	; 61
    6960:	60 96       	adiw	r28, 0x10	; 16
    6962:	0f b6       	in	r0, 0x3f	; 63
    6964:	f8 94       	cli
    6966:	de bf       	out	0x3e, r29	; 62
    6968:	0f be       	out	0x3f, r0	; 63
    696a:	cd bf       	out	0x3d, r28	; 61
    696c:	cf 91       	pop	r28
    696e:	df 91       	pop	r29
    6970:	1f 91       	pop	r17
    6972:	0f 91       	pop	r16
    6974:	ff 90       	pop	r15
    6976:	ef 90       	pop	r14
    6978:	df 90       	pop	r13
    697a:	cf 90       	pop	r12
    697c:	bf 90       	pop	r11
    697e:	af 90       	pop	r10
    6980:	9f 90       	pop	r9
    6982:	8f 90       	pop	r8
    6984:	7f 90       	pop	r7
    6986:	6f 90       	pop	r6
    6988:	08 95       	ret

0000698a <RNDIS_Host_InitializeDevice>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t RNDIS_Host_InitializeDevice(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    698a:	0f 93       	push	r16
    698c:	1f 93       	push	r17
    698e:	df 93       	push	r29
    6990:	cf 93       	push	r28
    6992:	cd b7       	in	r28, 0x3d	; 61
    6994:	de b7       	in	r29, 0x3e	; 62
    6996:	cc 54       	subi	r28, 0x4C	; 76
    6998:	d0 40       	sbci	r29, 0x00	; 0
    699a:	0f b6       	in	r0, 0x3f	; 63
    699c:	f8 94       	cli
    699e:	de bf       	out	0x3e, r29	; 62
    69a0:	0f be       	out	0x3f, r0	; 63
    69a2:	cd bf       	out	0x3d, r28	; 61
    69a4:	8c 01       	movw	r16, r24
	uint8_t ErrorCode;

	RNDIS_Initialize_Message_t  InitMessage;
	RNDIS_Initialize_Complete_t InitMessageResponse;

	InitMessage.MessageType     = REMOTE_NDIS_INITIALIZE_MSG;
    69a6:	82 e0       	ldi	r24, 0x02	; 2
    69a8:	90 e0       	ldi	r25, 0x00	; 0
    69aa:	a0 e0       	ldi	r26, 0x00	; 0
    69ac:	b0 e0       	ldi	r27, 0x00	; 0
    69ae:	89 83       	std	Y+1, r24	; 0x01
    69b0:	9a 83       	std	Y+2, r25	; 0x02
    69b2:	ab 83       	std	Y+3, r26	; 0x03
    69b4:	bc 83       	std	Y+4, r27	; 0x04
	InitMessage.MessageLength   = sizeof(RNDIS_Initialize_Message_t);
    69b6:	88 e1       	ldi	r24, 0x18	; 24
    69b8:	90 e0       	ldi	r25, 0x00	; 0
    69ba:	a0 e0       	ldi	r26, 0x00	; 0
    69bc:	b0 e0       	ldi	r27, 0x00	; 0
    69be:	8d 83       	std	Y+5, r24	; 0x05
    69c0:	9e 83       	std	Y+6, r25	; 0x06
    69c2:	af 83       	std	Y+7, r26	; 0x07
    69c4:	b8 87       	std	Y+8, r27	; 0x08
	InitMessage.RequestId       = RNDISInterfaceInfo->State.RequestID++;
    69c6:	f8 01       	movw	r30, r16
    69c8:	86 89       	ldd	r24, Z+22	; 0x16
    69ca:	97 89       	ldd	r25, Z+23	; 0x17
    69cc:	a0 8d       	ldd	r26, Z+24	; 0x18
    69ce:	b1 8d       	ldd	r27, Z+25	; 0x19
    69d0:	89 87       	std	Y+9, r24	; 0x09
    69d2:	9a 87       	std	Y+10, r25	; 0x0a
    69d4:	ab 87       	std	Y+11, r26	; 0x0b
    69d6:	bc 87       	std	Y+12, r27	; 0x0c
    69d8:	01 96       	adiw	r24, 0x01	; 1
    69da:	a1 1d       	adc	r26, r1
    69dc:	b1 1d       	adc	r27, r1
    69de:	86 8b       	std	Z+22, r24	; 0x16
    69e0:	97 8b       	std	Z+23, r25	; 0x17
    69e2:	a0 8f       	std	Z+24, r26	; 0x18
    69e4:	b1 8f       	std	Z+25, r27	; 0x19

	InitMessage.MajorVersion    = REMOTE_NDIS_VERSION_MAJOR;
    69e6:	81 e0       	ldi	r24, 0x01	; 1
    69e8:	90 e0       	ldi	r25, 0x00	; 0
    69ea:	a0 e0       	ldi	r26, 0x00	; 0
    69ec:	b0 e0       	ldi	r27, 0x00	; 0
    69ee:	8d 87       	std	Y+13, r24	; 0x0d
    69f0:	9e 87       	std	Y+14, r25	; 0x0e
    69f2:	af 87       	std	Y+15, r26	; 0x0f
    69f4:	b8 8b       	std	Y+16, r27	; 0x10
	InitMessage.MinorVersion    = REMOTE_NDIS_VERSION_MINOR;
    69f6:	19 8a       	std	Y+17, r1	; 0x11
    69f8:	1a 8a       	std	Y+18, r1	; 0x12
    69fa:	1b 8a       	std	Y+19, r1	; 0x13
    69fc:	1c 8a       	std	Y+20, r1	; 0x14
	InitMessage.MaxTransferSize = RNDISInterfaceInfo->Config.HostMaxPacketSize;
    69fe:	86 81       	ldd	r24, Z+6	; 0x06
    6a00:	97 81       	ldd	r25, Z+7	; 0x07
    6a02:	a0 85       	ldd	r26, Z+8	; 0x08
    6a04:	b1 85       	ldd	r27, Z+9	; 0x09
    6a06:	8d 8b       	std	Y+21, r24	; 0x15
    6a08:	9e 8b       	std	Y+22, r25	; 0x16
    6a0a:	af 8b       	std	Y+23, r26	; 0x17
    6a0c:	b8 8f       	std	Y+24, r27	; 0x18

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &InitMessage,
    6a0e:	c8 01       	movw	r24, r16
    6a10:	be 01       	movw	r22, r28
    6a12:	6f 5f       	subi	r22, 0xFF	; 255
    6a14:	7f 4f       	sbci	r23, 0xFF	; 255
    6a16:	48 e1       	ldi	r20, 0x18	; 24
    6a18:	50 e0       	ldi	r21, 0x00	; 0
    6a1a:	40 de       	rcall	.-896    	; 0x669c <RNDIS_SendEncapsulatedCommand>
    6a1c:	28 2f       	mov	r18, r24
    6a1e:	88 23       	and	r24, r24
    6a20:	f9 f4       	brne	.+62     	; 0x6a60 <RNDIS_Host_InitializeDevice+0xd6>
	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &InitMessageResponse,
    6a22:	c8 01       	movw	r24, r16
    6a24:	be 01       	movw	r22, r28
    6a26:	67 5e       	subi	r22, 0xE7	; 231
    6a28:	7f 4f       	sbci	r23, 0xFF	; 255
    6a2a:	44 e3       	ldi	r20, 0x34	; 52
    6a2c:	50 e0       	ldi	r21, 0x00	; 0
    6a2e:	4d de       	rcall	.-870    	; 0x66ca <RNDIS_GetEncapsulatedResponse>
    6a30:	28 2f       	mov	r18, r24
    6a32:	88 23       	and	r24, r24
    6a34:	a9 f4       	brne	.+42     	; 0x6a60 <RNDIS_Host_InitializeDevice+0xd6>
	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
    6a36:	8d a1       	ldd	r24, Y+37	; 0x25
    6a38:	9e a1       	ldd	r25, Y+38	; 0x26
    6a3a:	af a1       	ldd	r26, Y+39	; 0x27
    6a3c:	b8 a5       	ldd	r27, Y+40	; 0x28
    6a3e:	00 97       	sbiw	r24, 0x00	; 0
    6a40:	a1 05       	cpc	r26, r1
    6a42:	b1 05       	cpc	r27, r1
    6a44:	11 f0       	breq	.+4      	; 0x6a4a <RNDIS_Host_InitializeDevice+0xc0>
    6a46:	20 ec       	ldi	r18, 0xC0	; 192
    6a48:	0b c0       	rjmp	.+22     	; 0x6a60 <RNDIS_Host_InitializeDevice+0xd6>
	  return RNDIS_COMMAND_FAILED;

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = InitMessageResponse.MaxTransferSize;
    6a4a:	fe 01       	movw	r30, r28
    6a4c:	fd 96       	adiw	r30, 0x3d	; 61
    6a4e:	80 81       	ld	r24, Z
    6a50:	91 81       	ldd	r25, Z+1	; 0x01
    6a52:	a2 81       	ldd	r26, Z+2	; 0x02
    6a54:	b3 81       	ldd	r27, Z+3	; 0x03
    6a56:	f8 01       	movw	r30, r16
    6a58:	82 8b       	std	Z+18, r24	; 0x12
    6a5a:	93 8b       	std	Z+19, r25	; 0x13
    6a5c:	a4 8b       	std	Z+20, r26	; 0x14
    6a5e:	b5 8b       	std	Z+21, r27	; 0x15

	return HOST_SENDCONTROL_Successful;
}
    6a60:	82 2f       	mov	r24, r18
    6a62:	c4 5b       	subi	r28, 0xB4	; 180
    6a64:	df 4f       	sbci	r29, 0xFF	; 255
    6a66:	0f b6       	in	r0, 0x3f	; 63
    6a68:	f8 94       	cli
    6a6a:	de bf       	out	0x3e, r29	; 62
    6a6c:	0f be       	out	0x3f, r0	; 63
    6a6e:	cd bf       	out	0x3d, r28	; 61
    6a70:	cf 91       	pop	r28
    6a72:	df 91       	pop	r29
    6a74:	1f 91       	pop	r17
    6a76:	0f 91       	pop	r16
    6a78:	08 95       	ret

00006a7a <RNDIS_Host_ConfigurePipes>:
#include "RNDIS.h"

uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
    6a7a:	4f 92       	push	r4
    6a7c:	5f 92       	push	r5
    6a7e:	6f 92       	push	r6
    6a80:	7f 92       	push	r7
    6a82:	8f 92       	push	r8
    6a84:	9f 92       	push	r9
    6a86:	af 92       	push	r10
    6a88:	bf 92       	push	r11
    6a8a:	cf 92       	push	r12
    6a8c:	df 92       	push	r13
    6a8e:	ef 92       	push	r14
    6a90:	ff 92       	push	r15
    6a92:	0f 93       	push	r16
    6a94:	1f 93       	push	r17
    6a96:	df 93       	push	r29
    6a98:	cf 93       	push	r28
    6a9a:	00 d0       	rcall	.+0      	; 0x6a9c <RNDIS_Host_ConfigurePipes+0x22>
    6a9c:	00 d0       	rcall	.+0      	; 0x6a9e <RNDIS_Host_ConfigurePipes+0x24>
    6a9e:	cd b7       	in	r28, 0x3d	; 61
    6aa0:	de b7       	in	r29, 0x3e	; 62
    6aa2:	6c 01       	movw	r12, r24
    6aa4:	7a 83       	std	Y+2, r23	; 0x02
    6aa6:	69 83       	std	Y+1, r22	; 0x01
    6aa8:	5c 83       	std	Y+4, r21	; 0x04
    6aaa:	4b 83       	std	Y+3, r20	; 0x03
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
	USB_Descriptor_Endpoint_t*  NotificationEndpoint  = NULL;
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    6aac:	0a 96       	adiw	r24, 0x0a	; 10
    6aae:	fc 01       	movw	r30, r24
    6ab0:	80 e1       	ldi	r24, 0x10	; 16
    6ab2:	df 01       	movw	r26, r30
    6ab4:	1d 92       	st	X+, r1
    6ab6:	8a 95       	dec	r24
    6ab8:	e9 f7       	brne	.-6      	; 0x6ab4 <RNDIS_Host_ConfigurePipes+0x3a>

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
    6aba:	eb 81       	ldd	r30, Y+3	; 0x03
    6abc:	fc 81       	ldd	r31, Y+4	; 0x04
    6abe:	81 81       	ldd	r24, Z+1	; 0x01
    6ac0:	82 30       	cpi	r24, 0x02	; 2
    6ac2:	11 f0       	breq	.+4      	; 0x6ac8 <RNDIS_Host_ConfigurePipes+0x4e>
    6ac4:	81 e0       	ldi	r24, 0x01	; 1
    6ac6:	c6 c0       	rjmp	.+396    	; 0x6c54 <RNDIS_Host_ConfigurePipes+0x1da>
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    6ac8:	2f 01       	movw	r4, r30
    6aca:	66 24       	eor	r6, r6
    6acc:	77 24       	eor	r7, r7
    6ace:	aa 24       	eor	r10, r10
    6ad0:	bb 24       	eor	r11, r11
    6ad2:	88 24       	eor	r8, r8
    6ad4:	99 24       	eor	r9, r9

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    6ad6:	f3 e0       	ldi	r31, 0x03	; 3
    6ad8:	ef 2e       	mov	r14, r31
    6ada:	f1 2c       	mov	r15, r1
    6adc:	ec 0e       	add	r14, r28
    6ade:	fd 1e       	adc	r15, r29
    6ae0:	8e 01       	movw	r16, r28
    6ae2:	0f 5f       	subi	r16, 0xFF	; 255
    6ae4:	1f 4f       	sbci	r17, 0xFF	; 255
    6ae6:	04 c0       	rjmp	.+8      	; 0x6af0 <RNDIS_Host_ConfigurePipes+0x76>
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    6ae8:	88 24       	eor	r8, r8
    6aea:	99 24       	eor	r9, r9
    6aec:	66 24       	eor	r6, r6
    6aee:	77 24       	eor	r7, r7

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    6af0:	41 14       	cp	r4, r1
    6af2:	51 04       	cpc	r5, r1
    6af4:	41 f0       	breq	.+16     	; 0x6b06 <RNDIS_Host_ConfigurePipes+0x8c>
    6af6:	c8 01       	movw	r24, r16
    6af8:	b7 01       	movw	r22, r14
    6afa:	4f e3       	ldi	r20, 0x3F	; 63
    6afc:	56 e3       	ldi	r21, 0x36	; 54
    6afe:	0e 94 3a 29 	call	0x5274	; 0x5274 <USB_GetNextDescriptorComp>
    6b02:	88 23       	and	r24, r24
    6b04:	c1 f0       	breq	.+48     	; 0x6b36 <RNDIS_Host_ConfigurePipes+0xbc>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
    6b06:	a1 14       	cp	r10, r1
    6b08:	b1 04       	cpc	r11, r1
    6b0a:	49 f0       	breq	.+18     	; 0x6b1e <RNDIS_Host_ConfigurePipes+0xa4>
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    6b0c:	c8 01       	movw	r24, r16
    6b0e:	b7 01       	movw	r22, r14
    6b10:	42 e3       	ldi	r20, 0x32	; 50
    6b12:	52 e3       	ldi	r21, 0x32	; 50
    6b14:	0e 94 3a 29 	call	0x5274	; 0x5274 <USB_GetNextDescriptorComp>
    6b18:	88 23       	and	r24, r24
    6b1a:	31 f3       	breq	.-52     	; 0x6ae8 <RNDIS_Host_ConfigurePipes+0x6e>
    6b1c:	9a c0       	rjmp	.+308    	; 0x6c52 <RNDIS_Host_ConfigurePipes+0x1d8>
				DataINEndpoint  = NULL;
				DataOUTEndpoint = NULL;
			}
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    6b1e:	c8 01       	movw	r24, r16
    6b20:	b7 01       	movw	r22, r14
    6b22:	41 e2       	ldi	r20, 0x21	; 33
    6b24:	52 e3       	ldi	r21, 0x32	; 50
    6b26:	0e 94 3a 29 	call	0x5274	; 0x5274 <USB_GetNextDescriptorComp>
    6b2a:	88 23       	and	r24, r24
    6b2c:	09 f0       	breq	.+2      	; 0x6b30 <RNDIS_Host_ConfigurePipes+0xb6>
    6b2e:	91 c0       	rjmp	.+290    	; 0x6c52 <RNDIS_Host_ConfigurePipes+0x1d8>
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    6b30:	4b 80       	ldd	r4, Y+3	; 0x03
    6b32:	5c 80       	ldd	r5, Y+4	; 0x04
    6b34:	0e c0       	rjmp	.+28     	; 0x6b52 <RNDIS_Host_ConfigurePipes+0xd8>
			}

			continue;
		}

		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Endpoint_t);
    6b36:	eb 81       	ldd	r30, Y+3	; 0x03
    6b38:	fc 81       	ldd	r31, Y+4	; 0x04

		if (EndpointData->EndpointAddress & ENDPOINT_DESCRIPTOR_DIR_IN)
    6b3a:	82 81       	ldd	r24, Z+2	; 0x02
    6b3c:	87 fd       	sbrc	r24, 7
    6b3e:	02 c0       	rjmp	.+4      	; 0x6b44 <RNDIS_Host_ConfigurePipes+0xca>
    6b40:	3f 01       	movw	r6, r30
    6b42:	07 c0       	rjmp	.+14     	; 0x6b52 <RNDIS_Host_ConfigurePipes+0xd8>
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
    6b44:	83 81       	ldd	r24, Z+3	; 0x03
    6b46:	83 70       	andi	r24, 0x03	; 3
    6b48:	83 30       	cpi	r24, 0x03	; 3
    6b4a:	11 f0       	breq	.+4      	; 0x6b50 <RNDIS_Host_ConfigurePipes+0xd6>
    6b4c:	4f 01       	movw	r8, r30
    6b4e:	01 c0       	rjmp	.+2      	; 0x6b52 <RNDIS_Host_ConfigurePipes+0xd8>
    6b50:	5f 01       	movw	r10, r30
	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
    6b52:	81 14       	cp	r8, r1
    6b54:	91 04       	cpc	r9, r1
    6b56:	61 f2       	breq	.-104    	; 0x6af0 <RNDIS_Host_ConfigurePipes+0x76>
    6b58:	61 14       	cp	r6, r1
    6b5a:	71 04       	cpc	r7, r1
    6b5c:	49 f2       	breq	.-110    	; 0x6af0 <RNDIS_Host_ConfigurePipes+0x76>
    6b5e:	a1 14       	cp	r10, r1
    6b60:	b1 04       	cpc	r11, r1
    6b62:	31 f2       	breq	.-116    	; 0x6af0 <RNDIS_Host_ConfigurePipes+0x76>
    6b64:	ff 24       	eor	r15, r15
    6b66:	f3 94       	inc	r15
		}
	}

	for (uint8_t PipeNum = 1; PipeNum < PIPE_TOTAL_PIPES; PipeNum++)
	{
		if (PipeNum == RNDISInterfaceInfo->Config.DataINPipeNumber)
    6b68:	f6 01       	movw	r30, r12
    6b6a:	80 81       	ld	r24, Z
    6b6c:	f8 16       	cp	r15, r24
    6b6e:	e9 f4       	brne	.+58     	; 0x6baa <RNDIS_Host_ConfigurePipes+0x130>
		{
			Pipe_ConfigurePipe(PipeNum, EP_TYPE_BULK, PIPE_TOKEN_IN,
    6b70:	d4 01       	movw	r26, r8
    6b72:	12 96       	adiw	r26, 0x02	; 2
    6b74:	2c 91       	ld	r18, X
    6b76:	12 97       	sbiw	r26, 0x02	; 2
    6b78:	14 96       	adiw	r26, 0x04	; 4
    6b7a:	0d 91       	ld	r16, X+
    6b7c:	1c 91       	ld	r17, X
    6b7e:	15 97       	sbiw	r26, 0x05	; 5
    6b80:	81 81       	ldd	r24, Z+1	; 0x01
    6b82:	88 23       	and	r24, r24
    6b84:	11 f4       	brne	.+4      	; 0x6b8a <RNDIS_Host_ConfigurePipes+0x110>
    6b86:	90 e0       	ldi	r25, 0x00	; 0
    6b88:	01 c0       	rjmp	.+2      	; 0x6b8c <RNDIS_Host_ConfigurePipes+0x112>
    6b8a:	94 e0       	ldi	r25, 0x04	; 4
    6b8c:	8f 2d       	mov	r24, r15
    6b8e:	62 e0       	ldi	r22, 0x02	; 2
    6b90:	40 e1       	ldi	r20, 0x10	; 16
    6b92:	e9 2e       	mov	r14, r25
    6b94:	0e 94 12 26 	call	0x4c24	; 0x4c24 <Pipe_ConfigurePipe>
			                   DataINEndpoint->EndpointAddress, DataINEndpoint->EndpointSize,
			                   RNDISInterfaceInfo->Config.DataINPipeDoubleBank ? PIPE_BANK_DOUBLE : PIPE_BANK_SINGLE);

			RNDISInterfaceInfo->State.DataINPipeSize = DataINEndpoint->EndpointSize;
    6b98:	f4 01       	movw	r30, r8
    6b9a:	84 81       	ldd	r24, Z+4	; 0x04
    6b9c:	95 81       	ldd	r25, Z+5	; 0x05
    6b9e:	d6 01       	movw	r26, r12
    6ba0:	1d 96       	adiw	r26, 0x0d	; 13
    6ba2:	9c 93       	st	X, r25
    6ba4:	8e 93       	st	-X, r24
    6ba6:	1c 97       	sbiw	r26, 0x0c	; 12
    6ba8:	44 c0       	rjmp	.+136    	; 0x6c32 <RNDIS_Host_ConfigurePipes+0x1b8>
		}
		else if (PipeNum == RNDISInterfaceInfo->Config.DataOUTPipeNumber)
    6baa:	f6 01       	movw	r30, r12
    6bac:	82 81       	ldd	r24, Z+2	; 0x02
    6bae:	f8 16       	cp	r15, r24
    6bb0:	e9 f4       	brne	.+58     	; 0x6bec <RNDIS_Host_ConfigurePipes+0x172>
		{
			Pipe_ConfigurePipe(PipeNum, EP_TYPE_BULK, PIPE_TOKEN_OUT,
    6bb2:	d3 01       	movw	r26, r6
    6bb4:	12 96       	adiw	r26, 0x02	; 2
    6bb6:	2c 91       	ld	r18, X
    6bb8:	12 97       	sbiw	r26, 0x02	; 2
    6bba:	14 96       	adiw	r26, 0x04	; 4
    6bbc:	0d 91       	ld	r16, X+
    6bbe:	1c 91       	ld	r17, X
    6bc0:	15 97       	sbiw	r26, 0x05	; 5
    6bc2:	83 81       	ldd	r24, Z+3	; 0x03
    6bc4:	88 23       	and	r24, r24
    6bc6:	11 f4       	brne	.+4      	; 0x6bcc <RNDIS_Host_ConfigurePipes+0x152>
    6bc8:	90 e0       	ldi	r25, 0x00	; 0
    6bca:	01 c0       	rjmp	.+2      	; 0x6bce <RNDIS_Host_ConfigurePipes+0x154>
    6bcc:	94 e0       	ldi	r25, 0x04	; 4
    6bce:	8f 2d       	mov	r24, r15
    6bd0:	62 e0       	ldi	r22, 0x02	; 2
    6bd2:	40 e2       	ldi	r20, 0x20	; 32
    6bd4:	e9 2e       	mov	r14, r25
    6bd6:	0e 94 12 26 	call	0x4c24	; 0x4c24 <Pipe_ConfigurePipe>
			                   DataOUTEndpoint->EndpointAddress, DataOUTEndpoint->EndpointSize,
			                   RNDISInterfaceInfo->Config.DataOUTPipeDoubleBank ? PIPE_BANK_DOUBLE : PIPE_BANK_SINGLE);

			RNDISInterfaceInfo->State.DataOUTPipeSize = DataOUTEndpoint->EndpointSize;
    6bda:	f3 01       	movw	r30, r6
    6bdc:	84 81       	ldd	r24, Z+4	; 0x04
    6bde:	95 81       	ldd	r25, Z+5	; 0x05
    6be0:	d6 01       	movw	r26, r12
    6be2:	1f 96       	adiw	r26, 0x0f	; 15
    6be4:	9c 93       	st	X, r25
    6be6:	8e 93       	st	-X, r24
    6be8:	1e 97       	sbiw	r26, 0x0e	; 14
    6bea:	23 c0       	rjmp	.+70     	; 0x6c32 <RNDIS_Host_ConfigurePipes+0x1b8>
		}
		else if (PipeNum == RNDISInterfaceInfo->Config.NotificationPipeNumber)
    6bec:	f6 01       	movw	r30, r12
    6bee:	84 81       	ldd	r24, Z+4	; 0x04
    6bf0:	f8 16       	cp	r15, r24
    6bf2:	f9 f4       	brne	.+62     	; 0x6c32 <RNDIS_Host_ConfigurePipes+0x1b8>
		{
			Pipe_ConfigurePipe(PipeNum, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,
    6bf4:	d5 01       	movw	r26, r10
    6bf6:	12 96       	adiw	r26, 0x02	; 2
    6bf8:	2c 91       	ld	r18, X
    6bfa:	12 97       	sbiw	r26, 0x02	; 2
    6bfc:	14 96       	adiw	r26, 0x04	; 4
    6bfe:	0d 91       	ld	r16, X+
    6c00:	1c 91       	ld	r17, X
    6c02:	15 97       	sbiw	r26, 0x05	; 5
    6c04:	85 81       	ldd	r24, Z+5	; 0x05
    6c06:	88 23       	and	r24, r24
    6c08:	11 f4       	brne	.+4      	; 0x6c0e <RNDIS_Host_ConfigurePipes+0x194>
    6c0a:	90 e0       	ldi	r25, 0x00	; 0
    6c0c:	01 c0       	rjmp	.+2      	; 0x6c10 <RNDIS_Host_ConfigurePipes+0x196>
    6c0e:	94 e0       	ldi	r25, 0x04	; 4
    6c10:	8f 2d       	mov	r24, r15
    6c12:	63 e0       	ldi	r22, 0x03	; 3
    6c14:	40 e1       	ldi	r20, 0x10	; 16
    6c16:	e9 2e       	mov	r14, r25
    6c18:	0e 94 12 26 	call	0x4c24	; 0x4c24 <Pipe_ConfigurePipe>
			                   NotificationEndpoint->EndpointAddress, NotificationEndpoint->EndpointSize,
			                   RNDISInterfaceInfo->Config.NotificationPipeDoubleBank ? PIPE_BANK_DOUBLE : PIPE_BANK_SINGLE);
			Pipe_SetInterruptPeriod(NotificationEndpoint->PollingIntervalMS);
    6c1c:	f5 01       	movw	r30, r10
    6c1e:	86 81       	ldd	r24, Z+6	; 0x06
			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
			 */
			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
			{
				UPCFG2X = Milliseconds;
    6c20:	80 93 ad 00 	sts	0x00AD, r24

			RNDISInterfaceInfo->State.NotificationPipeSize = NotificationEndpoint->EndpointSize;
    6c24:	84 81       	ldd	r24, Z+4	; 0x04
    6c26:	95 81       	ldd	r25, Z+5	; 0x05
    6c28:	d6 01       	movw	r26, r12
    6c2a:	51 96       	adiw	r26, 0x11	; 17
    6c2c:	9c 93       	st	X, r25
    6c2e:	8e 93       	st	-X, r24
    6c30:	50 97       	sbiw	r26, 0x10	; 16
		{
			DataOUTEndpoint = EndpointData;
		}
	}

	for (uint8_t PipeNum = 1; PipeNum < PIPE_TOTAL_PIPES; PipeNum++)
    6c32:	f3 94       	inc	r15
    6c34:	b7 e0       	ldi	r27, 0x07	; 7
    6c36:	fb 16       	cp	r15, r27
    6c38:	09 f0       	breq	.+2      	; 0x6c3c <RNDIS_Host_ConfigurePipes+0x1c2>
    6c3a:	96 cf       	rjmp	.-212    	; 0x6b68 <RNDIS_Host_ConfigurePipes+0xee>

			RNDISInterfaceInfo->State.NotificationPipeSize = NotificationEndpoint->EndpointSize;
		}
	}

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
    6c3c:	f2 01       	movw	r30, r4
    6c3e:	82 81       	ldd	r24, Z+2	; 0x02
    6c40:	d6 01       	movw	r26, r12
    6c42:	1b 96       	adiw	r26, 0x0b	; 11
    6c44:	8c 93       	st	X, r24
    6c46:	1b 97       	sbiw	r26, 0x0b	; 11
	RNDISInterfaceInfo->State.IsActive = true;
    6c48:	81 e0       	ldi	r24, 0x01	; 1
    6c4a:	1a 96       	adiw	r26, 0x0a	; 10
    6c4c:	8c 93       	st	X, r24
    6c4e:	80 e0       	ldi	r24, 0x00	; 0
    6c50:	01 c0       	rjmp	.+2      	; 0x6c54 <RNDIS_Host_ConfigurePipes+0x1da>

	return RNDIS_ENUMERROR_NoError;
    6c52:	82 e0       	ldi	r24, 0x02	; 2
}
    6c54:	0f 90       	pop	r0
    6c56:	0f 90       	pop	r0
    6c58:	0f 90       	pop	r0
    6c5a:	0f 90       	pop	r0
    6c5c:	cf 91       	pop	r28
    6c5e:	df 91       	pop	r29
    6c60:	1f 91       	pop	r17
    6c62:	0f 91       	pop	r16
    6c64:	ff 90       	pop	r15
    6c66:	ef 90       	pop	r14
    6c68:	df 90       	pop	r13
    6c6a:	cf 90       	pop	r12
    6c6c:	bf 90       	pop	r11
    6c6e:	af 90       	pop	r10
    6c70:	9f 90       	pop	r9
    6c72:	8f 90       	pop	r8
    6c74:	7f 90       	pop	r7
    6c76:	6f 90       	pop	r6
    6c78:	5f 90       	pop	r5
    6c7a:	4f 90       	pop	r4
    6c7c:	08 95       	ret

00006c7e <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint>:

	return DESCRIPTOR_SEARCH_NotFound;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint(void* const CurrentDescriptor)
{
    6c7e:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Endpoint)
    6c80:	81 81       	ldd	r24, Z+1	; 0x01
    6c82:	85 30       	cpi	r24, 0x05	; 5
    6c84:	59 f4       	brne	.+22     	; 0x6c9c <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1e>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    6c86:	83 81       	ldd	r24, Z+3	; 0x03
    6c88:	83 70       	andi	r24, 0x03	; 3
    6c8a:	82 50       	subi	r24, 0x02	; 2
    6c8c:	82 30       	cpi	r24, 0x02	; 2
    6c8e:	50 f4       	brcc	.+20     	; 0x6ca4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    6c90:	82 81       	ldd	r24, Z+2	; 0x02
    6c92:	0e 94 5c 26 	call	0x4cb8	; 0x4cb8 <Pipe_IsEndpointBound>
    6c96:	88 23       	and	r24, r24
    6c98:	29 f4       	brne	.+10     	; 0x6ca4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    6c9a:	08 95       	ret
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	else if (Header->Type == DTYPE_Interface)
    6c9c:	84 30       	cpi	r24, 0x04	; 4
    6c9e:	11 f4       	brne	.+4      	; 0x6ca4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    6ca0:	81 e0       	ldi	r24, 0x01	; 1
    6ca2:	08 95       	ret
    6ca4:	82 e0       	ldi	r24, 0x02	; 2
	{
		return DESCRIPTOR_SEARCH_Fail;
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    6ca6:	08 95       	ret

00006ca8 <__mulsi3>:
    6ca8:	62 9f       	mul	r22, r18
    6caa:	d0 01       	movw	r26, r0
    6cac:	73 9f       	mul	r23, r19
    6cae:	f0 01       	movw	r30, r0
    6cb0:	82 9f       	mul	r24, r18
    6cb2:	e0 0d       	add	r30, r0
    6cb4:	f1 1d       	adc	r31, r1
    6cb6:	64 9f       	mul	r22, r20
    6cb8:	e0 0d       	add	r30, r0
    6cba:	f1 1d       	adc	r31, r1
    6cbc:	92 9f       	mul	r25, r18
    6cbe:	f0 0d       	add	r31, r0
    6cc0:	83 9f       	mul	r24, r19
    6cc2:	f0 0d       	add	r31, r0
    6cc4:	74 9f       	mul	r23, r20
    6cc6:	f0 0d       	add	r31, r0
    6cc8:	65 9f       	mul	r22, r21
    6cca:	f0 0d       	add	r31, r0
    6ccc:	99 27       	eor	r25, r25
    6cce:	72 9f       	mul	r23, r18
    6cd0:	b0 0d       	add	r27, r0
    6cd2:	e1 1d       	adc	r30, r1
    6cd4:	f9 1f       	adc	r31, r25
    6cd6:	63 9f       	mul	r22, r19
    6cd8:	b0 0d       	add	r27, r0
    6cda:	e1 1d       	adc	r30, r1
    6cdc:	f9 1f       	adc	r31, r25
    6cde:	bd 01       	movw	r22, r26
    6ce0:	cf 01       	movw	r24, r30
    6ce2:	11 24       	eor	r1, r1
    6ce4:	08 95       	ret

00006ce6 <__udivmodsi4>:
    6ce6:	a1 e2       	ldi	r26, 0x21	; 33
    6ce8:	1a 2e       	mov	r1, r26
    6cea:	aa 1b       	sub	r26, r26
    6cec:	bb 1b       	sub	r27, r27
    6cee:	fd 01       	movw	r30, r26
    6cf0:	0d c0       	rjmp	.+26     	; 0x6d0c <__udivmodsi4_ep>

00006cf2 <__udivmodsi4_loop>:
    6cf2:	aa 1f       	adc	r26, r26
    6cf4:	bb 1f       	adc	r27, r27
    6cf6:	ee 1f       	adc	r30, r30
    6cf8:	ff 1f       	adc	r31, r31
    6cfa:	a2 17       	cp	r26, r18
    6cfc:	b3 07       	cpc	r27, r19
    6cfe:	e4 07       	cpc	r30, r20
    6d00:	f5 07       	cpc	r31, r21
    6d02:	20 f0       	brcs	.+8      	; 0x6d0c <__udivmodsi4_ep>
    6d04:	a2 1b       	sub	r26, r18
    6d06:	b3 0b       	sbc	r27, r19
    6d08:	e4 0b       	sbc	r30, r20
    6d0a:	f5 0b       	sbc	r31, r21

00006d0c <__udivmodsi4_ep>:
    6d0c:	66 1f       	adc	r22, r22
    6d0e:	77 1f       	adc	r23, r23
    6d10:	88 1f       	adc	r24, r24
    6d12:	99 1f       	adc	r25, r25
    6d14:	1a 94       	dec	r1
    6d16:	69 f7       	brne	.-38     	; 0x6cf2 <__udivmodsi4_loop>
    6d18:	60 95       	com	r22
    6d1a:	70 95       	com	r23
    6d1c:	80 95       	com	r24
    6d1e:	90 95       	com	r25
    6d20:	9b 01       	movw	r18, r22
    6d22:	ac 01       	movw	r20, r24
    6d24:	bd 01       	movw	r22, r26
    6d26:	cf 01       	movw	r24, r30
    6d28:	08 95       	ret

00006d2a <strcmp_P>:
    6d2a:	fb 01       	movw	r30, r22
    6d2c:	dc 01       	movw	r26, r24
    6d2e:	8d 91       	ld	r24, X+
    6d30:	05 90       	lpm	r0, Z+
    6d32:	80 19       	sub	r24, r0
    6d34:	01 10       	cpse	r0, r1
    6d36:	d9 f3       	breq	.-10     	; 0x6d2e <strcmp_P+0x4>
    6d38:	99 0b       	sbc	r25, r25
    6d3a:	08 95       	ret

00006d3c <strcpy_P>:
    6d3c:	fb 01       	movw	r30, r22
    6d3e:	dc 01       	movw	r26, r24
    6d40:	05 90       	lpm	r0, Z+
    6d42:	0d 92       	st	X+, r0
    6d44:	00 20       	and	r0, r0
    6d46:	e1 f7       	brne	.-8      	; 0x6d40 <strcpy_P+0x4>
    6d48:	08 95       	ret

00006d4a <strncpy_P>:
    6d4a:	fb 01       	movw	r30, r22
    6d4c:	dc 01       	movw	r26, r24
    6d4e:	41 50       	subi	r20, 0x01	; 1
    6d50:	50 40       	sbci	r21, 0x00	; 0
    6d52:	48 f0       	brcs	.+18     	; 0x6d66 <strncpy_P+0x1c>
    6d54:	05 90       	lpm	r0, Z+
    6d56:	0d 92       	st	X+, r0
    6d58:	00 20       	and	r0, r0
    6d5a:	c9 f7       	brne	.-14     	; 0x6d4e <strncpy_P+0x4>
    6d5c:	01 c0       	rjmp	.+2      	; 0x6d60 <strncpy_P+0x16>
    6d5e:	1d 92       	st	X+, r1
    6d60:	41 50       	subi	r20, 0x01	; 1
    6d62:	50 40       	sbci	r21, 0x00	; 0
    6d64:	e0 f7       	brcc	.-8      	; 0x6d5e <strncpy_P+0x14>
    6d66:	08 95       	ret

00006d68 <strtok>:
    6d68:	4a e1       	ldi	r20, 0x1A	; 26
    6d6a:	53 e0       	ldi	r21, 0x03	; 3
    6d6c:	3a c0       	rjmp	.+116    	; 0x6de2 <strtok_r>

00006d6e <memcpy>:
    6d6e:	fb 01       	movw	r30, r22
    6d70:	dc 01       	movw	r26, r24
    6d72:	02 c0       	rjmp	.+4      	; 0x6d78 <memcpy+0xa>
    6d74:	01 90       	ld	r0, Z+
    6d76:	0d 92       	st	X+, r0
    6d78:	41 50       	subi	r20, 0x01	; 1
    6d7a:	50 40       	sbci	r21, 0x00	; 0
    6d7c:	d8 f7       	brcc	.-10     	; 0x6d74 <memcpy+0x6>
    6d7e:	08 95       	ret

00006d80 <memset>:
    6d80:	dc 01       	movw	r26, r24
    6d82:	01 c0       	rjmp	.+2      	; 0x6d86 <memset+0x6>
    6d84:	6d 93       	st	X+, r22
    6d86:	41 50       	subi	r20, 0x01	; 1
    6d88:	50 40       	sbci	r21, 0x00	; 0
    6d8a:	e0 f7       	brcc	.-8      	; 0x6d84 <memset+0x4>
    6d8c:	08 95       	ret

00006d8e <strchr>:
    6d8e:	fc 01       	movw	r30, r24
    6d90:	81 91       	ld	r24, Z+
    6d92:	86 17       	cp	r24, r22
    6d94:	21 f0       	breq	.+8      	; 0x6d9e <strchr+0x10>
    6d96:	88 23       	and	r24, r24
    6d98:	d9 f7       	brne	.-10     	; 0x6d90 <strchr+0x2>
    6d9a:	99 27       	eor	r25, r25
    6d9c:	08 95       	ret
    6d9e:	31 97       	sbiw	r30, 0x01	; 1
    6da0:	cf 01       	movw	r24, r30
    6da2:	08 95       	ret

00006da4 <strcmp>:
    6da4:	fb 01       	movw	r30, r22
    6da6:	dc 01       	movw	r26, r24
    6da8:	8d 91       	ld	r24, X+
    6daa:	01 90       	ld	r0, Z+
    6dac:	80 19       	sub	r24, r0
    6dae:	01 10       	cpse	r0, r1
    6db0:	d9 f3       	breq	.-10     	; 0x6da8 <strcmp+0x4>
    6db2:	99 0b       	sbc	r25, r25
    6db4:	08 95       	ret

00006db6 <strcpy>:
    6db6:	fb 01       	movw	r30, r22
    6db8:	dc 01       	movw	r26, r24
    6dba:	01 90       	ld	r0, Z+
    6dbc:	0d 92       	st	X+, r0
    6dbe:	00 20       	and	r0, r0
    6dc0:	e1 f7       	brne	.-8      	; 0x6dba <strcpy+0x4>
    6dc2:	08 95       	ret

00006dc4 <strncpy>:
    6dc4:	fb 01       	movw	r30, r22
    6dc6:	dc 01       	movw	r26, r24
    6dc8:	41 50       	subi	r20, 0x01	; 1
    6dca:	50 40       	sbci	r21, 0x00	; 0
    6dcc:	48 f0       	brcs	.+18     	; 0x6de0 <strncpy+0x1c>
    6dce:	01 90       	ld	r0, Z+
    6dd0:	0d 92       	st	X+, r0
    6dd2:	00 20       	and	r0, r0
    6dd4:	c9 f7       	brne	.-14     	; 0x6dc8 <strncpy+0x4>
    6dd6:	01 c0       	rjmp	.+2      	; 0x6dda <strncpy+0x16>
    6dd8:	1d 92       	st	X+, r1
    6dda:	41 50       	subi	r20, 0x01	; 1
    6ddc:	50 40       	sbci	r21, 0x00	; 0
    6dde:	e0 f7       	brcc	.-8      	; 0x6dd8 <strncpy+0x14>
    6de0:	08 95       	ret

00006de2 <strtok_r>:
    6de2:	fa 01       	movw	r30, r20
    6de4:	a1 91       	ld	r26, Z+
    6de6:	b0 81       	ld	r27, Z
    6de8:	00 97       	sbiw	r24, 0x00	; 0
    6dea:	19 f4       	brne	.+6      	; 0x6df2 <strtok_r+0x10>
    6dec:	10 97       	sbiw	r26, 0x00	; 0
    6dee:	e1 f0       	breq	.+56     	; 0x6e28 <strtok_r+0x46>
    6df0:	cd 01       	movw	r24, r26
    6df2:	dc 01       	movw	r26, r24
    6df4:	cd 01       	movw	r24, r26
    6df6:	0d 90       	ld	r0, X+
    6df8:	00 20       	and	r0, r0
    6dfa:	11 f4       	brne	.+4      	; 0x6e00 <strtok_r+0x1e>
    6dfc:	c0 01       	movw	r24, r0
    6dfe:	13 c0       	rjmp	.+38     	; 0x6e26 <strtok_r+0x44>
    6e00:	fb 01       	movw	r30, r22
    6e02:	21 91       	ld	r18, Z+
    6e04:	22 23       	and	r18, r18
    6e06:	19 f0       	breq	.+6      	; 0x6e0e <strtok_r+0x2c>
    6e08:	20 15       	cp	r18, r0
    6e0a:	d9 f7       	brne	.-10     	; 0x6e02 <strtok_r+0x20>
    6e0c:	f3 cf       	rjmp	.-26     	; 0x6df4 <strtok_r+0x12>
    6e0e:	fb 01       	movw	r30, r22
    6e10:	21 91       	ld	r18, Z+
    6e12:	20 15       	cp	r18, r0
    6e14:	19 f4       	brne	.+6      	; 0x6e1c <strtok_r+0x3a>
    6e16:	1e 92       	st	-X, r1
    6e18:	11 96       	adiw	r26, 0x01	; 1
    6e1a:	06 c0       	rjmp	.+12     	; 0x6e28 <strtok_r+0x46>
    6e1c:	22 23       	and	r18, r18
    6e1e:	c1 f7       	brne	.-16     	; 0x6e10 <strtok_r+0x2e>
    6e20:	0d 90       	ld	r0, X+
    6e22:	00 20       	and	r0, r0
    6e24:	a1 f7       	brne	.-24     	; 0x6e0e <strtok_r+0x2c>
    6e26:	d0 01       	movw	r26, r0
    6e28:	fa 01       	movw	r30, r20
    6e2a:	a1 93       	st	Z+, r26
    6e2c:	b0 83       	st	Z, r27
    6e2e:	08 95       	ret

00006e30 <sprintf_P>:
    6e30:	0f 93       	push	r16
    6e32:	1f 93       	push	r17
    6e34:	df 93       	push	r29
    6e36:	cf 93       	push	r28
    6e38:	cd b7       	in	r28, 0x3d	; 61
    6e3a:	de b7       	in	r29, 0x3e	; 62
    6e3c:	2e 97       	sbiw	r28, 0x0e	; 14
    6e3e:	0f b6       	in	r0, 0x3f	; 63
    6e40:	f8 94       	cli
    6e42:	de bf       	out	0x3e, r29	; 62
    6e44:	0f be       	out	0x3f, r0	; 63
    6e46:	cd bf       	out	0x3d, r28	; 61
    6e48:	0d 89       	ldd	r16, Y+21	; 0x15
    6e4a:	1e 89       	ldd	r17, Y+22	; 0x16
    6e4c:	8e e0       	ldi	r24, 0x0E	; 14
    6e4e:	8c 83       	std	Y+4, r24	; 0x04
    6e50:	1a 83       	std	Y+2, r17	; 0x02
    6e52:	09 83       	std	Y+1, r16	; 0x01
    6e54:	8f ef       	ldi	r24, 0xFF	; 255
    6e56:	9f e7       	ldi	r25, 0x7F	; 127
    6e58:	9e 83       	std	Y+6, r25	; 0x06
    6e5a:	8d 83       	std	Y+5, r24	; 0x05
    6e5c:	9e 01       	movw	r18, r28
    6e5e:	27 5e       	subi	r18, 0xE7	; 231
    6e60:	3f 4f       	sbci	r19, 0xFF	; 255
    6e62:	ce 01       	movw	r24, r28
    6e64:	01 96       	adiw	r24, 0x01	; 1
    6e66:	6f 89       	ldd	r22, Y+23	; 0x17
    6e68:	78 8d       	ldd	r23, Y+24	; 0x18
    6e6a:	a9 01       	movw	r20, r18
    6e6c:	11 d0       	rcall	.+34     	; 0x6e90 <vfprintf>
    6e6e:	2f 81       	ldd	r18, Y+7	; 0x07
    6e70:	38 85       	ldd	r19, Y+8	; 0x08
    6e72:	02 0f       	add	r16, r18
    6e74:	13 1f       	adc	r17, r19
    6e76:	f8 01       	movw	r30, r16
    6e78:	10 82       	st	Z, r1
    6e7a:	2e 96       	adiw	r28, 0x0e	; 14
    6e7c:	0f b6       	in	r0, 0x3f	; 63
    6e7e:	f8 94       	cli
    6e80:	de bf       	out	0x3e, r29	; 62
    6e82:	0f be       	out	0x3f, r0	; 63
    6e84:	cd bf       	out	0x3d, r28	; 61
    6e86:	cf 91       	pop	r28
    6e88:	df 91       	pop	r29
    6e8a:	1f 91       	pop	r17
    6e8c:	0f 91       	pop	r16
    6e8e:	08 95       	ret

00006e90 <vfprintf>:
    6e90:	2f 92       	push	r2
    6e92:	3f 92       	push	r3
    6e94:	4f 92       	push	r4
    6e96:	5f 92       	push	r5
    6e98:	6f 92       	push	r6
    6e9a:	7f 92       	push	r7
    6e9c:	8f 92       	push	r8
    6e9e:	9f 92       	push	r9
    6ea0:	af 92       	push	r10
    6ea2:	bf 92       	push	r11
    6ea4:	cf 92       	push	r12
    6ea6:	df 92       	push	r13
    6ea8:	ef 92       	push	r14
    6eaa:	ff 92       	push	r15
    6eac:	0f 93       	push	r16
    6eae:	1f 93       	push	r17
    6eb0:	df 93       	push	r29
    6eb2:	cf 93       	push	r28
    6eb4:	cd b7       	in	r28, 0x3d	; 61
    6eb6:	de b7       	in	r29, 0x3e	; 62
    6eb8:	2b 97       	sbiw	r28, 0x0b	; 11
    6eba:	0f b6       	in	r0, 0x3f	; 63
    6ebc:	f8 94       	cli
    6ebe:	de bf       	out	0x3e, r29	; 62
    6ec0:	0f be       	out	0x3f, r0	; 63
    6ec2:	cd bf       	out	0x3d, r28	; 61
    6ec4:	3c 01       	movw	r6, r24
    6ec6:	2b 01       	movw	r4, r22
    6ec8:	5a 01       	movw	r10, r20
    6eca:	fc 01       	movw	r30, r24
    6ecc:	17 82       	std	Z+7, r1	; 0x07
    6ece:	16 82       	std	Z+6, r1	; 0x06
    6ed0:	83 81       	ldd	r24, Z+3	; 0x03
    6ed2:	81 fd       	sbrc	r24, 1
    6ed4:	03 c0       	rjmp	.+6      	; 0x6edc <vfprintf+0x4c>
    6ed6:	6f ef       	ldi	r22, 0xFF	; 255
    6ed8:	7f ef       	ldi	r23, 0xFF	; 255
    6eda:	b9 c1       	rjmp	.+882    	; 0x724e <vfprintf+0x3be>
    6edc:	9a e0       	ldi	r25, 0x0A	; 10
    6ede:	89 2e       	mov	r8, r25
    6ee0:	1e 01       	movw	r2, r28
    6ee2:	08 94       	sec
    6ee4:	21 1c       	adc	r2, r1
    6ee6:	31 1c       	adc	r3, r1
    6ee8:	f3 01       	movw	r30, r6
    6eea:	23 81       	ldd	r18, Z+3	; 0x03
    6eec:	f2 01       	movw	r30, r4
    6eee:	23 fd       	sbrc	r18, 3
    6ef0:	85 91       	lpm	r24, Z+
    6ef2:	23 ff       	sbrs	r18, 3
    6ef4:	81 91       	ld	r24, Z+
    6ef6:	2f 01       	movw	r4, r30
    6ef8:	88 23       	and	r24, r24
    6efa:	09 f4       	brne	.+2      	; 0x6efe <vfprintf+0x6e>
    6efc:	a5 c1       	rjmp	.+842    	; 0x7248 <vfprintf+0x3b8>
    6efe:	85 32       	cpi	r24, 0x25	; 37
    6f00:	39 f4       	brne	.+14     	; 0x6f10 <vfprintf+0x80>
    6f02:	23 fd       	sbrc	r18, 3
    6f04:	85 91       	lpm	r24, Z+
    6f06:	23 ff       	sbrs	r18, 3
    6f08:	81 91       	ld	r24, Z+
    6f0a:	2f 01       	movw	r4, r30
    6f0c:	85 32       	cpi	r24, 0x25	; 37
    6f0e:	21 f4       	brne	.+8      	; 0x6f18 <vfprintf+0x88>
    6f10:	90 e0       	ldi	r25, 0x00	; 0
    6f12:	b3 01       	movw	r22, r6
    6f14:	cc d1       	rcall	.+920    	; 0x72ae <fputc>
    6f16:	e8 cf       	rjmp	.-48     	; 0x6ee8 <vfprintf+0x58>
    6f18:	98 2f       	mov	r25, r24
    6f1a:	ff 24       	eor	r15, r15
    6f1c:	ee 24       	eor	r14, r14
    6f1e:	99 24       	eor	r9, r9
    6f20:	ff e1       	ldi	r31, 0x1F	; 31
    6f22:	ff 15       	cp	r31, r15
    6f24:	d0 f0       	brcs	.+52     	; 0x6f5a <vfprintf+0xca>
    6f26:	9b 32       	cpi	r25, 0x2B	; 43
    6f28:	69 f0       	breq	.+26     	; 0x6f44 <vfprintf+0xb4>
    6f2a:	9c 32       	cpi	r25, 0x2C	; 44
    6f2c:	28 f4       	brcc	.+10     	; 0x6f38 <vfprintf+0xa8>
    6f2e:	90 32       	cpi	r25, 0x20	; 32
    6f30:	59 f0       	breq	.+22     	; 0x6f48 <vfprintf+0xb8>
    6f32:	93 32       	cpi	r25, 0x23	; 35
    6f34:	91 f4       	brne	.+36     	; 0x6f5a <vfprintf+0xca>
    6f36:	0e c0       	rjmp	.+28     	; 0x6f54 <vfprintf+0xc4>
    6f38:	9d 32       	cpi	r25, 0x2D	; 45
    6f3a:	49 f0       	breq	.+18     	; 0x6f4e <vfprintf+0xbe>
    6f3c:	90 33       	cpi	r25, 0x30	; 48
    6f3e:	69 f4       	brne	.+26     	; 0x6f5a <vfprintf+0xca>
    6f40:	41 e0       	ldi	r20, 0x01	; 1
    6f42:	24 c0       	rjmp	.+72     	; 0x6f8c <vfprintf+0xfc>
    6f44:	52 e0       	ldi	r21, 0x02	; 2
    6f46:	f5 2a       	or	r15, r21
    6f48:	84 e0       	ldi	r24, 0x04	; 4
    6f4a:	f8 2a       	or	r15, r24
    6f4c:	28 c0       	rjmp	.+80     	; 0x6f9e <vfprintf+0x10e>
    6f4e:	98 e0       	ldi	r25, 0x08	; 8
    6f50:	f9 2a       	or	r15, r25
    6f52:	25 c0       	rjmp	.+74     	; 0x6f9e <vfprintf+0x10e>
    6f54:	e0 e1       	ldi	r30, 0x10	; 16
    6f56:	fe 2a       	or	r15, r30
    6f58:	22 c0       	rjmp	.+68     	; 0x6f9e <vfprintf+0x10e>
    6f5a:	f7 fc       	sbrc	r15, 7
    6f5c:	29 c0       	rjmp	.+82     	; 0x6fb0 <vfprintf+0x120>
    6f5e:	89 2f       	mov	r24, r25
    6f60:	80 53       	subi	r24, 0x30	; 48
    6f62:	8a 30       	cpi	r24, 0x0A	; 10
    6f64:	70 f4       	brcc	.+28     	; 0x6f82 <vfprintf+0xf2>
    6f66:	f6 fe       	sbrs	r15, 6
    6f68:	05 c0       	rjmp	.+10     	; 0x6f74 <vfprintf+0xe4>
    6f6a:	98 9c       	mul	r9, r8
    6f6c:	90 2c       	mov	r9, r0
    6f6e:	11 24       	eor	r1, r1
    6f70:	98 0e       	add	r9, r24
    6f72:	15 c0       	rjmp	.+42     	; 0x6f9e <vfprintf+0x10e>
    6f74:	e8 9c       	mul	r14, r8
    6f76:	e0 2c       	mov	r14, r0
    6f78:	11 24       	eor	r1, r1
    6f7a:	e8 0e       	add	r14, r24
    6f7c:	f0 e2       	ldi	r31, 0x20	; 32
    6f7e:	ff 2a       	or	r15, r31
    6f80:	0e c0       	rjmp	.+28     	; 0x6f9e <vfprintf+0x10e>
    6f82:	9e 32       	cpi	r25, 0x2E	; 46
    6f84:	29 f4       	brne	.+10     	; 0x6f90 <vfprintf+0x100>
    6f86:	f6 fc       	sbrc	r15, 6
    6f88:	5f c1       	rjmp	.+702    	; 0x7248 <vfprintf+0x3b8>
    6f8a:	40 e4       	ldi	r20, 0x40	; 64
    6f8c:	f4 2a       	or	r15, r20
    6f8e:	07 c0       	rjmp	.+14     	; 0x6f9e <vfprintf+0x10e>
    6f90:	9c 36       	cpi	r25, 0x6C	; 108
    6f92:	19 f4       	brne	.+6      	; 0x6f9a <vfprintf+0x10a>
    6f94:	50 e8       	ldi	r21, 0x80	; 128
    6f96:	f5 2a       	or	r15, r21
    6f98:	02 c0       	rjmp	.+4      	; 0x6f9e <vfprintf+0x10e>
    6f9a:	98 36       	cpi	r25, 0x68	; 104
    6f9c:	49 f4       	brne	.+18     	; 0x6fb0 <vfprintf+0x120>
    6f9e:	f2 01       	movw	r30, r4
    6fa0:	23 fd       	sbrc	r18, 3
    6fa2:	95 91       	lpm	r25, Z+
    6fa4:	23 ff       	sbrs	r18, 3
    6fa6:	91 91       	ld	r25, Z+
    6fa8:	2f 01       	movw	r4, r30
    6faa:	99 23       	and	r25, r25
    6fac:	09 f0       	breq	.+2      	; 0x6fb0 <vfprintf+0x120>
    6fae:	b8 cf       	rjmp	.-144    	; 0x6f20 <vfprintf+0x90>
    6fb0:	89 2f       	mov	r24, r25
    6fb2:	85 54       	subi	r24, 0x45	; 69
    6fb4:	83 30       	cpi	r24, 0x03	; 3
    6fb6:	18 f0       	brcs	.+6      	; 0x6fbe <vfprintf+0x12e>
    6fb8:	80 52       	subi	r24, 0x20	; 32
    6fba:	83 30       	cpi	r24, 0x03	; 3
    6fbc:	38 f4       	brcc	.+14     	; 0x6fcc <vfprintf+0x13c>
    6fbe:	44 e0       	ldi	r20, 0x04	; 4
    6fc0:	50 e0       	ldi	r21, 0x00	; 0
    6fc2:	a4 0e       	add	r10, r20
    6fc4:	b5 1e       	adc	r11, r21
    6fc6:	5f e3       	ldi	r21, 0x3F	; 63
    6fc8:	59 83       	std	Y+1, r21	; 0x01
    6fca:	0f c0       	rjmp	.+30     	; 0x6fea <vfprintf+0x15a>
    6fcc:	93 36       	cpi	r25, 0x63	; 99
    6fce:	31 f0       	breq	.+12     	; 0x6fdc <vfprintf+0x14c>
    6fd0:	93 37       	cpi	r25, 0x73	; 115
    6fd2:	79 f0       	breq	.+30     	; 0x6ff2 <vfprintf+0x162>
    6fd4:	93 35       	cpi	r25, 0x53	; 83
    6fd6:	09 f0       	breq	.+2      	; 0x6fda <vfprintf+0x14a>
    6fd8:	52 c0       	rjmp	.+164    	; 0x707e <vfprintf+0x1ee>
    6fda:	1f c0       	rjmp	.+62     	; 0x701a <vfprintf+0x18a>
    6fdc:	f5 01       	movw	r30, r10
    6fde:	80 81       	ld	r24, Z
    6fe0:	89 83       	std	Y+1, r24	; 0x01
    6fe2:	42 e0       	ldi	r20, 0x02	; 2
    6fe4:	50 e0       	ldi	r21, 0x00	; 0
    6fe6:	a4 0e       	add	r10, r20
    6fe8:	b5 1e       	adc	r11, r21
    6fea:	61 01       	movw	r12, r2
    6fec:	01 e0       	ldi	r16, 0x01	; 1
    6fee:	10 e0       	ldi	r17, 0x00	; 0
    6ff0:	11 c0       	rjmp	.+34     	; 0x7014 <vfprintf+0x184>
    6ff2:	f5 01       	movw	r30, r10
    6ff4:	c0 80       	ld	r12, Z
    6ff6:	d1 80       	ldd	r13, Z+1	; 0x01
    6ff8:	f6 fc       	sbrc	r15, 6
    6ffa:	03 c0       	rjmp	.+6      	; 0x7002 <vfprintf+0x172>
    6ffc:	6f ef       	ldi	r22, 0xFF	; 255
    6ffe:	7f ef       	ldi	r23, 0xFF	; 255
    7000:	02 c0       	rjmp	.+4      	; 0x7006 <vfprintf+0x176>
    7002:	69 2d       	mov	r22, r9
    7004:	70 e0       	ldi	r23, 0x00	; 0
    7006:	42 e0       	ldi	r20, 0x02	; 2
    7008:	50 e0       	ldi	r21, 0x00	; 0
    700a:	a4 0e       	add	r10, r20
    700c:	b5 1e       	adc	r11, r21
    700e:	c6 01       	movw	r24, r12
    7010:	43 d1       	rcall	.+646    	; 0x7298 <strnlen>
    7012:	8c 01       	movw	r16, r24
    7014:	5f e7       	ldi	r21, 0x7F	; 127
    7016:	f5 22       	and	r15, r21
    7018:	13 c0       	rjmp	.+38     	; 0x7040 <vfprintf+0x1b0>
    701a:	f5 01       	movw	r30, r10
    701c:	c0 80       	ld	r12, Z
    701e:	d1 80       	ldd	r13, Z+1	; 0x01
    7020:	f6 fc       	sbrc	r15, 6
    7022:	03 c0       	rjmp	.+6      	; 0x702a <vfprintf+0x19a>
    7024:	6f ef       	ldi	r22, 0xFF	; 255
    7026:	7f ef       	ldi	r23, 0xFF	; 255
    7028:	02 c0       	rjmp	.+4      	; 0x702e <vfprintf+0x19e>
    702a:	69 2d       	mov	r22, r9
    702c:	70 e0       	ldi	r23, 0x00	; 0
    702e:	42 e0       	ldi	r20, 0x02	; 2
    7030:	50 e0       	ldi	r21, 0x00	; 0
    7032:	a4 0e       	add	r10, r20
    7034:	b5 1e       	adc	r11, r21
    7036:	c6 01       	movw	r24, r12
    7038:	24 d1       	rcall	.+584    	; 0x7282 <strnlen_P>
    703a:	8c 01       	movw	r16, r24
    703c:	50 e8       	ldi	r21, 0x80	; 128
    703e:	f5 2a       	or	r15, r21
    7040:	f3 fe       	sbrs	r15, 3
    7042:	06 c0       	rjmp	.+12     	; 0x7050 <vfprintf+0x1c0>
    7044:	18 c0       	rjmp	.+48     	; 0x7076 <vfprintf+0x1e6>
    7046:	80 e2       	ldi	r24, 0x20	; 32
    7048:	90 e0       	ldi	r25, 0x00	; 0
    704a:	b3 01       	movw	r22, r6
    704c:	30 d1       	rcall	.+608    	; 0x72ae <fputc>
    704e:	ea 94       	dec	r14
    7050:	8e 2d       	mov	r24, r14
    7052:	90 e0       	ldi	r25, 0x00	; 0
    7054:	08 17       	cp	r16, r24
    7056:	19 07       	cpc	r17, r25
    7058:	b0 f3       	brcs	.-20     	; 0x7046 <vfprintf+0x1b6>
    705a:	0d c0       	rjmp	.+26     	; 0x7076 <vfprintf+0x1e6>
    705c:	f6 01       	movw	r30, r12
    705e:	f7 fc       	sbrc	r15, 7
    7060:	85 91       	lpm	r24, Z+
    7062:	f7 fe       	sbrs	r15, 7
    7064:	81 91       	ld	r24, Z+
    7066:	6f 01       	movw	r12, r30
    7068:	90 e0       	ldi	r25, 0x00	; 0
    706a:	b3 01       	movw	r22, r6
    706c:	20 d1       	rcall	.+576    	; 0x72ae <fputc>
    706e:	e1 10       	cpse	r14, r1
    7070:	ea 94       	dec	r14
    7072:	01 50       	subi	r16, 0x01	; 1
    7074:	10 40       	sbci	r17, 0x00	; 0
    7076:	01 15       	cp	r16, r1
    7078:	11 05       	cpc	r17, r1
    707a:	81 f7       	brne	.-32     	; 0x705c <vfprintf+0x1cc>
    707c:	e2 c0       	rjmp	.+452    	; 0x7242 <vfprintf+0x3b2>
    707e:	94 36       	cpi	r25, 0x64	; 100
    7080:	11 f0       	breq	.+4      	; 0x7086 <vfprintf+0x1f6>
    7082:	99 36       	cpi	r25, 0x69	; 105
    7084:	61 f5       	brne	.+88     	; 0x70de <vfprintf+0x24e>
    7086:	f7 fe       	sbrs	r15, 7
    7088:	08 c0       	rjmp	.+16     	; 0x709a <vfprintf+0x20a>
    708a:	f5 01       	movw	r30, r10
    708c:	20 81       	ld	r18, Z
    708e:	31 81       	ldd	r19, Z+1	; 0x01
    7090:	42 81       	ldd	r20, Z+2	; 0x02
    7092:	53 81       	ldd	r21, Z+3	; 0x03
    7094:	84 e0       	ldi	r24, 0x04	; 4
    7096:	90 e0       	ldi	r25, 0x00	; 0
    7098:	0a c0       	rjmp	.+20     	; 0x70ae <vfprintf+0x21e>
    709a:	f5 01       	movw	r30, r10
    709c:	80 81       	ld	r24, Z
    709e:	91 81       	ldd	r25, Z+1	; 0x01
    70a0:	9c 01       	movw	r18, r24
    70a2:	44 27       	eor	r20, r20
    70a4:	37 fd       	sbrc	r19, 7
    70a6:	40 95       	com	r20
    70a8:	54 2f       	mov	r21, r20
    70aa:	82 e0       	ldi	r24, 0x02	; 2
    70ac:	90 e0       	ldi	r25, 0x00	; 0
    70ae:	a8 0e       	add	r10, r24
    70b0:	b9 1e       	adc	r11, r25
    70b2:	9f e6       	ldi	r25, 0x6F	; 111
    70b4:	f9 22       	and	r15, r25
    70b6:	57 ff       	sbrs	r21, 7
    70b8:	09 c0       	rjmp	.+18     	; 0x70cc <vfprintf+0x23c>
    70ba:	50 95       	com	r21
    70bc:	40 95       	com	r20
    70be:	30 95       	com	r19
    70c0:	21 95       	neg	r18
    70c2:	3f 4f       	sbci	r19, 0xFF	; 255
    70c4:	4f 4f       	sbci	r20, 0xFF	; 255
    70c6:	5f 4f       	sbci	r21, 0xFF	; 255
    70c8:	e0 e8       	ldi	r30, 0x80	; 128
    70ca:	fe 2a       	or	r15, r30
    70cc:	ca 01       	movw	r24, r20
    70ce:	b9 01       	movw	r22, r18
    70d0:	a1 01       	movw	r20, r2
    70d2:	2a e0       	ldi	r18, 0x0A	; 10
    70d4:	30 e0       	ldi	r19, 0x00	; 0
    70d6:	17 d1       	rcall	.+558    	; 0x7306 <__ultoa_invert>
    70d8:	d8 2e       	mov	r13, r24
    70da:	d2 18       	sub	r13, r2
    70dc:	3f c0       	rjmp	.+126    	; 0x715c <vfprintf+0x2cc>
    70de:	95 37       	cpi	r25, 0x75	; 117
    70e0:	29 f4       	brne	.+10     	; 0x70ec <vfprintf+0x25c>
    70e2:	1f 2d       	mov	r17, r15
    70e4:	1f 7e       	andi	r17, 0xEF	; 239
    70e6:	2a e0       	ldi	r18, 0x0A	; 10
    70e8:	30 e0       	ldi	r19, 0x00	; 0
    70ea:	1d c0       	rjmp	.+58     	; 0x7126 <vfprintf+0x296>
    70ec:	1f 2d       	mov	r17, r15
    70ee:	19 7f       	andi	r17, 0xF9	; 249
    70f0:	9f 36       	cpi	r25, 0x6F	; 111
    70f2:	61 f0       	breq	.+24     	; 0x710c <vfprintf+0x27c>
    70f4:	90 37       	cpi	r25, 0x70	; 112
    70f6:	20 f4       	brcc	.+8      	; 0x7100 <vfprintf+0x270>
    70f8:	98 35       	cpi	r25, 0x58	; 88
    70fa:	09 f0       	breq	.+2      	; 0x70fe <vfprintf+0x26e>
    70fc:	a5 c0       	rjmp	.+330    	; 0x7248 <vfprintf+0x3b8>
    70fe:	0f c0       	rjmp	.+30     	; 0x711e <vfprintf+0x28e>
    7100:	90 37       	cpi	r25, 0x70	; 112
    7102:	39 f0       	breq	.+14     	; 0x7112 <vfprintf+0x282>
    7104:	98 37       	cpi	r25, 0x78	; 120
    7106:	09 f0       	breq	.+2      	; 0x710a <vfprintf+0x27a>
    7108:	9f c0       	rjmp	.+318    	; 0x7248 <vfprintf+0x3b8>
    710a:	04 c0       	rjmp	.+8      	; 0x7114 <vfprintf+0x284>
    710c:	28 e0       	ldi	r18, 0x08	; 8
    710e:	30 e0       	ldi	r19, 0x00	; 0
    7110:	0a c0       	rjmp	.+20     	; 0x7126 <vfprintf+0x296>
    7112:	10 61       	ori	r17, 0x10	; 16
    7114:	14 fd       	sbrc	r17, 4
    7116:	14 60       	ori	r17, 0x04	; 4
    7118:	20 e1       	ldi	r18, 0x10	; 16
    711a:	30 e0       	ldi	r19, 0x00	; 0
    711c:	04 c0       	rjmp	.+8      	; 0x7126 <vfprintf+0x296>
    711e:	14 fd       	sbrc	r17, 4
    7120:	16 60       	ori	r17, 0x06	; 6
    7122:	20 e1       	ldi	r18, 0x10	; 16
    7124:	32 e0       	ldi	r19, 0x02	; 2
    7126:	17 ff       	sbrs	r17, 7
    7128:	08 c0       	rjmp	.+16     	; 0x713a <vfprintf+0x2aa>
    712a:	f5 01       	movw	r30, r10
    712c:	60 81       	ld	r22, Z
    712e:	71 81       	ldd	r23, Z+1	; 0x01
    7130:	82 81       	ldd	r24, Z+2	; 0x02
    7132:	93 81       	ldd	r25, Z+3	; 0x03
    7134:	44 e0       	ldi	r20, 0x04	; 4
    7136:	50 e0       	ldi	r21, 0x00	; 0
    7138:	08 c0       	rjmp	.+16     	; 0x714a <vfprintf+0x2ba>
    713a:	f5 01       	movw	r30, r10
    713c:	80 81       	ld	r24, Z
    713e:	91 81       	ldd	r25, Z+1	; 0x01
    7140:	bc 01       	movw	r22, r24
    7142:	80 e0       	ldi	r24, 0x00	; 0
    7144:	90 e0       	ldi	r25, 0x00	; 0
    7146:	42 e0       	ldi	r20, 0x02	; 2
    7148:	50 e0       	ldi	r21, 0x00	; 0
    714a:	a4 0e       	add	r10, r20
    714c:	b5 1e       	adc	r11, r21
    714e:	a1 01       	movw	r20, r2
    7150:	da d0       	rcall	.+436    	; 0x7306 <__ultoa_invert>
    7152:	d8 2e       	mov	r13, r24
    7154:	d2 18       	sub	r13, r2
    7156:	8f e7       	ldi	r24, 0x7F	; 127
    7158:	f8 2e       	mov	r15, r24
    715a:	f1 22       	and	r15, r17
    715c:	f6 fe       	sbrs	r15, 6
    715e:	0b c0       	rjmp	.+22     	; 0x7176 <vfprintf+0x2e6>
    7160:	5e ef       	ldi	r21, 0xFE	; 254
    7162:	f5 22       	and	r15, r21
    7164:	d9 14       	cp	r13, r9
    7166:	38 f4       	brcc	.+14     	; 0x7176 <vfprintf+0x2e6>
    7168:	f4 fe       	sbrs	r15, 4
    716a:	07 c0       	rjmp	.+14     	; 0x717a <vfprintf+0x2ea>
    716c:	f2 fc       	sbrc	r15, 2
    716e:	05 c0       	rjmp	.+10     	; 0x717a <vfprintf+0x2ea>
    7170:	8f ee       	ldi	r24, 0xEF	; 239
    7172:	f8 22       	and	r15, r24
    7174:	02 c0       	rjmp	.+4      	; 0x717a <vfprintf+0x2ea>
    7176:	1d 2d       	mov	r17, r13
    7178:	01 c0       	rjmp	.+2      	; 0x717c <vfprintf+0x2ec>
    717a:	19 2d       	mov	r17, r9
    717c:	f4 fe       	sbrs	r15, 4
    717e:	0d c0       	rjmp	.+26     	; 0x719a <vfprintf+0x30a>
    7180:	fe 01       	movw	r30, r28
    7182:	ed 0d       	add	r30, r13
    7184:	f1 1d       	adc	r31, r1
    7186:	80 81       	ld	r24, Z
    7188:	80 33       	cpi	r24, 0x30	; 48
    718a:	19 f4       	brne	.+6      	; 0x7192 <vfprintf+0x302>
    718c:	99 ee       	ldi	r25, 0xE9	; 233
    718e:	f9 22       	and	r15, r25
    7190:	08 c0       	rjmp	.+16     	; 0x71a2 <vfprintf+0x312>
    7192:	1f 5f       	subi	r17, 0xFF	; 255
    7194:	f2 fe       	sbrs	r15, 2
    7196:	05 c0       	rjmp	.+10     	; 0x71a2 <vfprintf+0x312>
    7198:	03 c0       	rjmp	.+6      	; 0x71a0 <vfprintf+0x310>
    719a:	8f 2d       	mov	r24, r15
    719c:	86 78       	andi	r24, 0x86	; 134
    719e:	09 f0       	breq	.+2      	; 0x71a2 <vfprintf+0x312>
    71a0:	1f 5f       	subi	r17, 0xFF	; 255
    71a2:	0f 2d       	mov	r16, r15
    71a4:	f3 fc       	sbrc	r15, 3
    71a6:	13 c0       	rjmp	.+38     	; 0x71ce <vfprintf+0x33e>
    71a8:	f0 fe       	sbrs	r15, 0
    71aa:	0e c0       	rjmp	.+28     	; 0x71c8 <vfprintf+0x338>
    71ac:	1e 15       	cp	r17, r14
    71ae:	10 f0       	brcs	.+4      	; 0x71b4 <vfprintf+0x324>
    71b0:	9d 2c       	mov	r9, r13
    71b2:	0a c0       	rjmp	.+20     	; 0x71c8 <vfprintf+0x338>
    71b4:	9d 2c       	mov	r9, r13
    71b6:	9e 0c       	add	r9, r14
    71b8:	91 1a       	sub	r9, r17
    71ba:	1e 2d       	mov	r17, r14
    71bc:	05 c0       	rjmp	.+10     	; 0x71c8 <vfprintf+0x338>
    71be:	80 e2       	ldi	r24, 0x20	; 32
    71c0:	90 e0       	ldi	r25, 0x00	; 0
    71c2:	b3 01       	movw	r22, r6
    71c4:	74 d0       	rcall	.+232    	; 0x72ae <fputc>
    71c6:	1f 5f       	subi	r17, 0xFF	; 255
    71c8:	1e 15       	cp	r17, r14
    71ca:	c8 f3       	brcs	.-14     	; 0x71be <vfprintf+0x32e>
    71cc:	04 c0       	rjmp	.+8      	; 0x71d6 <vfprintf+0x346>
    71ce:	1e 15       	cp	r17, r14
    71d0:	10 f4       	brcc	.+4      	; 0x71d6 <vfprintf+0x346>
    71d2:	e1 1a       	sub	r14, r17
    71d4:	01 c0       	rjmp	.+2      	; 0x71d8 <vfprintf+0x348>
    71d6:	ee 24       	eor	r14, r14
    71d8:	04 ff       	sbrs	r16, 4
    71da:	0e c0       	rjmp	.+28     	; 0x71f8 <vfprintf+0x368>
    71dc:	80 e3       	ldi	r24, 0x30	; 48
    71de:	90 e0       	ldi	r25, 0x00	; 0
    71e0:	b3 01       	movw	r22, r6
    71e2:	65 d0       	rcall	.+202    	; 0x72ae <fputc>
    71e4:	02 ff       	sbrs	r16, 2
    71e6:	1b c0       	rjmp	.+54     	; 0x721e <vfprintf+0x38e>
    71e8:	01 fd       	sbrc	r16, 1
    71ea:	03 c0       	rjmp	.+6      	; 0x71f2 <vfprintf+0x362>
    71ec:	88 e7       	ldi	r24, 0x78	; 120
    71ee:	90 e0       	ldi	r25, 0x00	; 0
    71f0:	0e c0       	rjmp	.+28     	; 0x720e <vfprintf+0x37e>
    71f2:	88 e5       	ldi	r24, 0x58	; 88
    71f4:	90 e0       	ldi	r25, 0x00	; 0
    71f6:	0b c0       	rjmp	.+22     	; 0x720e <vfprintf+0x37e>
    71f8:	80 2f       	mov	r24, r16
    71fa:	86 78       	andi	r24, 0x86	; 134
    71fc:	81 f0       	breq	.+32     	; 0x721e <vfprintf+0x38e>
    71fe:	01 ff       	sbrs	r16, 1
    7200:	02 c0       	rjmp	.+4      	; 0x7206 <vfprintf+0x376>
    7202:	8b e2       	ldi	r24, 0x2B	; 43
    7204:	01 c0       	rjmp	.+2      	; 0x7208 <vfprintf+0x378>
    7206:	80 e2       	ldi	r24, 0x20	; 32
    7208:	f7 fc       	sbrc	r15, 7
    720a:	8d e2       	ldi	r24, 0x2D	; 45
    720c:	90 e0       	ldi	r25, 0x00	; 0
    720e:	b3 01       	movw	r22, r6
    7210:	4e d0       	rcall	.+156    	; 0x72ae <fputc>
    7212:	05 c0       	rjmp	.+10     	; 0x721e <vfprintf+0x38e>
    7214:	80 e3       	ldi	r24, 0x30	; 48
    7216:	90 e0       	ldi	r25, 0x00	; 0
    7218:	b3 01       	movw	r22, r6
    721a:	49 d0       	rcall	.+146    	; 0x72ae <fputc>
    721c:	9a 94       	dec	r9
    721e:	d9 14       	cp	r13, r9
    7220:	c8 f3       	brcs	.-14     	; 0x7214 <vfprintf+0x384>
    7222:	da 94       	dec	r13
    7224:	f1 01       	movw	r30, r2
    7226:	ed 0d       	add	r30, r13
    7228:	f1 1d       	adc	r31, r1
    722a:	80 81       	ld	r24, Z
    722c:	90 e0       	ldi	r25, 0x00	; 0
    722e:	b3 01       	movw	r22, r6
    7230:	3e d0       	rcall	.+124    	; 0x72ae <fputc>
    7232:	dd 20       	and	r13, r13
    7234:	b1 f7       	brne	.-20     	; 0x7222 <vfprintf+0x392>
    7236:	05 c0       	rjmp	.+10     	; 0x7242 <vfprintf+0x3b2>
    7238:	80 e2       	ldi	r24, 0x20	; 32
    723a:	90 e0       	ldi	r25, 0x00	; 0
    723c:	b3 01       	movw	r22, r6
    723e:	37 d0       	rcall	.+110    	; 0x72ae <fputc>
    7240:	ea 94       	dec	r14
    7242:	ee 20       	and	r14, r14
    7244:	c9 f7       	brne	.-14     	; 0x7238 <vfprintf+0x3a8>
    7246:	50 ce       	rjmp	.-864    	; 0x6ee8 <vfprintf+0x58>
    7248:	f3 01       	movw	r30, r6
    724a:	66 81       	ldd	r22, Z+6	; 0x06
    724c:	77 81       	ldd	r23, Z+7	; 0x07
    724e:	cb 01       	movw	r24, r22
    7250:	2b 96       	adiw	r28, 0x0b	; 11
    7252:	0f b6       	in	r0, 0x3f	; 63
    7254:	f8 94       	cli
    7256:	de bf       	out	0x3e, r29	; 62
    7258:	0f be       	out	0x3f, r0	; 63
    725a:	cd bf       	out	0x3d, r28	; 61
    725c:	cf 91       	pop	r28
    725e:	df 91       	pop	r29
    7260:	1f 91       	pop	r17
    7262:	0f 91       	pop	r16
    7264:	ff 90       	pop	r15
    7266:	ef 90       	pop	r14
    7268:	df 90       	pop	r13
    726a:	cf 90       	pop	r12
    726c:	bf 90       	pop	r11
    726e:	af 90       	pop	r10
    7270:	9f 90       	pop	r9
    7272:	8f 90       	pop	r8
    7274:	7f 90       	pop	r7
    7276:	6f 90       	pop	r6
    7278:	5f 90       	pop	r5
    727a:	4f 90       	pop	r4
    727c:	3f 90       	pop	r3
    727e:	2f 90       	pop	r2
    7280:	08 95       	ret

00007282 <strnlen_P>:
    7282:	fc 01       	movw	r30, r24
    7284:	05 90       	lpm	r0, Z+
    7286:	61 50       	subi	r22, 0x01	; 1
    7288:	70 40       	sbci	r23, 0x00	; 0
    728a:	01 10       	cpse	r0, r1
    728c:	d8 f7       	brcc	.-10     	; 0x7284 <strnlen_P+0x2>
    728e:	80 95       	com	r24
    7290:	90 95       	com	r25
    7292:	8e 0f       	add	r24, r30
    7294:	9f 1f       	adc	r25, r31
    7296:	08 95       	ret

00007298 <strnlen>:
    7298:	fc 01       	movw	r30, r24
    729a:	61 50       	subi	r22, 0x01	; 1
    729c:	70 40       	sbci	r23, 0x00	; 0
    729e:	01 90       	ld	r0, Z+
    72a0:	01 10       	cpse	r0, r1
    72a2:	d8 f7       	brcc	.-10     	; 0x729a <strnlen+0x2>
    72a4:	80 95       	com	r24
    72a6:	90 95       	com	r25
    72a8:	8e 0f       	add	r24, r30
    72aa:	9f 1f       	adc	r25, r31
    72ac:	08 95       	ret

000072ae <fputc>:
    72ae:	0f 93       	push	r16
    72b0:	1f 93       	push	r17
    72b2:	cf 93       	push	r28
    72b4:	df 93       	push	r29
    72b6:	8c 01       	movw	r16, r24
    72b8:	eb 01       	movw	r28, r22
    72ba:	8b 81       	ldd	r24, Y+3	; 0x03
    72bc:	81 ff       	sbrs	r24, 1
    72be:	1b c0       	rjmp	.+54     	; 0x72f6 <fputc+0x48>
    72c0:	82 ff       	sbrs	r24, 2
    72c2:	0d c0       	rjmp	.+26     	; 0x72de <fputc+0x30>
    72c4:	2e 81       	ldd	r18, Y+6	; 0x06
    72c6:	3f 81       	ldd	r19, Y+7	; 0x07
    72c8:	8c 81       	ldd	r24, Y+4	; 0x04
    72ca:	9d 81       	ldd	r25, Y+5	; 0x05
    72cc:	28 17       	cp	r18, r24
    72ce:	39 07       	cpc	r19, r25
    72d0:	64 f4       	brge	.+24     	; 0x72ea <fputc+0x3c>
    72d2:	e8 81       	ld	r30, Y
    72d4:	f9 81       	ldd	r31, Y+1	; 0x01
    72d6:	01 93       	st	Z+, r16
    72d8:	f9 83       	std	Y+1, r31	; 0x01
    72da:	e8 83       	st	Y, r30
    72dc:	06 c0       	rjmp	.+12     	; 0x72ea <fputc+0x3c>
    72de:	e8 85       	ldd	r30, Y+8	; 0x08
    72e0:	f9 85       	ldd	r31, Y+9	; 0x09
    72e2:	80 2f       	mov	r24, r16
    72e4:	09 95       	icall
    72e6:	89 2b       	or	r24, r25
    72e8:	31 f4       	brne	.+12     	; 0x72f6 <fputc+0x48>
    72ea:	8e 81       	ldd	r24, Y+6	; 0x06
    72ec:	9f 81       	ldd	r25, Y+7	; 0x07
    72ee:	01 96       	adiw	r24, 0x01	; 1
    72f0:	9f 83       	std	Y+7, r25	; 0x07
    72f2:	8e 83       	std	Y+6, r24	; 0x06
    72f4:	02 c0       	rjmp	.+4      	; 0x72fa <fputc+0x4c>
    72f6:	0f ef       	ldi	r16, 0xFF	; 255
    72f8:	1f ef       	ldi	r17, 0xFF	; 255
    72fa:	c8 01       	movw	r24, r16
    72fc:	df 91       	pop	r29
    72fe:	cf 91       	pop	r28
    7300:	1f 91       	pop	r17
    7302:	0f 91       	pop	r16
    7304:	08 95       	ret

00007306 <__ultoa_invert>:
    7306:	fa 01       	movw	r30, r20
    7308:	aa 27       	eor	r26, r26
    730a:	28 30       	cpi	r18, 0x08	; 8
    730c:	51 f1       	breq	.+84     	; 0x7362 <__ultoa_invert+0x5c>
    730e:	20 31       	cpi	r18, 0x10	; 16
    7310:	81 f1       	breq	.+96     	; 0x7372 <__ultoa_invert+0x6c>
    7312:	e8 94       	clt
    7314:	6f 93       	push	r22
    7316:	6e 7f       	andi	r22, 0xFE	; 254
    7318:	6e 5f       	subi	r22, 0xFE	; 254
    731a:	7f 4f       	sbci	r23, 0xFF	; 255
    731c:	8f 4f       	sbci	r24, 0xFF	; 255
    731e:	9f 4f       	sbci	r25, 0xFF	; 255
    7320:	af 4f       	sbci	r26, 0xFF	; 255
    7322:	b1 e0       	ldi	r27, 0x01	; 1
    7324:	3e d0       	rcall	.+124    	; 0x73a2 <__ultoa_invert+0x9c>
    7326:	b4 e0       	ldi	r27, 0x04	; 4
    7328:	3c d0       	rcall	.+120    	; 0x73a2 <__ultoa_invert+0x9c>
    732a:	67 0f       	add	r22, r23
    732c:	78 1f       	adc	r23, r24
    732e:	89 1f       	adc	r24, r25
    7330:	9a 1f       	adc	r25, r26
    7332:	a1 1d       	adc	r26, r1
    7334:	68 0f       	add	r22, r24
    7336:	79 1f       	adc	r23, r25
    7338:	8a 1f       	adc	r24, r26
    733a:	91 1d       	adc	r25, r1
    733c:	a1 1d       	adc	r26, r1
    733e:	6a 0f       	add	r22, r26
    7340:	71 1d       	adc	r23, r1
    7342:	81 1d       	adc	r24, r1
    7344:	91 1d       	adc	r25, r1
    7346:	a1 1d       	adc	r26, r1
    7348:	20 d0       	rcall	.+64     	; 0x738a <__ultoa_invert+0x84>
    734a:	09 f4       	brne	.+2      	; 0x734e <__ultoa_invert+0x48>
    734c:	68 94       	set
    734e:	3f 91       	pop	r19
    7350:	2a e0       	ldi	r18, 0x0A	; 10
    7352:	26 9f       	mul	r18, r22
    7354:	11 24       	eor	r1, r1
    7356:	30 19       	sub	r19, r0
    7358:	30 5d       	subi	r19, 0xD0	; 208
    735a:	31 93       	st	Z+, r19
    735c:	de f6       	brtc	.-74     	; 0x7314 <__ultoa_invert+0xe>
    735e:	cf 01       	movw	r24, r30
    7360:	08 95       	ret
    7362:	46 2f       	mov	r20, r22
    7364:	47 70       	andi	r20, 0x07	; 7
    7366:	40 5d       	subi	r20, 0xD0	; 208
    7368:	41 93       	st	Z+, r20
    736a:	b3 e0       	ldi	r27, 0x03	; 3
    736c:	0f d0       	rcall	.+30     	; 0x738c <__ultoa_invert+0x86>
    736e:	c9 f7       	brne	.-14     	; 0x7362 <__ultoa_invert+0x5c>
    7370:	f6 cf       	rjmp	.-20     	; 0x735e <__ultoa_invert+0x58>
    7372:	46 2f       	mov	r20, r22
    7374:	4f 70       	andi	r20, 0x0F	; 15
    7376:	40 5d       	subi	r20, 0xD0	; 208
    7378:	4a 33       	cpi	r20, 0x3A	; 58
    737a:	18 f0       	brcs	.+6      	; 0x7382 <__ultoa_invert+0x7c>
    737c:	49 5d       	subi	r20, 0xD9	; 217
    737e:	31 fd       	sbrc	r19, 1
    7380:	40 52       	subi	r20, 0x20	; 32
    7382:	41 93       	st	Z+, r20
    7384:	02 d0       	rcall	.+4      	; 0x738a <__ultoa_invert+0x84>
    7386:	a9 f7       	brne	.-22     	; 0x7372 <__ultoa_invert+0x6c>
    7388:	ea cf       	rjmp	.-44     	; 0x735e <__ultoa_invert+0x58>
    738a:	b4 e0       	ldi	r27, 0x04	; 4
    738c:	a6 95       	lsr	r26
    738e:	97 95       	ror	r25
    7390:	87 95       	ror	r24
    7392:	77 95       	ror	r23
    7394:	67 95       	ror	r22
    7396:	ba 95       	dec	r27
    7398:	c9 f7       	brne	.-14     	; 0x738c <__ultoa_invert+0x86>
    739a:	00 97       	sbiw	r24, 0x00	; 0
    739c:	61 05       	cpc	r22, r1
    739e:	71 05       	cpc	r23, r1
    73a0:	08 95       	ret
    73a2:	9b 01       	movw	r18, r22
    73a4:	ac 01       	movw	r20, r24
    73a6:	0a 2e       	mov	r0, r26
    73a8:	06 94       	lsr	r0
    73aa:	57 95       	ror	r21
    73ac:	47 95       	ror	r20
    73ae:	37 95       	ror	r19
    73b0:	27 95       	ror	r18
    73b2:	ba 95       	dec	r27
    73b4:	c9 f7       	brne	.-14     	; 0x73a8 <__ultoa_invert+0xa2>
    73b6:	62 0f       	add	r22, r18
    73b8:	73 1f       	adc	r23, r19
    73ba:	84 1f       	adc	r24, r20
    73bc:	95 1f       	adc	r25, r21
    73be:	a0 1d       	adc	r26, r0
    73c0:	08 95       	ret

000073c2 <_exit>:
    73c2:	f8 94       	cli

000073c4 <__stop_program>:
    73c4:	ff cf       	rjmp	.-2      	; 0x73c4 <__stop_program>
