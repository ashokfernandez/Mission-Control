
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000054  00800100  00002d54  00002de8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d54  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012a3  00800154  00800154  00002e3c  2**0
                  ALLOC
  3 .stab         00000e10  00000000  00000000  00002e3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000430  00000000  00000000  00003c4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000004a0  00000000  00000000  0000407c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000c0f  00000000  00000000  0000451c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007793  00000000  00000000  0000512b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002556  00000000  00000000  0000c8be  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00005899  00000000  00000000  0000ee14  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000660  00000000  00000000  000146b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002b13  00000000  00000000  00014d10  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002c4a  00000000  00000000  00017823  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000004c8  00000000  00000000  0001a46d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

	return Endpoint_IsConfigured();
}

void Endpoint_ClearEndpoints(void)
{
       0:	1d c2       	rjmp	.+1082   	; 0x43c <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
       4:	39 c2       	rjmp	.+1138   	; 0x478 <__bad_interrupt>
       6:	00 00       	nop
       8:	37 c2       	rjmp	.+1134   	; 0x478 <__bad_interrupt>
       a:	00 00       	nop
       c:	35 c2       	rjmp	.+1130   	; 0x478 <__bad_interrupt>
       e:	00 00       	nop
      10:	33 c2       	rjmp	.+1126   	; 0x478 <__bad_interrupt>
      12:	00 00       	nop
      14:	31 c2       	rjmp	.+1122   	; 0x478 <__bad_interrupt>
      16:	00 00       	nop
      18:	2f c2       	rjmp	.+1118   	; 0x478 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2d c2       	rjmp	.+1114   	; 0x478 <__bad_interrupt>
      1e:	00 00       	nop
      20:	2b c2       	rjmp	.+1110   	; 0x478 <__bad_interrupt>
      22:	00 00       	nop
      24:	29 c2       	rjmp	.+1106   	; 0x478 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 8c 12 	jmp	0x2518	; 0x2518 <__vector_10>
      2c:	25 c2       	rjmp	.+1098   	; 0x478 <__bad_interrupt>
      2e:	00 00       	nop
      30:	23 c2       	rjmp	.+1094   	; 0x478 <__bad_interrupt>
      32:	00 00       	nop
      34:	21 c2       	rjmp	.+1090   	; 0x478 <__bad_interrupt>
      36:	00 00       	nop
      38:	1f c2       	rjmp	.+1086   	; 0x478 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	1d c2       	rjmp	.+1082   	; 0x478 <__bad_interrupt>
      3e:	00 00       	nop
      40:	1b c2       	rjmp	.+1078   	; 0x478 <__bad_interrupt>
      42:	00 00       	nop
      44:	19 c2       	rjmp	.+1074   	; 0x478 <__bad_interrupt>
      46:	00 00       	nop
      48:	17 c2       	rjmp	.+1070   	; 0x478 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	15 c2       	rjmp	.+1066   	; 0x478 <__bad_interrupt>
      4e:	00 00       	nop
      50:	13 c2       	rjmp	.+1062   	; 0x478 <__bad_interrupt>
      52:	00 00       	nop
      54:	11 c2       	rjmp	.+1058   	; 0x478 <__bad_interrupt>
      56:	00 00       	nop
      58:	0f c2       	rjmp	.+1054   	; 0x478 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0d c2       	rjmp	.+1050   	; 0x478 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0b c2       	rjmp	.+1046   	; 0x478 <__bad_interrupt>
      62:	00 00       	nop
      64:	09 c2       	rjmp	.+1042   	; 0x478 <__bad_interrupt>
      66:	00 00       	nop
      68:	07 c2       	rjmp	.+1038   	; 0x478 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	05 c2       	rjmp	.+1034   	; 0x478 <__bad_interrupt>
      6e:	00 00       	nop
      70:	03 c2       	rjmp	.+1030   	; 0x478 <__bad_interrupt>
      72:	00 00       	nop
      74:	01 c2       	rjmp	.+1026   	; 0x478 <__bad_interrupt>
      76:	00 00       	nop
      78:	ff c1       	rjmp	.+1022   	; 0x478 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	fd c1       	rjmp	.+1018   	; 0x478 <__bad_interrupt>
      7e:	00 00       	nop
      80:	fb c1       	rjmp	.+1014   	; 0x478 <__bad_interrupt>
      82:	00 00       	nop
      84:	f9 c1       	rjmp	.+1010   	; 0x478 <__bad_interrupt>
      86:	00 00       	nop
      88:	f7 c1       	rjmp	.+1006   	; 0x478 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	f5 c1       	rjmp	.+1002   	; 0x478 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f3 c1       	rjmp	.+998    	; 0x478 <__bad_interrupt>
      92:	00 00       	nop
      94:	f1 c1       	rjmp	.+994    	; 0x478 <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 30 31 31 32 32 09 09 3c 2f 70 3e     </i>101122..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <AdapterVendorDescription>:
     422:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt
     432:	65 72 00                                            er.

00000435 <AdapterMACAddress>:
     435:	02 00 02 00 02 00 00                                .......

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d0 e2       	ldi	r29, 0x20	; 32
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	e4 e5       	ldi	r30, 0x54	; 84
     450:	fd e2       	ldi	r31, 0x2D	; 45
     452:	00 e0       	ldi	r16, 0x00	; 0
     454:	0b bf       	out	0x3b, r16	; 59
     456:	02 c0       	rjmp	.+4      	; 0x45c <__do_copy_data+0x14>
     458:	07 90       	elpm	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	a4 35       	cpi	r26, 0x54	; 84
     45e:	b1 07       	cpc	r27, r17
     460:	d9 f7       	brne	.-10     	; 0x458 <__do_copy_data+0x10>

00000462 <__do_clear_bss>:
     462:	13 e1       	ldi	r17, 0x13	; 19
     464:	a4 e5       	ldi	r26, 0x54	; 84
     466:	b1 e0       	ldi	r27, 0x01	; 1
     468:	01 c0       	rjmp	.+2      	; 0x46c <.do_clear_bss_start>

0000046a <.do_clear_bss_loop>:
     46a:	1d 92       	st	X+, r1

0000046c <.do_clear_bss_start>:
     46c:	a7 3f       	cpi	r26, 0xF7	; 247
     46e:	b1 07       	cpc	r27, r17
     470:	e1 f7       	brne	.-8      	; 0x46a <.do_clear_bss_loop>
     472:	9b d1       	rcall	.+822    	; 0x7aa <main>
     474:	0c 94 a8 16 	jmp	0x2d50	; 0x2d50 <_exit>

00000478 <__bad_interrupt>:
     478:	c3 cd       	rjmp	.-1146   	; 0x0 <__vectors>

0000047a <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     47a:	8b b1       	in	r24, 0x0b	; 11
     47c:	8f 70       	andi	r24, 0x0F	; 15
     47e:	80 6a       	ori	r24, 0xA0	; 160
     480:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     482:	08 95       	ret

00000484 <EVENT_USB_Device_Disconnect>:
     484:	8b b1       	in	r24, 0x0b	; 11
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	80 61       	ori	r24, 0x10	; 16
     48a:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     48c:	08 95       	ret

0000048e <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     48e:	80 91 e8 13 	lds	r24, 0x13E8
     492:	84 30       	cpi	r24, 0x04	; 4
     494:	69 f4       	brne	.+26     	; 0x4b0 <Ethernet_Task+0x22>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameInBuffer)
     496:	80 91 39 07 	lds	r24, 0x0739
     49a:	88 23       	and	r24, r24
     49c:	49 f0       	breq	.+18     	; 0x4b0 <Ethernet_Task+0x22>
     49e:	8b b1       	in	r24, 0x0b	; 11
     4a0:	8f 70       	andi	r24, 0x0F	; 15
     4a2:	80 62       	ori	r24, 0x20	; 32
     4a4:	8b b9       	out	0x0b, r24	; 11
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     4a6:	f0 d1       	rcall	.+992    	; 0x888 <Ethernet_ProcessPacket>
     4a8:	8b b1       	in	r24, 0x0b	; 11
     4aa:	8f 70       	andi	r24, 0x0F	; 15
     4ac:	80 66       	ori	r24, 0x60	; 96
     4ae:	8b b9       	out	0x0b, r24	; 11
     4b0:	08 95       	ret

000004b2 <RNDIS_Task>:
/** Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS
 *  wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper
 *  to a frame in the FrameOUT global before sending the buffer contents to the host.
 */
void RNDIS_Task(void)
{
     4b2:	df 93       	push	r29
     4b4:	cf 93       	push	r28
     4b6:	cd b7       	in	r28, 0x3d	; 61
     4b8:	de b7       	in	r29, 0x3e	; 62
     4ba:	ac 97       	sbiw	r28, 0x2c	; 44
     4bc:	0f b6       	in	r0, 0x3f	; 63
     4be:	f8 94       	cli
     4c0:	de bf       	out	0x3e, r29	; 62
     4c2:	0f be       	out	0x3f, r0	; 63
     4c4:	cd bf       	out	0x3d, r28	; 61
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     4c6:	83 e0       	ldi	r24, 0x03	; 3
     4c8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     4cc:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the notification endpoint */
	Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

	/* Check if a message response is ready for the host */
	if (Endpoint_IsINReady() && ResponseReady)
     4d0:	80 ff       	sbrs	r24, 0
     4d2:	1a c0       	rjmp	.+52     	; 0x508 <RNDIS_Task+0x56>
     4d4:	80 91 55 01 	lds	r24, 0x0155
     4d8:	88 23       	and	r24, r24
     4da:	b1 f0       	breq	.+44     	; 0x508 <RNDIS_Task+0x56>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = 0,
				.wIndex        = 0,
				.wLength       = 0,
			};
     4dc:	de 01       	movw	r26, r28
     4de:	11 96       	adiw	r26, 0x01	; 1
     4e0:	e0 e0       	ldi	r30, 0x00	; 0
     4e2:	f1 e0       	ldi	r31, 0x01	; 1
     4e4:	88 e0       	ldi	r24, 0x08	; 8
     4e6:	01 90       	ld	r0, Z+
     4e8:	0d 92       	st	X+, r0
     4ea:	81 50       	subi	r24, 0x01	; 1
     4ec:	e1 f7       	brne	.-8      	; 0x4e6 <RNDIS_Task+0x34>

		/* Indicate that a message response is ready for the host */
		Endpoint_Write_Stream_LE(&Notification, sizeof(Notification));
     4ee:	ce 01       	movw	r24, r28
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	68 e0       	ldi	r22, 0x08	; 8
     4f4:	70 e0       	ldi	r23, 0x00	; 0
     4f6:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     4fa:	80 91 e8 00 	lds	r24, 0x00E8
     4fe:	8e 77       	andi	r24, 0x7E	; 126
     500:	80 93 e8 00 	sts	0x00E8, r24

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();

		/* Indicate a response is no longer ready */
		ResponseReady = false;
     504:	10 92 55 01 	sts	0x0155, r1
	}

	/* Don't process the data endpoints until the system is in the data initialized state, and the buffer is free */
	if ((CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
     508:	20 91 56 01 	lds	r18, 0x0156
     50c:	22 30       	cpi	r18, 0x02	; 2
     50e:	09 f0       	breq	.+2      	; 0x512 <RNDIS_Task+0x60>
     510:	89 c0       	rjmp	.+274    	; 0x624 <RNDIS_Task+0x172>
     512:	e0 91 44 01 	lds	r30, 0x0144
     516:	f0 91 45 01 	lds	r31, 0x0145
     51a:	84 81       	ldd	r24, Z+4	; 0x04
     51c:	95 81       	ldd	r25, Z+5	; 0x05
     51e:	a6 81       	ldd	r26, Z+6	; 0x06
     520:	b7 81       	ldd	r27, Z+7	; 0x07
     522:	00 97       	sbiw	r24, 0x00	; 0
     524:	a1 05       	cpc	r26, r1
     526:	b1 05       	cpc	r27, r1
     528:	09 f0       	breq	.+2      	; 0x52c <RNDIS_Task+0x7a>
     52a:	7c c0       	rjmp	.+248    	; 0x624 <RNDIS_Task+0x172>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     52c:	20 93 e9 00 	sts	0x00E9, r18
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     530:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);

		/* Check if the data OUT endpoint contains data, and that the IN buffer is empty */
		if (Endpoint_IsOUTReceived() && !(FrameIN.FrameInBuffer))
     534:	82 ff       	sbrs	r24, 2
     536:	2f c0       	rjmp	.+94     	; 0x596 <RNDIS_Task+0xe4>
     538:	80 91 39 07 	lds	r24, 0x0739
     53c:	88 23       	and	r24, r24
     53e:	59 f5       	brne	.+86     	; 0x596 <RNDIS_Task+0xe4>
		{
			/* Read in the packet message header */
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t));
     540:	ce 01       	movw	r24, r28
     542:	01 96       	adiw	r24, 0x01	; 1
     544:	6c e2       	ldi	r22, 0x2C	; 44
     546:	70 e0       	ldi	r23, 0x00	; 0
     548:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <Endpoint_Read_Stream_LE>

			/* Stall the request if the data is too large */
			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
     54c:	2d 85       	ldd	r18, Y+13	; 0x0d
     54e:	3e 85       	ldd	r19, Y+14	; 0x0e
     550:	4f 85       	ldd	r20, Y+15	; 0x0f
     552:	58 89       	ldd	r21, Y+16	; 0x10
     554:	2d 3d       	cpi	r18, 0xDD	; 221
     556:	85 e0       	ldi	r24, 0x05	; 5
     558:	38 07       	cpc	r19, r24
     55a:	80 e0       	ldi	r24, 0x00	; 0
     55c:	48 07       	cpc	r20, r24
     55e:	80 e0       	ldi	r24, 0x00	; 0
     560:	58 07       	cpc	r21, r24
     562:	30 f0       	brcs	.+12     	; 0x570 <RNDIS_Task+0xbe>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     564:	80 91 eb 00 	lds	r24, 0x00EB
     568:	80 62       	ori	r24, 0x20	; 32
     56a:	80 93 eb 00 	sts	0x00EB, r24
     56e:	5a c0       	rjmp	.+180    	; 0x624 <RNDIS_Task+0x172>
				Endpoint_StallTransaction();
				return;
			}

			/* Read in the Ethernet frame into the buffer */
			Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength);
     570:	8b e5       	ldi	r24, 0x5B	; 91
     572:	91 e0       	ldi	r25, 0x01	; 1
     574:	b9 01       	movw	r22, r18
     576:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     57a:	80 91 e8 00 	lds	r24, 0x00E8
     57e:	8b 77       	andi	r24, 0x7B	; 123
     580:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();

			/* Store the size of the Ethernet frame */
			FrameIN.FrameLength = RNDISPacketHeader.DataLength;
     584:	8d 85       	ldd	r24, Y+13	; 0x0d
     586:	9e 85       	ldd	r25, Y+14	; 0x0e
     588:	90 93 38 07 	sts	0x0738, r25
     58c:	80 93 37 07 	sts	0x0737, r24

			/* Indicate Ethernet IN buffer full */
			FrameIN.FrameInBuffer = true;
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	80 93 39 07 	sts	0x0739, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     596:	81 e0       	ldi	r24, 0x01	; 1
     598:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     59c:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPNUM);

		/* Check if the data IN endpoint is ready for more data, and that the IN buffer is full */
		if (Endpoint_IsINReady() && FrameOUT.FrameInBuffer)
     5a0:	80 ff       	sbrs	r24, 0
     5a2:	40 c0       	rjmp	.+128    	; 0x624 <RNDIS_Task+0x172>
     5a4:	80 91 18 0d 	lds	r24, 0x0D18
     5a8:	88 23       	and	r24, r24
     5aa:	e1 f1       	breq	.+120    	; 0x624 <RNDIS_Task+0x172>
		{
			/* Clear the packet header with all 0s so that the relevant fields can be filled */
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
     5ac:	fe 01       	movw	r30, r28
     5ae:	31 96       	adiw	r30, 0x01	; 1
     5b0:	8c e2       	ldi	r24, 0x2C	; 44
     5b2:	df 01       	movw	r26, r30
     5b4:	1d 92       	st	X+, r1
     5b6:	8a 95       	dec	r24
     5b8:	e9 f7       	brne	.-6      	; 0x5b4 <RNDIS_Task+0x102>

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
     5ba:	81 e0       	ldi	r24, 0x01	; 1
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	a0 e0       	ldi	r26, 0x00	; 0
     5c0:	b0 e0       	ldi	r27, 0x00	; 0
     5c2:	89 83       	std	Y+1, r24	; 0x01
     5c4:	9a 83       	std	Y+2, r25	; 0x02
     5c6:	ab 83       	std	Y+3, r26	; 0x03
     5c8:	bc 83       	std	Y+4, r27	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
     5ca:	80 91 16 0d 	lds	r24, 0x0D16
     5ce:	90 91 17 0d 	lds	r25, 0x0D17
     5d2:	8c 96       	adiw	r24, 0x2c	; 44
     5d4:	9c 01       	movw	r18, r24
     5d6:	40 e0       	ldi	r20, 0x00	; 0
     5d8:	50 e0       	ldi	r21, 0x00	; 0
     5da:	8c 97       	sbiw	r24, 0x2c	; 44
     5dc:	2d 83       	std	Y+5, r18	; 0x05
     5de:	3e 83       	std	Y+6, r19	; 0x06
     5e0:	4f 83       	std	Y+7, r20	; 0x07
     5e2:	58 87       	std	Y+8, r21	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     5e4:	24 e2       	ldi	r18, 0x24	; 36
     5e6:	30 e0       	ldi	r19, 0x00	; 0
     5e8:	40 e0       	ldi	r20, 0x00	; 0
     5ea:	50 e0       	ldi	r21, 0x00	; 0
     5ec:	29 87       	std	Y+9, r18	; 0x09
     5ee:	3a 87       	std	Y+10, r19	; 0x0a
     5f0:	4b 87       	std	Y+11, r20	; 0x0b
     5f2:	5c 87       	std	Y+12, r21	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     5f4:	a0 e0       	ldi	r26, 0x00	; 0
     5f6:	b0 e0       	ldi	r27, 0x00	; 0
     5f8:	8d 87       	std	Y+13, r24	; 0x0d
     5fa:	9e 87       	std	Y+14, r25	; 0x0e
     5fc:	af 87       	std	Y+15, r26	; 0x0f
     5fe:	b8 8b       	std	Y+16, r27	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t));
     600:	cf 01       	movw	r24, r30
     602:	6c e2       	ldi	r22, 0x2C	; 44
     604:	70 e0       	ldi	r23, 0x00	; 0
     606:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength);
     60a:	6d 85       	ldd	r22, Y+13	; 0x0d
     60c:	7e 85       	ldd	r23, Y+14	; 0x0e
     60e:	8a e3       	ldi	r24, 0x3A	; 58
     610:	97 e0       	ldi	r25, 0x07	; 7
     612:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     616:	80 91 e8 00 	lds	r24, 0x00E8
     61a:	8e 77       	andi	r24, 0x7E	; 126
     61c:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameInBuffer = false;
     620:	10 92 18 0d 	sts	0x0D18, r1
		}
	}
}
     624:	ac 96       	adiw	r28, 0x2c	; 44
     626:	0f b6       	in	r0, 0x3f	; 63
     628:	f8 94       	cli
     62a:	de bf       	out	0x3e, r29	; 62
     62c:	0f be       	out	0x3f, r0	; 63
     62e:	cd bf       	out	0x3d, r28	; 61
     630:	cf 91       	pop	r28
     632:	df 91       	pop	r29
     634:	08 95       	ret

00000636 <EVENT_USB_Device_ControlRequest>:
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Process RNDIS class commands */
	switch (USB_ControlRequest.bRequest)
     636:	80 91 ea 13 	lds	r24, 0x13EA
     63a:	88 23       	and	r24, r24
     63c:	21 f0       	breq	.+8      	; 0x646 <EVENT_USB_Device_ControlRequest+0x10>
     63e:	81 30       	cpi	r24, 0x01	; 1
     640:	09 f0       	breq	.+2      	; 0x644 <EVENT_USB_Device_ControlRequest+0xe>
     642:	50 c0       	rjmp	.+160    	; 0x6e4 <EVENT_USB_Device_ControlRequest+0xae>
     644:	19 c0       	rjmp	.+50     	; 0x678 <EVENT_USB_Device_ControlRequest+0x42>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     646:	80 91 e9 13 	lds	r24, 0x13E9
     64a:	81 32       	cpi	r24, 0x21	; 33
     64c:	09 f0       	breq	.+2      	; 0x650 <EVENT_USB_Device_ControlRequest+0x1a>
     64e:	4a c0       	rjmp	.+148    	; 0x6e4 <EVENT_USB_Device_ControlRequest+0xae>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     650:	80 91 e8 00 	lds	r24, 0x00E8
     654:	87 7f       	andi	r24, 0xF7	; 247
     656:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Read in the RNDIS message into the message buffer */
				Endpoint_Read_Control_Stream_LE(RNDISMessageBuffer, USB_ControlRequest.wLength);
     65a:	60 91 ef 13 	lds	r22, 0x13EF
     65e:	70 91 f0 13 	lds	r23, 0x13F0
     662:	80 e6       	ldi	r24, 0x60	; 96
     664:	93 e1       	ldi	r25, 0x13	; 19
     666:	0e 94 82 15 	call	0x2b04	; 0x2b04 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     66a:	80 91 e8 00 	lds	r24, 0x00E8
     66e:	8e 77       	andi	r24, 0x7E	; 126
     670:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				/* Process the RNDIS message */
				ProcessRNDISControlMessage();
     674:	0c 94 f0 0e 	jmp	0x1de0	; 0x1de0 <ProcessRNDISControlMessage>
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     678:	80 91 e9 13 	lds	r24, 0x13E9
     67c:	81 3a       	cpi	r24, 0xA1	; 161
     67e:	91 f5       	brne	.+100    	; 0x6e4 <EVENT_USB_Device_ControlRequest+0xae>
			{
				/* Check if a response to the last message is ready */
				if (!(MessageHeader->MessageLength))
     680:	e0 91 44 01 	lds	r30, 0x0144
     684:	f0 91 45 01 	lds	r31, 0x0145
     688:	84 81       	ldd	r24, Z+4	; 0x04
     68a:	95 81       	ldd	r25, Z+5	; 0x05
     68c:	a6 81       	ldd	r26, Z+6	; 0x06
     68e:	b7 81       	ldd	r27, Z+7	; 0x07
     690:	00 97       	sbiw	r24, 0x00	; 0
     692:	a1 05       	cpc	r26, r1
     694:	b1 05       	cpc	r27, r1
     696:	51 f4       	brne	.+20     	; 0x6ac <EVENT_USB_Device_ControlRequest+0x76>
				{
					/* Set the response to a single 0x00 byte to indicate that no response is ready */
					RNDISMessageBuffer[0] = 0;
     698:	10 92 60 13 	sts	0x1360, r1
					MessageHeader->MessageLength = 1;
     69c:	81 e0       	ldi	r24, 0x01	; 1
     69e:	90 e0       	ldi	r25, 0x00	; 0
     6a0:	a0 e0       	ldi	r26, 0x00	; 0
     6a2:	b0 e0       	ldi	r27, 0x00	; 0
     6a4:	84 83       	std	Z+4, r24	; 0x04
     6a6:	95 83       	std	Z+5, r25	; 0x05
     6a8:	a6 83       	std	Z+6, r26	; 0x06
     6aa:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     6ac:	80 91 e8 00 	lds	r24, 0x00E8
     6b0:	87 7f       	andi	r24, 0xF7	; 247
     6b2:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();

				/* Write the message response data to the endpoint */
				Endpoint_Write_Control_Stream_LE(RNDISMessageBuffer, MessageHeader->MessageLength);
     6b6:	e0 91 44 01 	lds	r30, 0x0144
     6ba:	f0 91 45 01 	lds	r31, 0x0145
     6be:	64 81       	ldd	r22, Z+4	; 0x04
     6c0:	75 81       	ldd	r23, Z+5	; 0x05
     6c2:	80 e6       	ldi	r24, 0x60	; 96
     6c4:	93 e1       	ldi	r25, 0x13	; 19
     6c6:	0e 94 c4 14 	call	0x2988	; 0x2988 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     6ca:	80 91 e8 00 	lds	r24, 0x00E8
     6ce:	8b 77       	andi	r24, 0x7B	; 123
     6d0:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				/* Reset the message header once again after transmission */
				MessageHeader->MessageLength = 0;
     6d4:	e0 91 44 01 	lds	r30, 0x0144
     6d8:	f0 91 45 01 	lds	r31, 0x0145
     6dc:	14 82       	std	Z+4, r1	; 0x04
     6de:	15 82       	std	Z+5, r1	; 0x05
     6e0:	16 82       	std	Z+6, r1	; 0x06
     6e2:	17 82       	std	Z+7, r1	; 0x07
     6e4:	08 95       	ret

000006e6 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the RNDIS device endpoints and starts the relevant tasks.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     6e6:	ef 92       	push	r14
     6e8:	ff 92       	push	r15
     6ea:	0f 93       	push	r16
     6ec:	1f 93       	push	r17
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	61 e8       	ldi	r22, 0x81	; 129
     6f2:	42 e3       	ldi	r20, 0x32	; 50
     6f4:	0e 94 c3 11 	call	0x2386	; 0x2386 <Endpoint_ConfigureEndpoint_Prv>
     6f8:	08 2f       	mov	r16, r24
	                                            CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
	                                            CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     6fa:	82 e0       	ldi	r24, 0x02	; 2
     6fc:	60 e8       	ldi	r22, 0x80	; 128
     6fe:	42 e3       	ldi	r20, 0x32	; 50
     700:	0e 94 c3 11 	call	0x2386	; 0x2386 <Endpoint_ConfigureEndpoint_Prv>
     704:	e8 2e       	mov	r14, r24
     706:	83 e0       	ldi	r24, 0x03	; 3
     708:	61 ec       	ldi	r22, 0xC1	; 193
     70a:	42 e0       	ldi	r20, 0x02	; 2
     70c:	0e 94 c3 11 	call	0x2386	; 0x2386 <Endpoint_ConfigureEndpoint_Prv>
     710:	10 e0       	ldi	r17, 0x00	; 0
     712:	ff 24       	eor	r15, r15
     714:	0e 21       	and	r16, r14
     716:	1f 21       	and	r17, r15
     718:	01 70       	andi	r16, 0x01	; 1
     71a:	10 70       	andi	r17, 0x00	; 0
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	08 23       	and	r16, r24
     720:	19 23       	and	r17, r25
     722:	01 2b       	or	r16, r17
     724:	11 f4       	brne	.+4      	; 0x72a <EVENT_USB_Device_ConfigurationChanged+0x44>
     726:	90 e9       	ldi	r25, 0x90	; 144
     728:	01 c0       	rjmp	.+2      	; 0x72c <EVENT_USB_Device_ConfigurationChanged+0x46>
     72a:	90 e6       	ldi	r25, 0x60	; 96
     72c:	8b b1       	in	r24, 0x0b	; 11
     72e:	8f 70       	andi	r24, 0x0F	; 15
     730:	98 2b       	or	r25, r24
     732:	9b b9       	out	0x0b, r25	; 11
}
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	08 95       	ret

0000073e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     73e:	84 b7       	in	r24, 0x34	; 52
     740:	87 7f       	andi	r24, 0xF7	; 247
     742:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     744:	38 e1       	ldi	r19, 0x18	; 24
     746:	0f b6       	in	r0, 0x3f	; 63
     748:	f8 94       	cli
     74a:	30 93 60 00 	sts	0x0060, r19
     74e:	10 92 60 00 	sts	0x0060, r1
     752:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     754:	80 e0       	ldi	r24, 0x00	; 0
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	20 e8       	ldi	r18, 0x80	; 128
     75a:	0f b6       	in	r0, 0x3f	; 63
     75c:	f8 94       	cli
     75e:	20 93 61 00 	sts	0x0061, r18
     762:	80 93 61 00 	sts	0x0061, r24
     766:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     768:	8a b1       	in	r24, 0x0a	; 10
     76a:	80 6f       	ori	r24, 0xF0	; 240
     76c:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     76e:	8b b1       	in	r24, 0x0b	; 11
     770:	8f 70       	andi	r24, 0x0F	; 15
     772:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     774:	83 e3       	ldi	r24, 0x33	; 51
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	90 93 cd 00 	sts	0x00CD, r25
     77c:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     780:	86 e0       	ldi	r24, 0x06	; 6
     782:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     786:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     78a:	30 93 c9 00 	sts	0x00C9, r19

				DDRD  |= (1 << 3);
     78e:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     790:	5a 9a       	sbi	0x0b, 2	; 11
			static inline void SerialStream_Init(const uint32_t BaudRate,
			                                     const bool DoubleSpeed)
			{
				Serial_Init(BaudRate, DoubleSpeed);

				stdout = &USARTStream;
     792:	86 e4       	ldi	r24, 0x46	; 70
     794:	91 e0       	ldi	r25, 0x01	; 1
     796:	90 93 f4 13 	sts	0x13F4, r25
     79a:	80 93 f3 13 	sts	0x13F3, r24
				stdin  = &USARTStream;
     79e:	90 93 f2 13 	sts	0x13F2, r25
     7a2:	80 93 f1 13 	sts	0x13F1, r24

	/* Hardware Initialization */
	LEDs_Init();
	SerialStream_Init(9600, false);
	USB_Init();
     7a6:	0c 94 76 12 	jmp	0x24ec	; 0x24ec <USB_Init>

000007aa <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     7aa:	c9 df       	rcall	.-110    	; 0x73e <SetupHardware>

	/* Webserver Initialization */
	TCP_Init();
     7ac:	1c d1       	rcall	.+568    	; 0x9e6 <TCP_Init>
	Webserver_Init();
     7ae:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     7b2:	8b b1       	in	r24, 0x0b	; 11
     7b4:	8f 70       	andi	r24, 0x0F	; 15
     7b6:	80 61       	ori	r24, 0x10	; 16
     7b8:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     7ba:	78 94       	sei

	for (;;)
	{
		Ethernet_Task();
     7bc:	68 de       	rcall	.-816    	; 0x48e <Ethernet_Task>
		TCP_Task();
     7be:	8d d6       	rcall	.+3354   	; 0x14da <TCP_Task>
		RNDIS_Task();
     7c0:	78 de       	rcall	.-784    	; 0x4b2 <RNDIS_Task>
		USB_USBTask();
     7c2:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <USB_USBTask>
     7c6:	fa cf       	rjmp	.-12     	; 0x7bc <main+0x12>

000007c8 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     7c8:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     7ca:	92 30       	cpi	r25, 0x02	; 2
     7cc:	49 f0       	breq	.+18     	; 0x7e0 <CALLBACK_USB_GetDescriptor+0x18>
     7ce:	93 30       	cpi	r25, 0x03	; 3
     7d0:	61 f0       	breq	.+24     	; 0x7ea <CALLBACK_USB_GetDescriptor+0x22>
     7d2:	91 30       	cpi	r25, 0x01	; 1
     7d4:	f9 f4       	brne	.+62     	; 0x814 <CALLBACK_USB_GetDescriptor+0x4c>
     7d6:	e8 e9       	ldi	r30, 0x98	; 152
     7d8:	f0 e0       	ldi	r31, 0x00	; 0
     7da:	22 e1       	ldi	r18, 0x12	; 18
     7dc:	30 e0       	ldi	r19, 0x00	; 0
     7de:	1e c0       	rjmp	.+60     	; 0x81c <CALLBACK_USB_GetDescriptor+0x54>
     7e0:	ea ea       	ldi	r30, 0xAA	; 170
     7e2:	f0 e0       	ldi	r31, 0x00	; 0
     7e4:	2e e3       	ldi	r18, 0x3E	; 62
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	19 c0       	rjmp	.+50     	; 0x81c <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     7ea:	81 30       	cpi	r24, 0x01	; 1
     7ec:	49 f0       	breq	.+18     	; 0x800 <CALLBACK_USB_GetDescriptor+0x38>
     7ee:	81 30       	cpi	r24, 0x01	; 1
     7f0:	18 f0       	brcs	.+6      	; 0x7f8 <CALLBACK_USB_GetDescriptor+0x30>
     7f2:	82 30       	cpi	r24, 0x02	; 2
     7f4:	79 f4       	brne	.+30     	; 0x814 <CALLBACK_USB_GetDescriptor+0x4c>
     7f6:	08 c0       	rjmp	.+16     	; 0x808 <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     7f8:	e8 ee       	ldi	r30, 0xE8	; 232
     7fa:	f0 e0       	ldi	r31, 0x00	; 0
     7fc:	84 91       	lpm	r24, Z+
     7fe:	07 c0       	rjmp	.+14     	; 0x80e <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     800:	ec ee       	ldi	r30, 0xEC	; 236
     802:	f0 e0       	ldi	r31, 0x00	; 0
     804:	84 91       	lpm	r24, Z+
     806:	03 c0       	rjmp	.+6      	; 0x80e <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     808:	e6 e0       	ldi	r30, 0x06	; 6
     80a:	f1 e0       	ldi	r31, 0x01	; 1
     80c:	84 91       	lpm	r24, Z+
     80e:	28 2f       	mov	r18, r24
     810:	30 e0       	ldi	r19, 0x00	; 0
     812:	04 c0       	rjmp	.+8      	; 0x81c <CALLBACK_USB_GetDescriptor+0x54>
     814:	e0 e0       	ldi	r30, 0x00	; 0
     816:	f0 e0       	ldi	r31, 0x00	; 0
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     81c:	ed 93       	st	X+, r30
     81e:	fc 93       	st	X, r31
	return Size;
}
     820:	c9 01       	movw	r24, r18
     822:	08 95       	ret

00000824 <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     824:	cf 93       	push	r28
     826:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     828:	76 95       	lsr	r23
     82a:	67 95       	ror	r22
     82c:	ec 01       	movw	r28, r24
     82e:	20 e0       	ldi	r18, 0x00	; 0
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	e0 e0       	ldi	r30, 0x00	; 0
     838:	f0 e0       	ldi	r31, 0x00	; 0
     83a:	09 c0       	rjmp	.+18     	; 0x84e <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     83c:	89 91       	ld	r24, Y+
     83e:	99 91       	ld	r25, Y+
     840:	a0 e0       	ldi	r26, 0x00	; 0
     842:	b0 e0       	ldi	r27, 0x00	; 0
     844:	28 0f       	add	r18, r24
     846:	39 1f       	adc	r19, r25
     848:	4a 1f       	adc	r20, r26
     84a:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     84c:	31 96       	adiw	r30, 0x01	; 1
     84e:	e6 17       	cp	r30, r22
     850:	f7 07       	cpc	r31, r23
     852:	a0 f3       	brcs	.-24     	; 0x83c <Ethernet_Checksum16+0x18>
     854:	0b c0       	rjmp	.+22     	; 0x86c <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     856:	da 01       	movw	r26, r20
     858:	c9 01       	movw	r24, r18
     85a:	a0 70       	andi	r26, 0x00	; 0
     85c:	b0 70       	andi	r27, 0x00	; 0
     85e:	9a 01       	movw	r18, r20
     860:	44 27       	eor	r20, r20
     862:	55 27       	eor	r21, r21
     864:	28 0f       	add	r18, r24
     866:	39 1f       	adc	r19, r25
     868:	4a 1f       	adc	r20, r26
     86a:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     86c:	da 01       	movw	r26, r20
     86e:	c9 01       	movw	r24, r18
     870:	80 70       	andi	r24, 0x00	; 0
     872:	90 70       	andi	r25, 0x00	; 0
     874:	00 97       	sbiw	r24, 0x00	; 0
     876:	a1 05       	cpc	r26, r1
     878:	b1 05       	cpc	r27, r1
     87a:	69 f7       	brne	.-38     	; 0x856 <Ethernet_Checksum16+0x32>
     87c:	20 95       	com	r18
     87e:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     880:	c9 01       	movw	r24, r18
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	08 95       	ret

00000888 <Ethernet_ProcessPacket>:

/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     88c:	cb e5       	ldi	r28, 0x5B	; 91
     88e:	d1 e0       	ldi	r29, 0x01	; 1
     890:	ce 01       	movw	r24, r28
     892:	69 d0       	rcall	.+210    	; 0x966 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     894:	ce 01       	movw	r24, r28
     896:	68 e0       	ldi	r22, 0x08	; 8
     898:	71 e0       	ldi	r23, 0x01	; 1
     89a:	46 e0       	ldi	r20, 0x06	; 6
     89c:	50 e0       	ldi	r21, 0x00	; 0
     89e:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
     8a2:	00 97       	sbiw	r24, 0x00	; 0
     8a4:	51 f0       	breq	.+20     	; 0x8ba <Ethernet_ProcessPacket+0x32>
     8a6:	ce 01       	movw	r24, r28
     8a8:	62 e1       	ldi	r22, 0x12	; 18
     8aa:	71 e0       	ldi	r23, 0x01	; 1
     8ac:	46 e0       	ldi	r20, 0x06	; 6
     8ae:	50 e0       	ldi	r21, 0x00	; 0
     8b0:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
     8b4:	00 97       	sbiw	r24, 0x00	; 0
     8b6:	09 f0       	breq	.+2      	; 0x8ba <Ethernet_ProcessPacket+0x32>
     8b8:	51 c0       	rjmp	.+162    	; 0x95c <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     8ba:	80 91 37 07 	lds	r24, 0x0737
     8be:	90 91 38 07 	lds	r25, 0x0738

				Temp = Data.Bytes[0];
     8c2:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     8c4:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     8c6:	92 2f       	mov	r25, r18
     8c8:	81 50       	subi	r24, 0x01	; 1
     8ca:	96 40       	sbci	r25, 0x06	; 6
     8cc:	08 f4       	brcc	.+2      	; 0x8d0 <Ethernet_ProcessPacket+0x48>
     8ce:	46 c0       	rjmp	.+140    	; 0x95c <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     8d0:	20 91 67 01 	lds	r18, 0x0167
     8d4:	30 91 68 01 	lds	r19, 0x0168

				Temp = Data.Bytes[0];
     8d8:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     8da:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     8dc:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     8de:	88 e0       	ldi	r24, 0x08	; 8
     8e0:	20 30       	cpi	r18, 0x00	; 0
     8e2:	38 07       	cpc	r19, r24
     8e4:	51 f0       	breq	.+20     	; 0x8fa <Ethernet_ProcessPacket+0x72>
     8e6:	26 50       	subi	r18, 0x06	; 6
     8e8:	38 40       	sbci	r19, 0x08	; 8
     8ea:	c1 f5       	brne	.+112    	; 0x95c <Ethernet_ProcessPacket+0xd4>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     8ec:	89 e6       	ldi	r24, 0x69	; 105
     8ee:	91 e0       	ldi	r25, 0x01	; 1
     8f0:	68 e4       	ldi	r22, 0x48	; 72
     8f2:	77 e0       	ldi	r23, 0x07	; 7
     8f4:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <ARP_ProcessARPPacket>
     8f8:	06 c0       	rjmp	.+12     	; 0x906 <Ethernet_ProcessPacket+0x7e>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     8fa:	89 e6       	ldi	r24, 0x69	; 105
     8fc:	91 e0       	ldi	r25, 0x01	; 1
     8fe:	68 e4       	ldi	r22, 0x48	; 72
     900:	77 e0       	ldi	r23, 0x07	; 7
     902:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <IP_ProcessIPPacket>
     906:	9c 01       	movw	r18, r24
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     908:	18 16       	cp	r1, r24
     90a:	19 06       	cpc	r1, r25
     90c:	24 f5       	brge	.+72     	; 0x956 <Ethernet_ProcessPacket+0xce>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     90e:	a0 e4       	ldi	r26, 0x40	; 64
     910:	b7 e0       	ldi	r27, 0x07	; 7
     912:	e8 e0       	ldi	r30, 0x08	; 8
     914:	f1 e0       	ldi	r31, 0x01	; 1
     916:	86 e0       	ldi	r24, 0x06	; 6
     918:	01 90       	ld	r0, Z+
     91a:	0d 92       	st	X+, r0
     91c:	81 50       	subi	r24, 0x01	; 1
     91e:	e1 f7       	brne	.-8      	; 0x918 <Ethernet_ProcessPacket+0x90>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     920:	aa e3       	ldi	r26, 0x3A	; 58
     922:	b7 e0       	ldi	r27, 0x07	; 7
     924:	e1 e6       	ldi	r30, 0x61	; 97
     926:	f1 e0       	ldi	r31, 0x01	; 1
     928:	86 e0       	ldi	r24, 0x06	; 6
     92a:	01 90       	ld	r0, Z+
     92c:	0d 92       	st	X+, r0
     92e:	81 50       	subi	r24, 0x01	; 1
     930:	e1 f7       	brne	.-8      	; 0x92a <Ethernet_ProcessPacket+0xa2>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     932:	80 91 67 01 	lds	r24, 0x0167
     936:	90 91 68 01 	lds	r25, 0x0168
     93a:	90 93 47 07 	sts	0x0747, r25
     93e:	80 93 46 07 	sts	0x0746, r24

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     942:	22 5f       	subi	r18, 0xF2	; 242
     944:	3f 4f       	sbci	r19, 0xFF	; 255
     946:	30 93 17 0d 	sts	0x0D17, r19
     94a:	20 93 16 0d 	sts	0x0D16, r18
			FrameOUT.FrameInBuffer          = true;
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	80 93 18 0d 	sts	0x0D18, r24
     954:	03 c0       	rjmp	.+6      	; 0x95c <Ethernet_ProcessPacket+0xd4>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     956:	2f 5f       	subi	r18, 0xFF	; 255
     958:	3f 4f       	sbci	r19, 0xFF	; 255
     95a:	11 f0       	breq	.+4      	; 0x960 <Ethernet_ProcessPacket+0xd8>
	{
		/* Clear the frame buffer */
		FrameIN.FrameInBuffer = false;
     95c:	10 92 39 07 	sts	0x0739, r1
	}
}
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	08 95       	ret

00000966 <DecodeEthernetFrameHeader>:
	if (SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE)
	  printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	else
	  printf_P(PSTR("  + Protocol: UNKNOWN E1\r\n"));
	#endif
}
     966:	08 95       	ret

00000968 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     968:	08 95       	ret

0000096a <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     96a:	08 95       	ret

0000096c <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     96c:	08 95       	ret

0000096e <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     96e:	08 95       	ret

00000970 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     970:	08 95       	ret

00000972 <DecodeDHCPHeader>:
		}

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}
	#endif
}
     972:	08 95       	ret

00000974 <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     974:	0f 93       	push	r16
     976:	1f 93       	push	r17
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	8c 01       	movw	r16, r24
     97e:	eb 01       	movw	r28, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     980:	f5 df       	rcall	.-22     	; 0x96c <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     982:	f8 01       	movw	r30, r16
     984:	80 81       	ld	r24, Z
     986:	88 30       	cpi	r24, 0x08	; 8
     988:	19 f0       	breq	.+6      	; 0x990 <ICMP_ProcessICMPPacket+0x1c>
     98a:	20 e0       	ldi	r18, 0x00	; 0
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	25 c0       	rjmp	.+74     	; 0x9da <ICMP_ProcessICMPPacket+0x66>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     990:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     992:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     994:	1b 82       	std	Y+3, r1	; 0x03
     996:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     998:	f8 01       	movw	r30, r16
     99a:	84 81       	ldd	r24, Z+4	; 0x04
     99c:	95 81       	ldd	r25, Z+5	; 0x05
     99e:	9d 83       	std	Y+5, r25	; 0x05
     9a0:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     9a2:	86 81       	ldd	r24, Z+6	; 0x06
     9a4:	97 81       	ldd	r25, Z+7	; 0x07
     9a6:	9f 83       	std	Y+7, r25	; 0x07
     9a8:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     9aa:	b8 01       	movw	r22, r16
     9ac:	68 5f       	subi	r22, 0xF8	; 248
     9ae:	7f 4f       	sbci	r23, 0xFF	; 255
     9b0:	00 91 37 07 	lds	r16, 0x0737
     9b4:	10 91 38 07 	lds	r17, 0x0738
     9b8:	05 5a       	subi	r16, 0xA5	; 165
     9ba:	1e 4f       	sbci	r17, 0xFE	; 254
     9bc:	06 1b       	sub	r16, r22
     9be:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     9c0:	ce 01       	movw	r24, r28
     9c2:	08 96       	adiw	r24, 0x08	; 8
     9c4:	a8 01       	movw	r20, r16
     9c6:	0e 94 89 16 	call	0x2d12	; 0x2d12 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     9ca:	08 5f       	subi	r16, 0xF8	; 248
     9cc:	1f 4f       	sbci	r17, 0xFF	; 255
     9ce:	ce 01       	movw	r24, r28
     9d0:	b8 01       	movw	r22, r16
     9d2:	28 df       	rcall	.-432    	; 0x824 <Ethernet_Checksum16>
     9d4:	9b 83       	std	Y+3, r25	; 0x03
     9d6:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     9d8:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     9da:	c9 01       	movw	r24, r18
     9dc:	df 91       	pop	r29
     9de:	cf 91       	pop	r28
     9e0:	1f 91       	pop	r17
     9e2:	0f 91       	pop	r16
     9e4:	08 95       	ret

000009e6 <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     9e6:	10 92 5d 13 	sts	0x135D, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     9ea:	8a e0       	ldi	r24, 0x0A	; 10
     9ec:	80 93 2e 0f 	sts	0x0F2E, r24
     9f0:	80 93 44 11 	sts	0x1144, r24
     9f4:	80 93 5a 13 	sts	0x135A, r24
}
     9f8:	08 95       	ret

000009fa <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     9fa:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     9fc:	80 91 5b 13 	lds	r24, 0x135B
     a00:	90 91 5c 13 	lds	r25, 0x135C
     a04:	82 17       	cp	r24, r18
     a06:	93 07       	cpc	r25, r19
     a08:	19 f4       	brne	.+6      	; 0xa10 <TCP_SetPortState+0x16>
     a0a:	80 e0       	ldi	r24, 0x00	; 0
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	13 c0       	rjmp	.+38     	; 0xa36 <TCP_SetPortState+0x3c>
     a10:	80 91 60 13 	lds	r24, 0x1360
     a14:	90 91 61 13 	lds	r25, 0x1361
     a18:	82 17       	cp	r24, r18
     a1a:	93 07       	cpc	r25, r19
     a1c:	19 f4       	brne	.+6      	; 0xa24 <TCP_SetPortState+0x2a>
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	09 c0       	rjmp	.+18     	; 0xa36 <TCP_SetPortState+0x3c>
     a24:	80 91 65 13 	lds	r24, 0x1365
     a28:	90 91 66 13 	lds	r25, 0x1366
     a2c:	82 17       	cp	r24, r18
     a2e:	93 07       	cpc	r25, r19
     a30:	79 f4       	brne	.+30     	; 0xa50 <TCP_SetPortState+0x56>
     a32:	82 e0       	ldi	r24, 0x02	; 2
     a34:	90 e0       	ldi	r25, 0x00	; 0
		{
			PortStateTable[PTableEntry].State = State;
     a36:	fc 01       	movw	r30, r24
     a38:	ee 0f       	add	r30, r30
     a3a:	ff 1f       	adc	r31, r31
     a3c:	ee 0f       	add	r30, r30
     a3e:	ff 1f       	adc	r31, r31
     a40:	e8 0f       	add	r30, r24
     a42:	f9 1f       	adc	r31, r25
     a44:	e5 5a       	subi	r30, 0xA5	; 165
     a46:	fc 4e       	sbci	r31, 0xEC	; 236
     a48:	62 83       	std	Z+2, r22	; 0x02
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     a4a:	54 83       	std	Z+4, r21	; 0x04
     a4c:	43 83       	std	Z+3, r20	; 0x03
     a4e:	02 c0       	rjmp	.+4      	; 0xa54 <TCP_SetPortState+0x5a>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     a50:	61 30       	cpi	r22, 0x01	; 1
     a52:	11 f0       	breq	.+4      	; 0xa58 <TCP_SetPortState+0x5e>
     a54:	81 e0       	ldi	r24, 0x01	; 1
     a56:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     a58:	80 91 5d 13 	lds	r24, 0x135D
     a5c:	88 23       	and	r24, r24
     a5e:	19 f4       	brne	.+6      	; 0xa66 <TCP_SetPortState+0x6c>
     a60:	80 e0       	ldi	r24, 0x00	; 0
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	0f c0       	rjmp	.+30     	; 0xa84 <TCP_SetPortState+0x8a>
     a66:	80 91 62 13 	lds	r24, 0x1362
     a6a:	88 23       	and	r24, r24
     a6c:	19 f4       	brne	.+6      	; 0xa74 <TCP_SetPortState+0x7a>
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	08 c0       	rjmp	.+16     	; 0xa84 <TCP_SetPortState+0x8a>
     a74:	80 91 67 13 	lds	r24, 0x1367
     a78:	88 23       	and	r24, r24
     a7a:	11 f0       	breq	.+4      	; 0xa80 <TCP_SetPortState+0x86>
     a7c:	80 e0       	ldi	r24, 0x00	; 0
     a7e:	08 95       	ret
     a80:	82 e0       	ldi	r24, 0x02	; 2
     a82:	90 e0       	ldi	r25, 0x00	; 0
			{
				PortStateTable[PTableEntry].Port  = Port;
     a84:	fc 01       	movw	r30, r24
     a86:	ee 0f       	add	r30, r30
     a88:	ff 1f       	adc	r31, r31
     a8a:	ee 0f       	add	r30, r30
     a8c:	ff 1f       	adc	r31, r31
     a8e:	e8 0f       	add	r30, r24
     a90:	f9 1f       	adc	r31, r25
     a92:	e5 5a       	subi	r30, 0xA5	; 165
     a94:	fc 4e       	sbci	r31, 0xEC	; 236
     a96:	31 83       	std	Z+1, r19	; 0x01
     a98:	20 83       	st	Z, r18
				PortStateTable[PTableEntry].State = State;
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	82 83       	std	Z+2, r24	; 0x02
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     a9e:	54 83       	std	Z+4, r21	; 0x04
     aa0:	43 83       	std	Z+3, r20	; 0x03
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     aa2:	08 95       	ret

00000aa4 <TCP_GetPortState>:
 *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 *
 *  \return A value from the TCP_PortStates_t enum
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
     aa4:	9c 01       	movw	r18, r24
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     aa6:	80 91 5b 13 	lds	r24, 0x135B
     aaa:	90 91 5c 13 	lds	r25, 0x135C
     aae:	82 17       	cp	r24, r18
     ab0:	93 07       	cpc	r25, r19
     ab2:	19 f4       	brne	.+6      	; 0xaba <TCP_GetPortState+0x16>
     ab4:	80 e0       	ldi	r24, 0x00	; 0
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	15 c0       	rjmp	.+42     	; 0xae4 <TCP_GetPortState+0x40>
     aba:	80 91 60 13 	lds	r24, 0x1360
     abe:	90 91 61 13 	lds	r25, 0x1361
     ac2:	82 17       	cp	r24, r18
     ac4:	93 07       	cpc	r25, r19
     ac6:	19 f4       	brne	.+6      	; 0xace <TCP_GetPortState+0x2a>
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	0b c0       	rjmp	.+22     	; 0xae4 <TCP_GetPortState+0x40>
     ace:	80 91 65 13 	lds	r24, 0x1365
     ad2:	90 91 66 13 	lds	r25, 0x1366
     ad6:	82 17       	cp	r24, r18
     ad8:	93 07       	cpc	r25, r19
     ada:	11 f0       	breq	.+4      	; 0xae0 <TCP_GetPortState+0x3c>
     adc:	80 e0       	ldi	r24, 0x00	; 0
     ade:	08 95       	ret
     ae0:	82 e0       	ldi	r24, 0x02	; 2
     ae2:	90 e0       	ldi	r25, 0x00	; 0
		  return PortStateTable[PTableEntry].State;
     ae4:	fc 01       	movw	r30, r24
     ae6:	ee 0f       	add	r30, r30
     ae8:	ff 1f       	adc	r31, r31
     aea:	ee 0f       	add	r30, r30
     aec:	ff 1f       	adc	r31, r31
     aee:	e8 0f       	add	r30, r24
     af0:	f9 1f       	adc	r31, r25
     af2:	e5 5a       	subi	r30, 0xA5	; 165
     af4:	fc 4e       	sbci	r31, 0xEC	; 236
     af6:	82 81       	ldd	r24, Z+2	; 0x02
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     af8:	08 95       	ret

00000afa <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               uint16_t TCPOutSize)
{
     afa:	2f 92       	push	r2
     afc:	3f 92       	push	r3
     afe:	4f 92       	push	r4
     b00:	5f 92       	push	r5
     b02:	6f 92       	push	r6
     b04:	7f 92       	push	r7
     b06:	8f 92       	push	r8
     b08:	9f 92       	push	r9
     b0a:	af 92       	push	r10
     b0c:	bf 92       	push	r11
     b0e:	cf 92       	push	r12
     b10:	df 92       	push	r13
     b12:	ef 92       	push	r14
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	df 93       	push	r29
     b1c:	cf 93       	push	r28
     b1e:	cd b7       	in	r28, 0x3d	; 61
     b20:	de b7       	in	r29, 0x3e	; 62
     b22:	2a 97       	sbiw	r28, 0x0a	; 10
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	f8 94       	cli
     b28:	de bf       	out	0x3e, r29	; 62
     b2a:	0f be       	out	0x3f, r0	; 63
     b2c:	cd bf       	out	0x3d, r28	; 61
     b2e:	9a 87       	std	Y+10, r25	; 0x0a
     b30:	89 87       	std	Y+9, r24	; 0x09
     b32:	3a 01       	movw	r6, r20
     b34:	49 83       	std	Y+1, r20	; 0x01
     b36:	5a 83       	std	Y+2, r21	; 0x02
     b38:	6b 83       	std	Y+3, r22	; 0x03
     b3a:	7c 83       	std	Y+4, r23	; 0x04
     b3c:	58 01       	movw	r10, r16
     b3e:	0d 83       	std	Y+5, r16	; 0x05
     b40:	1e 83       	std	Y+6, r17	; 0x06
     b42:	2f 83       	std	Y+7, r18	; 0x07
     b44:	38 87       	std	Y+8, r19	; 0x08
     b46:	b7 01       	movw	r22, r14
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
     b48:	88 24       	eor	r8, r8
     b4a:	99 24       	eor	r9, r9
	Checksum += ((uint16_t*)&SourceAddress)[1];
     b4c:	eb 80       	ldd	r14, Y+3	; 0x03
     b4e:	fc 80       	ldd	r15, Y+4	; 0x04
     b50:	00 e0       	ldi	r16, 0x00	; 0
     b52:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     b54:	cc 24       	eor	r12, r12
     b56:	dd 24       	eor	r13, r13
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     b58:	2f 81       	ldd	r18, Y+7	; 0x07
     b5a:	38 85       	ldd	r19, Y+8	; 0x08
     b5c:	40 e0       	ldi	r20, 0x00	; 0
     b5e:	50 e0       	ldi	r21, 0x00	; 0
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     b60:	87 2f       	mov	r24, r23
				Data.Bytes[1] = Temp;
     b62:	96 2f       	mov	r25, r22

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     b64:	1c 01       	movw	r2, r24
     b66:	44 24       	eor	r4, r4
     b68:	55 24       	eor	r5, r5
     b6a:	80 e0       	ldi	r24, 0x00	; 0
     b6c:	96 e0       	ldi	r25, 0x06	; 6
     b6e:	a0 e0       	ldi	r26, 0x00	; 0
     b70:	b0 e0       	ldi	r27, 0x00	; 0
     b72:	28 0e       	add	r2, r24
     b74:	39 1e       	adc	r3, r25
     b76:	4a 1e       	adc	r4, r26
     b78:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     b7a:	26 0c       	add	r2, r6
     b7c:	37 1c       	adc	r3, r7
     b7e:	48 1c       	adc	r4, r8
     b80:	59 1c       	adc	r5, r9
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     b82:	2a 0c       	add	r2, r10
     b84:	3b 1c       	adc	r3, r11
     b86:	4c 1c       	adc	r4, r12
     b88:	5d 1c       	adc	r5, r13
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     b8a:	2e 0c       	add	r2, r14
     b8c:	3f 1c       	adc	r3, r15
     b8e:	40 1e       	adc	r4, r16
     b90:	51 1e       	adc	r5, r17
	Checksum += SwapEndian_16(TCPOutSize);
     b92:	22 0e       	add	r2, r18
     b94:	33 1e       	adc	r3, r19
     b96:	44 1e       	adc	r4, r20
     b98:	55 1e       	adc	r5, r21

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     b9a:	fb 01       	movw	r30, r22
     b9c:	f6 95       	lsr	r31
     b9e:	e7 95       	ror	r30
     ba0:	49 85       	ldd	r20, Y+9	; 0x09
     ba2:	5a 85       	ldd	r21, Y+10	; 0x0a
     ba4:	20 e0       	ldi	r18, 0x00	; 0
     ba6:	30 e0       	ldi	r19, 0x00	; 0
     ba8:	0c c0       	rjmp	.+24     	; 0xbc2 <TCP_Checksum16+0xc8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     baa:	da 01       	movw	r26, r20
     bac:	8d 91       	ld	r24, X+
     bae:	9d 91       	ld	r25, X+
     bb0:	ad 01       	movw	r20, r26
     bb2:	a0 e0       	ldi	r26, 0x00	; 0
     bb4:	b0 e0       	ldi	r27, 0x00	; 0
     bb6:	28 0e       	add	r2, r24
     bb8:	39 1e       	adc	r3, r25
     bba:	4a 1e       	adc	r4, r26
     bbc:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     bbe:	2f 5f       	subi	r18, 0xFF	; 255
     bc0:	3f 4f       	sbci	r19, 0xFF	; 255
     bc2:	2e 17       	cp	r18, r30
     bc4:	3f 07       	cpc	r19, r31
     bc6:	88 f3       	brcs	.-30     	; 0xbaa <TCP_Checksum16+0xb0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     bc8:	60 ff       	sbrs	r22, 0
     bca:	17 c0       	rjmp	.+46     	; 0xbfa <TCP_Checksum16+0x100>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     bcc:	ee 0f       	add	r30, r30
     bce:	ff 1f       	adc	r31, r31
     bd0:	89 85       	ldd	r24, Y+9	; 0x09
     bd2:	9a 85       	ldd	r25, Y+10	; 0x0a
     bd4:	e8 0f       	add	r30, r24
     bd6:	f9 1f       	adc	r31, r25
     bd8:	80 81       	ld	r24, Z
     bda:	28 0e       	add	r2, r24
     bdc:	31 1c       	adc	r3, r1
     bde:	41 1c       	adc	r4, r1
     be0:	51 1c       	adc	r5, r1
     be2:	0b c0       	rjmp	.+22     	; 0xbfa <TCP_Checksum16+0x100>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     be4:	d2 01       	movw	r26, r4
     be6:	c1 01       	movw	r24, r2
     be8:	a0 70       	andi	r26, 0x00	; 0
     bea:	b0 70       	andi	r27, 0x00	; 0
     bec:	12 01       	movw	r2, r4
     bee:	44 24       	eor	r4, r4
     bf0:	55 24       	eor	r5, r5
     bf2:	28 0e       	add	r2, r24
     bf4:	39 1e       	adc	r3, r25
     bf6:	4a 1e       	adc	r4, r26
     bf8:	5b 1e       	adc	r5, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     bfa:	d2 01       	movw	r26, r4
     bfc:	c1 01       	movw	r24, r2
     bfe:	80 70       	andi	r24, 0x00	; 0
     c00:	90 70       	andi	r25, 0x00	; 0
     c02:	00 97       	sbiw	r24, 0x00	; 0
     c04:	a1 05       	cpc	r26, r1
     c06:	b1 05       	cpc	r27, r1
     c08:	69 f7       	brne	.-38     	; 0xbe4 <TCP_Checksum16+0xea>
     c0a:	91 01       	movw	r18, r2
     c0c:	20 95       	com	r18
     c0e:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     c10:	c9 01       	movw	r24, r18
     c12:	2a 96       	adiw	r28, 0x0a	; 10
     c14:	0f b6       	in	r0, 0x3f	; 63
     c16:	f8 94       	cli
     c18:	de bf       	out	0x3e, r29	; 62
     c1a:	0f be       	out	0x3f, r0	; 63
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	cf 91       	pop	r28
     c20:	df 91       	pop	r29
     c22:	1f 91       	pop	r17
     c24:	0f 91       	pop	r16
     c26:	ff 90       	pop	r15
     c28:	ef 90       	pop	r14
     c2a:	df 90       	pop	r13
     c2c:	cf 90       	pop	r12
     c2e:	bf 90       	pop	r11
     c30:	af 90       	pop	r10
     c32:	9f 90       	pop	r9
     c34:	8f 90       	pop	r8
     c36:	7f 90       	pop	r7
     c38:	6f 90       	pop	r6
     c3a:	5f 90       	pop	r5
     c3c:	4f 90       	pop	r4
     c3e:	3f 90       	pop	r3
     c40:	2f 90       	pop	r2
     c42:	08 95       	ret

00000c44 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     c44:	4f 92       	push	r4
     c46:	5f 92       	push	r5
     c48:	6f 92       	push	r6
     c4a:	7f 92       	push	r7
     c4c:	8f 92       	push	r8
     c4e:	9f 92       	push	r9
     c50:	af 92       	push	r10
     c52:	bf 92       	push	r11
     c54:	cf 92       	push	r12
     c56:	df 92       	push	r13
     c58:	ef 92       	push	r14
     c5a:	ff 92       	push	r15
     c5c:	0f 93       	push	r16
     c5e:	1f 93       	push	r17
     c60:	df 93       	push	r29
     c62:	cf 93       	push	r28
     c64:	00 d0       	rcall	.+0      	; 0xc66 <TCP_GetConnectionInfo+0x22>
     c66:	00 d0       	rcall	.+0      	; 0xc68 <TCP_GetConnectionInfo+0x24>
     c68:	cd b7       	in	r28, 0x3d	; 61
     c6a:	de b7       	in	r29, 0x3e	; 62
     c6c:	4c 01       	movw	r8, r24
     c6e:	49 83       	std	Y+1, r20	; 0x01
     c70:	5a 83       	std	Y+2, r21	; 0x02
     c72:	6b 83       	std	Y+3, r22	; 0x03
     c74:	7c 83       	std	Y+4, r23	; 0x04
     c76:	59 01       	movw	r10, r18
     c78:	29 e1       	ldi	r18, 0x19	; 25
     c7a:	e2 2e       	mov	r14, r18
     c7c:	2d e0       	ldi	r18, 0x0D	; 13
     c7e:	f2 2e       	mov	r15, r18
     c80:	00 e0       	ldi	r16, 0x00	; 0
     c82:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c84:	96 e1       	ldi	r25, 0x16	; 22
     c86:	49 2e       	mov	r4, r25
     c88:	92 e0       	ldi	r25, 0x02	; 2
     c8a:	59 2e       	mov	r5, r25
     c8c:	3e 01       	movw	r6, r28
     c8e:	08 94       	sec
     c90:	61 1c       	adc	r6, r1
     c92:	71 1c       	adc	r7, r1
     c94:	f7 01       	movw	r30, r14
     c96:	80 81       	ld	r24, Z
     c98:	91 81       	ldd	r25, Z+1	; 0x01
     c9a:	88 15       	cp	r24, r8
     c9c:	99 05       	cpc	r25, r9
     c9e:	d9 f4       	brne	.+54     	; 0xcd6 <TCP_GetConnectionInfo+0x92>
     ca0:	04 9d       	mul	r16, r4
     ca2:	60 01       	movw	r12, r0
     ca4:	05 9d       	mul	r16, r5
     ca6:	d0 0c       	add	r13, r0
     ca8:	14 9d       	mul	r17, r4
     caa:	d0 0c       	add	r13, r0
     cac:	11 24       	eor	r1, r1
     cae:	c6 01       	movw	r24, r12
     cb0:	83 5e       	subi	r24, 0xE3	; 227
     cb2:	92 4f       	sbci	r25, 0xF2	; 242
     cb4:	b3 01       	movw	r22, r6
     cb6:	44 e0       	ldi	r20, 0x04	; 4
     cb8:	50 e0       	ldi	r21, 0x00	; 0
     cba:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
     cbe:	00 97       	sbiw	r24, 0x00	; 0
     cc0:	51 f4       	brne	.+20     	; 0xcd6 <TCP_GetConnectionInfo+0x92>
     cc2:	f7 01       	movw	r30, r14
     cc4:	82 81       	ldd	r24, Z+2	; 0x02
     cc6:	93 81       	ldd	r25, Z+3	; 0x03
     cc8:	8a 15       	cp	r24, r10
     cca:	9b 05       	cpc	r25, r11
     ccc:	21 f4       	brne	.+8      	; 0xcd6 <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     cce:	96 01       	movw	r18, r12
     cd0:	2f 5d       	subi	r18, 0xDF	; 223
     cd2:	32 4f       	sbci	r19, 0xF2	; 242
     cd4:	0b c0       	rjmp	.+22     	; 0xcec <TCP_GetConnectionInfo+0xa8>
     cd6:	0f 5f       	subi	r16, 0xFF	; 255
     cd8:	1f 4f       	sbci	r17, 0xFF	; 255
     cda:	86 e1       	ldi	r24, 0x16	; 22
     cdc:	92 e0       	ldi	r25, 0x02	; 2
     cde:	e8 0e       	add	r14, r24
     ce0:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     ce2:	03 30       	cpi	r16, 0x03	; 3
     ce4:	11 05       	cpc	r17, r1
     ce6:	b1 f6       	brne	.-84     	; 0xc94 <TCP_GetConnectionInfo+0x50>
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     cec:	c9 01       	movw	r24, r18
     cee:	0f 90       	pop	r0
     cf0:	0f 90       	pop	r0
     cf2:	0f 90       	pop	r0
     cf4:	0f 90       	pop	r0
     cf6:	cf 91       	pop	r28
     cf8:	df 91       	pop	r29
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	ff 90       	pop	r15
     d00:	ef 90       	pop	r14
     d02:	df 90       	pop	r13
     d04:	cf 90       	pop	r12
     d06:	bf 90       	pop	r11
     d08:	af 90       	pop	r10
     d0a:	9f 90       	pop	r9
     d0c:	8f 90       	pop	r8
     d0e:	7f 90       	pop	r7
     d10:	6f 90       	pop	r6
     d12:	5f 90       	pop	r5
     d14:	4f 90       	pop	r4
     d16:	08 95       	ret

00000d18 <TCP_GetConnectionState>:
 *  \return A value from the TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     d18:	4f 92       	push	r4
     d1a:	5f 92       	push	r5
     d1c:	6f 92       	push	r6
     d1e:	7f 92       	push	r7
     d20:	8f 92       	push	r8
     d22:	9f 92       	push	r9
     d24:	af 92       	push	r10
     d26:	bf 92       	push	r11
     d28:	cf 92       	push	r12
     d2a:	df 92       	push	r13
     d2c:	ef 92       	push	r14
     d2e:	ff 92       	push	r15
     d30:	0f 93       	push	r16
     d32:	1f 93       	push	r17
     d34:	df 93       	push	r29
     d36:	cf 93       	push	r28
     d38:	00 d0       	rcall	.+0      	; 0xd3a <TCP_GetConnectionState+0x22>
     d3a:	00 d0       	rcall	.+0      	; 0xd3c <TCP_GetConnectionState+0x24>
     d3c:	cd b7       	in	r28, 0x3d	; 61
     d3e:	de b7       	in	r29, 0x3e	; 62
     d40:	4c 01       	movw	r8, r24
     d42:	49 83       	std	Y+1, r20	; 0x01
     d44:	5a 83       	std	Y+2, r21	; 0x02
     d46:	6b 83       	std	Y+3, r22	; 0x03
     d48:	7c 83       	std	Y+4, r23	; 0x04
     d4a:	59 01       	movw	r10, r18
     d4c:	49 e1       	ldi	r20, 0x19	; 25
     d4e:	e4 2e       	mov	r14, r20
     d50:	4d e0       	ldi	r20, 0x0D	; 13
     d52:	f4 2e       	mov	r15, r20
     d54:	00 e0       	ldi	r16, 0x00	; 0
     d56:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d58:	36 e1       	ldi	r19, 0x16	; 22
     d5a:	43 2e       	mov	r4, r19
     d5c:	32 e0       	ldi	r19, 0x02	; 2
     d5e:	53 2e       	mov	r5, r19
     d60:	3e 01       	movw	r6, r28
     d62:	08 94       	sec
     d64:	61 1c       	adc	r6, r1
     d66:	71 1c       	adc	r7, r1
     d68:	f7 01       	movw	r30, r14
     d6a:	80 81       	ld	r24, Z
     d6c:	91 81       	ldd	r25, Z+1	; 0x01
     d6e:	88 15       	cp	r24, r8
     d70:	99 05       	cpc	r25, r9
     d72:	e1 f4       	brne	.+56     	; 0xdac <TCP_GetConnectionState+0x94>
     d74:	04 9d       	mul	r16, r4
     d76:	60 01       	movw	r12, r0
     d78:	05 9d       	mul	r16, r5
     d7a:	d0 0c       	add	r13, r0
     d7c:	14 9d       	mul	r17, r4
     d7e:	d0 0c       	add	r13, r0
     d80:	11 24       	eor	r1, r1
     d82:	c6 01       	movw	r24, r12
     d84:	83 5e       	subi	r24, 0xE3	; 227
     d86:	92 4f       	sbci	r25, 0xF2	; 242
     d88:	b3 01       	movw	r22, r6
     d8a:	44 e0       	ldi	r20, 0x04	; 4
     d8c:	50 e0       	ldi	r21, 0x00	; 0
     d8e:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
     d92:	00 97       	sbiw	r24, 0x00	; 0
     d94:	59 f4       	brne	.+22     	; 0xdac <TCP_GetConnectionState+0x94>
     d96:	f7 01       	movw	r30, r14
     d98:	82 81       	ldd	r24, Z+2	; 0x02
     d9a:	93 81       	ldd	r25, Z+3	; 0x03
     d9c:	8a 15       	cp	r24, r10
     d9e:	9b 05       	cpc	r25, r11
     da0:	29 f4       	brne	.+10     	; 0xdac <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     da2:	f6 01       	movw	r30, r12
     da4:	e2 5d       	subi	r30, 0xD2	; 210
     da6:	f0 4f       	sbci	r31, 0xF0	; 240
     da8:	80 81       	ld	r24, Z
     daa:	0a c0       	rjmp	.+20     	; 0xdc0 <TCP_GetConnectionState+0xa8>
     dac:	0f 5f       	subi	r16, 0xFF	; 255
     dae:	1f 4f       	sbci	r17, 0xFF	; 255
     db0:	86 e1       	ldi	r24, 0x16	; 22
     db2:	92 e0       	ldi	r25, 0x02	; 2
     db4:	e8 0e       	add	r14, r24
     db6:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     db8:	03 30       	cpi	r16, 0x03	; 3
     dba:	11 05       	cpc	r17, r1
     dbc:	a9 f6       	brne	.-86     	; 0xd68 <TCP_GetConnectionState+0x50>
     dbe:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     dc0:	0f 90       	pop	r0
     dc2:	0f 90       	pop	r0
     dc4:	0f 90       	pop	r0
     dc6:	0f 90       	pop	r0
     dc8:	cf 91       	pop	r28
     dca:	df 91       	pop	r29
     dcc:	1f 91       	pop	r17
     dce:	0f 91       	pop	r16
     dd0:	ff 90       	pop	r15
     dd2:	ef 90       	pop	r14
     dd4:	df 90       	pop	r13
     dd6:	cf 90       	pop	r12
     dd8:	bf 90       	pop	r11
     dda:	af 90       	pop	r10
     ddc:	9f 90       	pop	r9
     dde:	8f 90       	pop	r8
     de0:	7f 90       	pop	r7
     de2:	6f 90       	pop	r6
     de4:	5f 90       	pop	r5
     de6:	4f 90       	pop	r4
     de8:	08 95       	ret

00000dea <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     dea:	3f 92       	push	r3
     dec:	4f 92       	push	r4
     dee:	5f 92       	push	r5
     df0:	6f 92       	push	r6
     df2:	7f 92       	push	r7
     df4:	8f 92       	push	r8
     df6:	9f 92       	push	r9
     df8:	af 92       	push	r10
     dfa:	bf 92       	push	r11
     dfc:	cf 92       	push	r12
     dfe:	df 92       	push	r13
     e00:	ef 92       	push	r14
     e02:	ff 92       	push	r15
     e04:	0f 93       	push	r16
     e06:	1f 93       	push	r17
     e08:	df 93       	push	r29
     e0a:	cf 93       	push	r28
     e0c:	00 d0       	rcall	.+0      	; 0xe0e <TCP_SetConnectionState+0x24>
     e0e:	00 d0       	rcall	.+0      	; 0xe10 <TCP_SetConnectionState+0x26>
     e10:	cd b7       	in	r28, 0x3d	; 61
     e12:	de b7       	in	r29, 0x3e	; 62
     e14:	5c 01       	movw	r10, r24
     e16:	49 83       	std	Y+1, r20	; 0x01
     e18:	5a 83       	std	Y+2, r21	; 0x02
     e1a:	6b 83       	std	Y+3, r22	; 0x03
     e1c:	7c 83       	std	Y+4, r23	; 0x04
     e1e:	49 01       	movw	r8, r18
     e20:	30 2e       	mov	r3, r16
     e22:	79 e1       	ldi	r23, 0x19	; 25
     e24:	e7 2e       	mov	r14, r23
     e26:	7d e0       	ldi	r23, 0x0D	; 13
     e28:	f7 2e       	mov	r15, r23
     e2a:	00 e0       	ldi	r16, 0x00	; 0
     e2c:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     e2e:	66 e1       	ldi	r22, 0x16	; 22
     e30:	46 2e       	mov	r4, r22
     e32:	62 e0       	ldi	r22, 0x02	; 2
     e34:	56 2e       	mov	r5, r22
     e36:	3e 01       	movw	r6, r28
     e38:	08 94       	sec
     e3a:	61 1c       	adc	r6, r1
     e3c:	71 1c       	adc	r7, r1
     e3e:	f7 01       	movw	r30, r14
     e40:	80 81       	ld	r24, Z
     e42:	91 81       	ldd	r25, Z+1	; 0x01
     e44:	8a 15       	cp	r24, r10
     e46:	9b 05       	cpc	r25, r11
     e48:	d9 f4       	brne	.+54     	; 0xe80 <TCP_SetConnectionState+0x96>
     e4a:	04 9d       	mul	r16, r4
     e4c:	60 01       	movw	r12, r0
     e4e:	05 9d       	mul	r16, r5
     e50:	d0 0c       	add	r13, r0
     e52:	14 9d       	mul	r17, r4
     e54:	d0 0c       	add	r13, r0
     e56:	11 24       	eor	r1, r1
     e58:	c6 01       	movw	r24, r12
     e5a:	83 5e       	subi	r24, 0xE3	; 227
     e5c:	92 4f       	sbci	r25, 0xF2	; 242
     e5e:	b3 01       	movw	r22, r6
     e60:	44 e0       	ldi	r20, 0x04	; 4
     e62:	50 e0       	ldi	r21, 0x00	; 0
     e64:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
     e68:	00 97       	sbiw	r24, 0x00	; 0
     e6a:	51 f4       	brne	.+20     	; 0xe80 <TCP_SetConnectionState+0x96>
     e6c:	f7 01       	movw	r30, r14
     e6e:	82 81       	ldd	r24, Z+2	; 0x02
     e70:	93 81       	ldd	r25, Z+3	; 0x03
     e72:	88 15       	cp	r24, r8
     e74:	99 05       	cpc	r25, r9
     e76:	21 f4       	brne	.+8      	; 0xe80 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     e78:	f6 01       	movw	r30, r12
     e7a:	e2 5d       	subi	r30, 0xD2	; 210
     e7c:	f0 4f       	sbci	r31, 0xF0	; 240
     e7e:	47 c0       	rjmp	.+142    	; 0xf0e <TCP_SetConnectionState+0x124>
			return true;
     e80:	0f 5f       	subi	r16, 0xFF	; 255
     e82:	1f 4f       	sbci	r17, 0xFF	; 255
     e84:	86 e1       	ldi	r24, 0x16	; 22
     e86:	92 e0       	ldi	r25, 0x02	; 2
     e88:	e8 0e       	add	r14, r24
     e8a:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     e8c:	03 30       	cpi	r16, 0x03	; 3
     e8e:	11 05       	cpc	r17, r1
     e90:	b1 f6       	brne	.-84     	; 0xe3e <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     e92:	80 91 2e 0f 	lds	r24, 0x0F2E
     e96:	8a 30       	cpi	r24, 0x0A	; 10
     e98:	19 f4       	brne	.+6      	; 0xea0 <TCP_SetConnectionState+0xb6>
     e9a:	40 e0       	ldi	r20, 0x00	; 0
     e9c:	50 e0       	ldi	r21, 0x00	; 0
     e9e:	0f c0       	rjmp	.+30     	; 0xebe <TCP_SetConnectionState+0xd4>
     ea0:	80 91 44 11 	lds	r24, 0x1144
     ea4:	8a 30       	cpi	r24, 0x0A	; 10
     ea6:	19 f4       	brne	.+6      	; 0xeae <TCP_SetConnectionState+0xc4>
     ea8:	41 e0       	ldi	r20, 0x01	; 1
     eaa:	50 e0       	ldi	r21, 0x00	; 0
     eac:	08 c0       	rjmp	.+16     	; 0xebe <TCP_SetConnectionState+0xd4>
     eae:	80 91 5a 13 	lds	r24, 0x135A
     eb2:	8a 30       	cpi	r24, 0x0A	; 10
     eb4:	11 f0       	breq	.+4      	; 0xeba <TCP_SetConnectionState+0xd0>
     eb6:	80 e0       	ldi	r24, 0x00	; 0
     eb8:	2c c0       	rjmp	.+88     	; 0xf12 <TCP_SetConnectionState+0x128>
     eba:	42 e0       	ldi	r20, 0x02	; 2
     ebc:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     ebe:	86 e1       	ldi	r24, 0x16	; 22
     ec0:	92 e0       	ldi	r25, 0x02	; 2
     ec2:	48 9f       	mul	r20, r24
     ec4:	90 01       	movw	r18, r0
     ec6:	49 9f       	mul	r20, r25
     ec8:	30 0d       	add	r19, r0
     eca:	58 9f       	mul	r21, r24
     ecc:	30 0d       	add	r19, r0
     ece:	11 24       	eor	r1, r1
     ed0:	27 5e       	subi	r18, 0xE7	; 231
     ed2:	32 4f       	sbci	r19, 0xF2	; 242
     ed4:	f9 01       	movw	r30, r18
     ed6:	b1 82       	std	Z+1, r11	; 0x01
     ed8:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     eda:	89 81       	ldd	r24, Y+1	; 0x01
     edc:	9a 81       	ldd	r25, Y+2	; 0x02
     ede:	ab 81       	ldd	r26, Y+3	; 0x03
     ee0:	bc 81       	ldd	r27, Y+4	; 0x04
     ee2:	84 83       	std	Z+4, r24	; 0x04
     ee4:	95 83       	std	Z+5, r25	; 0x05
     ee6:	a6 83       	std	Z+6, r26	; 0x06
     ee8:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     eea:	8b e0       	ldi	r24, 0x0B	; 11
     eec:	91 e0       	ldi	r25, 0x01	; 1
     eee:	48 9f       	mul	r20, r24
     ef0:	f0 01       	movw	r30, r0
     ef2:	49 9f       	mul	r20, r25
     ef4:	f0 0d       	add	r31, r0
     ef6:	58 9f       	mul	r21, r24
     ef8:	f0 0d       	add	r31, r0
     efa:	11 24       	eor	r1, r1
     efc:	ee 0f       	add	r30, r30
     efe:	ff 1f       	adc	r31, r31
     f00:	e5 5e       	subi	r30, 0xE5	; 229
     f02:	f2 4f       	sbci	r31, 0xF2	; 242
     f04:	91 82       	std	Z+1, r9	; 0x01
     f06:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     f08:	2b 5e       	subi	r18, 0xEB	; 235
     f0a:	3d 4f       	sbci	r19, 0xFD	; 253
     f0c:	f9 01       	movw	r30, r18
     f0e:	30 82       	st	Z, r3
     f10:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	1f 91       	pop	r17
     f20:	0f 91       	pop	r16
     f22:	ff 90       	pop	r15
     f24:	ef 90       	pop	r14
     f26:	df 90       	pop	r13
     f28:	cf 90       	pop	r12
     f2a:	bf 90       	pop	r11
     f2c:	af 90       	pop	r10
     f2e:	9f 90       	pop	r9
     f30:	8f 90       	pop	r8
     f32:	7f 90       	pop	r7
     f34:	6f 90       	pop	r6
     f36:	5f 90       	pop	r5
     f38:	4f 90       	pop	r4
     f3a:	3f 90       	pop	r3
     f3c:	08 95       	ret

00000f3e <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     f3e:	af 92       	push	r10
     f40:	bf 92       	push	r11
     f42:	cf 92       	push	r12
     f44:	df 92       	push	r13
     f46:	ef 92       	push	r14
     f48:	ff 92       	push	r15
     f4a:	0f 93       	push	r16
     f4c:	1f 93       	push	r17
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
     f52:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     f54:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     f56:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     f58:	cb 01       	movw	r24, r22
     f5a:	09 dd       	rcall	.-1518   	; 0x96e <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     f5c:	d7 01       	movw	r26, r14
     f5e:	12 96       	adiw	r26, 0x02	; 2
     f60:	8d 91       	ld	r24, X+
     f62:	9c 91       	ld	r25, X
     f64:	13 97       	sbiw	r26, 0x03	; 3
     f66:	9e dd       	rcall	.-1220   	; 0xaa4 <TCP_GetPortState>
     f68:	81 30       	cpi	r24, 0x01	; 1
     f6a:	09 f0       	breq	.+2      	; 0xf6e <TCP_ProcessTCPPacket+0x30>
     f6c:	2a c2       	rjmp	.+1108   	; 0x13c2 <TCP_ProcessTCPPacket+0x484>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     f6e:	e7 01       	movw	r28, r14
     f70:	8d 85       	ldd	r24, Y+13	; 0x0d
     f72:	81 ff       	sbrs	r24, 1
     f74:	0b c0       	rjmp	.+22     	; 0xf8c <TCP_ProcessTCPPacket+0x4e>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     f76:	f5 01       	movw	r30, r10
     f78:	44 85       	ldd	r20, Z+12	; 0x0c
     f7a:	55 85       	ldd	r21, Z+13	; 0x0d
     f7c:	66 85       	ldd	r22, Z+14	; 0x0e
     f7e:	77 85       	ldd	r23, Z+15	; 0x0f
     f80:	28 81       	ld	r18, Y
     f82:	39 81       	ldd	r19, Y+1	; 0x01
     f84:	8a 81       	ldd	r24, Y+2	; 0x02
     f86:	9b 81       	ldd	r25, Y+3	; 0x03
     f88:	00 e0       	ldi	r16, 0x00	; 0
     f8a:	2f df       	rcall	.-418    	; 0xdea <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     f8c:	d7 01       	movw	r26, r14
     f8e:	1d 96       	adiw	r26, 0x0d	; 13
     f90:	8c 91       	ld	r24, X
     f92:	1d 97       	sbiw	r26, 0x0d	; 13
     f94:	12 96       	adiw	r26, 0x02	; 2
     f96:	ed 91       	ld	r30, X+
     f98:	fc 91       	ld	r31, X
     f9a:	13 97       	sbiw	r26, 0x03	; 3
     f9c:	e5 01       	movw	r28, r10
     f9e:	4c 85       	ldd	r20, Y+12	; 0x0c
     fa0:	5d 85       	ldd	r21, Y+13	; 0x0d
     fa2:	6e 85       	ldd	r22, Y+14	; 0x0e
     fa4:	7f 85       	ldd	r23, Y+15	; 0x0f
     fa6:	2d 91       	ld	r18, X+
     fa8:	3c 91       	ld	r19, X
     faa:	82 ff       	sbrs	r24, 2
     fac:	08 c0       	rjmp	.+16     	; 0xfbe <TCP_ProcessTCPPacket+0x80>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     fae:	cf 01       	movw	r24, r30
     fb0:	0a e0       	ldi	r16, 0x0A	; 10
     fb2:	1b df       	rcall	.-458    	; 0xdea <TCP_SetConnectionState>
     fb4:	88 23       	and	r24, r24
     fb6:	09 f4       	brne	.+2      	; 0xfba <TCP_ProcessTCPPacket+0x7c>
     fb8:	38 c2       	rjmp	.+1136   	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     fba:	84 e1       	ldi	r24, 0x14	; 20
     fbc:	5d c0       	rjmp	.+186    	; 0x1078 <TCP_ProcessTCPPacket+0x13a>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     fbe:	cf 01       	movw	r24, r30
     fc0:	ab de       	rcall	.-682    	; 0xd18 <TCP_GetConnectionState>
     fc2:	84 30       	cpi	r24, 0x04	; 4
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <TCP_ProcessTCPPacket+0x8a>
     fc6:	68 c1       	rjmp	.+720    	; 0x1298 <TCP_ProcessTCPPacket+0x35a>
     fc8:	85 30       	cpi	r24, 0x05	; 5
     fca:	48 f4       	brcc	.+18     	; 0xfde <TCP_ProcessTCPPacket+0xa0>
     fcc:	82 30       	cpi	r24, 0x02	; 2
     fce:	09 f4       	brne	.+2      	; 0xfd2 <TCP_ProcessTCPPacket+0x94>
     fd0:	56 c0       	rjmp	.+172    	; 0x107e <TCP_ProcessTCPPacket+0x140>
     fd2:	83 30       	cpi	r24, 0x03	; 3
     fd4:	08 f0       	brcs	.+2      	; 0xfd8 <TCP_ProcessTCPPacket+0x9a>
     fd6:	7f c0       	rjmp	.+254    	; 0x10d6 <TCP_ProcessTCPPacket+0x198>
     fd8:	88 23       	and	r24, r24
     fda:	59 f0       	breq	.+22     	; 0xff2 <TCP_ProcessTCPPacket+0xb4>
     fdc:	26 c2       	rjmp	.+1100   	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
     fde:	86 30       	cpi	r24, 0x06	; 6
     fe0:	09 f4       	brne	.+2      	; 0xfe4 <TCP_ProcessTCPPacket+0xa6>
     fe2:	dc c1       	rjmp	.+952    	; 0x139c <TCP_ProcessTCPPacket+0x45e>
     fe4:	86 30       	cpi	r24, 0x06	; 6
     fe6:	08 f4       	brcc	.+2      	; 0xfea <TCP_ProcessTCPPacket+0xac>
     fe8:	9e c1       	rjmp	.+828    	; 0x1326 <TCP_ProcessTCPPacket+0x3e8>
     fea:	87 30       	cpi	r24, 0x07	; 7
     fec:	09 f0       	breq	.+2      	; 0xff0 <TCP_ProcessTCPPacket+0xb2>
     fee:	1d c2       	rjmp	.+1082   	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
     ff0:	35 c1       	rjmp	.+618    	; 0x125c <TCP_ProcessTCPPacket+0x31e>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     ff2:	d7 01       	movw	r26, r14
     ff4:	1d 96       	adiw	r26, 0x0d	; 13
     ff6:	8c 91       	ld	r24, X
     ff8:	1d 97       	sbiw	r26, 0x0d	; 13
     ffa:	82 30       	cpi	r24, 0x02	; 2
     ffc:	09 f0       	breq	.+2      	; 0x1000 <TCP_ProcessTCPPacket+0xc2>
     ffe:	15 c2       	rjmp	.+1066   	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1000:	e5 01       	movw	r28, r10
    1002:	4c 85       	ldd	r20, Y+12	; 0x0c
    1004:	5d 85       	ldd	r21, Y+13	; 0x0d
    1006:	6e 85       	ldd	r22, Y+14	; 0x0e
    1008:	7f 85       	ldd	r23, Y+15	; 0x0f
    100a:	2d 91       	ld	r18, X+
    100c:	3c 91       	ld	r19, X
    100e:	11 97       	sbiw	r26, 0x01	; 1
    1010:	12 96       	adiw	r26, 0x02	; 2
    1012:	8d 91       	ld	r24, X+
    1014:	9c 91       	ld	r25, X
    1016:	13 97       	sbiw	r26, 0x03	; 3
    1018:	02 e0       	ldi	r16, 0x02	; 2
    101a:	e7 de       	rcall	.-562    	; 0xdea <TCP_SetConnectionState>
    101c:	88 23       	and	r24, r24
    101e:	59 f1       	breq	.+86     	; 0x1076 <TCP_ProcessTCPPacket+0x138>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    1020:	82 e1       	ldi	r24, 0x12	; 18
    1022:	f6 01       	movw	r30, r12
    1024:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    1026:	4c 85       	ldd	r20, Y+12	; 0x0c
    1028:	5d 85       	ldd	r21, Y+13	; 0x0d
    102a:	6e 85       	ldd	r22, Y+14	; 0x0e
    102c:	7f 85       	ldd	r23, Y+15	; 0x0f
    102e:	d7 01       	movw	r26, r14
    1030:	2d 91       	ld	r18, X+
    1032:	3c 91       	ld	r19, X
    1034:	11 97       	sbiw	r26, 0x01	; 1
    1036:	12 96       	adiw	r26, 0x02	; 2
    1038:	8d 91       	ld	r24, X+
    103a:	9c 91       	ld	r25, X
    103c:	13 97       	sbiw	r26, 0x03	; 3
    103e:	02 de       	rcall	.-1020   	; 0xc44 <TCP_GetConnectionInfo>
    1040:	fc 01       	movw	r30, r24
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    1042:	e7 01       	movw	r28, r14
    1044:	8c 81       	ldd	r24, Y+4	; 0x04
    1046:	9d 81       	ldd	r25, Y+5	; 0x05
    1048:	ae 81       	ldd	r26, Y+6	; 0x06
    104a:	bf 81       	ldd	r27, Y+7	; 0x07

				Temp = Data.Bytes[0];
    104c:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[3];
    104e:	8b 2f       	mov	r24, r27
				Data.Bytes[3] = Temp;
    1050:	b2 2f       	mov	r27, r18

				Temp = Data.Bytes[1];
    1052:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    1054:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    1056:	a2 2f       	mov	r26, r18

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    1058:	01 96       	adiw	r24, 0x01	; 1
    105a:	a1 1d       	adc	r26, r1
    105c:	b1 1d       	adc	r27, r1
    105e:	80 83       	st	Z, r24
    1060:	91 83       	std	Z+1, r25	; 0x01
    1062:	a2 83       	std	Z+2, r26	; 0x02
    1064:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
    1066:	14 82       	std	Z+4, r1	; 0x04
    1068:	15 82       	std	Z+5, r1	; 0x05
    106a:	16 82       	std	Z+6, r1	; 0x06
    106c:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
    106e:	e4 5f       	subi	r30, 0xF4	; 244
    1070:	fd 4f       	sbci	r31, 0xFD	; 253
    1072:	10 82       	st	Z, r1
    1074:	e8 c1       	rjmp	.+976    	; 0x1446 <TCP_ProcessTCPPacket+0x508>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    1076:	84 e0       	ldi	r24, 0x04	; 4
    1078:	f6 01       	movw	r30, r12
    107a:	85 87       	std	Z+13, r24	; 0x0d
    107c:	e4 c1       	rjmp	.+968    	; 0x1446 <TCP_ProcessTCPPacket+0x508>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    107e:	d7 01       	movw	r26, r14
    1080:	1d 96       	adiw	r26, 0x0d	; 13
    1082:	8c 91       	ld	r24, X
    1084:	1d 97       	sbiw	r26, 0x0d	; 13
    1086:	80 31       	cpi	r24, 0x10	; 16
    1088:	09 f0       	breq	.+2      	; 0x108c <TCP_ProcessTCPPacket+0x14e>
    108a:	cf c1       	rjmp	.+926    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    108c:	e5 01       	movw	r28, r10
    108e:	4c 85       	ldd	r20, Y+12	; 0x0c
    1090:	5d 85       	ldd	r21, Y+13	; 0x0d
    1092:	6e 85       	ldd	r22, Y+14	; 0x0e
    1094:	7f 85       	ldd	r23, Y+15	; 0x0f
    1096:	2d 91       	ld	r18, X+
    1098:	3c 91       	ld	r19, X
    109a:	11 97       	sbiw	r26, 0x01	; 1
    109c:	12 96       	adiw	r26, 0x02	; 2
    109e:	8d 91       	ld	r24, X+
    10a0:	9c 91       	ld	r25, X
    10a2:	13 97       	sbiw	r26, 0x03	; 3
    10a4:	03 e0       	ldi	r16, 0x03	; 3
    10a6:	a1 de       	rcall	.-702    	; 0xdea <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10a8:	4c 85       	ldd	r20, Y+12	; 0x0c
    10aa:	5d 85       	ldd	r21, Y+13	; 0x0d
    10ac:	6e 85       	ldd	r22, Y+14	; 0x0e
    10ae:	7f 85       	ldd	r23, Y+15	; 0x0f
    10b0:	f7 01       	movw	r30, r14
    10b2:	20 81       	ld	r18, Z
    10b4:	31 81       	ldd	r19, Z+1	; 0x01
    10b6:	82 81       	ldd	r24, Z+2	; 0x02
    10b8:	93 81       	ldd	r25, Z+3	; 0x03
    10ba:	c4 dd       	rcall	.-1144   	; 0xc44 <TCP_GetConnectionInfo>
    10bc:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    10be:	84 81       	ldd	r24, Z+4	; 0x04
    10c0:	95 81       	ldd	r25, Z+5	; 0x05
    10c2:	a6 81       	ldd	r26, Z+6	; 0x06
    10c4:	b7 81       	ldd	r27, Z+7	; 0x07
    10c6:	01 96       	adiw	r24, 0x01	; 1
    10c8:	a1 1d       	adc	r26, r1
    10ca:	b1 1d       	adc	r27, r1
    10cc:	84 83       	std	Z+4, r24	; 0x04
    10ce:	95 83       	std	Z+5, r25	; 0x05
    10d0:	a6 83       	std	Z+6, r26	; 0x06
    10d2:	b7 83       	std	Z+7, r27	; 0x07
    10d4:	aa c1       	rjmp	.+852    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    10d6:	d7 01       	movw	r26, r14
    10d8:	1d 96       	adiw	r26, 0x0d	; 13
    10da:	8c 91       	ld	r24, X
    10dc:	1d 97       	sbiw	r26, 0x0d	; 13
    10de:	81 31       	cpi	r24, 0x11	; 17
    10e0:	a9 f5       	brne	.+106    	; 0x114c <TCP_ProcessTCPPacket+0x20e>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    10e2:	e6 01       	movw	r28, r12
    10e4:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10e6:	f5 01       	movw	r30, r10
    10e8:	44 85       	ldd	r20, Z+12	; 0x0c
    10ea:	55 85       	ldd	r21, Z+13	; 0x0d
    10ec:	66 85       	ldd	r22, Z+14	; 0x0e
    10ee:	77 85       	ldd	r23, Z+15	; 0x0f
    10f0:	2d 91       	ld	r18, X+
    10f2:	3c 91       	ld	r19, X
    10f4:	11 97       	sbiw	r26, 0x01	; 1
    10f6:	12 96       	adiw	r26, 0x02	; 2
    10f8:	8d 91       	ld	r24, X+
    10fa:	9c 91       	ld	r25, X
    10fc:	13 97       	sbiw	r26, 0x03	; 3
    10fe:	06 e0       	ldi	r16, 0x06	; 6
    1100:	74 de       	rcall	.-792    	; 0xdea <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1102:	d5 01       	movw	r26, r10
    1104:	1c 96       	adiw	r26, 0x0c	; 12
    1106:	4d 91       	ld	r20, X+
    1108:	5d 91       	ld	r21, X+
    110a:	6d 91       	ld	r22, X+
    110c:	7c 91       	ld	r23, X
    110e:	1f 97       	sbiw	r26, 0x0f	; 15
    1110:	e7 01       	movw	r28, r14
    1112:	28 81       	ld	r18, Y
    1114:	39 81       	ldd	r19, Y+1	; 0x01
    1116:	8a 81       	ldd	r24, Y+2	; 0x02
    1118:	9b 81       	ldd	r25, Y+3	; 0x03
    111a:	94 dd       	rcall	.-1240   	; 0xc44 <TCP_GetConnectionInfo>
    111c:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    111e:	80 81       	ld	r24, Z
    1120:	91 81       	ldd	r25, Z+1	; 0x01
    1122:	a2 81       	ldd	r26, Z+2	; 0x02
    1124:	b3 81       	ldd	r27, Z+3	; 0x03
    1126:	01 96       	adiw	r24, 0x01	; 1
    1128:	a1 1d       	adc	r26, r1
    112a:	b1 1d       	adc	r27, r1
    112c:	80 83       	st	Z, r24
    112e:	91 83       	std	Z+1, r25	; 0x01
    1130:	a2 83       	std	Z+2, r26	; 0x02
    1132:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1134:	84 81       	ldd	r24, Z+4	; 0x04
    1136:	95 81       	ldd	r25, Z+5	; 0x05
    1138:	a6 81       	ldd	r26, Z+6	; 0x06
    113a:	b7 81       	ldd	r27, Z+7	; 0x07
    113c:	01 96       	adiw	r24, 0x01	; 1
    113e:	a1 1d       	adc	r26, r1
    1140:	b1 1d       	adc	r27, r1
    1142:	84 83       	std	Z+4, r24	; 0x04
    1144:	95 83       	std	Z+5, r25	; 0x05
    1146:	a6 83       	std	Z+6, r26	; 0x06
    1148:	b7 83       	std	Z+7, r27	; 0x07
    114a:	7d c1       	rjmp	.+762    	; 0x1446 <TCP_ProcessTCPPacket+0x508>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    114c:	80 31       	cpi	r24, 0x10	; 16
    114e:	19 f0       	breq	.+6      	; 0x1156 <TCP_ProcessTCPPacket+0x218>
    1150:	88 31       	cpi	r24, 0x18	; 24
    1152:	09 f0       	breq	.+2      	; 0x1156 <TCP_ProcessTCPPacket+0x218>
    1154:	6a c1       	rjmp	.+724    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1156:	f5 01       	movw	r30, r10
    1158:	44 85       	ldd	r20, Z+12	; 0x0c
    115a:	55 85       	ldd	r21, Z+13	; 0x0d
    115c:	66 85       	ldd	r22, Z+14	; 0x0e
    115e:	77 85       	ldd	r23, Z+15	; 0x0f
    1160:	d7 01       	movw	r26, r14
    1162:	2d 91       	ld	r18, X+
    1164:	3c 91       	ld	r19, X
    1166:	11 97       	sbiw	r26, 0x01	; 1
    1168:	12 96       	adiw	r26, 0x02	; 2
    116a:	8d 91       	ld	r24, X+
    116c:	9c 91       	ld	r25, X
    116e:	13 97       	sbiw	r26, 0x03	; 3
    1170:	69 dd       	rcall	.-1326   	; 0xc44 <TCP_GetConnectionInfo>
    1172:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    1174:	fc 01       	movw	r30, r24
    1176:	e4 5f       	subi	r30, 0xF4	; 244
    1178:	fd 4f       	sbci	r31, 0xFD	; 253
    117a:	80 81       	ld	r24, Z
    117c:	88 23       	and	r24, r24
    117e:	81 f4       	brne	.+32     	; 0x11a0 <TCP_ProcessTCPPacket+0x262>
    1180:	c5 5f       	subi	r28, 0xF5	; 245
    1182:	dd 4f       	sbci	r29, 0xFD	; 253
    1184:	88 81       	ld	r24, Y
    1186:	cb 50       	subi	r28, 0x0B	; 11
    1188:	d2 40       	sbci	r29, 0x02	; 2
    118a:	88 23       	and	r24, r24
    118c:	49 f4       	brne	.+18     	; 0x11a0 <TCP_ProcessTCPPacket+0x262>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    118e:	c6 5f       	subi	r28, 0xF6	; 246
    1190:	dd 4f       	sbci	r29, 0xFD	; 253
    1192:	18 82       	st	Y, r1
    1194:	ca 50       	subi	r28, 0x0A	; 10
    1196:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
    119c:	19 86       	std	Y+9, r1	; 0x09
    119e:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    11a0:	c6 5f       	subi	r28, 0xF6	; 246
    11a2:	dd 4f       	sbci	r29, 0xFD	; 253
    11a4:	88 81       	ld	r24, Y
    11a6:	ca 50       	subi	r28, 0x0A	; 10
    11a8:	d2 40       	sbci	r29, 0x02	; 2
    11aa:	88 23       	and	r24, r24
    11ac:	09 f0       	breq	.+2      	; 0x11b0 <TCP_ProcessTCPPacket+0x272>
    11ae:	3a c1       	rjmp	.+628    	; 0x1424 <TCP_ProcessTCPPacket+0x4e6>
    11b0:	68 85       	ldd	r22, Y+8	; 0x08
    11b2:	79 85       	ldd	r23, Y+9	; 0x09
    11b4:	b2 e0       	ldi	r27, 0x02	; 2
    11b6:	60 30       	cpi	r22, 0x00	; 0
    11b8:	7b 07       	cpc	r23, r27
    11ba:	09 f4       	brne	.+2      	; 0x11be <TCP_ProcessTCPPacket+0x280>
    11bc:	33 c1       	rjmp	.+614    	; 0x1424 <TCP_ProcessTCPPacket+0x4e6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    11be:	f5 01       	movw	r30, r10
    11c0:	20 81       	ld	r18, Z
    11c2:	2f 70       	andi	r18, 0x0F	; 15
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	22 0f       	add	r18, r18
    11c8:	33 1f       	adc	r19, r19
    11ca:	22 0f       	add	r18, r18
    11cc:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    11ce:	d7 01       	movw	r26, r14
    11d0:	1c 96       	adiw	r26, 0x0c	; 12
    11d2:	8c 91       	ld	r24, X
    11d4:	82 95       	swap	r24
    11d6:	8f 70       	andi	r24, 0x0F	; 15
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	88 0f       	add	r24, r24
    11dc:	99 1f       	adc	r25, r25
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    11e2:	02 81       	ldd	r16, Z+2	; 0x02
    11e4:	13 81       	ldd	r17, Z+3	; 0x03

				Temp = Data.Bytes[0];
    11e6:	40 2f       	mov	r20, r16
				Data.Bytes[0] = Data.Bytes[1];
    11e8:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
    11ea:	14 2f       	mov	r17, r20
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    11ec:	02 1b       	sub	r16, r18
    11ee:	13 0b       	sbc	r17, r19
    11f0:	08 1b       	sub	r16, r24
    11f2:	19 0b       	sbc	r17, r25

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    11f4:	9b 01       	movw	r18, r22
    11f6:	26 5f       	subi	r18, 0xF6	; 246
    11f8:	3f 4f       	sbci	r19, 0xFF	; 255
    11fa:	2c 0f       	add	r18, r28
    11fc:	3d 1f       	adc	r19, r29
    11fe:	a7 01       	movw	r20, r14
    1200:	48 0f       	add	r20, r24
    1202:	59 1f       	adc	r21, r25
    1204:	c9 01       	movw	r24, r18
    1206:	ba 01       	movw	r22, r20
    1208:	a8 01       	movw	r20, r16
    120a:	0e 94 80 16 	call	0x2d00	; 0x2d00 <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    120e:	98 01       	movw	r18, r16
    1210:	40 e0       	ldi	r20, 0x00	; 0
    1212:	50 e0       	ldi	r21, 0x00	; 0
    1214:	88 81       	ld	r24, Y
    1216:	99 81       	ldd	r25, Y+1	; 0x01
    1218:	aa 81       	ldd	r26, Y+2	; 0x02
    121a:	bb 81       	ldd	r27, Y+3	; 0x03
    121c:	82 0f       	add	r24, r18
    121e:	93 1f       	adc	r25, r19
    1220:	a4 1f       	adc	r26, r20
    1222:	b5 1f       	adc	r27, r21
    1224:	88 83       	st	Y, r24
    1226:	99 83       	std	Y+1, r25	; 0x01
    1228:	aa 83       	std	Y+2, r26	; 0x02
    122a:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    122c:	88 85       	ldd	r24, Y+8	; 0x08
    122e:	99 85       	ldd	r25, Y+9	; 0x09
    1230:	80 0f       	add	r24, r16
    1232:	91 1f       	adc	r25, r17
    1234:	99 87       	std	Y+9, r25	; 0x09
    1236:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    1238:	80 50       	subi	r24, 0x00	; 0
    123a:	92 40       	sbci	r25, 0x02	; 2
    123c:	21 f0       	breq	.+8      	; 0x1246 <TCP_ProcessTCPPacket+0x308>
    123e:	f7 01       	movw	r30, r14
    1240:	85 85       	ldd	r24, Z+13	; 0x0d
    1242:	83 ff       	sbrs	r24, 3
    1244:	f2 c0       	rjmp	.+484    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
							{
								ConnectionInfo->Buffer.InUse = false;
    1246:	c4 5f       	subi	r28, 0xF4	; 244
    1248:	dd 4f       	sbci	r29, 0xFD	; 253
    124a:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
    124c:	fe 01       	movw	r30, r28
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1252:	80 e1       	ldi	r24, 0x10	; 16
    1254:	d6 01       	movw	r26, r12
    1256:	1d 96       	adiw	r26, 0x0d	; 13
    1258:	8c 93       	st	X, r24
    125a:	f5 c0       	rjmp	.+490    	; 0x1446 <TCP_ProcessTCPPacket+0x508>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    125c:	e5 01       	movw	r28, r10
    125e:	4c 85       	ldd	r20, Y+12	; 0x0c
    1260:	5d 85       	ldd	r21, Y+13	; 0x0d
    1262:	6e 85       	ldd	r22, Y+14	; 0x0e
    1264:	7f 85       	ldd	r23, Y+15	; 0x0f
    1266:	f7 01       	movw	r30, r14
    1268:	20 81       	ld	r18, Z
    126a:	31 81       	ldd	r19, Z+1	; 0x01
    126c:	82 81       	ldd	r24, Z+2	; 0x02
    126e:	93 81       	ldd	r25, Z+3	; 0x03
    1270:	e9 dc       	rcall	.-1582   	; 0xc44 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1272:	21 e1       	ldi	r18, 0x11	; 17
    1274:	d6 01       	movw	r26, r12
    1276:	1d 96       	adiw	r26, 0x0d	; 13
    1278:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    127a:	fc 01       	movw	r30, r24
    127c:	e4 5f       	subi	r30, 0xF4	; 244
    127e:	fd 4f       	sbci	r31, 0xFD	; 253
    1280:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1282:	4c 85       	ldd	r20, Y+12	; 0x0c
    1284:	5d 85       	ldd	r21, Y+13	; 0x0d
    1286:	6e 85       	ldd	r22, Y+14	; 0x0e
    1288:	7f 85       	ldd	r23, Y+15	; 0x0f
    128a:	e7 01       	movw	r28, r14
    128c:	28 81       	ld	r18, Y
    128e:	39 81       	ldd	r19, Y+1	; 0x01
    1290:	8a 81       	ldd	r24, Y+2	; 0x02
    1292:	9b 81       	ldd	r25, Y+3	; 0x03
    1294:	04 e0       	ldi	r16, 0x04	; 4
    1296:	80 c0       	rjmp	.+256    	; 0x1398 <TCP_ProcessTCPPacket+0x45a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1298:	f7 01       	movw	r30, r14
    129a:	85 85       	ldd	r24, Z+13	; 0x0d
    129c:	81 31       	cpi	r24, 0x11	; 17
    129e:	a1 f5       	brne	.+104    	; 0x1308 <TCP_ProcessTCPPacket+0x3ca>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12a0:	d5 01       	movw	r26, r10
    12a2:	1c 96       	adiw	r26, 0x0c	; 12
    12a4:	4d 91       	ld	r20, X+
    12a6:	5d 91       	ld	r21, X+
    12a8:	6d 91       	ld	r22, X+
    12aa:	7c 91       	ld	r23, X
    12ac:	1f 97       	sbiw	r26, 0x0f	; 15
    12ae:	20 81       	ld	r18, Z
    12b0:	31 81       	ldd	r19, Z+1	; 0x01
    12b2:	82 81       	ldd	r24, Z+2	; 0x02
    12b4:	93 81       	ldd	r25, Z+3	; 0x03
    12b6:	c6 dc       	rcall	.-1652   	; 0xc44 <TCP_GetConnectionInfo>
    12b8:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    12ba:	80 e1       	ldi	r24, 0x10	; 16
    12bc:	e6 01       	movw	r28, r12
    12be:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    12c0:	80 81       	ld	r24, Z
    12c2:	91 81       	ldd	r25, Z+1	; 0x01
    12c4:	a2 81       	ldd	r26, Z+2	; 0x02
    12c6:	b3 81       	ldd	r27, Z+3	; 0x03
    12c8:	01 96       	adiw	r24, 0x01	; 1
    12ca:	a1 1d       	adc	r26, r1
    12cc:	b1 1d       	adc	r27, r1
    12ce:	80 83       	st	Z, r24
    12d0:	91 83       	std	Z+1, r25	; 0x01
    12d2:	a2 83       	std	Z+2, r26	; 0x02
    12d4:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    12d6:	84 81       	ldd	r24, Z+4	; 0x04
    12d8:	95 81       	ldd	r25, Z+5	; 0x05
    12da:	a6 81       	ldd	r26, Z+6	; 0x06
    12dc:	b7 81       	ldd	r27, Z+7	; 0x07
    12de:	01 96       	adiw	r24, 0x01	; 1
    12e0:	a1 1d       	adc	r26, r1
    12e2:	b1 1d       	adc	r27, r1
    12e4:	84 83       	std	Z+4, r24	; 0x04
    12e6:	95 83       	std	Z+5, r25	; 0x05
    12e8:	a6 83       	std	Z+6, r26	; 0x06
    12ea:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12ec:	f5 01       	movw	r30, r10
    12ee:	44 85       	ldd	r20, Z+12	; 0x0c
    12f0:	55 85       	ldd	r21, Z+13	; 0x0d
    12f2:	66 85       	ldd	r22, Z+14	; 0x0e
    12f4:	77 85       	ldd	r23, Z+15	; 0x0f
    12f6:	d7 01       	movw	r26, r14
    12f8:	2d 91       	ld	r18, X+
    12fa:	3c 91       	ld	r19, X
    12fc:	11 97       	sbiw	r26, 0x01	; 1
    12fe:	12 96       	adiw	r26, 0x02	; 2
    1300:	8d 91       	ld	r24, X+
    1302:	9c 91       	ld	r25, X
    1304:	13 97       	sbiw	r26, 0x03	; 3
    1306:	47 c0       	rjmp	.+142    	; 0x1396 <TCP_ProcessTCPPacket+0x458>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1308:	80 31       	cpi	r24, 0x10	; 16
    130a:	09 f0       	breq	.+2      	; 0x130e <TCP_ProcessTCPPacket+0x3d0>
    130c:	8e c0       	rjmp	.+284    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    130e:	e5 01       	movw	r28, r10
    1310:	4c 85       	ldd	r20, Y+12	; 0x0c
    1312:	5d 85       	ldd	r21, Y+13	; 0x0d
    1314:	6e 85       	ldd	r22, Y+14	; 0x0e
    1316:	7f 85       	ldd	r23, Y+15	; 0x0f
    1318:	f7 01       	movw	r30, r14
    131a:	20 81       	ld	r18, Z
    131c:	31 81       	ldd	r19, Z+1	; 0x01
    131e:	82 81       	ldd	r24, Z+2	; 0x02
    1320:	93 81       	ldd	r25, Z+3	; 0x03
    1322:	05 e0       	ldi	r16, 0x05	; 5
    1324:	4c c0       	rjmp	.+152    	; 0x13be <TCP_ProcessTCPPacket+0x480>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1326:	d7 01       	movw	r26, r14
    1328:	1d 96       	adiw	r26, 0x0d	; 13
    132a:	8c 91       	ld	r24, X
    132c:	1d 97       	sbiw	r26, 0x0d	; 13
    132e:	81 31       	cpi	r24, 0x11	; 17
    1330:	09 f0       	breq	.+2      	; 0x1334 <TCP_ProcessTCPPacket+0x3f6>
    1332:	7b c0       	rjmp	.+246    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1334:	e5 01       	movw	r28, r10
    1336:	4c 85       	ldd	r20, Y+12	; 0x0c
    1338:	5d 85       	ldd	r21, Y+13	; 0x0d
    133a:	6e 85       	ldd	r22, Y+14	; 0x0e
    133c:	7f 85       	ldd	r23, Y+15	; 0x0f
    133e:	2d 91       	ld	r18, X+
    1340:	3c 91       	ld	r19, X
    1342:	11 97       	sbiw	r26, 0x01	; 1
    1344:	12 96       	adiw	r26, 0x02	; 2
    1346:	8d 91       	ld	r24, X+
    1348:	9c 91       	ld	r25, X
    134a:	13 97       	sbiw	r26, 0x03	; 3
    134c:	7b dc       	rcall	.-1802   	; 0xc44 <TCP_GetConnectionInfo>
    134e:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1350:	80 e1       	ldi	r24, 0x10	; 16
    1352:	d6 01       	movw	r26, r12
    1354:	1d 96       	adiw	r26, 0x0d	; 13
    1356:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1358:	80 81       	ld	r24, Z
    135a:	91 81       	ldd	r25, Z+1	; 0x01
    135c:	a2 81       	ldd	r26, Z+2	; 0x02
    135e:	b3 81       	ldd	r27, Z+3	; 0x03
    1360:	01 96       	adiw	r24, 0x01	; 1
    1362:	a1 1d       	adc	r26, r1
    1364:	b1 1d       	adc	r27, r1
    1366:	80 83       	st	Z, r24
    1368:	91 83       	std	Z+1, r25	; 0x01
    136a:	a2 83       	std	Z+2, r26	; 0x02
    136c:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    136e:	84 81       	ldd	r24, Z+4	; 0x04
    1370:	95 81       	ldd	r25, Z+5	; 0x05
    1372:	a6 81       	ldd	r26, Z+6	; 0x06
    1374:	b7 81       	ldd	r27, Z+7	; 0x07
    1376:	01 96       	adiw	r24, 0x01	; 1
    1378:	a1 1d       	adc	r26, r1
    137a:	b1 1d       	adc	r27, r1
    137c:	84 83       	std	Z+4, r24	; 0x04
    137e:	95 83       	std	Z+5, r25	; 0x05
    1380:	a6 83       	std	Z+6, r26	; 0x06
    1382:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1384:	4c 85       	ldd	r20, Y+12	; 0x0c
    1386:	5d 85       	ldd	r21, Y+13	; 0x0d
    1388:	6e 85       	ldd	r22, Y+14	; 0x0e
    138a:	7f 85       	ldd	r23, Y+15	; 0x0f
    138c:	e7 01       	movw	r28, r14
    138e:	28 81       	ld	r18, Y
    1390:	39 81       	ldd	r19, Y+1	; 0x01
    1392:	8a 81       	ldd	r24, Y+2	; 0x02
    1394:	9b 81       	ldd	r25, Y+3	; 0x03
    1396:	0a e0       	ldi	r16, 0x0A	; 10
    1398:	28 dd       	rcall	.-1456   	; 0xdea <TCP_SetConnectionState>
    139a:	55 c0       	rjmp	.+170    	; 0x1446 <TCP_ProcessTCPPacket+0x508>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    139c:	f7 01       	movw	r30, r14
    139e:	85 85       	ldd	r24, Z+13	; 0x0d
    13a0:	80 31       	cpi	r24, 0x10	; 16
    13a2:	09 f0       	breq	.+2      	; 0x13a6 <TCP_ProcessTCPPacket+0x468>
    13a4:	42 c0       	rjmp	.+132    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    13a6:	d5 01       	movw	r26, r10
    13a8:	1c 96       	adiw	r26, 0x0c	; 12
    13aa:	4d 91       	ld	r20, X+
    13ac:	5d 91       	ld	r21, X+
    13ae:	6d 91       	ld	r22, X+
    13b0:	7c 91       	ld	r23, X
    13b2:	1f 97       	sbiw	r26, 0x0f	; 15
    13b4:	20 81       	ld	r18, Z
    13b6:	31 81       	ldd	r19, Z+1	; 0x01
    13b8:	82 81       	ldd	r24, Z+2	; 0x02
    13ba:	93 81       	ldd	r25, Z+3	; 0x03
    13bc:	0a e0       	ldi	r16, 0x0A	; 10
    13be:	15 dd       	rcall	.-1494   	; 0xdea <TCP_SetConnectionState>
    13c0:	34 c0       	rjmp	.+104    	; 0x142a <TCP_ProcessTCPPacket+0x4ec>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    13c2:	84 e1       	ldi	r24, 0x14	; 20
    13c4:	e6 01       	movw	r28, r12
    13c6:	8d 87       	std	Y+13, r24	; 0x0d
    13c8:	3e c0       	rjmp	.+124    	; 0x1446 <TCP_ProcessTCPPacket+0x508>
    13ca:	82 e0       	ldi	r24, 0x02	; 2
    13cc:	90 e0       	ldi	r25, 0x00	; 0
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    13ce:	f6 01       	movw	r30, r12
    13d0:	97 87       	std	Z+15, r25	; 0x0f
    13d2:	86 87       	std	Z+14, r24	; 0x0e
    13d4:	0c c0       	rjmp	.+24     	; 0x13ee <TCP_ProcessTCPPacket+0x4b0>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    13d6:	80 e0       	ldi	r24, 0x00	; 0
    13d8:	92 e0       	ldi	r25, 0x02	; 2
    13da:	20 85       	ldd	r18, Z+8	; 0x08
    13dc:	31 85       	ldd	r19, Z+9	; 0x09
    13de:	82 1b       	sub	r24, r18
    13e0:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    13e2:	d6 01       	movw	r26, r12
    13e4:	1e 96       	adiw	r26, 0x0e	; 14
    13e6:	9c 93       	st	X, r25
    13e8:	1e 97       	sbiw	r26, 0x0e	; 14
    13ea:	1f 96       	adiw	r26, 0x0f	; 15
    13ec:	8c 93       	st	X, r24

		TCPHeaderOUT->UrgentPointer        = 0;
    13ee:	e6 01       	movw	r28, r12
    13f0:	1b 8a       	std	Y+19, r1	; 0x13
    13f2:	1a 8a       	std	Y+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    13f4:	19 8a       	std	Y+17, r1	; 0x11
    13f6:	18 8a       	std	Y+16, r1	; 0x10
		TCPHeaderOUT->Reserved             = 0;
    13f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    13fa:	80 7f       	andi	r24, 0xF0	; 240
    13fc:	8c 87       	std	Y+12, r24	; 0x0c

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    13fe:	f5 01       	movw	r30, r10
    1400:	40 89       	ldd	r20, Z+16	; 0x10
    1402:	51 89       	ldd	r21, Z+17	; 0x11
    1404:	62 89       	ldd	r22, Z+18	; 0x12
    1406:	73 89       	ldd	r23, Z+19	; 0x13
    1408:	04 85       	ldd	r16, Z+12	; 0x0c
    140a:	15 85       	ldd	r17, Z+13	; 0x0d
    140c:	26 85       	ldd	r18, Z+14	; 0x0e
    140e:	37 85       	ldd	r19, Z+15	; 0x0f
    1410:	c6 01       	movw	r24, r12
    1412:	e4 e1       	ldi	r30, 0x14	; 20
    1414:	ee 2e       	mov	r14, r30
    1416:	f1 2c       	mov	r15, r1
    1418:	70 db       	rcall	.-2336   	; 0xafa <TCP_Checksum16>
    141a:	99 8b       	std	Y+17, r25	; 0x11
    141c:	88 8b       	std	Y+16, r24	; 0x10
    141e:	24 e1       	ldi	r18, 0x14	; 20
    1420:	30 e0       	ldi	r19, 0x00	; 0
    1422:	05 c0       	rjmp	.+10     	; 0x142e <TCP_ProcessTCPPacket+0x4f0>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1424:	2f ef       	ldi	r18, 0xFF	; 255
    1426:	3f ef       	ldi	r19, 0xFF	; 255
    1428:	02 c0       	rjmp	.+4      	; 0x142e <TCP_ProcessTCPPacket+0x4f0>
    142a:	20 e0       	ldi	r18, 0x00	; 0
    142c:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    142e:	c9 01       	movw	r24, r18
    1430:	df 91       	pop	r29
    1432:	cf 91       	pop	r28
    1434:	1f 91       	pop	r17
    1436:	0f 91       	pop	r16
    1438:	ff 90       	pop	r15
    143a:	ef 90       	pop	r14
    143c:	df 90       	pop	r13
    143e:	cf 90       	pop	r12
    1440:	bf 90       	pop	r11
    1442:	af 90       	pop	r10
    1444:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1446:	d5 01       	movw	r26, r10
    1448:	1c 96       	adiw	r26, 0x0c	; 12
    144a:	4d 91       	ld	r20, X+
    144c:	5d 91       	ld	r21, X+
    144e:	6d 91       	ld	r22, X+
    1450:	7c 91       	ld	r23, X
    1452:	1f 97       	sbiw	r26, 0x0f	; 15
    1454:	e7 01       	movw	r28, r14
    1456:	28 81       	ld	r18, Y
    1458:	39 81       	ldd	r19, Y+1	; 0x01
    145a:	8a 81       	ldd	r24, Y+2	; 0x02
    145c:	9b 81       	ldd	r25, Y+3	; 0x03
    145e:	f2 db       	rcall	.-2076   	; 0xc44 <TCP_GetConnectionInfo>
    1460:	fc 01       	movw	r30, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1462:	8a 81       	ldd	r24, Y+2	; 0x02
    1464:	9b 81       	ldd	r25, Y+3	; 0x03
    1466:	d6 01       	movw	r26, r12
    1468:	11 96       	adiw	r26, 0x01	; 1
    146a:	9c 93       	st	X, r25
    146c:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    146e:	88 81       	ld	r24, Y
    1470:	99 81       	ldd	r25, Y+1	; 0x01
    1472:	13 96       	adiw	r26, 0x03	; 3
    1474:	9c 93       	st	X, r25
    1476:	8e 93       	st	-X, r24
    1478:	12 97       	sbiw	r26, 0x02	; 2
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    147a:	34 81       	ldd	r19, Z+4	; 0x04
    147c:	25 81       	ldd	r18, Z+5	; 0x05
    147e:	96 81       	ldd	r25, Z+6	; 0x06
    1480:	87 81       	ldd	r24, Z+7	; 0x07
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1482:	14 96       	adiw	r26, 0x04	; 4
    1484:	8c 93       	st	X, r24
    1486:	14 97       	sbiw	r26, 0x04	; 4
    1488:	15 96       	adiw	r26, 0x05	; 5
    148a:	9c 93       	st	X, r25
    148c:	15 97       	sbiw	r26, 0x05	; 5
    148e:	16 96       	adiw	r26, 0x06	; 6
    1490:	2c 93       	st	X, r18
    1492:	16 97       	sbiw	r26, 0x06	; 6
    1494:	17 96       	adiw	r26, 0x07	; 7
    1496:	3c 93       	st	X, r19
    1498:	17 97       	sbiw	r26, 0x07	; 7
    149a:	30 81       	ld	r19, Z
    149c:	21 81       	ldd	r18, Z+1	; 0x01
    149e:	92 81       	ldd	r25, Z+2	; 0x02
    14a0:	83 81       	ldd	r24, Z+3	; 0x03
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    14a2:	18 96       	adiw	r26, 0x08	; 8
    14a4:	8c 93       	st	X, r24
    14a6:	18 97       	sbiw	r26, 0x08	; 8
    14a8:	19 96       	adiw	r26, 0x09	; 9
    14aa:	9c 93       	st	X, r25
    14ac:	19 97       	sbiw	r26, 0x09	; 9
    14ae:	1a 96       	adiw	r26, 0x0a	; 10
    14b0:	2c 93       	st	X, r18
    14b2:	1a 97       	sbiw	r26, 0x0a	; 10
    14b4:	1b 96       	adiw	r26, 0x0b	; 11
    14b6:	3c 93       	st	X, r19
    14b8:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    14ba:	1c 96       	adiw	r26, 0x0c	; 12
    14bc:	8c 91       	ld	r24, X
    14be:	1c 97       	sbiw	r26, 0x0c	; 12
    14c0:	8f 70       	andi	r24, 0x0F	; 15
    14c2:	80 65       	ori	r24, 0x50	; 80
    14c4:	1c 96       	adiw	r26, 0x0c	; 12
    14c6:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    14c8:	e4 5f       	subi	r30, 0xF4	; 244
    14ca:	fd 4f       	sbci	r31, 0xFD	; 253
    14cc:	80 81       	ld	r24, Z
    14ce:	ec 50       	subi	r30, 0x0C	; 12
    14d0:	f2 40       	sbci	r31, 0x02	; 2
    14d2:	88 23       	and	r24, r24
    14d4:	09 f4       	brne	.+2      	; 0x14d8 <TCP_ProcessTCPPacket+0x59a>
    14d6:	79 cf       	rjmp	.-270    	; 0x13ca <TCP_ProcessTCPPacket+0x48c>
    14d8:	7e cf       	rjmp	.-260    	; 0x13d6 <TCP_ProcessTCPPacket+0x498>

000014da <TCP_Task>:
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    14da:	2f 92       	push	r2
    14dc:	3f 92       	push	r3
    14de:	4f 92       	push	r4
    14e0:	5f 92       	push	r5
    14e2:	6f 92       	push	r6
    14e4:	7f 92       	push	r7
    14e6:	8f 92       	push	r8
    14e8:	9f 92       	push	r9
    14ea:	af 92       	push	r10
    14ec:	bf 92       	push	r11
    14ee:	cf 92       	push	r12
    14f0:	df 92       	push	r13
    14f2:	ef 92       	push	r14
    14f4:	ff 92       	push	r15
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	00 d0       	rcall	.+0      	; 0x1500 <TCP_Task+0x26>
    1500:	cd b7       	in	r28, 0x3d	; 61
    1502:	de b7       	in	r29, 0x3e	; 62
    1504:	39 e1       	ldi	r19, 0x19	; 25
    1506:	c3 2e       	mov	r12, r19
    1508:	3d e0       	ldi	r19, 0x0D	; 13
    150a:	d3 2e       	mov	r13, r19
    150c:	00 e0       	ldi	r16, 0x00	; 0
    150e:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1510:	26 e1       	ldi	r18, 0x16	; 22
    1512:	e2 2e       	mov	r14, r18
    1514:	22 e0       	ldi	r18, 0x02	; 2
    1516:	f2 2e       	mov	r15, r18
    1518:	1c c0       	rjmp	.+56     	; 0x1552 <TCP_Task+0x78>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    151a:	80 91 5d 13 	lds	r24, 0x135D
    151e:	81 30       	cpi	r24, 0x01	; 1
    1520:	79 f4       	brne	.+30     	; 0x1540 <TCP_Task+0x66>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1522:	0e 9d       	mul	r16, r14
    1524:	b0 01       	movw	r22, r0
    1526:	0f 9d       	mul	r16, r15
    1528:	70 0d       	add	r23, r0
    152a:	1e 9d       	mul	r17, r14
    152c:	70 0d       	add	r23, r0
    152e:	11 24       	eor	r1, r1
    1530:	67 5d       	subi	r22, 0xD7	; 215
    1532:	72 4f       	sbci	r23, 0xF2	; 242
    1534:	e0 91 5e 13 	lds	r30, 0x135E
    1538:	f0 91 5f 13 	lds	r31, 0x135F
    153c:	c6 01       	movw	r24, r12
    153e:	09 95       	icall
    1540:	0f 5f       	subi	r16, 0xFF	; 255
    1542:	1f 4f       	sbci	r17, 0xFF	; 255
    1544:	26 e1       	ldi	r18, 0x16	; 22
    1546:	32 e0       	ldi	r19, 0x02	; 2
    1548:	c2 0e       	add	r12, r18
    154a:	d3 1e       	adc	r13, r19
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    154c:	03 30       	cpi	r16, 0x03	; 3
    154e:	11 05       	cpc	r17, r1
    1550:	59 f0       	breq	.+22     	; 0x1568 <TCP_Task+0x8e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1552:	20 91 5b 13 	lds	r18, 0x135B
    1556:	30 91 5c 13 	lds	r19, 0x135C
    155a:	d6 01       	movw	r26, r12
    155c:	8d 91       	ld	r24, X+
    155e:	9c 91       	ld	r25, X
    1560:	28 17       	cp	r18, r24
    1562:	39 07       	cpc	r19, r25
    1564:	69 f7       	brne	.-38     	; 0x1540 <TCP_Task+0x66>
    1566:	d9 cf       	rjmp	.-78     	; 0x151a <TCP_Task+0x40>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameInBuffer)
    1568:	80 91 18 0d 	lds	r24, 0x0D18
    156c:	88 23       	and	r24, r24
    156e:	09 f0       	breq	.+2      	; 0x1572 <TCP_Task+0x98>
    1570:	20 c1       	rjmp	.+576    	; 0x17b2 <TCP_Task+0x2d8>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    1572:	80 91 2b 0f 	lds	r24, 0x0F2B
    1576:	88 23       	and	r24, r24
    1578:	39 f0       	breq	.+14     	; 0x1588 <TCP_Task+0xae>
    157a:	80 91 2c 0f 	lds	r24, 0x0F2C
    157e:	88 23       	and	r24, r24
    1580:	19 f0       	breq	.+6      	; 0x1588 <TCP_Task+0xae>
    1582:	1a 82       	std	Y+2, r1	; 0x02
    1584:	19 82       	std	Y+1, r1	; 0x01
    1586:	1b c0       	rjmp	.+54     	; 0x15be <TCP_Task+0xe4>
    1588:	80 91 41 11 	lds	r24, 0x1141
    158c:	88 23       	and	r24, r24
    158e:	49 f0       	breq	.+18     	; 0x15a2 <TCP_Task+0xc8>
    1590:	80 91 42 11 	lds	r24, 0x1142
    1594:	88 23       	and	r24, r24
    1596:	29 f0       	breq	.+10     	; 0x15a2 <TCP_Task+0xc8>
    1598:	e1 e0       	ldi	r30, 0x01	; 1
    159a:	f0 e0       	ldi	r31, 0x00	; 0
    159c:	fa 83       	std	Y+2, r31	; 0x02
    159e:	e9 83       	std	Y+1, r30	; 0x01
    15a0:	0e c0       	rjmp	.+28     	; 0x15be <TCP_Task+0xe4>
    15a2:	80 91 57 13 	lds	r24, 0x1357
    15a6:	88 23       	and	r24, r24
    15a8:	09 f4       	brne	.+2      	; 0x15ac <TCP_Task+0xd2>
    15aa:	03 c1       	rjmp	.+518    	; 0x17b2 <TCP_Task+0x2d8>
    15ac:	80 91 58 13 	lds	r24, 0x1358
    15b0:	88 23       	and	r24, r24
    15b2:	09 f4       	brne	.+2      	; 0x15b6 <TCP_Task+0xdc>
    15b4:	fe c0       	rjmp	.+508    	; 0x17b2 <TCP_Task+0x2d8>
    15b6:	22 e0       	ldi	r18, 0x02	; 2
    15b8:	30 e0       	ldi	r19, 0x00	; 0
    15ba:	3a 83       	std	Y+2, r19	; 0x02
    15bc:	29 83       	std	Y+1, r18	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
    15be:	9a e3       	ldi	r25, 0x3A	; 58
    15c0:	a9 2e       	mov	r10, r25
    15c2:	97 e0       	ldi	r25, 0x07	; 7
    15c4:	b9 2e       	mov	r11, r25
    15c6:	8e e0       	ldi	r24, 0x0E	; 14
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	a8 0e       	add	r10, r24
    15cc:	b9 1e       	adc	r11, r25
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                             sizeof(IP_Header_t)];
    15ce:	8a e3       	ldi	r24, 0x3A	; 58
    15d0:	c8 2e       	mov	r12, r24
    15d2:	87 e0       	ldi	r24, 0x07	; 7
    15d4:	d8 2e       	mov	r13, r24
    15d6:	a2 e2       	ldi	r26, 0x22	; 34
    15d8:	b0 e0       	ldi	r27, 0x00	; 0
    15da:	ca 0e       	add	r12, r26
    15dc:	db 1e       	adc	r13, r27
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    15de:	86 e1       	ldi	r24, 0x16	; 22
    15e0:	92 e0       	ldi	r25, 0x02	; 2
    15e2:	e9 81       	ldd	r30, Y+1	; 0x01
    15e4:	fa 81       	ldd	r31, Y+2	; 0x02
    15e6:	e8 9f       	mul	r30, r24
    15e8:	a0 01       	movw	r20, r0
    15ea:	e9 9f       	mul	r30, r25
    15ec:	50 0d       	add	r21, r0
    15ee:	f8 9f       	mul	r31, r24
    15f0:	50 0d       	add	r21, r0
    15f2:	11 24       	eor	r1, r1
    15f4:	09 e1       	ldi	r16, 0x19	; 25
    15f6:	80 2e       	mov	r8, r16
    15f8:	0d e0       	ldi	r16, 0x0D	; 13
    15fa:	90 2e       	mov	r9, r16
    15fc:	84 0e       	add	r8, r20
    15fe:	95 1e       	adc	r9, r21
    1600:	d4 01       	movw	r26, r8
    1602:	50 96       	adiw	r26, 0x10	; 16
    1604:	6d 90       	ld	r6, X+
    1606:	7c 90       	ld	r7, X
    1608:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    160a:	8d 91       	ld	r24, X+
    160c:	9c 91       	ld	r25, X
    160e:	90 93 5d 07 	sts	0x075D, r25
    1612:	80 93 5c 07 	sts	0x075C, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    1616:	8b e0       	ldi	r24, 0x0B	; 11
    1618:	91 e0       	ldi	r25, 0x01	; 1
    161a:	9f 01       	movw	r18, r30
    161c:	28 9f       	mul	r18, r24
    161e:	f0 01       	movw	r30, r0
    1620:	29 9f       	mul	r18, r25
    1622:	f0 0d       	add	r31, r0
    1624:	38 9f       	mul	r19, r24
    1626:	f0 0d       	add	r31, r0
    1628:	11 24       	eor	r1, r1
    162a:	ee 0f       	add	r30, r30
    162c:	ff 1f       	adc	r31, r31
    162e:	e5 5e       	subi	r30, 0xE5	; 229
    1630:	f2 4f       	sbci	r31, 0xF2	; 242
    1632:	80 81       	ld	r24, Z
    1634:	91 81       	ldd	r25, Z+1	; 0x01
    1636:	d6 01       	movw	r26, r12
    1638:	13 96       	adiw	r26, 0x03	; 3
    163a:	9c 93       	st	X, r25
    163c:	8e 93       	st	-X, r24
    163e:	12 97       	sbiw	r26, 0x02	; 2
    1640:	f4 01       	movw	r30, r8
    1642:	3c 96       	adiw	r30, 0x0c	; 12
    1644:	d4 01       	movw	r26, r8
    1646:	1c 96       	adiw	r26, 0x0c	; 12
    1648:	3c 91       	ld	r19, X
    164a:	1c 97       	sbiw	r26, 0x0c	; 12
    164c:	21 81       	ldd	r18, Z+1	; 0x01
    164e:	92 81       	ldd	r25, Z+2	; 0x02
    1650:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    1652:	f6 01       	movw	r30, r12
    1654:	84 83       	std	Z+4, r24	; 0x04
    1656:	95 83       	std	Z+5, r25	; 0x05
    1658:	26 83       	std	Z+6, r18	; 0x06
    165a:	37 83       	std	Z+7, r19	; 0x07
    165c:	f4 01       	movw	r30, r8
    165e:	38 96       	adiw	r30, 0x08	; 8
    1660:	18 96       	adiw	r26, 0x08	; 8
    1662:	3c 91       	ld	r19, X
    1664:	21 81       	ldd	r18, Z+1	; 0x01
    1666:	92 81       	ldd	r25, Z+2	; 0x02
    1668:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    166a:	f6 01       	movw	r30, r12
    166c:	80 87       	std	Z+8, r24	; 0x08
    166e:	91 87       	std	Z+9, r25	; 0x09
    1670:	22 87       	std	Z+10, r18	; 0x0a
    1672:	33 87       	std	Z+11, r19	; 0x0b

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;
    1674:	82 e0       	ldi	r24, 0x02	; 2
    1676:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    1678:	97 87       	std	Z+15, r25	; 0x0f
    167a:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    167c:	80 e1       	ldi	r24, 0x10	; 16
    167e:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
    1680:	13 8a       	std	Z+19, r1	; 0x13
    1682:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
    1684:	11 8a       	std	Z+17, r1	; 0x11
    1686:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
    1688:	80 e5       	ldi	r24, 0x50	; 80
    168a:	84 87       	std	Z+12, r24	; 0x0c

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    168c:	2a e3       	ldi	r18, 0x3A	; 58
    168e:	37 e0       	ldi	r19, 0x07	; 7
    1690:	2a 5c       	subi	r18, 0xCA	; 202
    1692:	3f 4f       	sbci	r19, 0xFF	; 255
    1694:	45 5d       	subi	r20, 0xD5	; 213
    1696:	52 4f       	sbci	r21, 0xF2	; 242
    1698:	c9 01       	movw	r24, r18
    169a:	ba 01       	movw	r22, r20
    169c:	a3 01       	movw	r20, r6
    169e:	0e 94 80 16 	call	0x2d00	; 0x2d00 <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    16a2:	c3 01       	movw	r24, r6
    16a4:	a0 e0       	ldi	r26, 0x00	; 0
    16a6:	b0 e0       	ldi	r27, 0x00	; 0
    16a8:	f4 01       	movw	r30, r8
    16aa:	24 85       	ldd	r18, Z+12	; 0x0c
    16ac:	35 85       	ldd	r19, Z+13	; 0x0d
    16ae:	46 85       	ldd	r20, Z+14	; 0x0e
    16b0:	57 85       	ldd	r21, Z+15	; 0x0f
    16b2:	82 0f       	add	r24, r18
    16b4:	93 1f       	adc	r25, r19
    16b6:	a4 1f       	adc	r26, r20
    16b8:	b5 1f       	adc	r27, r21
    16ba:	84 87       	std	Z+12, r24	; 0x0c
    16bc:	95 87       	std	Z+13, r25	; 0x0d
    16be:	a6 87       	std	Z+14, r26	; 0x0e
    16c0:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    16c2:	24 e1       	ldi	r18, 0x14	; 20
    16c4:	30 e0       	ldi	r19, 0x00	; 0
    16c6:	62 0e       	add	r6, r18
    16c8:	73 1e       	adc	r7, r19
    16ca:	20 90 0e 01 	lds	r2, 0x010E
    16ce:	30 90 0f 01 	lds	r3, 0x010F
    16d2:	40 90 10 01 	lds	r4, 0x0110
    16d6:	50 90 11 01 	lds	r5, 0x0111
    16da:	04 81       	ldd	r16, Z+4	; 0x04
    16dc:	15 81       	ldd	r17, Z+5	; 0x05
    16de:	26 81       	ldd	r18, Z+6	; 0x06
    16e0:	37 81       	ldd	r19, Z+7	; 0x07
    16e2:	c6 01       	movw	r24, r12
    16e4:	b2 01       	movw	r22, r4
    16e6:	a1 01       	movw	r20, r2
    16e8:	73 01       	movw	r14, r6
    16ea:	07 da       	rcall	.-3058   	; 0xafa <TCP_Checksum16>
    16ec:	d6 01       	movw	r26, r12
    16ee:	51 96       	adiw	r26, 0x11	; 17
    16f0:	9c 93       	st	X, r25
    16f2:	8e 93       	st	-X, r24
    16f4:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    16f6:	83 01       	movw	r16, r6
    16f8:	0c 5e       	subi	r16, 0xEC	; 236
    16fa:	1f 4f       	sbci	r17, 0xFF	; 255
    16fc:	f5 01       	movw	r30, r10
    16fe:	12 83       	std	Z+2, r17	; 0x02
    1700:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    1702:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    1704:	85 e4       	ldi	r24, 0x45	; 69
    1706:	80 93 48 07 	sts	0x0748, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    170a:	16 82       	std	Z+6, r1	; 0x06
    170c:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    170e:	15 82       	std	Z+5, r1	; 0x05
    1710:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    1712:	13 86       	std	Z+11, r1	; 0x0b
    1714:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    1716:	86 e0       	ldi	r24, 0x06	; 6
    1718:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    171a:	80 e8       	ldi	r24, 0x80	; 128
    171c:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    171e:	d5 01       	movw	r26, r10
    1720:	1c 96       	adiw	r26, 0x0c	; 12
    1722:	2d 92       	st	X+, r2
    1724:	3d 92       	st	X+, r3
    1726:	4d 92       	st	X+, r4
    1728:	5c 92       	st	X, r5
    172a:	1f 97       	sbiw	r26, 0x0f	; 15
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    172c:	f4 01       	movw	r30, r8
    172e:	84 81       	ldd	r24, Z+4	; 0x04
    1730:	95 81       	ldd	r25, Z+5	; 0x05
    1732:	a6 81       	ldd	r26, Z+6	; 0x06
    1734:	b7 81       	ldd	r27, Z+7	; 0x07
    1736:	f5 01       	movw	r30, r10
    1738:	80 8b       	std	Z+16, r24	; 0x10
    173a:	91 8b       	std	Z+17, r25	; 0x11
    173c:	a2 8b       	std	Z+18, r26	; 0x12
    173e:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1740:	c5 01       	movw	r24, r10
    1742:	64 e1       	ldi	r22, 0x14	; 20
    1744:	70 e0       	ldi	r23, 0x00	; 0
    1746:	6e d8       	rcall	.-3876   	; 0x824 <Ethernet_Checksum16>
    1748:	d5 01       	movw	r26, r10
    174a:	1b 96       	adiw	r26, 0x0b	; 11
    174c:	9c 93       	st	X, r25
    174e:	8e 93       	st	-X, r24
    1750:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    1752:	aa e3       	ldi	r26, 0x3A	; 58
    1754:	b7 e0       	ldi	r27, 0x07	; 7
    1756:	16 96       	adiw	r26, 0x06	; 6
    1758:	e8 e0       	ldi	r30, 0x08	; 8
    175a:	f1 e0       	ldi	r31, 0x01	; 1
    175c:	86 e0       	ldi	r24, 0x06	; 6
    175e:	01 90       	ld	r0, Z+
    1760:	0d 92       	st	X+, r0
    1762:	81 50       	subi	r24, 0x01	; 1
    1764:	e1 f7       	brne	.-8      	; 0x175e <TCP_Task+0x284>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    1766:	aa e3       	ldi	r26, 0x3A	; 58
    1768:	b7 e0       	ldi	r27, 0x07	; 7
    176a:	e0 e2       	ldi	r30, 0x20	; 32
    176c:	f1 e0       	ldi	r31, 0x01	; 1
    176e:	86 e0       	ldi	r24, 0x06	; 6
    1770:	01 90       	ld	r0, Z+
    1772:	0d 92       	st	X+, r0
    1774:	81 50       	subi	r24, 0x01	; 1
    1776:	e1 f7       	brne	.-8      	; 0x1770 <TCP_Task+0x296>
    1778:	88 e0       	ldi	r24, 0x08	; 8
    177a:	90 e0       	ldi	r25, 0x00	; 0
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    177c:	90 93 47 07 	sts	0x0747, r25
    1780:	80 93 46 07 	sts	0x0746, r24

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
    1784:	02 5f       	subi	r16, 0xF2	; 242
    1786:	1f 4f       	sbci	r17, 0xFF	; 255
    1788:	10 93 17 0d 	sts	0x0D17, r17
    178c:	00 93 16 0d 	sts	0x0D16, r16
			FrameOUT.FrameInBuffer          = true;
    1790:	81 e0       	ldi	r24, 0x01	; 1
    1792:	80 93 18 0d 	sts	0x0D18, r24

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    1796:	86 e1       	ldi	r24, 0x16	; 22
    1798:	92 e0       	ldi	r25, 0x02	; 2
    179a:	29 81       	ldd	r18, Y+1	; 0x01
    179c:	3a 81       	ldd	r19, Y+2	; 0x02
    179e:	28 9f       	mul	r18, r24
    17a0:	f0 01       	movw	r30, r0
    17a2:	29 9f       	mul	r18, r25
    17a4:	f0 0d       	add	r31, r0
    17a6:	38 9f       	mul	r19, r24
    17a8:	f0 0d       	add	r31, r0
    17aa:	11 24       	eor	r1, r1
    17ac:	e4 5d       	subi	r30, 0xD4	; 212
    17ae:	f0 4f       	sbci	r31, 0xF0	; 240
    17b0:	10 82       	st	Z, r1

			break;
		}
	}
}
    17b2:	0f 90       	pop	r0
    17b4:	0f 90       	pop	r0
    17b6:	cf 91       	pop	r28
    17b8:	df 91       	pop	r29
    17ba:	1f 91       	pop	r17
    17bc:	0f 91       	pop	r16
    17be:	ff 90       	pop	r15
    17c0:	ef 90       	pop	r14
    17c2:	df 90       	pop	r13
    17c4:	cf 90       	pop	r12
    17c6:	bf 90       	pop	r11
    17c8:	af 90       	pop	r10
    17ca:	9f 90       	pop	r9
    17cc:	8f 90       	pop	r8
    17ce:	7f 90       	pop	r7
    17d0:	6f 90       	pop	r6
    17d2:	5f 90       	pop	r5
    17d4:	4f 90       	pop	r4
    17d6:	3f 90       	pop	r3
    17d8:	2f 90       	pop	r2
    17da:	08 95       	ret

000017dc <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    17dc:	ef 92       	push	r14
    17de:	ff 92       	push	r15
    17e0:	0f 93       	push	r16
    17e2:	1f 93       	push	r17
    17e4:	cf 93       	push	r28
    17e6:	df 93       	push	r29
    17e8:	7c 01       	movw	r14, r24
    17ea:	eb 01       	movw	r28, r22
    17ec:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    17ee:	cb 01       	movw	r24, r22
    17f0:	bf d8       	rcall	.-3714   	; 0x970 <DecodeUDPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    17f2:	8a 81       	ldd	r24, Y+2	; 0x02
    17f4:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    17f6:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    17f8:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    17fa:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    17fc:	83 34       	cpi	r24, 0x43	; 67
    17fe:	91 05       	cpc	r25, r1
    1800:	e9 f4       	brne	.+58     	; 0x183c <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1802:	be 01       	movw	r22, r28
    1804:	68 5f       	subi	r22, 0xF8	; 248
    1806:	7f 4f       	sbci	r23, 0xFF	; 255
    1808:	a8 01       	movw	r20, r16
    180a:	48 5f       	subi	r20, 0xF8	; 248
    180c:	5f 4f       	sbci	r21, 0xFF	; 255
    180e:	c7 01       	movw	r24, r14
    1810:	1f d0       	rcall	.+62     	; 0x1850 <DHCP_ProcessDHCPPacket>
    1812:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1814:	18 16       	cp	r1, r24
    1816:	19 06       	cpc	r1, r25
    1818:	8c f4       	brge	.+34     	; 0x183c <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    181a:	8a 81       	ldd	r24, Y+2	; 0x02
    181c:	9b 81       	ldd	r25, Y+3	; 0x03
    181e:	f8 01       	movw	r30, r16
    1820:	91 83       	std	Z+1, r25	; 0x01
    1822:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1824:	88 81       	ld	r24, Y
    1826:	99 81       	ldd	r25, Y+1	; 0x01
    1828:	93 83       	std	Z+3, r25	; 0x03
    182a:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    182c:	17 82       	std	Z+7, r1	; 0x07
    182e:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1830:	c9 01       	movw	r24, r18
    1832:	08 96       	adiw	r24, 0x08	; 8
    1834:	94 83       	std	Z+4, r25	; 0x04
    1836:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1838:	9c 01       	movw	r18, r24
    183a:	02 c0       	rjmp	.+4      	; 0x1840 <UDP_ProcessUDPPacket+0x64>
    183c:	20 e0       	ldi	r18, 0x00	; 0
    183e:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1840:	c9 01       	movw	r24, r18
    1842:	df 91       	pop	r29
    1844:	cf 91       	pop	r28
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	08 95       	ret

00001850 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1850:	8f 92       	push	r8
    1852:	9f 92       	push	r9
    1854:	af 92       	push	r10
    1856:	bf 92       	push	r11
    1858:	cf 92       	push	r12
    185a:	df 92       	push	r13
    185c:	ef 92       	push	r14
    185e:	ff 92       	push	r15
    1860:	0f 93       	push	r16
    1862:	1f 93       	push	r17
    1864:	cf 93       	push	r28
    1866:	df 93       	push	r29
    1868:	8b 01       	movw	r16, r22
    186a:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    186c:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    186e:	80 ef       	ldi	r24, 0xF0	; 240
    1870:	88 2e       	mov	r8, r24
    1872:	91 2c       	mov	r9, r1
    1874:	86 0e       	add	r8, r22
    1876:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1878:	cb 01       	movw	r24, r22
    187a:	7b d8       	rcall	.-3850   	; 0x972 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    187c:	80 ef       	ldi	r24, 0xF0	; 240
    187e:	fe 01       	movw	r30, r28
    1880:	11 92       	st	Z+, r1
    1882:	8a 95       	dec	r24
    1884:	e9 f7       	brne	.-6      	; 0x1880 <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1886:	f8 01       	movw	r30, r16
    1888:	81 81       	ldd	r24, Z+1	; 0x01
    188a:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    188c:	82 e0       	ldi	r24, 0x02	; 2
    188e:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    1890:	82 81       	ldd	r24, Z+2	; 0x02
    1892:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    1894:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    1896:	84 81       	ldd	r24, Z+4	; 0x04
    1898:	95 81       	ldd	r25, Z+5	; 0x05
    189a:	a6 81       	ldd	r26, Z+6	; 0x06
    189c:	b7 81       	ldd	r27, Z+7	; 0x07
    189e:	8c 83       	std	Y+4, r24	; 0x04
    18a0:	9d 83       	std	Y+5, r25	; 0x05
    18a2:	ae 83       	std	Y+6, r26	; 0x06
    18a4:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    18a6:	19 86       	std	Y+9, r1	; 0x09
    18a8:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    18aa:	82 85       	ldd	r24, Z+10	; 0x0a
    18ac:	93 85       	ldd	r25, Z+11	; 0x0b
    18ae:	9b 87       	std	Y+11, r25	; 0x0b
    18b0:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    18b2:	c0 90 1c 01 	lds	r12, 0x011C
    18b6:	d0 90 1d 01 	lds	r13, 0x011D
    18ba:	e0 90 1e 01 	lds	r14, 0x011E
    18be:	f0 90 1f 01 	lds	r15, 0x011F
    18c2:	c8 8a       	std	Y+16, r12	; 0x10
    18c4:	d9 8a       	std	Y+17, r13	; 0x11
    18c6:	ea 8a       	std	Y+18, r14	; 0x12
    18c8:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    18ca:	04 5e       	subi	r16, 0xE4	; 228
    18cc:	1f 4f       	sbci	r17, 0xFF	; 255
    18ce:	ce 01       	movw	r24, r28
    18d0:	4c 96       	adiw	r24, 0x1c	; 28
    18d2:	b8 01       	movw	r22, r16
    18d4:	46 e0       	ldi	r20, 0x06	; 6
    18d6:	50 e0       	ldi	r21, 0x00	; 0
    18d8:	0e 94 89 16 	call	0x2d12	; 0x2d12 <memmove>
				} Data;

				Data.DWord = DWord;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[3];
    18dc:	83 e6       	ldi	r24, 0x63	; 99
    18de:	93 e5       	ldi	r25, 0x53	; 83
    18e0:	a2 e8       	ldi	r26, 0x82	; 130
    18e2:	b3 e6       	ldi	r27, 0x63	; 99
				Data.Bytes[3] = Temp;
    18e4:	b3 e6       	ldi	r27, 0x63	; 99

				Temp = Data.Bytes[1];
    18e6:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    18e8:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    18ea:	a2 2f       	mov	r26, r18
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    18ec:	c4 51       	subi	r28, 0x14	; 20
    18ee:	df 4f       	sbci	r29, 0xFF	; 255
    18f0:	88 83       	st	Y, r24
    18f2:	99 83       	std	Y+1, r25	; 0x01
    18f4:	aa 83       	std	Y+2, r26	; 0x02
    18f6:	bb 83       	std	Y+3, r27	; 0x03
    18f8:	cc 5e       	subi	r28, 0xEC	; 236
    18fa:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    18fc:	f5 01       	movw	r30, r10
    18fe:	c4 86       	std	Z+12, r12	; 0x0c
    1900:	d5 86       	std	Z+13, r13	; 0x0d
    1902:	e6 86       	std	Z+14, r14	; 0x0e
    1904:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1906:	80 91 0e 01 	lds	r24, 0x010E
    190a:	90 91 0f 01 	lds	r25, 0x010F
    190e:	a0 91 10 01 	lds	r26, 0x0110
    1912:	b0 91 11 01 	lds	r27, 0x0111
    1916:	80 8b       	std	Z+16, r24	; 0x10
    1918:	91 8b       	std	Z+17, r25	; 0x11
    191a:	a2 8b       	std	Z+18, r26	; 0x12
    191c:	b3 8b       	std	Z+19, r27	; 0x13
    191e:	5b c0       	rjmp	.+182    	; 0x19d6 <DHCP_ProcessDHCPPacket+0x186>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1920:	85 33       	cpi	r24, 0x35	; 53
    1922:	09 f0       	breq	.+2      	; 0x1926 <DHCP_ProcessDHCPPacket+0xd6>
    1924:	4d c0       	rjmp	.+154    	; 0x19c0 <DHCP_ProcessDHCPPacket+0x170>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1926:	94 01       	movw	r18, r8
    1928:	2e 5f       	subi	r18, 0xFE	; 254
    192a:	3f 4f       	sbci	r19, 0xFF	; 255
    192c:	f4 01       	movw	r30, r8
    192e:	82 81       	ldd	r24, Z+2	; 0x02
    1930:	81 30       	cpi	r24, 0x01	; 1
    1932:	19 f0       	breq	.+6      	; 0x193a <DHCP_ProcessDHCPPacket+0xea>
    1934:	83 30       	cpi	r24, 0x03	; 3
    1936:	09 f0       	breq	.+2      	; 0x193a <DHCP_ProcessDHCPPacket+0xea>
    1938:	48 c0       	rjmp	.+144    	; 0x19ca <DHCP_ProcessDHCPPacket+0x17a>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    193a:	fe 01       	movw	r30, r28
    193c:	e0 51       	subi	r30, 0x10	; 16
    193e:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1940:	df 01       	movw	r26, r30
    1942:	85 e3       	ldi	r24, 0x35	; 53
    1944:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1946:	81 e0       	ldi	r24, 0x01	; 1
    1948:	81 83       	std	Z+1, r24	; 0x01
    194a:	ed 01       	movw	r28, r26
    194c:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    194e:	f9 01       	movw	r30, r18
    1950:	80 81       	ld	r24, Z
    1952:	81 30       	cpi	r24, 0x01	; 1
    1954:	11 f0       	breq	.+4      	; 0x195a <DHCP_ProcessDHCPPacket+0x10a>
    1956:	85 e0       	ldi	r24, 0x05	; 5
    1958:	01 c0       	rjmp	.+2      	; 0x195c <DHCP_ProcessDHCPPacket+0x10c>
    195a:	82 e0       	ldi	r24, 0x02	; 2
    195c:	11 96       	adiw	r26, 0x01	; 1
    195e:	8c 93       	st	X, r24
    1960:	fe 01       	movw	r30, r28
    1962:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	89 83       	std	Y+1, r24	; 0x01
    1968:	cf 01       	movw	r24, r30
    196a:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    196c:	34 e0       	ldi	r19, 0x04	; 4
    196e:	31 83       	std	Z+1, r19	; 0x01
    1970:	dc 01       	movw	r26, r24
    1972:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1974:	2f ef       	ldi	r18, 0xFF	; 255
    1976:	fc 01       	movw	r30, r24
    1978:	21 83       	std	Z+1, r18	; 0x01
    197a:	fd 01       	movw	r30, r26
    197c:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    197e:	11 96       	adiw	r26, 0x01	; 1
    1980:	2c 93       	st	X, r18
    1982:	df 01       	movw	r26, r30
    1984:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1986:	21 83       	std	Z+1, r18	; 0x01
    1988:	fd 01       	movw	r30, r26
    198a:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    198c:	11 96       	adiw	r26, 0x01	; 1
    198e:	1c 92       	st	X, r1
    1990:	df 01       	movw	r26, r30
    1992:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1994:	86 e3       	ldi	r24, 0x36	; 54
    1996:	81 83       	std	Z+1, r24	; 0x01
    1998:	fd 01       	movw	r30, r26
    199a:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    199c:	11 96       	adiw	r26, 0x01	; 1
    199e:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    19a0:	80 91 0e 01 	lds	r24, 0x010E
    19a4:	90 91 0f 01 	lds	r25, 0x010F
    19a8:	a0 91 10 01 	lds	r26, 0x0110
    19ac:	b0 91 11 01 	lds	r27, 0x0111
    19b0:	81 83       	std	Z+1, r24	; 0x01
    19b2:	92 83       	std	Z+2, r25	; 0x02
    19b4:	a3 83       	std	Z+3, r26	; 0x03
    19b6:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    19b8:	25 83       	std	Z+5, r18	; 0x05
    19ba:	20 e0       	ldi	r18, 0x00	; 0
    19bc:	31 e0       	ldi	r19, 0x01	; 1
    19be:	12 c0       	rjmp	.+36     	; 0x19e4 <DHCP_ProcessDHCPPacket+0x194>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    19c0:	88 23       	and	r24, r24
    19c2:	19 f4       	brne	.+6      	; 0x19ca <DHCP_ProcessDHCPPacket+0x17a>
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	04 c0       	rjmp	.+8      	; 0x19d2 <DHCP_ProcessDHCPPacket+0x182>
    19ca:	f4 01       	movw	r30, r8
    19cc:	81 81       	ldd	r24, Z+1	; 0x01
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	02 96       	adiw	r24, 0x02	; 2
    19d2:	88 0e       	add	r8, r24
    19d4:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    19d6:	f4 01       	movw	r30, r8
    19d8:	80 81       	ld	r24, Z
    19da:	8f 3f       	cpi	r24, 0xFF	; 255
    19dc:	09 f0       	breq	.+2      	; 0x19e0 <DHCP_ProcessDHCPPacket+0x190>
    19de:	a0 cf       	rjmp	.-192    	; 0x1920 <DHCP_ProcessDHCPPacket+0xd0>
    19e0:	20 e0       	ldi	r18, 0x00	; 0
    19e2:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    19e4:	c9 01       	movw	r24, r18
    19e6:	df 91       	pop	r29
    19e8:	cf 91       	pop	r28
    19ea:	1f 91       	pop	r17
    19ec:	0f 91       	pop	r16
    19ee:	ff 90       	pop	r15
    19f0:	ef 90       	pop	r14
    19f2:	df 90       	pop	r13
    19f4:	cf 90       	pop	r12
    19f6:	bf 90       	pop	r11
    19f8:	af 90       	pop	r10
    19fa:	9f 90       	pop	r9
    19fc:	8f 90       	pop	r8
    19fe:	08 95       	ret

00001a00 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1a00:	ef 92       	push	r14
    1a02:	ff 92       	push	r15
    1a04:	0f 93       	push	r16
    1a06:	1f 93       	push	r17
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
    1a0c:	18 2f       	mov	r17, r24
    1a0e:	09 2f       	mov	r16, r25
    1a10:	f6 2e       	mov	r15, r22
    1a12:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    1a14:	0e 94 b4 04 	call	0x968	; 0x968 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1a18:	c1 2f       	mov	r28, r17
    1a1a:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1a1c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a1e:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1a20:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1a22:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1a24:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1a26:	80 50       	subi	r24, 0x00	; 0
    1a28:	98 40       	sbci	r25, 0x08	; 8
    1a2a:	09 f0       	breq	.+2      	; 0x1a2e <ARP_ProcessARPPacket+0x2e>
    1a2c:	5e c0       	rjmp	.+188    	; 0x1aea <ARP_ProcessARPPacket+0xea>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1a2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1a30:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1a32:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1a34:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1a36:	92 2f       	mov	r25, r18
    1a38:	01 97       	sbiw	r24, 0x01	; 1
    1a3a:	09 f0       	breq	.+2      	; 0x1a3e <ARP_ProcessARPPacket+0x3e>
    1a3c:	56 c0       	rjmp	.+172    	; 0x1aea <ARP_ProcessARPPacket+0xea>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1a3e:	ce 01       	movw	r24, r28
    1a40:	48 96       	adiw	r24, 0x18	; 24
    1a42:	6e e0       	ldi	r22, 0x0E	; 14
    1a44:	71 e0       	ldi	r23, 0x01	; 1
    1a46:	44 e0       	ldi	r20, 0x04	; 4
    1a48:	50 e0       	ldi	r21, 0x00	; 0
    1a4a:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	59 f0       	breq	.+22     	; 0x1a68 <ARP_ProcessARPPacket+0x68>
    1a52:	ce 01       	movw	r24, r28
    1a54:	42 96       	adiw	r24, 0x12	; 18
    1a56:	68 e0       	ldi	r22, 0x08	; 8
    1a58:	71 e0       	ldi	r23, 0x01	; 1
    1a5a:	46 e0       	ldi	r20, 0x06	; 6
    1a5c:	50 e0       	ldi	r21, 0x00	; 0
    1a5e:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
    1a62:	00 97       	sbiw	r24, 0x00	; 0
    1a64:	09 f0       	breq	.+2      	; 0x1a68 <ARP_ProcessARPPacket+0x68>
    1a66:	41 c0       	rjmp	.+130    	; 0x1aea <ARP_ProcessARPPacket+0xea>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1a68:	ef 2d       	mov	r30, r15
    1a6a:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1a6c:	88 81       	ld	r24, Y
    1a6e:	99 81       	ldd	r25, Y+1	; 0x01
    1a70:	91 83       	std	Z+1, r25	; 0x01
    1a72:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1a74:	8a 81       	ldd	r24, Y+2	; 0x02
    1a76:	9b 81       	ldd	r25, Y+3	; 0x03
    1a78:	93 83       	std	Z+3, r25	; 0x03
    1a7a:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1a7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a7e:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1a80:	8d 81       	ldd	r24, Y+5	; 0x05
    1a82:	85 83       	std	Z+5, r24	; 0x05
    1a84:	80 e0       	ldi	r24, 0x00	; 0
    1a86:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1a88:	97 83       	std	Z+7, r25	; 0x07
    1a8a:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    1a8c:	9f 01       	movw	r18, r30
    1a8e:	2e 5e       	subi	r18, 0xEE	; 238
    1a90:	3f 4f       	sbci	r19, 0xFF	; 255
    1a92:	ae 01       	movw	r20, r28
    1a94:	48 5f       	subi	r20, 0xF8	; 248
    1a96:	5f 4f       	sbci	r21, 0xFF	; 255
    1a98:	86 e0       	ldi	r24, 0x06	; 6
    1a9a:	da 01       	movw	r26, r20
    1a9c:	0d 90       	ld	r0, X+
    1a9e:	ad 01       	movw	r20, r26
    1aa0:	d9 01       	movw	r26, r18
    1aa2:	0d 92       	st	X+, r0
    1aa4:	9d 01       	movw	r18, r26
    1aa6:	81 50       	subi	r24, 0x01	; 1
    1aa8:	c1 f7       	brne	.-16     	; 0x1a9a <ARP_ProcessARPPacket+0x9a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1aaa:	8e 85       	ldd	r24, Y+14	; 0x0e
    1aac:	9f 85       	ldd	r25, Y+15	; 0x0f
    1aae:	a8 89       	ldd	r26, Y+16	; 0x10
    1ab0:	b9 89       	ldd	r27, Y+17	; 0x11
    1ab2:	80 8f       	std	Z+24, r24	; 0x18
    1ab4:	91 8f       	std	Z+25, r25	; 0x19
    1ab6:	a2 8f       	std	Z+26, r26	; 0x1a
    1ab8:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1aba:	ef 01       	movw	r28, r30
    1abc:	28 96       	adiw	r28, 0x08	; 8
    1abe:	a8 e0       	ldi	r26, 0x08	; 8
    1ac0:	b1 e0       	ldi	r27, 0x01	; 1
    1ac2:	86 e0       	ldi	r24, 0x06	; 6
    1ac4:	0d 90       	ld	r0, X+
    1ac6:	09 92       	st	Y+, r0
    1ac8:	81 50       	subi	r24, 0x01	; 1
    1aca:	e1 f7       	brne	.-8      	; 0x1ac4 <ARP_ProcessARPPacket+0xc4>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1acc:	80 91 0e 01 	lds	r24, 0x010E
    1ad0:	90 91 0f 01 	lds	r25, 0x010F
    1ad4:	a0 91 10 01 	lds	r26, 0x0110
    1ad8:	b0 91 11 01 	lds	r27, 0x0111
    1adc:	86 87       	std	Z+14, r24	; 0x0e
    1ade:	97 87       	std	Z+15, r25	; 0x0f
    1ae0:	a0 8b       	std	Z+16, r26	; 0x10
    1ae2:	b1 8b       	std	Z+17, r27	; 0x11
    1ae4:	2c e1       	ldi	r18, 0x1C	; 28
    1ae6:	30 e0       	ldi	r19, 0x00	; 0
    1ae8:	02 c0       	rjmp	.+4      	; 0x1aee <ARP_ProcessARPPacket+0xee>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1aea:	20 e0       	ldi	r18, 0x00	; 0
    1aec:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    1aee:	c9 01       	movw	r24, r18
    1af0:	df 91       	pop	r29
    1af2:	cf 91       	pop	r28
    1af4:	1f 91       	pop	r17
    1af6:	0f 91       	pop	r16
    1af8:	ff 90       	pop	r15
    1afa:	ef 90       	pop	r14
    1afc:	08 95       	ret

00001afe <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    1afe:	df 92       	push	r13
    1b00:	ef 92       	push	r14
    1b02:	ff 92       	push	r15
    1b04:	0f 93       	push	r16
    1b06:	1f 93       	push	r17
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
    1b0c:	7c 01       	movw	r14, r24
    1b0e:	eb 01       	movw	r28, r22
	DecodeIPHeader(InDataStart);
    1b10:	0e 94 b5 04 	call	0x96a	; 0x96a <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1b14:	f7 01       	movw	r30, r14
    1b16:	d0 80       	ld	r13, Z
    1b18:	ff e0       	ldi	r31, 0x0F	; 15
    1b1a:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1b1c:	87 01       	movw	r16, r14
    1b1e:	00 5f       	subi	r16, 0xF0	; 240
    1b20:	1f 4f       	sbci	r17, 0xFF	; 255
    1b22:	c8 01       	movw	r24, r16
    1b24:	6e e0       	ldi	r22, 0x0E	; 14
    1b26:	71 e0       	ldi	r23, 0x01	; 1
    1b28:	44 e0       	ldi	r20, 0x04	; 4
    1b2a:	50 e0       	ldi	r21, 0x00	; 0
    1b2c:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
    1b30:	00 97       	sbiw	r24, 0x00	; 0
    1b32:	49 f0       	breq	.+18     	; 0x1b46 <IP_ProcessIPPacket+0x48>
    1b34:	c8 01       	movw	r24, r16
    1b36:	68 e1       	ldi	r22, 0x18	; 24
    1b38:	71 e0       	ldi	r23, 0x01	; 1
    1b3a:	44 e0       	ldi	r20, 0x04	; 4
    1b3c:	50 e0       	ldi	r21, 0x00	; 0
    1b3e:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcmp>
    1b42:	00 97       	sbiw	r24, 0x00	; 0
    1b44:	71 f4       	brne	.+28     	; 0x1b62 <IP_ProcessIPPacket+0x64>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1b46:	2d 2d       	mov	r18, r13
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	22 0f       	add	r18, r18
    1b4c:	33 1f       	adc	r19, r19
    1b4e:	22 0f       	add	r18, r18
    1b50:	33 1f       	adc	r19, r19
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1b52:	f7 01       	movw	r30, r14
    1b54:	81 85       	ldd	r24, Z+9	; 0x09
    1b56:	86 30       	cpi	r24, 0x06	; 6
    1b58:	81 f0       	breq	.+32     	; 0x1b7a <IP_ProcessIPPacket+0x7c>
    1b5a:	81 31       	cpi	r24, 0x11	; 17
    1b5c:	b9 f0       	breq	.+46     	; 0x1b8c <IP_ProcessIPPacket+0x8e>
    1b5e:	81 30       	cpi	r24, 0x01	; 1
    1b60:	19 f0       	breq	.+6      	; 0x1b68 <IP_ProcessIPPacket+0x6a>
    1b62:	20 e0       	ldi	r18, 0x00	; 0
    1b64:	30 e0       	ldi	r19, 0x00	; 0
    1b66:	49 c0       	rjmp	.+146    	; 0x1bfa <IP_ProcessIPPacket+0xfc>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1b68:	be 01       	movw	r22, r28
    1b6a:	6c 5e       	subi	r22, 0xEC	; 236
    1b6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b6e:	c7 01       	movw	r24, r14
    1b70:	82 0f       	add	r24, r18
    1b72:	93 1f       	adc	r25, r19
    1b74:	0e 94 ba 04 	call	0x974	; 0x974 <ICMP_ProcessICMPPacket>
    1b78:	11 c0       	rjmp	.+34     	; 0x1b9c <IP_ProcessIPPacket+0x9e>
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1b7a:	2e 0d       	add	r18, r14
    1b7c:	3f 1d       	adc	r19, r15
    1b7e:	ae 01       	movw	r20, r28
    1b80:	4c 5e       	subi	r20, 0xEC	; 236
    1b82:	5f 4f       	sbci	r21, 0xFF	; 255
    1b84:	c7 01       	movw	r24, r14
    1b86:	b9 01       	movw	r22, r18
    1b88:	da d9       	rcall	.-3148   	; 0xf3e <TCP_ProcessTCPPacket>
    1b8a:	08 c0       	rjmp	.+16     	; 0x1b9c <IP_ProcessIPPacket+0x9e>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1b8c:	2e 0d       	add	r18, r14
    1b8e:	3f 1d       	adc	r19, r15
    1b90:	ae 01       	movw	r20, r28
    1b92:	4c 5e       	subi	r20, 0xEC	; 236
    1b94:	5f 4f       	sbci	r21, 0xFF	; 255
    1b96:	c7 01       	movw	r24, r14
    1b98:	b9 01       	movw	r22, r18
    1b9a:	20 de       	rcall	.-960    	; 0x17dc <UDP_ProcessUDPPacket>
    1b9c:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1b9e:	18 16       	cp	r1, r24
    1ba0:	19 06       	cpc	r1, r25
    1ba2:	5c f5       	brge	.+86     	; 0x1bfa <IP_ProcessIPPacket+0xfc>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1ba4:	8c 01       	movw	r16, r24
    1ba6:	0c 5e       	subi	r16, 0xEC	; 236
    1ba8:	1f 4f       	sbci	r17, 0xFF	; 255
    1baa:	1a 83       	std	Y+2, r17	; 0x02
    1bac:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    1bae:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1bb0:	85 e4       	ldi	r24, 0x45	; 69
    1bb2:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1bb4:	1e 82       	std	Y+6, r1	; 0x06
    1bb6:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1bb8:	1d 82       	std	Y+5, r1	; 0x05
    1bba:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    1bbc:	1b 86       	std	Y+11, r1	; 0x0b
    1bbe:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1bc0:	f7 01       	movw	r30, r14
    1bc2:	81 85       	ldd	r24, Z+9	; 0x09
    1bc4:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1bc6:	80 e8       	ldi	r24, 0x80	; 128
    1bc8:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1bca:	80 89       	ldd	r24, Z+16	; 0x10
    1bcc:	91 89       	ldd	r25, Z+17	; 0x11
    1bce:	a2 89       	ldd	r26, Z+18	; 0x12
    1bd0:	b3 89       	ldd	r27, Z+19	; 0x13
    1bd2:	8c 87       	std	Y+12, r24	; 0x0c
    1bd4:	9d 87       	std	Y+13, r25	; 0x0d
    1bd6:	ae 87       	std	Y+14, r26	; 0x0e
    1bd8:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1bda:	84 85       	ldd	r24, Z+12	; 0x0c
    1bdc:	95 85       	ldd	r25, Z+13	; 0x0d
    1bde:	a6 85       	ldd	r26, Z+14	; 0x0e
    1be0:	b7 85       	ldd	r27, Z+15	; 0x0f
    1be2:	88 8b       	std	Y+16, r24	; 0x10
    1be4:	99 8b       	std	Y+17, r25	; 0x11
    1be6:	aa 8b       	std	Y+18, r26	; 0x12
    1be8:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1bea:	ce 01       	movw	r24, r28
    1bec:	64 e1       	ldi	r22, 0x14	; 20
    1bee:	70 e0       	ldi	r23, 0x00	; 0
    1bf0:	0e 94 12 04 	call	0x824	; 0x824 <Ethernet_Checksum16>
    1bf4:	9b 87       	std	Y+11, r25	; 0x0b
    1bf6:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1bf8:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    1bfa:	c9 01       	movw	r24, r18
    1bfc:	df 91       	pop	r29
    1bfe:	cf 91       	pop	r28
    1c00:	1f 91       	pop	r17
    1c02:	0f 91       	pop	r16
    1c04:	ff 90       	pop	r15
    1c06:	ef 90       	pop	r14
    1c08:	df 90       	pop	r13
    1c0a:	08 95       	ret

00001c0c <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1c0c:	db 01       	movw	r26, r22
    1c0e:	0d 90       	ld	r0, X+
    1c10:	00 20       	and	r0, r0
    1c12:	e9 f7       	brne	.-6      	; 0x1c0e <IsHTTPCommand+0x2>
    1c14:	11 97       	sbiw	r26, 0x01	; 1
    1c16:	a6 1b       	sub	r26, r22
    1c18:	b7 0b       	sbc	r27, r23
    1c1a:	ad 01       	movw	r20, r26
    1c1c:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <strncmp>
    1c20:	9c 01       	movw	r18, r24
    1c22:	80 e0       	ldi	r24, 0x00	; 0
    1c24:	23 2b       	or	r18, r19
    1c26:	09 f4       	brne	.+2      	; 0x1c2a <IsHTTPCommand+0x1e>
    1c28:	81 e0       	ldi	r24, 0x01	; 1
}
    1c2a:	08 95       	ret

00001c2c <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1c2c:	af 92       	push	r10
    1c2e:	bf 92       	push	r11
    1c30:	cf 92       	push	r12
    1c32:	df 92       	push	r13
    1c34:	ef 92       	push	r14
    1c36:	ff 92       	push	r15
    1c38:	0f 93       	push	r16
    1c3a:	1f 93       	push	r17
    1c3c:	cf 93       	push	r28
    1c3e:	df 93       	push	r29
    1c40:	5c 01       	movw	r10, r24
    1c42:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1c44:	8b 01       	movw	r16, r22
    1c46:	0e 5f       	subi	r16, 0xFE	; 254
    1c48:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1c4a:	33 e0       	ldi	r19, 0x03	; 3
    1c4c:	c3 2e       	mov	r12, r19
    1c4e:	32 e0       	ldi	r19, 0x02	; 2
    1c50:	d3 2e       	mov	r13, r19
    1c52:	c6 0e       	add	r12, r22
    1c54:	d7 1e       	adc	r13, r23
    1c56:	f6 01       	movw	r30, r12
    1c58:	80 81       	ld	r24, Z
    1c5a:	88 23       	and	r24, r24
    1c5c:	09 f4       	brne	.+2      	; 0x1c60 <Webserver_ApplicationCallback+0x34>
    1c5e:	65 c0       	rjmp	.+202    	; 0x1d2a <Webserver_ApplicationCallback+0xfe>
    1c60:	22 e0       	ldi	r18, 0x02	; 2
    1c62:	e2 2e       	mov	r14, r18
    1c64:	f2 2e       	mov	r15, r18
    1c66:	e6 0e       	add	r14, r22
    1c68:	f7 1e       	adc	r15, r23
    1c6a:	f7 01       	movw	r30, r14
    1c6c:	80 81       	ld	r24, Z
    1c6e:	88 23       	and	r24, r24
    1c70:	09 f0       	breq	.+2      	; 0x1c74 <Webserver_ApplicationCallback+0x48>
    1c72:	a4 c0       	rjmp	.+328    	; 0x1dbc <Webserver_ApplicationCallback+0x190>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1c74:	c8 01       	movw	r24, r16
    1c76:	66 e2       	ldi	r22, 0x26	; 38
    1c78:	71 e0       	ldi	r23, 0x01	; 1
    1c7a:	c8 df       	rcall	.-112    	; 0x1c0c <IsHTTPCommand>
    1c7c:	88 23       	and	r24, r24
    1c7e:	f9 f0       	breq	.+62     	; 0x1cbe <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1c80:	c8 01       	movw	r24, r16
    1c82:	6a e2       	ldi	r22, 0x2A	; 42
    1c84:	71 e0       	ldi	r23, 0x01	; 1
    1c86:	c2 df       	rcall	.-124    	; 0x1c0c <IsHTTPCommand>
    1c88:	88 23       	and	r24, r24
    1c8a:	49 f1       	breq	.+82     	; 0x1cde <Webserver_ApplicationCallback+0xb2>
			{
				PageBlock = 0;
    1c8c:	10 92 54 01 	sts	0x0154, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1c90:	c8 01       	movw	r24, r16
    1c92:	60 e3       	ldi	r22, 0x30	; 48
    1c94:	71 e0       	ldi	r23, 0x01	; 1
    1c96:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1c9a:	81 e0       	ldi	r24, 0x01	; 1
    1c9c:	f7 01       	movw	r30, r14
    1c9e:	80 83       	st	Z, r24
    1ca0:	f8 01       	movw	r30, r16
    1ca2:	01 90       	ld	r0, Z+
    1ca4:	00 20       	and	r0, r0
    1ca6:	e9 f7       	brne	.-6      	; 0x1ca2 <Webserver_ApplicationCallback+0x76>
    1ca8:	31 97       	sbiw	r30, 0x01	; 1
    1caa:	e0 1b       	sub	r30, r16
    1cac:	f1 0b       	sbc	r31, r17
    1cae:	f9 83       	std	Y+1, r31	; 0x01
    1cb0:	e8 83       	st	Y, r30
    1cb2:	f6 01       	movw	r30, r12
    1cb4:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1cb6:	cc 5f       	subi	r28, 0xFC	; 252
    1cb8:	dd 4f       	sbci	r29, 0xFD	; 253
    1cba:	88 83       	st	Y, r24
    1cbc:	7f c0       	rjmp	.+254    	; 0x1dbc <Webserver_ApplicationCallback+0x190>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1cbe:	c8 01       	movw	r24, r16
    1cc0:	61 e3       	ldi	r22, 0x31	; 49
    1cc2:	71 e0       	ldi	r23, 0x01	; 1
    1cc4:	a3 df       	rcall	.-186    	; 0x1c0c <IsHTTPCommand>
    1cc6:	88 23       	and	r24, r24
    1cc8:	09 f1       	breq	.+66     	; 0x1d0c <Webserver_ApplicationCallback+0xe0>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1cca:	c8 01       	movw	r24, r16
    1ccc:	66 e3       	ldi	r22, 0x36	; 54
    1cce:	71 e0       	ldi	r23, 0x01	; 1
    1cd0:	9d df       	rcall	.-198    	; 0x1c0c <IsHTTPCommand>
    1cd2:	88 23       	and	r24, r24
    1cd4:	21 f0       	breq	.+8      	; 0x1cde <Webserver_ApplicationCallback+0xb2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1cd6:	c8 01       	movw	r24, r16
    1cd8:	60 e3       	ldi	r22, 0x30	; 48
    1cda:	71 e0       	ldi	r23, 0x01	; 1
    1cdc:	03 c0       	rjmp	.+6      	; 0x1ce4 <Webserver_ApplicationCallback+0xb8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1cde:	c8 01       	movw	r24, r16
    1ce0:	64 e8       	ldi	r22, 0x84	; 132
    1ce2:	71 e0       	ldi	r23, 0x01	; 1
    1ce4:	e1 d7       	rcall	.+4034   	; 0x2ca8 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	f7 01       	movw	r30, r14
    1cea:	80 83       	st	Z, r24
    1cec:	f8 01       	movw	r30, r16
    1cee:	01 90       	ld	r0, Z+
    1cf0:	00 20       	and	r0, r0
    1cf2:	e9 f7       	brne	.-6      	; 0x1cee <Webserver_ApplicationCallback+0xc2>
    1cf4:	31 97       	sbiw	r30, 0x01	; 1
    1cf6:	e0 1b       	sub	r30, r16
    1cf8:	f1 0b       	sbc	r31, r17
    1cfa:	f9 83       	std	Y+1, r31	; 0x01
    1cfc:	e8 83       	st	Y, r30
    1cfe:	f6 01       	movw	r30, r12
    1d00:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1d02:	85 e1       	ldi	r24, 0x15	; 21
    1d04:	92 e0       	ldi	r25, 0x02	; 2
    1d06:	a8 0e       	add	r10, r24
    1d08:	b9 1e       	adc	r11, r25
    1d0a:	55 c0       	rjmp	.+170    	; 0x1db6 <Webserver_ApplicationCallback+0x18a>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1d0c:	c8 01       	movw	r24, r16
    1d0e:	6e e3       	ldi	r22, 0x3E	; 62
    1d10:	71 e0       	ldi	r23, 0x01	; 1
    1d12:	7c df       	rcall	.-264    	; 0x1c0c <IsHTTPCommand>
    1d14:	88 23       	and	r24, r24
    1d16:	21 f0       	breq	.+8      	; 0x1d20 <Webserver_ApplicationCallback+0xf4>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	f7 01       	movw	r30, r14
    1d1c:	80 83       	st	Z, r24
    1d1e:	ef cf       	rjmp	.-34     	; 0x1cfe <Webserver_ApplicationCallback+0xd2>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1d20:	f6 01       	movw	r30, r12
    1d22:	10 82       	st	Z, r1
    1d24:	19 82       	std	Y+1, r1	; 0x01
    1d26:	18 82       	st	Y, r1
    1d28:	49 c0       	rjmp	.+146    	; 0x1dbc <Webserver_ApplicationCallback+0x190>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1d2a:	cc 5f       	subi	r28, 0xFC	; 252
    1d2c:	dd 4f       	sbci	r29, 0xFD	; 253
    1d2e:	88 81       	ld	r24, Y
    1d30:	c4 50       	subi	r28, 0x04	; 4
    1d32:	d2 40       	sbci	r29, 0x02	; 2
    1d34:	88 23       	and	r24, r24
    1d36:	09 f4       	brne	.+2      	; 0x1d3a <Webserver_ApplicationCallback+0x10e>
    1d38:	41 c0       	rjmp	.+130    	; 0x1dbc <Webserver_ApplicationCallback+0x190>
    1d3a:	ce 5f       	subi	r28, 0xFE	; 254
    1d3c:	dd 4f       	sbci	r29, 0xFD	; 253
    1d3e:	88 81       	ld	r24, Y
    1d40:	c2 50       	subi	r28, 0x02	; 2
    1d42:	d2 40       	sbci	r29, 0x02	; 2
    1d44:	88 23       	and	r24, r24
    1d46:	d1 f1       	breq	.+116    	; 0x1dbc <Webserver_ApplicationCallback+0x190>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1d48:	80 91 54 01 	lds	r24, 0x0154
    1d4c:	c8 2e       	mov	r12, r24
    1d4e:	dd 24       	eor	r13, r13
    1d50:	d6 94       	lsr	r13
    1d52:	dc 2c       	mov	r13, r12
    1d54:	cc 24       	eor	r12, r12
    1d56:	d7 94       	ror	r13
    1d58:	c7 94       	ror	r12
    1d5a:	86 ec       	ldi	r24, 0xC6	; 198
    1d5c:	91 e0       	ldi	r25, 0x01	; 1
    1d5e:	c8 0e       	add	r12, r24
    1d60:	d9 1e       	adc	r13, r25
    1d62:	c6 01       	movw	r24, r12
    1d64:	a8 d7       	rcall	.+3920   	; 0x2cb6 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1d66:	7c 01       	movw	r14, r24
    1d68:	91 e8       	ldi	r25, 0x81	; 129
    1d6a:	e9 16       	cp	r14, r25
    1d6c:	f1 04       	cpc	r15, r1
    1d6e:	18 f0       	brcs	.+6      	; 0x1d76 <Webserver_ApplicationCallback+0x14a>
    1d70:	80 e8       	ldi	r24, 0x80	; 128
    1d72:	e8 2e       	mov	r14, r24
    1d74:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1d76:	c8 01       	movw	r24, r16
    1d78:	b6 01       	movw	r22, r12
    1d7a:	a7 01       	movw	r20, r14
    1d7c:	a5 d7       	rcall	.+3914   	; 0x2cc8 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1d7e:	ce 5f       	subi	r28, 0xFE	; 254
    1d80:	dd 4f       	sbci	r29, 0xFD	; 253
    1d82:	81 e0       	ldi	r24, 0x01	; 1
    1d84:	88 83       	st	Y, r24
    1d86:	c2 50       	subi	r28, 0x02	; 2
    1d88:	d2 40       	sbci	r29, 0x02	; 2
    1d8a:	f9 82       	std	Y+1, r15	; 0x01
    1d8c:	e8 82       	st	Y, r14
    1d8e:	cd 5f       	subi	r28, 0xFD	; 253
    1d90:	dd 4f       	sbci	r29, 0xFD	; 253
    1d92:	88 83       	st	Y, r24
    1d94:	c3 50       	subi	r28, 0x03	; 3
    1d96:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1d98:	80 91 54 01 	lds	r24, 0x0154
    1d9c:	8f 5f       	subi	r24, 0xFF	; 255
    1d9e:	80 93 54 01 	sts	0x0154, r24
    1da2:	81 50       	subi	r24, 0x01	; 1
    1da4:	83 30       	cpi	r24, 0x03	; 3
    1da6:	51 f4       	brne	.+20     	; 0x1dbc <Webserver_ApplicationCallback+0x190>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1da8:	cc 5f       	subi	r28, 0xFC	; 252
    1daa:	dd 4f       	sbci	r29, 0xFD	; 253
    1dac:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1dae:	e5 e1       	ldi	r30, 0x15	; 21
    1db0:	f2 e0       	ldi	r31, 0x02	; 2
    1db2:	ae 0e       	add	r10, r30
    1db4:	bf 1e       	adc	r11, r31
    1db6:	87 e0       	ldi	r24, 0x07	; 7
    1db8:	f5 01       	movw	r30, r10
    1dba:	80 83       	st	Z, r24
		}
	}
}
    1dbc:	df 91       	pop	r29
    1dbe:	cf 91       	pop	r28
    1dc0:	1f 91       	pop	r17
    1dc2:	0f 91       	pop	r16
    1dc4:	ff 90       	pop	r15
    1dc6:	ef 90       	pop	r14
    1dc8:	df 90       	pop	r13
    1dca:	cf 90       	pop	r12
    1dcc:	bf 90       	pop	r11
    1dce:	af 90       	pop	r10
    1dd0:	08 95       	ret

00001dd2 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1dd2:	80 e0       	ldi	r24, 0x00	; 0
    1dd4:	90 e5       	ldi	r25, 0x50	; 80
    1dd6:	61 e0       	ldi	r22, 0x01	; 1
    1dd8:	46 e1       	ldi	r20, 0x16	; 22
    1dda:	5e e0       	ldi	r21, 0x0E	; 14
    1ddc:	0c 94 fd 04 	jmp	0x9fa	; 0x9fa <TCP_SetPortState>

00001de0 <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
    1de0:	e0 91 44 01 	lds	r30, 0x0144
    1de4:	f0 91 45 01 	lds	r31, 0x0145
    1de8:	80 81       	ld	r24, Z
    1dea:	91 81       	ldd	r25, Z+1	; 0x01
    1dec:	a2 81       	ldd	r26, Z+2	; 0x02
    1dee:	b3 81       	ldd	r27, Z+3	; 0x03
    1df0:	84 30       	cpi	r24, 0x04	; 4
    1df2:	91 05       	cpc	r25, r1
    1df4:	a1 05       	cpc	r26, r1
    1df6:	b1 05       	cpc	r27, r1
    1df8:	09 f4       	brne	.+2      	; 0x1dfc <ProcessRNDISControlMessage+0x1c>
    1dfa:	a1 c0       	rjmp	.+322    	; 0x1f3e <ProcessRNDISControlMessage+0x15e>
    1dfc:	85 30       	cpi	r24, 0x05	; 5
    1dfe:	91 05       	cpc	r25, r1
    1e00:	a1 05       	cpc	r26, r1
    1e02:	b1 05       	cpc	r27, r1
    1e04:	58 f4       	brcc	.+22     	; 0x1e1c <ProcessRNDISControlMessage+0x3c>
    1e06:	82 30       	cpi	r24, 0x02	; 2
    1e08:	91 05       	cpc	r25, r1
    1e0a:	a1 05       	cpc	r26, r1
    1e0c:	b1 05       	cpc	r27, r1
    1e0e:	c1 f0       	breq	.+48     	; 0x1e40 <ProcessRNDISControlMessage+0x60>
    1e10:	03 97       	sbiw	r24, 0x03	; 3
    1e12:	a1 05       	cpc	r26, r1
    1e14:	b1 05       	cpc	r27, r1
    1e16:	09 f0       	breq	.+2      	; 0x1e1a <ProcessRNDISControlMessage+0x3a>
    1e18:	b5 c2       	rjmp	.+1386   	; 0x2384 <__stack+0x285>
    1e1a:	88 c0       	rjmp	.+272    	; 0x1f2c <ProcessRNDISControlMessage+0x14c>
    1e1c:	86 30       	cpi	r24, 0x06	; 6
    1e1e:	91 05       	cpc	r25, r1
    1e20:	a1 05       	cpc	r26, r1
    1e22:	b1 05       	cpc	r27, r1
    1e24:	09 f4       	brne	.+2      	; 0x1e28 <ProcessRNDISControlMessage+0x48>
    1e26:	34 c2       	rjmp	.+1128   	; 0x2290 <__stack+0x191>
    1e28:	86 30       	cpi	r24, 0x06	; 6
    1e2a:	91 05       	cpc	r25, r1
    1e2c:	a1 05       	cpc	r26, r1
    1e2e:	b1 05       	cpc	r27, r1
    1e30:	08 f4       	brcc	.+2      	; 0x1e34 <ProcessRNDISControlMessage+0x54>
    1e32:	d5 c1       	rjmp	.+938    	; 0x21de <__stack+0xdf>
    1e34:	08 97       	sbiw	r24, 0x08	; 8
    1e36:	a1 05       	cpc	r26, r1
    1e38:	b1 05       	cpc	r27, r1
    1e3a:	09 f0       	breq	.+2      	; 0x1e3e <ProcessRNDISControlMessage+0x5e>
    1e3c:	a3 c2       	rjmp	.+1350   	; 0x2384 <__stack+0x285>
    1e3e:	4c c2       	rjmp	.+1176   	; 0x22d8 <__stack+0x1d9>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
    1e40:	21 e0       	ldi	r18, 0x01	; 1
    1e42:	20 93 55 01 	sts	0x0155, r18

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
    1e46:	82 e0       	ldi	r24, 0x02	; 2
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	a0 e0       	ldi	r26, 0x00	; 0
    1e4c:	b0 e8       	ldi	r27, 0x80	; 128
    1e4e:	80 93 60 13 	sts	0x1360, r24
    1e52:	90 93 61 13 	sts	0x1361, r25
    1e56:	a0 93 62 13 	sts	0x1362, r26
    1e5a:	b0 93 63 13 	sts	0x1363, r27
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
    1e5e:	84 e3       	ldi	r24, 0x34	; 52
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	a0 e0       	ldi	r26, 0x00	; 0
    1e64:	b0 e0       	ldi	r27, 0x00	; 0
    1e66:	80 93 64 13 	sts	0x1364, r24
    1e6a:	90 93 65 13 	sts	0x1365, r25
    1e6e:	a0 93 66 13 	sts	0x1366, r26
    1e72:	b0 93 67 13 	sts	0x1367, r27
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
    1e76:	10 92 6c 13 	sts	0x136C, r1
    1e7a:	10 92 6d 13 	sts	0x136D, r1
    1e7e:	10 92 6e 13 	sts	0x136E, r1
    1e82:	10 92 6f 13 	sts	0x136F, r1

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	a0 e0       	ldi	r26, 0x00	; 0
    1e8c:	b0 e0       	ldi	r27, 0x00	; 0
    1e8e:	80 93 70 13 	sts	0x1370, r24
    1e92:	90 93 71 13 	sts	0x1371, r25
    1e96:	a0 93 72 13 	sts	0x1372, r26
    1e9a:	b0 93 73 13 	sts	0x1373, r27
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
    1e9e:	10 92 74 13 	sts	0x1374, r1
    1ea2:	10 92 75 13 	sts	0x1375, r1
    1ea6:	10 92 76 13 	sts	0x1376, r1
    1eaa:	10 92 77 13 	sts	0x1377, r1
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
    1eae:	80 93 78 13 	sts	0x1378, r24
    1eb2:	90 93 79 13 	sts	0x1379, r25
    1eb6:	a0 93 7a 13 	sts	0x137A, r26
    1eba:	b0 93 7b 13 	sts	0x137B, r27
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
    1ebe:	10 92 7c 13 	sts	0x137C, r1
    1ec2:	10 92 7d 13 	sts	0x137D, r1
    1ec6:	10 92 7e 13 	sts	0x137E, r1
    1eca:	10 92 7f 13 	sts	0x137F, r1
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
    1ece:	80 93 80 13 	sts	0x1380, r24
    1ed2:	90 93 81 13 	sts	0x1381, r25
    1ed6:	a0 93 82 13 	sts	0x1382, r26
    1eda:	b0 93 83 13 	sts	0x1383, r27
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    1ede:	88 e0       	ldi	r24, 0x08	; 8
    1ee0:	96 e0       	ldi	r25, 0x06	; 6
    1ee2:	a0 e0       	ldi	r26, 0x00	; 0
    1ee4:	b0 e0       	ldi	r27, 0x00	; 0
    1ee6:	80 93 84 13 	sts	0x1384, r24
    1eea:	90 93 85 13 	sts	0x1385, r25
    1eee:	a0 93 86 13 	sts	0x1386, r26
    1ef2:	b0 93 87 13 	sts	0x1387, r27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
    1ef6:	10 92 88 13 	sts	0x1388, r1
    1efa:	10 92 89 13 	sts	0x1389, r1
    1efe:	10 92 8a 13 	sts	0x138A, r1
    1f02:	10 92 8b 13 	sts	0x138B, r1
			INITIALIZE_Response->AFListOffset          = 0;
    1f06:	10 92 8c 13 	sts	0x138C, r1
    1f0a:	10 92 8d 13 	sts	0x138D, r1
    1f0e:	10 92 8e 13 	sts	0x138E, r1
    1f12:	10 92 8f 13 	sts	0x138F, r1
			INITIALIZE_Response->AFListSize            = 0;
    1f16:	10 92 90 13 	sts	0x1390, r1
    1f1a:	10 92 91 13 	sts	0x1391, r1
    1f1e:	10 92 92 13 	sts	0x1392, r1
    1f22:	10 92 93 13 	sts	0x1393, r1

			CurrRNDISState = RNDIS_Initialized;
    1f26:	20 93 56 01 	sts	0x0156, r18
    1f2a:	08 95       	ret

			break;
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
    1f2c:	10 92 55 01 	sts	0x0155, r1
			MessageHeader->MessageLength = 0;
    1f30:	14 82       	std	Z+4, r1	; 0x04
    1f32:	15 82       	std	Z+5, r1	; 0x05
    1f34:	16 82       	std	Z+6, r1	; 0x06
    1f36:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
    1f38:	10 92 56 01 	sts	0x0156, r1
    1f3c:	08 95       	ret

			break;
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
    1f3e:	81 e0       	ldi	r24, 0x01	; 1
    1f40:	80 93 55 01 	sts	0x0155, r24

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
    1f44:	60 e6       	ldi	r22, 0x60	; 96
    1f46:	73 e1       	ldi	r23, 0x13	; 19
			uint32_t                Query_Oid      = QUERY_Message->Oid;
    1f48:	20 91 6c 13 	lds	r18, 0x136C
    1f4c:	30 91 6d 13 	lds	r19, 0x136D
    1f50:	40 91 6e 13 	lds	r20, 0x136E
    1f54:	50 91 6f 13 	lds	r21, 0x136F
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
    1f58:	84 e0       	ldi	r24, 0x04	; 4
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	a0 e0       	ldi	r26, 0x00	; 0
    1f5e:	b0 e8       	ldi	r27, 0x80	; 128
    1f60:	80 93 60 13 	sts	0x1360, r24
    1f64:	90 93 61 13 	sts	0x1361, r25
    1f68:	a0 93 62 13 	sts	0x1362, r26
    1f6c:	b0 93 63 13 	sts	0x1363, r27
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
    1f70:	88 e1       	ldi	r24, 0x18	; 24
    1f72:	90 e0       	ldi	r25, 0x00	; 0
    1f74:	a0 e0       	ldi	r26, 0x00	; 0
    1f76:	b0 e0       	ldi	r27, 0x00	; 0
    1f78:	80 93 64 13 	sts	0x1364, r24
    1f7c:	90 93 65 13 	sts	0x1365, r25
    1f80:	a0 93 66 13 	sts	0x1366, r26
    1f84:	b0 93 67 13 	sts	0x1367, r27
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1f88:	2e 30       	cpi	r18, 0x0E	; 14
    1f8a:	81 e0       	ldi	r24, 0x01	; 1
    1f8c:	38 07       	cpc	r19, r24
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	48 07       	cpc	r20, r24
    1f92:	80 e0       	ldi	r24, 0x00	; 0
    1f94:	58 07       	cpc	r21, r24
    1f96:	09 f4       	brne	.+2      	; 0x1f9a <ProcessRNDISControlMessage+0x1ba>
    1f98:	e4 c0       	rjmp	.+456    	; 0x2162 <__stack+0x63>
    1f9a:	2f 30       	cpi	r18, 0x0F	; 15
    1f9c:	81 e0       	ldi	r24, 0x01	; 1
    1f9e:	38 07       	cpc	r19, r24
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	48 07       	cpc	r20, r24
    1fa4:	80 e0       	ldi	r24, 0x00	; 0
    1fa6:	58 07       	cpc	r21, r24
    1fa8:	08 f0       	brcs	.+2      	; 0x1fac <ProcessRNDISControlMessage+0x1cc>
    1faa:	58 c0       	rjmp	.+176    	; 0x205c <ProcessRNDISControlMessage+0x27c>
    1fac:	26 30       	cpi	r18, 0x06	; 6
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	38 07       	cpc	r19, r24
    1fb2:	81 e0       	ldi	r24, 0x01	; 1
    1fb4:	48 07       	cpc	r20, r24
    1fb6:	80 e0       	ldi	r24, 0x00	; 0
    1fb8:	58 07       	cpc	r21, r24
    1fba:	09 f4       	brne	.+2      	; 0x1fbe <ProcessRNDISControlMessage+0x1de>
    1fbc:	af c0       	rjmp	.+350    	; 0x211c <__stack+0x1d>
    1fbe:	27 30       	cpi	r18, 0x07	; 7
    1fc0:	81 e0       	ldi	r24, 0x01	; 1
    1fc2:	38 07       	cpc	r19, r24
    1fc4:	81 e0       	ldi	r24, 0x01	; 1
    1fc6:	48 07       	cpc	r20, r24
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	58 07       	cpc	r21, r24
    1fcc:	f8 f4       	brcc	.+62     	; 0x200c <ProcessRNDISControlMessage+0x22c>
    1fce:	22 30       	cpi	r18, 0x02	; 2
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	38 07       	cpc	r19, r24
    1fd4:	81 e0       	ldi	r24, 0x01	; 1
    1fd6:	48 07       	cpc	r20, r24
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
    1fda:	58 07       	cpc	r21, r24
    1fdc:	09 f4       	brne	.+2      	; 0x1fe0 <ProcessRNDISControlMessage+0x200>
    1fde:	ca c0       	rjmp	.+404    	; 0x2174 <__stack+0x75>
    1fe0:	23 30       	cpi	r18, 0x03	; 3
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	38 07       	cpc	r19, r24
    1fe6:	81 e0       	ldi	r24, 0x01	; 1
    1fe8:	48 07       	cpc	r20, r24
    1fea:	80 e0       	ldi	r24, 0x00	; 0
    1fec:	58 07       	cpc	r21, r24
    1fee:	38 f4       	brcc	.+14     	; 0x1ffe <ProcessRNDISControlMessage+0x21e>
    1ff0:	21 50       	subi	r18, 0x01	; 1
    1ff2:	31 40       	sbci	r19, 0x01	; 1
    1ff4:	41 40       	sbci	r20, 0x01	; 1
    1ff6:	50 40       	sbci	r21, 0x00	; 0
    1ff8:	09 f0       	breq	.+2      	; 0x1ffc <ProcessRNDISControlMessage+0x21c>
    1ffa:	d4 c0       	rjmp	.+424    	; 0x21a4 <__stack+0xa5>
    1ffc:	80 c0       	rjmp	.+256    	; 0x20fe <ProcessRNDISControlMessage+0x31e>
    1ffe:	25 50       	subi	r18, 0x05	; 5
    2000:	31 40       	sbci	r19, 0x01	; 1
    2002:	41 40       	sbci	r20, 0x01	; 1
    2004:	50 40       	sbci	r21, 0x00	; 0
    2006:	08 f0       	brcs	.+2      	; 0x200a <ProcessRNDISControlMessage+0x22a>
    2008:	cd c0       	rjmp	.+410    	; 0x21a4 <__stack+0xa5>
    200a:	b4 c0       	rjmp	.+360    	; 0x2174 <__stack+0x75>
    200c:	2c 30       	cpi	r18, 0x0C	; 12
    200e:	81 e0       	ldi	r24, 0x01	; 1
    2010:	38 07       	cpc	r19, r24
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	48 07       	cpc	r20, r24
    2016:	80 e0       	ldi	r24, 0x00	; 0
    2018:	58 07       	cpc	r21, r24
    201a:	80 f4       	brcc	.+32     	; 0x203c <ProcessRNDISControlMessage+0x25c>
    201c:	2a 30       	cpi	r18, 0x0A	; 10
    201e:	61 e0       	ldi	r22, 0x01	; 1
    2020:	36 07       	cpc	r19, r22
    2022:	61 e0       	ldi	r22, 0x01	; 1
    2024:	46 07       	cpc	r20, r22
    2026:	60 e0       	ldi	r22, 0x00	; 0
    2028:	56 07       	cpc	r21, r22
    202a:	08 f0       	brcs	.+2      	; 0x202e <ProcessRNDISControlMessage+0x24e>
    202c:	77 c0       	rjmp	.+238    	; 0x211c <__stack+0x1d>
    202e:	27 50       	subi	r18, 0x07	; 7
    2030:	31 40       	sbci	r19, 0x01	; 1
    2032:	41 40       	sbci	r20, 0x01	; 1
    2034:	50 40       	sbci	r21, 0x00	; 0
    2036:	09 f0       	breq	.+2      	; 0x203a <ProcessRNDISControlMessage+0x25a>
    2038:	b5 c0       	rjmp	.+362    	; 0x21a4 <__stack+0xa5>
    203a:	7f c0       	rjmp	.+254    	; 0x213a <__stack+0x3b>
    203c:	2c 30       	cpi	r18, 0x0C	; 12
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	38 07       	cpc	r19, r24
    2042:	81 e0       	ldi	r24, 0x01	; 1
    2044:	48 07       	cpc	r20, r24
    2046:	80 e0       	ldi	r24, 0x00	; 0
    2048:	58 07       	cpc	r21, r24
    204a:	09 f4       	brne	.+2      	; 0x204e <ProcessRNDISControlMessage+0x26e>
    204c:	62 c0       	rjmp	.+196    	; 0x2112 <__stack+0x13>
    204e:	2d 50       	subi	r18, 0x0D	; 13
    2050:	31 40       	sbci	r19, 0x01	; 1
    2052:	41 40       	sbci	r20, 0x01	; 1
    2054:	50 40       	sbci	r21, 0x00	; 0
    2056:	09 f0       	breq	.+2      	; 0x205a <ProcessRNDISControlMessage+0x27a>
    2058:	a5 c0       	rjmp	.+330    	; 0x21a4 <__stack+0xa5>
    205a:	65 c0       	rjmp	.+202    	; 0x2126 <__stack+0x27>
    205c:	26 30       	cpi	r18, 0x06	; 6
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	38 07       	cpc	r19, r24
    2062:	82 e0       	ldi	r24, 0x02	; 2
    2064:	48 07       	cpc	r20, r24
    2066:	80 e0       	ldi	r24, 0x00	; 0
    2068:	58 07       	cpc	r21, r24
    206a:	10 f5       	brcc	.+68     	; 0x20b0 <ProcessRNDISControlMessage+0x2d0>
    206c:	21 30       	cpi	r18, 0x01	; 1
    206e:	61 e0       	ldi	r22, 0x01	; 1
    2070:	36 07       	cpc	r19, r22
    2072:	62 e0       	ldi	r22, 0x02	; 2
    2074:	46 07       	cpc	r20, r22
    2076:	60 e0       	ldi	r22, 0x00	; 0
    2078:	56 07       	cpc	r21, r22
    207a:	08 f0       	brcs	.+2      	; 0x207e <ProcessRNDISControlMessage+0x29e>
    207c:	7b c0       	rjmp	.+246    	; 0x2174 <__stack+0x75>
    207e:	24 31       	cpi	r18, 0x14	; 20
    2080:	81 e0       	ldi	r24, 0x01	; 1
    2082:	38 07       	cpc	r19, r24
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	48 07       	cpc	r20, r24
    2088:	80 e0       	ldi	r24, 0x00	; 0
    208a:	58 07       	cpc	r21, r24
    208c:	09 f4       	brne	.+2      	; 0x2090 <ProcessRNDISControlMessage+0x2b0>
    208e:	72 c0       	rjmp	.+228    	; 0x2174 <__stack+0x75>
    2090:	22 30       	cpi	r18, 0x02	; 2
    2092:	62 e0       	ldi	r22, 0x02	; 2
    2094:	36 07       	cpc	r19, r22
    2096:	61 e0       	ldi	r22, 0x01	; 1
    2098:	46 07       	cpc	r20, r22
    209a:	60 e0       	ldi	r22, 0x00	; 0
    209c:	56 07       	cpc	r21, r22
    209e:	09 f4       	brne	.+2      	; 0x20a2 <ProcessRNDISControlMessage+0x2c2>
    20a0:	69 c0       	rjmp	.+210    	; 0x2174 <__stack+0x75>
    20a2:	21 51       	subi	r18, 0x11	; 17
    20a4:	31 40       	sbci	r19, 0x01	; 1
    20a6:	41 40       	sbci	r20, 0x01	; 1
    20a8:	50 40       	sbci	r21, 0x00	; 0
    20aa:	09 f0       	breq	.+2      	; 0x20ae <ProcessRNDISControlMessage+0x2ce>
    20ac:	7b c0       	rjmp	.+246    	; 0x21a4 <__stack+0xa5>
    20ae:	6b c0       	rjmp	.+214    	; 0x2186 <__stack+0x87>
    20b0:	24 30       	cpi	r18, 0x04	; 4
    20b2:	81 e0       	ldi	r24, 0x01	; 1
    20b4:	38 07       	cpc	r19, r24
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	48 07       	cpc	r20, r24
    20ba:	81 e0       	ldi	r24, 0x01	; 1
    20bc:	58 07       	cpc	r21, r24
    20be:	09 f4       	brne	.+2      	; 0x20c2 <ProcessRNDISControlMessage+0x2e2>
    20c0:	4b c0       	rjmp	.+150    	; 0x2158 <__stack+0x59>
    20c2:	25 30       	cpi	r18, 0x05	; 5
    20c4:	81 e0       	ldi	r24, 0x01	; 1
    20c6:	38 07       	cpc	r19, r24
    20c8:	81 e0       	ldi	r24, 0x01	; 1
    20ca:	48 07       	cpc	r20, r24
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	58 07       	cpc	r21, r24
    20d0:	58 f4       	brcc	.+22     	; 0x20e8 <ProcessRNDISControlMessage+0x308>
    20d2:	21 50       	subi	r18, 0x01	; 1
    20d4:	31 40       	sbci	r19, 0x01	; 1
    20d6:	41 40       	sbci	r20, 0x01	; 1
    20d8:	51 40       	sbci	r21, 0x01	; 1
    20da:	22 30       	cpi	r18, 0x02	; 2
    20dc:	31 05       	cpc	r19, r1
    20de:	41 05       	cpc	r20, r1
    20e0:	51 05       	cpc	r21, r1
    20e2:	08 f0       	brcs	.+2      	; 0x20e6 <ProcessRNDISControlMessage+0x306>
    20e4:	5f c0       	rjmp	.+190    	; 0x21a4 <__stack+0xa5>
    20e6:	2e c0       	rjmp	.+92     	; 0x2144 <__stack+0x45>
    20e8:	21 50       	subi	r18, 0x01	; 1
    20ea:	31 40       	sbci	r19, 0x01	; 1
    20ec:	42 40       	sbci	r20, 0x02	; 2
    20ee:	51 40       	sbci	r21, 0x01	; 1
    20f0:	23 30       	cpi	r18, 0x03	; 3
    20f2:	31 05       	cpc	r19, r1
    20f4:	41 05       	cpc	r20, r1
    20f6:	51 05       	cpc	r21, r1
    20f8:	08 f0       	brcs	.+2      	; 0x20fc <ProcessRNDISControlMessage+0x31c>
    20fa:	54 c0       	rjmp	.+168    	; 0x21a4 <__stack+0xa5>
    20fc:	3b c0       	rjmp	.+118    	; 0x2174 <__stack+0x75>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    20fe:	cb 01       	movw	r24, r22
    2100:	48 96       	adiw	r24, 0x18	; 24
    2102:	66 eb       	ldi	r22, 0xB6	; 182
    2104:	73 e0       	ldi	r23, 0x03	; 3
    2106:	4c e6       	ldi	r20, 0x6C	; 108
    2108:	50 e0       	ldi	r21, 0x00	; 0
    210a:	c5 d5       	rcall	.+2954   	; 0x2c96 <memcpy_P>
    210c:	8c e6       	ldi	r24, 0x6C	; 108
    210e:	90 e0       	ldi	r25, 0x00	; 0
    2110:	07 c1       	rjmp	.+526    	; 0x2320 <__stack+0x221>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	9f ef       	ldi	r25, 0xFF	; 255
    2116:	af ef       	ldi	r26, 0xFF	; 255
    2118:	b0 e0       	ldi	r27, 0x00	; 0
    211a:	39 c0       	rjmp	.+114    	; 0x218e <__stack+0x8f>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
    211c:	8c ed       	ldi	r24, 0xDC	; 220
    211e:	95 e0       	ldi	r25, 0x05	; 5
    2120:	a0 e0       	ldi	r26, 0x00	; 0
    2122:	b0 e0       	ldi	r27, 0x00	; 0
    2124:	34 c0       	rjmp	.+104    	; 0x218e <__stack+0x8f>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
    2126:	cb 01       	movw	r24, r22
    2128:	48 96       	adiw	r24, 0x18	; 24
    212a:	62 e2       	ldi	r22, 0x22	; 34
    212c:	74 e0       	ldi	r23, 0x04	; 4
    212e:	43 e1       	ldi	r20, 0x13	; 19
    2130:	50 e0       	ldi	r21, 0x00	; 0
    2132:	b1 d5       	rcall	.+2914   	; 0x2c96 <memcpy_P>
    2134:	83 e1       	ldi	r24, 0x13	; 19
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	f3 c0       	rjmp	.+486    	; 0x2320 <__stack+0x221>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
    213a:	80 ea       	ldi	r24, 0xA0	; 160
    213c:	96 e8       	ldi	r25, 0x86	; 134
    213e:	a1 e0       	ldi	r26, 0x01	; 1
    2140:	b0 e0       	ldi	r27, 0x00	; 0
    2142:	25 c0       	rjmp	.+74     	; 0x218e <__stack+0x8f>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
    2144:	cb 01       	movw	r24, r22
    2146:	48 96       	adiw	r24, 0x18	; 24
    2148:	65 e3       	ldi	r22, 0x35	; 53
    214a:	74 e0       	ldi	r23, 0x04	; 4
    214c:	46 e0       	ldi	r20, 0x06	; 6
    214e:	50 e0       	ldi	r21, 0x00	; 0
    2150:	a2 d5       	rcall	.+2884   	; 0x2c96 <memcpy_P>
    2152:	86 e0       	ldi	r24, 0x06	; 6
    2154:	90 e0       	ldi	r25, 0x00	; 0
    2156:	e4 c0       	rjmp	.+456    	; 0x2320 <__stack+0x221>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
    2158:	81 e0       	ldi	r24, 0x01	; 1
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	a0 e0       	ldi	r26, 0x00	; 0
    215e:	b0 e0       	ldi	r27, 0x00	; 0
    2160:	16 c0       	rjmp	.+44     	; 0x218e <__stack+0x8f>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
    2162:	80 91 57 01 	lds	r24, 0x0157
    2166:	90 91 58 01 	lds	r25, 0x0158
    216a:	a0 91 59 01 	lds	r26, 0x0159
    216e:	b0 91 5a 01 	lds	r27, 0x015A
    2172:	0d c0       	rjmp	.+26     	; 0x218e <__stack+0x8f>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
    2174:	10 92 78 13 	sts	0x1378, r1
    2178:	10 92 79 13 	sts	0x1379, r1
    217c:	10 92 7a 13 	sts	0x137A, r1
    2180:	10 92 7b 13 	sts	0x137B, r1
    2184:	0c c0       	rjmp	.+24     	; 0x219e <__stack+0x9f>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
    2186:	80 e6       	ldi	r24, 0x60	; 96
    2188:	96 e0       	ldi	r25, 0x06	; 6
    218a:	a0 e0       	ldi	r26, 0x00	; 0
    218c:	b0 e0       	ldi	r27, 0x00	; 0
    218e:	80 93 78 13 	sts	0x1378, r24
    2192:	90 93 79 13 	sts	0x1379, r25
    2196:	a0 93 7a 13 	sts	0x137A, r26
    219a:	b0 93 7b 13 	sts	0x137B, r27
    219e:	84 e0       	ldi	r24, 0x04	; 4
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	be c0       	rjmp	.+380    	; 0x2320 <__stack+0x221>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    21a4:	8b eb       	ldi	r24, 0xBB	; 187
    21a6:	90 e0       	ldi	r25, 0x00	; 0
    21a8:	a0 e0       	ldi	r26, 0x00	; 0
    21aa:	b0 ec       	ldi	r27, 0xC0	; 192
    21ac:	80 93 6c 13 	sts	0x136C, r24
    21b0:	90 93 6d 13 	sts	0x136D, r25
    21b4:	a0 93 6e 13 	sts	0x136E, r26
    21b8:	b0 93 6f 13 	sts	0x136F, r27

				QUERY_Response->InformationBufferLength = 0;
    21bc:	10 92 70 13 	sts	0x1370, r1
    21c0:	10 92 71 13 	sts	0x1371, r1
    21c4:	10 92 72 13 	sts	0x1372, r1
    21c8:	10 92 73 13 	sts	0x1373, r1
				QUERY_Response->InformationBufferOffset = 0;
    21cc:	10 92 74 13 	sts	0x1374, r1
    21d0:	10 92 75 13 	sts	0x1375, r1
    21d4:	10 92 76 13 	sts	0x1376, r1
    21d8:	10 92 77 13 	sts	0x1377, r1
    21dc:	08 95       	ret

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	80 93 55 01 	sts	0x0155, r24

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
    21e4:	20 91 6c 13 	lds	r18, 0x136C
    21e8:	30 91 6d 13 	lds	r19, 0x136D
    21ec:	40 91 6e 13 	lds	r20, 0x136E
    21f0:	50 91 6f 13 	lds	r21, 0x136F

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
    21f4:	85 e0       	ldi	r24, 0x05	; 5
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	a0 e0       	ldi	r26, 0x00	; 0
    21fa:	b0 e8       	ldi	r27, 0x80	; 128
    21fc:	80 93 60 13 	sts	0x1360, r24
    2200:	90 93 61 13 	sts	0x1361, r25
    2204:	a0 93 62 13 	sts	0x1362, r26
    2208:	b0 93 63 13 	sts	0x1363, r27
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
    220c:	80 e1       	ldi	r24, 0x10	; 16
    220e:	90 e0       	ldi	r25, 0x00	; 0
    2210:	a0 e0       	ldi	r26, 0x00	; 0
    2212:	b0 e0       	ldi	r27, 0x00	; 0
    2214:	80 93 64 13 	sts	0x1364, r24
    2218:	90 93 65 13 	sts	0x1365, r25
    221c:	a0 93 66 13 	sts	0x1366, r26
    2220:	b0 93 67 13 	sts	0x1367, r27
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];
    2224:	80 91 74 13 	lds	r24, 0x1374
    2228:	90 91 75 13 	lds	r25, 0x1375
    222c:	a0 91 76 13 	lds	r26, 0x1376
    2230:	b0 91 77 13 	lds	r27, 0x1377
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
    2234:	2e 30       	cpi	r18, 0x0E	; 14
    2236:	61 e0       	ldi	r22, 0x01	; 1
    2238:	36 07       	cpc	r19, r22
    223a:	61 e0       	ldi	r22, 0x01	; 1
    223c:	46 07       	cpc	r20, r22
    223e:	60 e0       	ldi	r22, 0x00	; 0
    2240:	56 07       	cpc	r21, r22
    2242:	31 f0       	breq	.+12     	; 0x2250 <__stack+0x151>
    2244:	23 50       	subi	r18, 0x03	; 3
    2246:	31 40       	sbci	r19, 0x01	; 1
    2248:	41 40       	sbci	r20, 0x01	; 1
    224a:	51 40       	sbci	r21, 0x01	; 1
    224c:	a1 f4       	brne	.+40     	; 0x2276 <__stack+0x177>
    224e:	5f c0       	rjmp	.+190    	; 0x230e <__stack+0x20f>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
    2250:	fc 01       	movw	r30, r24
    2252:	e8 59       	subi	r30, 0x98	; 152
    2254:	fc 4e       	sbci	r31, 0xEC	; 236
    2256:	80 81       	ld	r24, Z
    2258:	91 81       	ldd	r25, Z+1	; 0x01
    225a:	a2 81       	ldd	r26, Z+2	; 0x02
    225c:	b3 81       	ldd	r27, Z+3	; 0x03
    225e:	80 93 57 01 	sts	0x0157, r24
    2262:	90 93 58 01 	sts	0x0158, r25
    2266:	a0 93 59 01 	sts	0x0159, r26
    226a:	b0 93 5a 01 	sts	0x015A, r27

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
    226e:	82 e0       	ldi	r24, 0x02	; 2
    2270:	80 93 56 01 	sts	0x0156, r24
    2274:	4c c0       	rjmp	.+152    	; 0x230e <__stack+0x20f>
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    2276:	8b eb       	ldi	r24, 0xBB	; 187
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	a0 e0       	ldi	r26, 0x00	; 0
    227c:	b0 ec       	ldi	r27, 0xC0	; 192
    227e:	80 93 6c 13 	sts	0x136C, r24
    2282:	90 93 6d 13 	sts	0x136D, r25
    2286:	a0 93 6e 13 	sts	0x136E, r26
    228a:	b0 93 6f 13 	sts	0x136F, r27
    228e:	08 95       	ret

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
    2290:	81 e0       	ldi	r24, 0x01	; 1
    2292:	80 93 55 01 	sts	0x0155, r24

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
    2296:	86 e0       	ldi	r24, 0x06	; 6
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	a0 e0       	ldi	r26, 0x00	; 0
    229c:	b0 e8       	ldi	r27, 0x80	; 128
    229e:	80 93 60 13 	sts	0x1360, r24
    22a2:	90 93 61 13 	sts	0x1361, r25
    22a6:	a0 93 62 13 	sts	0x1362, r26
    22aa:	b0 93 63 13 	sts	0x1363, r27
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
    22ae:	80 e1       	ldi	r24, 0x10	; 16
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	a0 e0       	ldi	r26, 0x00	; 0
    22b4:	b0 e0       	ldi	r27, 0x00	; 0
    22b6:	80 93 64 13 	sts	0x1364, r24
    22ba:	90 93 65 13 	sts	0x1365, r25
    22be:	a0 93 66 13 	sts	0x1366, r26
    22c2:	b0 93 67 13 	sts	0x1367, r27
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
    22c6:	10 92 68 13 	sts	0x1368, r1
    22ca:	10 92 69 13 	sts	0x1369, r1
    22ce:	10 92 6a 13 	sts	0x136A, r1
    22d2:	10 92 6b 13 	sts	0x136B, r1
    22d6:	1b c0       	rjmp	.+54     	; 0x230e <__stack+0x20f>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	80 93 55 01 	sts	0x0155, r24

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
    22de:	88 e0       	ldi	r24, 0x08	; 8
    22e0:	90 e0       	ldi	r25, 0x00	; 0
    22e2:	a0 e0       	ldi	r26, 0x00	; 0
    22e4:	b0 e8       	ldi	r27, 0x80	; 128
    22e6:	80 93 60 13 	sts	0x1360, r24
    22ea:	90 93 61 13 	sts	0x1361, r25
    22ee:	a0 93 62 13 	sts	0x1362, r26
    22f2:	b0 93 63 13 	sts	0x1363, r27
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
    22f6:	80 e1       	ldi	r24, 0x10	; 16
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	a0 e0       	ldi	r26, 0x00	; 0
    22fc:	b0 e0       	ldi	r27, 0x00	; 0
    22fe:	80 93 64 13 	sts	0x1364, r24
    2302:	90 93 65 13 	sts	0x1365, r25
    2306:	a0 93 66 13 	sts	0x1366, r26
    230a:	b0 93 67 13 	sts	0x1367, r27
			KEEPALIVE_Response->RequestId       = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
    230e:	10 92 6c 13 	sts	0x136C, r1
    2312:	10 92 6d 13 	sts	0x136D, r1
    2316:	10 92 6e 13 	sts	0x136E, r1
    231a:	10 92 6f 13 	sts	0x136F, r1
    231e:	08 95       	ret
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
    2320:	10 92 6c 13 	sts	0x136C, r1
    2324:	10 92 6d 13 	sts	0x136D, r1
    2328:	10 92 6e 13 	sts	0x136E, r1
    232c:	10 92 6f 13 	sts	0x136F, r1
				QUERY_Response->MessageLength          += ResponseSize;
    2330:	a0 e0       	ldi	r26, 0x00	; 0
    2332:	b0 e0       	ldi	r27, 0x00	; 0
    2334:	20 91 64 13 	lds	r18, 0x1364
    2338:	30 91 65 13 	lds	r19, 0x1365
    233c:	40 91 66 13 	lds	r20, 0x1366
    2340:	50 91 67 13 	lds	r21, 0x1367
    2344:	28 0f       	add	r18, r24
    2346:	39 1f       	adc	r19, r25
    2348:	4a 1f       	adc	r20, r26
    234a:	5b 1f       	adc	r21, r27
    234c:	20 93 64 13 	sts	0x1364, r18
    2350:	30 93 65 13 	sts	0x1365, r19
    2354:	40 93 66 13 	sts	0x1366, r20
    2358:	50 93 67 13 	sts	0x1367, r21

				QUERY_Response->InformationBufferLength = ResponseSize;
    235c:	80 93 70 13 	sts	0x1370, r24
    2360:	90 93 71 13 	sts	0x1371, r25
    2364:	a0 93 72 13 	sts	0x1372, r26
    2368:	b0 93 73 13 	sts	0x1373, r27
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    236c:	80 e1       	ldi	r24, 0x10	; 16
    236e:	90 e0       	ldi	r25, 0x00	; 0
    2370:	a0 e0       	ldi	r26, 0x00	; 0
    2372:	b0 e0       	ldi	r27, 0x00	; 0
    2374:	80 93 74 13 	sts	0x1374, r24
    2378:	90 93 75 13 	sts	0x1375, r25
    237c:	a0 93 76 13 	sts	0x1376, r26
    2380:	b0 93 77 13 	sts	0x1377, r27
    2384:	08 95       	ret

00002386 <Endpoint_ConfigureEndpoint_Prv>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2386:	80 93 e9 00 	sts	0x00E9, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    238a:	80 91 eb 00 	lds	r24, 0x00EB
    238e:	81 60       	ori	r24, 0x01	; 1
    2390:	80 93 eb 00 	sts	0x00EB, r24
                                    const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
    2394:	10 92 ed 00 	sts	0x00ED, r1
	UECFG0X = UECFG0XData;
    2398:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
    239c:	40 93 ed 00 	sts	0x00ED, r20
			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    23a0:	80 91 ee 00 	lds	r24, 0x00EE

	return Endpoint_IsConfigured();
}
    23a4:	88 1f       	adc	r24, r24
    23a6:	88 27       	eor	r24, r24
    23a8:	88 1f       	adc	r24, r24
    23aa:	08 95       	ret

000023ac <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    23ac:	80 91 e9 13 	lds	r24, 0x13E9
    23b0:	88 23       	and	r24, r24
    23b2:	9c f4       	brge	.+38     	; 0x23da <Endpoint_ClearStatusStage+0x2e>
    23b4:	04 c0       	rjmp	.+8      	; 0x23be <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    23b6:	80 91 e8 13 	lds	r24, 0x13E8
    23ba:	88 23       	and	r24, r24
    23bc:	b9 f0       	breq	.+46     	; 0x23ec <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    23be:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    23c2:	82 ff       	sbrs	r24, 2
    23c4:	f8 cf       	rjmp	.-16     	; 0x23b6 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    23c6:	80 91 e8 00 	lds	r24, 0x00E8
    23ca:	8b 77       	andi	r24, 0x7B	; 123
    23cc:	80 93 e8 00 	sts	0x00E8, r24
    23d0:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    23d2:	80 91 e8 13 	lds	r24, 0x13E8
    23d6:	88 23       	and	r24, r24
    23d8:	49 f0       	breq	.+18     	; 0x23ec <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    23da:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    23de:	80 ff       	sbrs	r24, 0
    23e0:	f8 cf       	rjmp	.-16     	; 0x23d2 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    23e2:	80 91 e8 00 	lds	r24, 0x00E8
    23e6:	8e 77       	andi	r24, 0x7E	; 126
    23e8:	80 93 e8 00 	sts	0x00E8, r24
    23ec:	08 95       	ret

000023ee <Endpoint_WaitUntilReady>:
			/** Returns the current USB frame number, when in device mode. Every millisecond the USB bus is active (i.e. enumerated to a host)
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    23ee:	40 91 e4 00 	lds	r20, 0x00E4
    23f2:	50 91 e5 00 	lds	r21, 0x00E5
    23f6:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    23f8:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    23fc:	80 ff       	sbrs	r24, 0
    23fe:	05 c0       	rjmp	.+10     	; 0x240a <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2400:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    2404:	80 ff       	sbrs	r24, 0
    2406:	05 c0       	rjmp	.+10     	; 0x2412 <Endpoint_WaitUntilReady+0x24>
    2408:	22 c0       	rjmp	.+68     	; 0x244e <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    240a:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    240e:	82 fd       	sbrc	r24, 2
    2410:	1e c0       	rjmp	.+60     	; 0x244e <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2412:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2416:	88 23       	and	r24, r24
    2418:	11 f4       	brne	.+4      	; 0x241e <Endpoint_WaitUntilReady+0x30>
    241a:	82 e0       	ldi	r24, 0x02	; 2
    241c:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    241e:	85 30       	cpi	r24, 0x05	; 5
    2420:	11 f4       	brne	.+4      	; 0x2426 <Endpoint_WaitUntilReady+0x38>
    2422:	83 e0       	ldi	r24, 0x03	; 3
    2424:	08 95       	ret
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2426:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    242a:	85 ff       	sbrs	r24, 5
    242c:	02 c0       	rjmp	.+4      	; 0x2432 <Endpoint_WaitUntilReady+0x44>
    242e:	81 e0       	ldi	r24, 0x01	; 1
    2430:	08 95       	ret
    2432:	80 91 e4 00 	lds	r24, 0x00E4
    2436:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    243a:	84 17       	cp	r24, r20
    243c:	95 07       	cpc	r25, r21
    243e:	e1 f2       	breq	.-72     	; 0x23f8 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    2440:	22 23       	and	r18, r18
    2442:	11 f4       	brne	.+4      	; 0x2448 <Endpoint_WaitUntilReady+0x5a>
    2444:	84 e0       	ldi	r24, 0x04	; 4
    2446:	08 95       	ret
    2448:	21 50       	subi	r18, 0x01	; 1
    244a:	ac 01       	movw	r20, r24
    244c:	d5 cf       	rjmp	.-86     	; 0x23f8 <Endpoint_WaitUntilReady+0xa>
    244e:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    2450:	08 95       	ret

00002452 <USB_ResetInterface>:
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    2452:	55 d0       	rcall	.+170    	; 0x24fe <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2454:	5c d0       	rcall	.+184    	; 0x250e <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
    2456:	80 91 d8 00 	lds	r24, 0x00D8

				USBCON = (Temp & ~(1 << USBE));
    245a:	98 2f       	mov	r25, r24
    245c:	9f 77       	andi	r25, 0x7F	; 127
    245e:	90 93 d8 00 	sts	0x00D8, r25
				USBCON = (Temp |  (1 << USBE));
    2462:	80 68       	ori	r24, 0x80	; 128
    2464:	80 93 d8 00 	sts	0x00D8, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    2468:	8c e0       	ldi	r24, 0x0C	; 12
    246a:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    246c:	89 b5       	in	r24, 0x29	; 41
    246e:	82 60       	ori	r24, 0x02	; 2
    2470:	89 bd       	out	0x29, r24	; 41
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
    2472:	09 b4       	in	r0, 0x29	; 41
    2474:	00 fe       	sbrs	r0, 0
    2476:	fd cf       	rjmp	.-6      	; 0x2472 <USB_ResetInterface+0x20>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    2478:	80 91 d8 00 	lds	r24, 0x00D8
    247c:	8f 7d       	andi	r24, 0xDF	; 223
    247e:	80 93 d8 00 	sts	0x00D8, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    2482:	80 91 d7 00 	lds	r24, 0x00D7
    2486:	80 68       	ori	r24, 0x80	; 128
    2488:	80 93 d7 00 	sts	0x00D7, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
    248c:	10 92 e8 13 	sts	0x13E8, r1
	USB_ConfigurationNumber  = 0;
    2490:	10 92 e6 13 	sts	0x13E6, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
    2494:	10 92 e5 13 	sts	0x13E5, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
    2498:	10 92 e4 13 	sts	0x13E4, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    249c:	80 91 e0 00 	lds	r24, 0x00E0
    24a0:	8b 7f       	andi	r24, 0xFB	; 251
    24a2:	80 93 e0 00 	sts	0x00E0, r24
	if (USB_Options & USB_DEVICE_OPT_LOWSPEED)
	  USB_Device_SetLowSpeed();
	else
	  USB_Device_SetFullSpeed();

	USB_INT_Enable(USB_INT_VBUS);
    24a6:	80 91 d8 00 	lds	r24, 0x00D8
    24aa:	81 60       	ori	r24, 0x01	; 1
    24ac:	80 93 d8 00 	sts	0x00D8, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    24b0:	80 e0       	ldi	r24, 0x00	; 0
    24b2:	60 e0       	ldi	r22, 0x00	; 0
    24b4:	42 e0       	ldi	r20, 0x02	; 2
    24b6:	67 df       	rcall	.-306    	; 0x2386 <Endpoint_ConfigureEndpoint_Prv>

	Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
							   ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
							   ENDPOINT_BANK_SINGLE);

	USB_INT_Clear(USB_INT_SUSPI);
    24b8:	80 91 e1 00 	lds	r24, 0x00E1
    24bc:	8e 7f       	andi	r24, 0xFE	; 254
    24be:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_SUSPI);
    24c2:	80 91 e2 00 	lds	r24, 0x00E2
    24c6:	81 60       	ori	r24, 0x01	; 1
    24c8:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Enable(USB_INT_EORSTI);
    24cc:	80 91 e2 00 	lds	r24, 0x00E2
    24d0:	88 60       	ori	r24, 0x08	; 8
    24d2:	80 93 e2 00 	sts	0x00E2, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    24d6:	80 91 e0 00 	lds	r24, 0x00E0
    24da:	8e 7f       	andi	r24, 0xFE	; 254
    24dc:	80 93 e0 00 	sts	0x00E0, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    24e0:	80 91 d8 00 	lds	r24, 0x00D8
    24e4:	80 61       	ori	r24, 0x10	; 16
    24e6:	80 93 d8 00 	sts	0x00D8, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    24ea:	08 95       	ret

000024ec <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    24ec:	e7 ed       	ldi	r30, 0xD7	; 215
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	80 81       	ld	r24, Z
    24f2:	81 60       	ori	r24, 0x01	; 1
    24f4:	80 83       	st	Z, r24
	{
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	80 93 e7 13 	sts	0x13E7, r24

	USB_ResetInterface();
}
    24fc:	aa cf       	rjmp	.-172    	; 0x2452 <USB_ResetInterface>

000024fe <USB_INT_DisableAllInterrupts>:
#include "USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    24fe:	e8 ed       	ldi	r30, 0xD8	; 216
    2500:	f0 e0       	ldi	r31, 0x00	; 0
    2502:	80 81       	ld	r24, Z
    2504:	8c 7f       	andi	r24, 0xFC	; 252
    2506:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    2508:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    250c:	08 95       	ret

0000250e <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT  = 0;
    250e:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
    2512:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    2516:	08 95       	ret

00002518 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    2518:	1f 92       	push	r1
    251a:	0f 92       	push	r0
    251c:	0f b6       	in	r0, 0x3f	; 63
    251e:	0f 92       	push	r0
    2520:	0b b6       	in	r0, 0x3b	; 59
    2522:	0f 92       	push	r0
    2524:	11 24       	eor	r1, r1
    2526:	2f 93       	push	r18
    2528:	3f 93       	push	r19
    252a:	4f 93       	push	r20
    252c:	5f 93       	push	r21
    252e:	6f 93       	push	r22
    2530:	7f 93       	push	r23
    2532:	8f 93       	push	r24
    2534:	9f 93       	push	r25
    2536:	af 93       	push	r26
    2538:	bf 93       	push	r27
    253a:	ef 93       	push	r30
    253c:	ff 93       	push	r31
	#if defined(USB_CAN_BE_DEVICE)
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUS) && USB_INT_IsEnabled(USB_INT_VBUS))
    253e:	80 91 da 00 	lds	r24, 0x00DA
    2542:	80 ff       	sbrs	r24, 0
    2544:	17 c0       	rjmp	.+46     	; 0x2574 <__vector_10+0x5c>
    2546:	80 91 d8 00 	lds	r24, 0x00D8
    254a:	80 ff       	sbrs	r24, 0
    254c:	13 c0       	rjmp	.+38     	; 0x2574 <__vector_10+0x5c>
	{
		USB_INT_Clear(USB_INT_VBUS);
    254e:	80 91 da 00 	lds	r24, 0x00DA
    2552:	8e 7f       	andi	r24, 0xFE	; 254
    2554:	80 93 da 00 	sts	0x00DA, r24
				 *  \note This function is not available on some AVR models which do not support hardware VBUS monitoring.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    2558:	80 91 d9 00 	lds	r24, 0x00D9

		if (USB_VBUS_GetStatus())
    255c:	80 ff       	sbrs	r24, 0
    255e:	06 c0       	rjmp	.+12     	; 0x256c <__vector_10+0x54>
		{
			USB_DeviceState = DEVICE_STATE_Powered;
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	80 93 e8 13 	sts	0x13E8, r24
			EVENT_USB_Device_Connect();
    2566:	0e 94 3d 02 	call	0x47a	; 0x47a <EVENT_USB_Device_Connect>
    256a:	04 c0       	rjmp	.+8      	; 0x2574 <__vector_10+0x5c>
		}
		else
		{
			USB_DeviceState = DEVICE_STATE_Unattached;
    256c:	10 92 e8 13 	sts	0x13E8, r1
			EVENT_USB_Device_Disconnect();
    2570:	0e 94 42 02 	call	0x484	; 0x484 <EVENT_USB_Device_Disconnect>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    2574:	80 91 e1 00 	lds	r24, 0x00E1
    2578:	80 ff       	sbrs	r24, 0
    257a:	1d c0       	rjmp	.+58     	; 0x25b6 <__vector_10+0x9e>
    257c:	80 91 e2 00 	lds	r24, 0x00E2
    2580:	80 ff       	sbrs	r24, 0
    2582:	19 c0       	rjmp	.+50     	; 0x25b6 <__vector_10+0x9e>
	{
		USB_INT_Clear(USB_INT_SUSPI);
    2584:	80 91 e1 00 	lds	r24, 0x00E1
    2588:	8e 7f       	andi	r24, 0xFE	; 254
    258a:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPI);
    258e:	80 91 e2 00 	lds	r24, 0x00E2
    2592:	8e 7f       	andi	r24, 0xFE	; 254
    2594:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
    2598:	80 91 e2 00 	lds	r24, 0x00E2
    259c:	80 61       	ori	r24, 0x10	; 16
    259e:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    25a2:	80 91 d8 00 	lds	r24, 0x00D8
    25a6:	80 62       	ori	r24, 0x20	; 32
    25a8:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    25ac:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    25ae:	85 e0       	ldi	r24, 0x05	; 5
    25b0:	80 93 e8 13 	sts	0x13E8, r24
		EVENT_USB_Device_Suspend();
    25b4:	e8 d1       	rcall	.+976    	; 0x2986 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    25b6:	80 91 e1 00 	lds	r24, 0x00E1
    25ba:	84 ff       	sbrs	r24, 4
    25bc:	2e c0       	rjmp	.+92     	; 0x261a <__vector_10+0x102>
    25be:	80 91 e2 00 	lds	r24, 0x00E2
    25c2:	84 ff       	sbrs	r24, 4
    25c4:	2a c0       	rjmp	.+84     	; 0x261a <__vector_10+0x102>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    25c6:	8c e0       	ldi	r24, 0x0C	; 12
    25c8:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    25ca:	89 b5       	in	r24, 0x29	; 41
    25cc:	82 60       	ori	r24, 0x02	; 2
    25ce:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    25d0:	09 b4       	in	r0, 0x29	; 41
    25d2:	00 fe       	sbrs	r0, 0
    25d4:	fd cf       	rjmp	.-6      	; 0x25d0 <__vector_10+0xb8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    25d6:	80 91 d8 00 	lds	r24, 0x00D8
    25da:	8f 7d       	andi	r24, 0xDF	; 223
    25dc:	80 93 d8 00 	sts	0x00D8, r24
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUPI);
    25e0:	80 91 e1 00 	lds	r24, 0x00E1
    25e4:	8f 7e       	andi	r24, 0xEF	; 239
    25e6:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUPI);
    25ea:	80 91 e2 00 	lds	r24, 0x00E2
    25ee:	8f 7e       	andi	r24, 0xEF	; 239
    25f0:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPI);
    25f4:	80 91 e2 00 	lds	r24, 0x00E2
    25f8:	81 60       	ori	r24, 0x01	; 1
    25fa:	80 93 e2 00 	sts	0x00E2, r24

		if (USB_ConfigurationNumber)
    25fe:	80 91 e6 13 	lds	r24, 0x13E6
    2602:	88 23       	and	r24, r24
    2604:	31 f4       	brne	.+12     	; 0x2612 <__vector_10+0xfa>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2606:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    260a:	87 fd       	sbrc	r24, 7
    260c:	02 c0       	rjmp	.+4      	; 0x2612 <__vector_10+0xfa>
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	01 c0       	rjmp	.+2      	; 0x2614 <__vector_10+0xfc>
    2612:	84 e0       	ldi	r24, 0x04	; 4
    2614:	80 93 e8 13 	sts	0x13E8, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    2618:	b6 d1       	rcall	.+876    	; 0x2986 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    261a:	80 91 e1 00 	lds	r24, 0x00E1
    261e:	83 ff       	sbrs	r24, 3
    2620:	22 c0       	rjmp	.+68     	; 0x2666 <__vector_10+0x14e>
    2622:	80 91 e2 00 	lds	r24, 0x00E2
    2626:	83 ff       	sbrs	r24, 3
    2628:	1e c0       	rjmp	.+60     	; 0x2666 <__vector_10+0x14e>
	{
		USB_INT_Clear(USB_INT_EORSTI);
    262a:	80 91 e1 00 	lds	r24, 0x00E1
    262e:	87 7f       	andi	r24, 0xF7	; 247
    2630:	80 93 e1 00 	sts	0x00E1, r24

		USB_DeviceState         = DEVICE_STATE_Default;
    2634:	82 e0       	ldi	r24, 0x02	; 2
    2636:	80 93 e8 13 	sts	0x13E8, r24
		USB_ConfigurationNumber = 0;
    263a:	10 92 e6 13 	sts	0x13E6, r1

		USB_INT_Clear(USB_INT_SUSPI);
    263e:	80 91 e1 00 	lds	r24, 0x00E1
    2642:	8e 7f       	andi	r24, 0xFE	; 254
    2644:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPI);
    2648:	80 91 e2 00 	lds	r24, 0x00E2
    264c:	8e 7f       	andi	r24, 0xFE	; 254
    264e:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
    2652:	80 91 e2 00 	lds	r24, 0x00E2
    2656:	80 61       	ori	r24, 0x10	; 16
    2658:	80 93 e2 00 	sts	0x00E2, r24
    265c:	80 e0       	ldi	r24, 0x00	; 0
    265e:	60 e0       	ldi	r22, 0x00	; 0
    2660:	42 e0       	ldi	r20, 0x02	; 2
    2662:	91 de       	rcall	.-734    	; 0x2386 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    2664:	90 d1       	rcall	.+800    	; 0x2986 <USB_Event_Stub>
	}

	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    2666:	80 91 e1 00 	lds	r24, 0x00E1
    266a:	82 ff       	sbrs	r24, 2
    266c:	0a c0       	rjmp	.+20     	; 0x2682 <__vector_10+0x16a>
    266e:	80 91 e2 00 	lds	r24, 0x00E2
    2672:	82 ff       	sbrs	r24, 2
    2674:	06 c0       	rjmp	.+12     	; 0x2682 <__vector_10+0x16a>
	{
		USB_INT_Clear(USB_INT_SOFI);
    2676:	80 91 e1 00 	lds	r24, 0x00E1
    267a:	8b 7f       	andi	r24, 0xFB	; 251
    267c:	80 93 e1 00 	sts	0x00E1, r24

		EVENT_USB_Device_StartOfFrame();
    2680:	82 d1       	rcall	.+772    	; 0x2986 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2682:	ff 91       	pop	r31
    2684:	ef 91       	pop	r30
    2686:	bf 91       	pop	r27
    2688:	af 91       	pop	r26
    268a:	9f 91       	pop	r25
    268c:	8f 91       	pop	r24
    268e:	7f 91       	pop	r23
    2690:	6f 91       	pop	r22
    2692:	5f 91       	pop	r21
    2694:	4f 91       	pop	r20
    2696:	3f 91       	pop	r19
    2698:	2f 91       	pop	r18
    269a:	0f 90       	pop	r0
    269c:	0b be       	out	0x3b, r0	; 59
    269e:	0f 90       	pop	r0
    26a0:	0f be       	out	0x3f, r0	; 63
    26a2:	0f 90       	pop	r0
    26a4:	1f 90       	pop	r1
    26a6:	18 95       	reti

000026a8 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    26a8:	0f 93       	push	r16
    26aa:	1f 93       	push	r17
    26ac:	df 93       	push	r29
    26ae:	cf 93       	push	r28
    26b0:	cd b7       	in	r28, 0x3d	; 61
    26b2:	de b7       	in	r29, 0x3e	; 62
    26b4:	ac 97       	sbiw	r28, 0x2c	; 44
    26b6:	0f b6       	in	r0, 0x3f	; 63
    26b8:	f8 94       	cli
    26ba:	de bf       	out	0x3e, r29	; 62
    26bc:	0f be       	out	0x3f, r0	; 63
    26be:	cd bf       	out	0x3d, r28	; 61
    26c0:	e9 ee       	ldi	r30, 0xE9	; 233
    26c2:	f3 e1       	ldi	r31, 0x13	; 19
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    26c4:	80 91 f1 00 	lds	r24, 0x00F1
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
    26c8:	81 93       	st	Z+, r24

void USB_Device_ProcessControlRequest(void)
{
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    26ca:	23 e1       	ldi	r18, 0x13	; 19
    26cc:	e1 3f       	cpi	r30, 0xF1	; 241
    26ce:	f2 07       	cpc	r31, r18
    26d0:	c9 f7       	brne	.-14     	; 0x26c4 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_Byte();

	EVENT_USB_Device_ControlRequest();
    26d2:	0e 94 1b 03 	call	0x636	; 0x636 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    26d6:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    26da:	83 ff       	sbrs	r24, 3
    26dc:	3b c1       	rjmp	.+630    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    26de:	80 91 e9 13 	lds	r24, 0x13E9

		switch (USB_ControlRequest.bRequest)
    26e2:	30 91 ea 13 	lds	r19, 0x13EA
    26e6:	35 30       	cpi	r19, 0x05	; 5
    26e8:	09 f4       	brne	.+2      	; 0x26ec <USB_Device_ProcessControlRequest+0x44>
    26ea:	87 c0       	rjmp	.+270    	; 0x27fa <USB_Device_ProcessControlRequest+0x152>
    26ec:	36 30       	cpi	r19, 0x06	; 6
    26ee:	40 f4       	brcc	.+16     	; 0x2700 <USB_Device_ProcessControlRequest+0x58>
    26f0:	31 30       	cpi	r19, 0x01	; 1
    26f2:	c9 f1       	breq	.+114    	; 0x2766 <USB_Device_ProcessControlRequest+0xbe>
    26f4:	31 30       	cpi	r19, 0x01	; 1
    26f6:	70 f0       	brcs	.+28     	; 0x2714 <USB_Device_ProcessControlRequest+0x6c>
    26f8:	33 30       	cpi	r19, 0x03	; 3
    26fa:	09 f0       	breq	.+2      	; 0x26fe <USB_Device_ProcessControlRequest+0x56>
    26fc:	2b c1       	rjmp	.+598    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
    26fe:	33 c0       	rjmp	.+102    	; 0x2766 <USB_Device_ProcessControlRequest+0xbe>
    2700:	38 30       	cpi	r19, 0x08	; 8
    2702:	09 f4       	brne	.+2      	; 0x2706 <USB_Device_ProcessControlRequest+0x5e>
    2704:	f8 c0       	rjmp	.+496    	; 0x28f6 <USB_Device_ProcessControlRequest+0x24e>
    2706:	39 30       	cpi	r19, 0x09	; 9
    2708:	09 f4       	brne	.+2      	; 0x270c <USB_Device_ProcessControlRequest+0x64>
    270a:	07 c1       	rjmp	.+526    	; 0x291a <USB_Device_ProcessControlRequest+0x272>
    270c:	36 30       	cpi	r19, 0x06	; 6
    270e:	09 f0       	breq	.+2      	; 0x2712 <USB_Device_ProcessControlRequest+0x6a>
    2710:	21 c1       	rjmp	.+578    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
    2712:	99 c0       	rjmp	.+306    	; 0x2846 <USB_Device_ProcessControlRequest+0x19e>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2714:	80 38       	cpi	r24, 0x80	; 128
    2716:	21 f0       	breq	.+8      	; 0x2720 <USB_Device_ProcessControlRequest+0x78>
    2718:	82 38       	cpi	r24, 0x82	; 130
    271a:	09 f0       	breq	.+2      	; 0x271e <USB_Device_ProcessControlRequest+0x76>
    271c:	1b c1       	rjmp	.+566    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
    271e:	08 c0       	rjmp	.+16     	; 0x2730 <USB_Device_ProcessControlRequest+0x88>
    2720:	90 91 e4 13 	lds	r25, 0x13E4
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
    2724:	80 91 e5 13 	lds	r24, 0x13E5
    2728:	88 23       	and	r24, r24
    272a:	99 f0       	breq	.+38     	; 0x2752 <USB_Device_ProcessControlRequest+0xaa>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    272c:	92 60       	ori	r25, 0x02	; 2
    272e:	11 c0       	rjmp	.+34     	; 0x2752 <USB_Device_ProcessControlRequest+0xaa>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2730:	80 91 ed 13 	lds	r24, 0x13ED
    2734:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2736:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    273a:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	25 e0       	ldi	r18, 0x05	; 5
    2742:	96 95       	lsr	r25
    2744:	87 95       	ror	r24
    2746:	2a 95       	dec	r18
    2748:	e1 f7       	brne	.-8      	; 0x2742 <USB_Device_ProcessControlRequest+0x9a>
    274a:	98 2f       	mov	r25, r24
    274c:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    274e:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2752:	80 91 e8 00 	lds	r24, 0x00E8
    2756:	87 7f       	andi	r24, 0xF7	; 247
    2758:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    275c:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Word >> 8);
    2760:	10 92 f1 00 	sts	0x00F1, r1
    2764:	d3 c0       	rjmp	.+422    	; 0x290c <USB_Device_ProcessControlRequest+0x264>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2766:	88 23       	and	r24, r24
    2768:	19 f0       	breq	.+6      	; 0x2770 <USB_Device_ProcessControlRequest+0xc8>
    276a:	82 30       	cpi	r24, 0x02	; 2
    276c:	09 f0       	breq	.+2      	; 0x2770 <USB_Device_ProcessControlRequest+0xc8>
    276e:	f2 c0       	rjmp	.+484    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	8f 71       	andi	r24, 0x1F	; 31
    2774:	90 70       	andi	r25, 0x00	; 0
    2776:	00 97       	sbiw	r24, 0x00	; 0
    2778:	21 f0       	breq	.+8      	; 0x2782 <USB_Device_ProcessControlRequest+0xda>
    277a:	02 97       	sbiw	r24, 0x02	; 2
    277c:	09 f0       	breq	.+2      	; 0x2780 <USB_Device_ProcessControlRequest+0xd8>
    277e:	ea c0       	rjmp	.+468    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
    2780:	0c c0       	rjmp	.+24     	; 0x279a <USB_Device_ProcessControlRequest+0xf2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2782:	80 91 eb 13 	lds	r24, 0x13EB
    2786:	81 30       	cpi	r24, 0x01	; 1
    2788:	09 f0       	breq	.+2      	; 0x278c <USB_Device_ProcessControlRequest+0xe4>
    278a:	e4 c0       	rjmp	.+456    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    278c:	10 92 e5 13 	sts	0x13E5, r1
    2790:	33 30       	cpi	r19, 0x03	; 3
    2792:	69 f5       	brne	.+90     	; 0x27ee <USB_Device_ProcessControlRequest+0x146>
    2794:	80 93 e5 13 	sts	0x13E5, r24
    2798:	2a c0       	rjmp	.+84     	; 0x27ee <USB_Device_ProcessControlRequest+0x146>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    279a:	80 91 eb 13 	lds	r24, 0x13EB
    279e:	88 23       	and	r24, r24
    27a0:	31 f5       	brne	.+76     	; 0x27ee <USB_Device_ProcessControlRequest+0x146>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    27a2:	20 91 ed 13 	lds	r18, 0x13ED
    27a6:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    27a8:	09 f4       	brne	.+2      	; 0x27ac <USB_Device_ProcessControlRequest+0x104>
    27aa:	d4 c0       	rjmp	.+424    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    27ac:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    27b0:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    27b4:	80 ff       	sbrs	r24, 0
    27b6:	1b c0       	rjmp	.+54     	; 0x27ee <USB_Device_ProcessControlRequest+0x146>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    27b8:	33 30       	cpi	r19, 0x03	; 3
    27ba:	21 f4       	brne	.+8      	; 0x27c4 <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    27bc:	80 91 eb 00 	lds	r24, 0x00EB
    27c0:	80 62       	ori	r24, 0x20	; 32
    27c2:	13 c0       	rjmp	.+38     	; 0x27ea <USB_Device_ProcessControlRequest+0x142>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    27c4:	80 91 eb 00 	lds	r24, 0x00EB
    27c8:	80 61       	ori	r24, 0x10	; 16
    27ca:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    27ce:	81 e0       	ldi	r24, 0x01	; 1
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	02 c0       	rjmp	.+4      	; 0x27d8 <USB_Device_ProcessControlRequest+0x130>
    27d4:	88 0f       	add	r24, r24
    27d6:	99 1f       	adc	r25, r25
    27d8:	2a 95       	dec	r18
    27da:	e2 f7       	brpl	.-8      	; 0x27d4 <USB_Device_ProcessControlRequest+0x12c>
    27dc:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    27e0:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    27e4:	80 91 eb 00 	lds	r24, 0x00EB
    27e8:	88 60       	ori	r24, 0x08	; 8
    27ea:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    27ee:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    27f2:	80 91 e8 00 	lds	r24, 0x00E8
    27f6:	87 7f       	andi	r24, 0xF7	; 247
    27f8:	8c c0       	rjmp	.+280    	; 0x2912 <USB_Device_ProcessControlRequest+0x26a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    27fa:	88 23       	and	r24, r24
    27fc:	09 f0       	breq	.+2      	; 0x2800 <USB_Device_ProcessControlRequest+0x158>
    27fe:	aa c0       	rjmp	.+340    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2800:	10 91 eb 13 	lds	r17, 0x13EB
    2804:	1f 77       	andi	r17, 0x7F	; 127

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    2806:	0f b7       	in	r16, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2808:	f8 94       	cli
    280a:	80 91 e8 00 	lds	r24, 0x00E8
    280e:	87 7f       	andi	r24, 0xF7	; 247
    2810:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_ClearSETUP();

		Endpoint_ClearStatusStage();
    2814:	cb dd       	rcall	.-1130   	; 0x23ac <Endpoint_ClearStatusStage>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2816:	80 91 e8 00 	lds	r24, 0x00E8

		while (!(Endpoint_IsINReady()));
    281a:	80 ff       	sbrs	r24, 0
    281c:	fc cf       	rjmp	.-8      	; 0x2816 <USB_Device_ProcessControlRequest+0x16e>

		USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    281e:	11 23       	and	r17, r17
    2820:	11 f4       	brne	.+4      	; 0x2826 <USB_Device_ProcessControlRequest+0x17e>
    2822:	82 e0       	ldi	r24, 0x02	; 2
    2824:	01 c0       	rjmp	.+2      	; 0x2828 <USB_Device_ProcessControlRequest+0x180>
    2826:	83 e0       	ldi	r24, 0x03	; 3
    2828:	80 93 e8 13 	sts	0x13E8, r24
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR  = ((UDADDR & (1 << ADDEN)) | (Address & 0x7F));
    282c:	80 91 e3 00 	lds	r24, 0x00E3
    2830:	80 78       	andi	r24, 0x80	; 128
    2832:	18 2b       	or	r17, r24
    2834:	10 93 e3 00 	sts	0x00E3, r17
				UDADDR |= (1 << ADDEN);
    2838:	80 91 e3 00 	lds	r24, 0x00E3
    283c:	80 68       	ori	r24, 0x80	; 128
    283e:	80 93 e3 00 	sts	0x00E3, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    2842:	0f bf       	out	0x3f, r16	; 63
    __asm__ volatile ("" ::: "memory");
    2844:	87 c0       	rjmp	.+270    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2846:	80 58       	subi	r24, 0x80	; 128
    2848:	82 30       	cpi	r24, 0x02	; 2
    284a:	08 f0       	brcs	.+2      	; 0x284e <USB_Device_ProcessControlRequest+0x1a6>
    284c:	83 c0       	rjmp	.+262    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
	#if !defined(USE_FLASH_DESCRIPTORS) && !defined(USE_EEPROM_DESCRIPTORS) && !defined(USE_RAM_DESCRIPTORS)
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    284e:	80 91 eb 13 	lds	r24, 0x13EB
    2852:	90 91 ec 13 	lds	r25, 0x13EC
    2856:	23 e0       	ldi	r18, 0x03	; 3
    2858:	8c 3d       	cpi	r24, 0xDC	; 220
    285a:	92 07       	cpc	r25, r18
    285c:	99 f5       	brne	.+102    	; 0x28c4 <USB_Device_ProcessControlRequest+0x21c>
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    285e:	7f b7       	in	r23, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2860:	f8 94       	cli
    2862:	de 01       	movw	r26, r28
    2864:	15 96       	adiw	r26, 0x05	; 5
    2866:	6e e0       	ldi	r22, 0x0E	; 14
    2868:	40 e0       	ldi	r20, 0x00	; 0
    286a:	50 e0       	ldi	r21, 0x00	; 0
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
		{
			uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    286c:	11 e2       	ldi	r17, 0x21	; 33
    286e:	e6 2f       	mov	r30, r22
    2870:	f0 e0       	ldi	r31, 0x00	; 0
    2872:	10 93 57 00 	sts	0x0057, r17
    2876:	84 91       	lpm	r24, Z+

			if (SerialCharNum & 0x01)
    2878:	40 ff       	sbrs	r20, 0
    287a:	03 c0       	rjmp	.+6      	; 0x2882 <USB_Device_ProcessControlRequest+0x1da>
			{
				SerialByte >>= 4;
    287c:	82 95       	swap	r24
    287e:	8f 70       	andi	r24, 0x0F	; 15
				SigReadAddress++;
    2880:	6f 5f       	subi	r22, 0xFF	; 255
			}

			SerialByte &= 0x0F;
    2882:	8f 70       	andi	r24, 0x0F	; 15
    2884:	28 2f       	mov	r18, r24
    2886:	30 e0       	ldi	r19, 0x00	; 0

			SignatureDescriptor.UnicodeString[SerialCharNum] = (SerialByte >= 10) ?
    2888:	8a 30       	cpi	r24, 0x0A	; 10
    288a:	18 f0       	brcs	.+6      	; 0x2892 <USB_Device_ProcessControlRequest+0x1ea>
    288c:	c9 01       	movw	r24, r18
    288e:	c7 96       	adiw	r24, 0x37	; 55
    2890:	02 c0       	rjmp	.+4      	; 0x2896 <USB_Device_ProcessControlRequest+0x1ee>
    2892:	c9 01       	movw	r24, r18
    2894:	c0 96       	adiw	r24, 0x30	; 48
    2896:	8d 93       	st	X+, r24
    2898:	9d 93       	st	X+, r25
    289a:	4f 5f       	subi	r20, 0xFF	; 255
    289c:	5f 4f       	sbci	r21, 0xFF	; 255

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
    289e:	44 31       	cpi	r20, 0x14	; 20
    28a0:	51 05       	cpc	r21, r1
    28a2:	29 f7       	brne	.-54     	; 0x286e <USB_Device_ProcessControlRequest+0x1c6>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    28a4:	7f bf       	out	0x3f, r23	; 63
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);
    28a6:	8a e2       	ldi	r24, 0x2A	; 42
    28a8:	8b 83       	std	Y+3, r24	; 0x03
	{
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    28aa:	83 e0       	ldi	r24, 0x03	; 3
    28ac:	8c 83       	std	Y+4, r24	; 0x04
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    28ae:	80 91 e8 00 	lds	r24, 0x00E8
    28b2:	87 7f       	andi	r24, 0xF7	; 247
    28b4:	80 93 e8 00 	sts	0x00E8, r24
		}
	}

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    28b8:	ce 01       	movw	r24, r28
    28ba:	03 96       	adiw	r24, 0x03	; 3
    28bc:	6a e2       	ldi	r22, 0x2A	; 42
    28be:	70 e0       	ldi	r23, 0x00	; 0
    28c0:	63 d0       	rcall	.+198    	; 0x2988 <Endpoint_Write_Control_Stream_LE>
    28c2:	13 c0       	rjmp	.+38     	; 0x28ea <USB_Device_ProcessControlRequest+0x242>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    28c4:	60 91 ed 13 	lds	r22, 0x13ED
    28c8:	ae 01       	movw	r20, r28
    28ca:	4f 5f       	subi	r20, 0xFF	; 255
    28cc:	5f 4f       	sbci	r21, 0xFF	; 255
    28ce:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <CALLBACK_USB_GetDescriptor>
    28d2:	bc 01       	movw	r22, r24
    28d4:	00 97       	sbiw	r24, 0x00	; 0
    28d6:	09 f4       	brne	.+2      	; 0x28da <USB_Device_ProcessControlRequest+0x232>
    28d8:	3d c0       	rjmp	.+122    	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
    28da:	80 91 e8 00 	lds	r24, 0x00E8
    28de:	87 7f       	andi	r24, 0xF7	; 247
    28e0:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    28e4:	89 81       	ldd	r24, Y+1	; 0x01
    28e6:	9a 81       	ldd	r25, Y+2	; 0x02
    28e8:	ad d0       	rcall	.+346    	; 0x2a44 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    28ea:	80 91 e8 00 	lds	r24, 0x00E8
    28ee:	8b 77       	andi	r24, 0x7B	; 123
    28f0:	80 93 e8 00 	sts	0x00E8, r24
    28f4:	2f c0       	rjmp	.+94     	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    28f6:	80 38       	cpi	r24, 0x80	; 128
    28f8:	69 f5       	brne	.+90     	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    28fa:	80 91 e8 00 	lds	r24, 0x00E8
    28fe:	87 7f       	andi	r24, 0xF7	; 247
    2900:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
    2904:	80 91 e6 13 	lds	r24, 0x13E6
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    2908:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    290c:	80 91 e8 00 	lds	r24, 0x00E8
    2910:	8e 77       	andi	r24, 0x7E	; 126
    2912:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2916:	4a dd       	rcall	.-1388   	; 0x23ac <Endpoint_ClearStatusStage>
    2918:	1d c0       	rjmp	.+58     	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    291a:	88 23       	and	r24, r24
    291c:	d9 f4       	brne	.+54     	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    291e:	90 91 eb 13 	lds	r25, 0x13EB
    2922:	92 30       	cpi	r25, 0x02	; 2
    2924:	b8 f4       	brcc	.+46     	; 0x2954 <USB_Device_ProcessControlRequest+0x2ac>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2926:	80 91 e8 00 	lds	r24, 0x00E8
    292a:	87 7f       	andi	r24, 0xF7	; 247
    292c:	80 93 e8 00 	sts	0x00E8, r24
	}
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2930:	90 93 e6 13 	sts	0x13E6, r25

	Endpoint_ClearStatusStage();
    2934:	3b dd       	rcall	.-1418   	; 0x23ac <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
    2936:	80 91 e6 13 	lds	r24, 0x13E6
    293a:	88 23       	and	r24, r24
    293c:	31 f4       	brne	.+12     	; 0x294a <USB_Device_ProcessControlRequest+0x2a2>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    293e:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2942:	87 fd       	sbrc	r24, 7
    2944:	02 c0       	rjmp	.+4      	; 0x294a <USB_Device_ProcessControlRequest+0x2a2>
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	01 c0       	rjmp	.+2      	; 0x294c <USB_Device_ProcessControlRequest+0x2a4>
    294a:	84 e0       	ldi	r24, 0x04	; 4
    294c:	80 93 e8 13 	sts	0x13E8, r24

	EVENT_USB_Device_ConfigurationChanged();
    2950:	0e 94 73 03 	call	0x6e6	; 0x6e6 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2954:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2958:	83 ff       	sbrs	r24, 3
    295a:	0a c0       	rjmp	.+20     	; 0x2970 <USB_Device_ProcessControlRequest+0x2c8>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    295c:	80 91 eb 00 	lds	r24, 0x00EB
    2960:	80 62       	ori	r24, 0x20	; 32
    2962:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2966:	80 91 e8 00 	lds	r24, 0x00E8
    296a:	87 7f       	andi	r24, 0xF7	; 247
    296c:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    2970:	ac 96       	adiw	r28, 0x2c	; 44
    2972:	0f b6       	in	r0, 0x3f	; 63
    2974:	f8 94       	cli
    2976:	de bf       	out	0x3e, r29	; 62
    2978:	0f be       	out	0x3f, r0	; 63
    297a:	cd bf       	out	0x3d, r28	; 61
    297c:	cf 91       	pop	r28
    297e:	df 91       	pop	r29
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	08 95       	ret

00002986 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2986:	08 95       	ret

00002988 <Endpoint_Write_Control_Stream_LE>:
    2988:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    298a:	40 91 ef 13 	lds	r20, 0x13EF
    298e:	50 91 f0 13 	lds	r21, 0x13F0
    2992:	46 17       	cp	r20, r22
    2994:	57 07       	cpc	r21, r23
    2996:	18 f4       	brcc	.+6      	; 0x299e <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2998:	f9 01       	movw	r30, r18
    299a:	90 e0       	ldi	r25, 0x00	; 0
    299c:	3d c0       	rjmp	.+122    	; 0x2a18 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    299e:	61 15       	cp	r22, r1
    29a0:	71 05       	cpc	r23, r1
    29a2:	11 f0       	breq	.+4      	; 0x29a8 <Endpoint_Write_Control_Stream_LE+0x20>
    29a4:	ab 01       	movw	r20, r22
    29a6:	f8 cf       	rjmp	.-16     	; 0x2998 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    29a8:	80 91 e8 00 	lds	r24, 0x00E8
    29ac:	8e 77       	andi	r24, 0x7E	; 126
    29ae:	80 93 e8 00 	sts	0x00E8, r24
    29b2:	40 e0       	ldi	r20, 0x00	; 0
    29b4:	50 e0       	ldi	r21, 0x00	; 0
    29b6:	f0 cf       	rjmp	.-32     	; 0x2998 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    29b8:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    29bc:	88 23       	and	r24, r24
    29be:	f1 f1       	breq	.+124    	; 0x2a3c <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    29c0:	85 30       	cpi	r24, 0x05	; 5
    29c2:	f1 f1       	breq	.+124    	; 0x2a40 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    29c4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    29c8:	83 ff       	sbrs	r24, 3
    29ca:	02 c0       	rjmp	.+4      	; 0x29d0 <Endpoint_Write_Control_Stream_LE+0x48>
    29cc:	81 e0       	ldi	r24, 0x01	; 1
    29ce:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    29d0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    29d4:	82 fd       	sbrc	r24, 2
    29d6:	2c c0       	rjmp	.+88     	; 0x2a30 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    29d8:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    29dc:	80 ff       	sbrs	r24, 0
    29de:	1c c0       	rjmp	.+56     	; 0x2a18 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    29e0:	20 91 f2 00 	lds	r18, 0x00F2
    29e4:	30 91 f3 00 	lds	r19, 0x00F3
    29e8:	07 c0       	rjmp	.+14     	; 0x29f8 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    29ea:	81 91       	ld	r24, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    29ec:	80 93 f1 00 	sts	0x00F1, r24
				Length--;
    29f0:	41 50       	subi	r20, 0x01	; 1
    29f2:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    29f4:	2f 5f       	subi	r18, 0xFF	; 255
    29f6:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    29f8:	41 15       	cp	r20, r1
    29fa:	51 05       	cpc	r21, r1
    29fc:	19 f0       	breq	.+6      	; 0x2a04 <Endpoint_Write_Control_Stream_LE+0x7c>
    29fe:	28 30       	cpi	r18, 0x08	; 8
    2a00:	31 05       	cpc	r19, r1
    2a02:	98 f3       	brcs	.-26     	; 0x29ea <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    2a04:	90 e0       	ldi	r25, 0x00	; 0
    2a06:	28 30       	cpi	r18, 0x08	; 8
    2a08:	31 05       	cpc	r19, r1
    2a0a:	09 f4       	brne	.+2      	; 0x2a0e <Endpoint_Write_Control_Stream_LE+0x86>
    2a0c:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2a0e:	80 91 e8 00 	lds	r24, 0x00E8
    2a12:	8e 77       	andi	r24, 0x7E	; 126
    2a14:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2a18:	41 15       	cp	r20, r1
    2a1a:	51 05       	cpc	r21, r1
    2a1c:	69 f6       	brne	.-102    	; 0x29b8 <Endpoint_Write_Control_Stream_LE+0x30>
    2a1e:	99 23       	and	r25, r25
    2a20:	59 f6       	brne	.-106    	; 0x29b8 <Endpoint_Write_Control_Stream_LE+0x30>
    2a22:	06 c0       	rjmp	.+12     	; 0x2a30 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2a24:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2a28:	88 23       	and	r24, r24
    2a2a:	41 f0       	breq	.+16     	; 0x2a3c <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2a2c:	85 30       	cpi	r24, 0x05	; 5
    2a2e:	41 f0       	breq	.+16     	; 0x2a40 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2a30:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2a34:	82 ff       	sbrs	r24, 2
    2a36:	f6 cf       	rjmp	.-20     	; 0x2a24 <Endpoint_Write_Control_Stream_LE+0x9c>
    2a38:	80 e0       	ldi	r24, 0x00	; 0
    2a3a:	08 95       	ret
    2a3c:	82 e0       	ldi	r24, 0x02	; 2
    2a3e:	08 95       	ret
    2a40:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2a42:	08 95       	ret

00002a44 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
    2a44:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    2a46:	40 91 ef 13 	lds	r20, 0x13EF
    2a4a:	50 91 f0 13 	lds	r21, 0x13F0
    2a4e:	46 17       	cp	r20, r22
    2a50:	57 07       	cpc	r21, r23
    2a52:	10 f4       	brcc	.+4      	; 0x2a58 <Endpoint_Write_Control_PStream_LE+0x14>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2a54:	60 e0       	ldi	r22, 0x00	; 0
    2a56:	40 c0       	rjmp	.+128    	; 0x2ad8 <Endpoint_Write_Control_PStream_LE+0x94>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    2a58:	61 15       	cp	r22, r1
    2a5a:	71 05       	cpc	r23, r1
    2a5c:	11 f0       	breq	.+4      	; 0x2a62 <Endpoint_Write_Control_PStream_LE+0x1e>
    2a5e:	ab 01       	movw	r20, r22
    2a60:	f9 cf       	rjmp	.-14     	; 0x2a54 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2a62:	80 91 e8 00 	lds	r24, 0x00E8
    2a66:	8e 77       	andi	r24, 0x7E	; 126
    2a68:	80 93 e8 00 	sts	0x00E8, r24
    2a6c:	40 e0       	ldi	r20, 0x00	; 0
    2a6e:	50 e0       	ldi	r21, 0x00	; 0
    2a70:	f1 cf       	rjmp	.-30     	; 0x2a54 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2a72:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2a76:	88 23       	and	r24, r24
    2a78:	09 f4       	brne	.+2      	; 0x2a7c <Endpoint_Write_Control_PStream_LE+0x38>
    2a7a:	40 c0       	rjmp	.+128    	; 0x2afc <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2a7c:	85 30       	cpi	r24, 0x05	; 5
    2a7e:	09 f4       	brne	.+2      	; 0x2a82 <Endpoint_Write_Control_PStream_LE+0x3e>
    2a80:	3f c0       	rjmp	.+126    	; 0x2b00 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2a82:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2a86:	83 ff       	sbrs	r24, 3
    2a88:	02 c0       	rjmp	.+4      	; 0x2a8e <Endpoint_Write_Control_PStream_LE+0x4a>
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2a8e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2a92:	82 fd       	sbrc	r24, 2
    2a94:	2d c0       	rjmp	.+90     	; 0x2af0 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2a96:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    2a9a:	80 ff       	sbrs	r24, 0
    2a9c:	1d c0       	rjmp	.+58     	; 0x2ad8 <Endpoint_Write_Control_PStream_LE+0x94>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2a9e:	80 91 f2 00 	lds	r24, 0x00F2
    2aa2:	90 91 f3 00 	lds	r25, 0x00F3
    2aa6:	09 c0       	rjmp	.+18     	; 0x2aba <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    2aa8:	f9 01       	movw	r30, r18
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2aaa:	2f 5f       	subi	r18, 0xFF	; 255
    2aac:	3f 4f       	sbci	r19, 0xFF	; 255
    2aae:	e4 91       	lpm	r30, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    2ab0:	e0 93 f1 00 	sts	0x00F1, r30
				Length--;
    2ab4:	41 50       	subi	r20, 0x01	; 1
    2ab6:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    2ab8:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    2aba:	41 15       	cp	r20, r1
    2abc:	51 05       	cpc	r21, r1
    2abe:	19 f0       	breq	.+6      	; 0x2ac6 <Endpoint_Write_Control_PStream_LE+0x82>
    2ac0:	88 30       	cpi	r24, 0x08	; 8
    2ac2:	91 05       	cpc	r25, r1
    2ac4:	88 f3       	brcs	.-30     	; 0x2aa8 <Endpoint_Write_Control_PStream_LE+0x64>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    2ac6:	60 e0       	ldi	r22, 0x00	; 0
    2ac8:	08 97       	sbiw	r24, 0x08	; 8
    2aca:	09 f4       	brne	.+2      	; 0x2ace <Endpoint_Write_Control_PStream_LE+0x8a>
    2acc:	61 e0       	ldi	r22, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2ace:	80 91 e8 00 	lds	r24, 0x00E8
    2ad2:	8e 77       	andi	r24, 0x7E	; 126
    2ad4:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2ad8:	41 15       	cp	r20, r1
    2ada:	51 05       	cpc	r21, r1
    2adc:	51 f6       	brne	.-108    	; 0x2a72 <Endpoint_Write_Control_PStream_LE+0x2e>
    2ade:	66 23       	and	r22, r22
    2ae0:	41 f6       	brne	.-112    	; 0x2a72 <Endpoint_Write_Control_PStream_LE+0x2e>
    2ae2:	06 c0       	rjmp	.+12     	; 0x2af0 <Endpoint_Write_Control_PStream_LE+0xac>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2ae4:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2ae8:	88 23       	and	r24, r24
    2aea:	41 f0       	breq	.+16     	; 0x2afc <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2aec:	85 30       	cpi	r24, 0x05	; 5
    2aee:	41 f0       	breq	.+16     	; 0x2b00 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2af0:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2af4:	82 ff       	sbrs	r24, 2
    2af6:	f6 cf       	rjmp	.-20     	; 0x2ae4 <Endpoint_Write_Control_PStream_LE+0xa0>
    2af8:	80 e0       	ldi	r24, 0x00	; 0
    2afa:	08 95       	ret
    2afc:	82 e0       	ldi	r24, 0x02	; 2
    2afe:	08 95       	ret
    2b00:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2b02:	08 95       	ret

00002b04 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
    2b04:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    2b06:	61 15       	cp	r22, r1
    2b08:	71 05       	cpc	r23, r1
    2b0a:	29 f4       	brne	.+10     	; 0x2b16 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2b0c:	80 91 e8 00 	lds	r24, 0x00E8
    2b10:	8b 77       	andi	r24, 0x7B	; 123
    2b12:	80 93 e8 00 	sts	0x00E8, r24
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2b16:	f9 01       	movw	r30, r18
    2b18:	22 c0       	rjmp	.+68     	; 0x2b5e <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2b1a:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2b1e:	88 23       	and	r24, r24
    2b20:	71 f1       	breq	.+92     	; 0x2b7e <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2b22:	85 30       	cpi	r24, 0x05	; 5
    2b24:	71 f1       	breq	.+92     	; 0x2b82 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2b26:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2b2a:	83 ff       	sbrs	r24, 3
    2b2c:	02 c0       	rjmp	.+4      	; 0x2b32 <Endpoint_Read_Control_Stream_LE+0x2e>
    2b2e:	81 e0       	ldi	r24, 0x01	; 1
    2b30:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2b32:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    2b36:	82 ff       	sbrs	r24, 2
    2b38:	f0 cf       	rjmp	.-32     	; 0x2b1a <Endpoint_Read_Control_Stream_LE+0x16>
    2b3a:	06 c0       	rjmp	.+12     	; 0x2b48 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    2b3c:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2b40:	81 93       	st	Z+, r24
				Length--;
    2b42:	61 50       	subi	r22, 0x01	; 1
    2b44:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2b46:	31 f0       	breq	.+12     	; 0x2b54 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2b48:	80 91 f2 00 	lds	r24, 0x00F2
    2b4c:	90 91 f3 00 	lds	r25, 0x00F3
    2b50:	89 2b       	or	r24, r25
    2b52:	a1 f7       	brne	.-24     	; 0x2b3c <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2b54:	80 91 e8 00 	lds	r24, 0x00E8
    2b58:	8b 77       	andi	r24, 0x7B	; 123
    2b5a:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    2b5e:	61 15       	cp	r22, r1
    2b60:	71 05       	cpc	r23, r1
    2b62:	d9 f6       	brne	.-74     	; 0x2b1a <Endpoint_Read_Control_Stream_LE+0x16>
    2b64:	06 c0       	rjmp	.+12     	; 0x2b72 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2b66:	80 91 e8 13 	lds	r24, 0x13E8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2b6a:	88 23       	and	r24, r24
    2b6c:	41 f0       	breq	.+16     	; 0x2b7e <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2b6e:	85 30       	cpi	r24, 0x05	; 5
    2b70:	41 f0       	breq	.+16     	; 0x2b82 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2b72:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    2b76:	80 ff       	sbrs	r24, 0
    2b78:	f6 cf       	rjmp	.-20     	; 0x2b66 <Endpoint_Read_Control_Stream_LE+0x62>
    2b7a:	80 e0       	ldi	r24, 0x00	; 0
    2b7c:	08 95       	ret
    2b7e:	82 e0       	ldi	r24, 0x02	; 2
    2b80:	08 95       	ret
    2b82:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2b84:	08 95       	ret

00002b86 <Endpoint_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    2b86:	ff 92       	push	r15
    2b88:	0f 93       	push	r16
    2b8a:	1f 93       	push	r17
    2b8c:	cf 93       	push	r28
    2b8e:	df 93       	push	r29
    2b90:	18 2f       	mov	r17, r24
    2b92:	09 2f       	mov	r16, r25
    2b94:	eb 01       	movw	r28, r22
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2b96:	2b dc       	rcall	.-1962   	; 0x23ee <Endpoint_WaitUntilReady>
    2b98:	f8 2e       	mov	r15, r24
    2b9a:	88 23       	and	r24, r24
    2b9c:	d1 f4       	brne	.+52     	; 0x2bd2 <Endpoint_Read_Stream_LE+0x4c>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2b9e:	81 2f       	mov	r24, r17
    2ba0:	90 2f       	mov	r25, r16
    2ba2:	9c 01       	movw	r18, r24
    2ba4:	89 01       	movw	r16, r18
    2ba6:	13 c0       	rjmp	.+38     	; 0x2bce <Endpoint_Read_Stream_LE+0x48>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2ba8:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2bac:	85 fd       	sbrc	r24, 5
    2bae:	09 c0       	rjmp	.+18     	; 0x2bc2 <Endpoint_Read_Stream_LE+0x3c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2bb0:	80 91 e8 00 	lds	r24, 0x00E8
    2bb4:	8b 77       	andi	r24, 0x7B	; 123
    2bb6:	80 93 e8 00 	sts	0x00E8, r24
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2bba:	19 dc       	rcall	.-1998   	; 0x23ee <Endpoint_WaitUntilReady>
    2bbc:	88 23       	and	r24, r24
    2bbe:	39 f0       	breq	.+14     	; 0x2bce <Endpoint_Read_Stream_LE+0x48>
    2bc0:	09 c0       	rjmp	.+18     	; 0x2bd4 <Endpoint_Read_Stream_LE+0x4e>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    2bc2:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2bc6:	f8 01       	movw	r30, r16
    2bc8:	81 93       	st	Z+, r24
    2bca:	8f 01       	movw	r16, r30
			Length--;
    2bcc:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    2bce:	20 97       	sbiw	r28, 0x00	; 0
    2bd0:	59 f7       	brne	.-42     	; 0x2ba8 <Endpoint_Read_Stream_LE+0x22>
    2bd2:	8f 2d       	mov	r24, r15
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2bd4:	df 91       	pop	r29
    2bd6:	cf 91       	pop	r28
    2bd8:	1f 91       	pop	r17
    2bda:	0f 91       	pop	r16
    2bdc:	ff 90       	pop	r15
    2bde:	08 95       	ret

00002be0 <Endpoint_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    2be0:	ff 92       	push	r15
    2be2:	0f 93       	push	r16
    2be4:	1f 93       	push	r17
    2be6:	cf 93       	push	r28
    2be8:	df 93       	push	r29
    2bea:	18 2f       	mov	r17, r24
    2bec:	09 2f       	mov	r16, r25
    2bee:	eb 01       	movw	r28, r22
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2bf0:	fe db       	rcall	.-2052   	; 0x23ee <Endpoint_WaitUntilReady>
    2bf2:	f8 2e       	mov	r15, r24
    2bf4:	88 23       	and	r24, r24
    2bf6:	d1 f4       	brne	.+52     	; 0x2c2c <Endpoint_Write_Stream_LE+0x4c>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2bf8:	81 2f       	mov	r24, r17
    2bfa:	90 2f       	mov	r25, r16
    2bfc:	9c 01       	movw	r18, r24
    2bfe:	89 01       	movw	r16, r18
    2c00:	13 c0       	rjmp	.+38     	; 0x2c28 <Endpoint_Write_Stream_LE+0x48>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2c02:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2c06:	85 fd       	sbrc	r24, 5
    2c08:	09 c0       	rjmp	.+18     	; 0x2c1c <Endpoint_Write_Stream_LE+0x3c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2c0a:	80 91 e8 00 	lds	r24, 0x00E8
    2c0e:	8e 77       	andi	r24, 0x7E	; 126
    2c10:	80 93 e8 00 	sts	0x00E8, r24
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2c14:	ec db       	rcall	.-2088   	; 0x23ee <Endpoint_WaitUntilReady>
    2c16:	88 23       	and	r24, r24
    2c18:	39 f0       	breq	.+14     	; 0x2c28 <Endpoint_Write_Stream_LE+0x48>
    2c1a:	09 c0       	rjmp	.+18     	; 0x2c2e <Endpoint_Write_Stream_LE+0x4e>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2c1c:	f8 01       	movw	r30, r16
    2c1e:	81 91       	ld	r24, Z+
    2c20:	8f 01       	movw	r16, r30
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    2c22:	80 93 f1 00 	sts	0x00F1, r24
			Length--;
    2c26:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    2c28:	20 97       	sbiw	r28, 0x00	; 0
    2c2a:	59 f7       	brne	.-42     	; 0x2c02 <Endpoint_Write_Stream_LE+0x22>
    2c2c:	8f 2d       	mov	r24, r15
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2c2e:	df 91       	pop	r29
    2c30:	cf 91       	pop	r28
    2c32:	1f 91       	pop	r17
    2c34:	0f 91       	pop	r16
    2c36:	ff 90       	pop	r15
    2c38:	08 95       	ret

00002c3a <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2c3a:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    2c3c:	80 91 e8 13 	lds	r24, 0x13E8
    2c40:	88 23       	and	r24, r24
    2c42:	61 f0       	breq	.+24     	; 0x2c5c <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2c44:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2c48:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2c4c:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    2c50:	83 ff       	sbrs	r24, 3
    2c52:	01 c0       	rjmp	.+2      	; 0x2c56 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    2c54:	29 dd       	rcall	.-1454   	; 0x26a8 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2c56:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2c58:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    2c5c:	1f 91       	pop	r17
    2c5e:	08 95       	ret

00002c60 <SerialStream_TxByte>:

FILE USARTStream = FDEV_SETUP_STREAM(SerialStream_TxByte, SerialStream_RxByte, _FDEV_SETUP_RW);

static int SerialStream_TxByte(char DataByte,
                               FILE *Stream)
{
    2c60:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_TxByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_TxByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2c62:	80 91 c8 00 	lds	r24, 0x00C8
    2c66:	85 ff       	sbrs	r24, 5
    2c68:	fc cf       	rjmp	.-8      	; 0x2c62 <SerialStream_TxByte+0x2>
				UDR1 = DataByte;
    2c6a:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_TxByte(DataByte);
	return 0;
}
    2c6e:	80 e0       	ldi	r24, 0x00	; 0
    2c70:	90 e0       	ldi	r25, 0x00	; 0
    2c72:	08 95       	ret

00002c74 <SerialStream_RxByte>:
			 *  \return Boolean true if a character has been received, false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2c74:	80 91 c8 00 	lds	r24, 0x00C8

static int SerialStream_RxByte(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2c78:	87 fd       	sbrc	r24, 7
    2c7a:	03 c0       	rjmp	.+6      	; 0x2c82 <SerialStream_RxByte+0xe>
    2c7c:	2e ef       	ldi	r18, 0xFE	; 254
    2c7e:	3f ef       	ldi	r19, 0xFF	; 255
    2c80:	08 c0       	rjmp	.+16     	; 0x2c92 <SerialStream_RxByte+0x1e>
			 *  \return Byte received from the USART.
			 */
			static inline char Serial_RxByte(void) ATTR_ALWAYS_INLINE;
			static inline char Serial_RxByte(void)
			{
				while (!(UCSR1A & (1 << RXC1)));
    2c82:	80 91 c8 00 	lds	r24, 0x00C8
    2c86:	87 ff       	sbrs	r24, 7
    2c88:	fc cf       	rjmp	.-8      	; 0x2c82 <SerialStream_RxByte+0xe>
				return UDR1;
    2c8a:	80 91 ce 00 	lds	r24, 0x00CE
	  return _FDEV_EOF;

	return Serial_RxByte();
    2c8e:	28 2f       	mov	r18, r24
    2c90:	30 e0       	ldi	r19, 0x00	; 0
}
    2c92:	c9 01       	movw	r24, r18
    2c94:	08 95       	ret

00002c96 <memcpy_P>:
    2c96:	fb 01       	movw	r30, r22
    2c98:	dc 01       	movw	r26, r24
    2c9a:	02 c0       	rjmp	.+4      	; 0x2ca0 <memcpy_P+0xa>
    2c9c:	05 90       	lpm	r0, Z+
    2c9e:	0d 92       	st	X+, r0
    2ca0:	41 50       	subi	r20, 0x01	; 1
    2ca2:	50 40       	sbci	r21, 0x00	; 0
    2ca4:	d8 f7       	brcc	.-10     	; 0x2c9c <memcpy_P+0x6>
    2ca6:	08 95       	ret

00002ca8 <strcpy_P>:
    2ca8:	fb 01       	movw	r30, r22
    2caa:	dc 01       	movw	r26, r24
    2cac:	05 90       	lpm	r0, Z+
    2cae:	0d 92       	st	X+, r0
    2cb0:	00 20       	and	r0, r0
    2cb2:	e1 f7       	brne	.-8      	; 0x2cac <strcpy_P+0x4>
    2cb4:	08 95       	ret

00002cb6 <strlen_P>:
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	05 90       	lpm	r0, Z+
    2cba:	00 20       	and	r0, r0
    2cbc:	e9 f7       	brne	.-6      	; 0x2cb8 <strlen_P+0x2>
    2cbe:	80 95       	com	r24
    2cc0:	90 95       	com	r25
    2cc2:	8e 0f       	add	r24, r30
    2cc4:	9f 1f       	adc	r25, r31
    2cc6:	08 95       	ret

00002cc8 <strncpy_P>:
    2cc8:	fb 01       	movw	r30, r22
    2cca:	dc 01       	movw	r26, r24
    2ccc:	41 50       	subi	r20, 0x01	; 1
    2cce:	50 40       	sbci	r21, 0x00	; 0
    2cd0:	48 f0       	brcs	.+18     	; 0x2ce4 <strncpy_P+0x1c>
    2cd2:	05 90       	lpm	r0, Z+
    2cd4:	0d 92       	st	X+, r0
    2cd6:	00 20       	and	r0, r0
    2cd8:	c9 f7       	brne	.-14     	; 0x2ccc <strncpy_P+0x4>
    2cda:	01 c0       	rjmp	.+2      	; 0x2cde <strncpy_P+0x16>
    2cdc:	1d 92       	st	X+, r1
    2cde:	41 50       	subi	r20, 0x01	; 1
    2ce0:	50 40       	sbci	r21, 0x00	; 0
    2ce2:	e0 f7       	brcc	.-8      	; 0x2cdc <strncpy_P+0x14>
    2ce4:	08 95       	ret

00002ce6 <memcmp>:
    2ce6:	fb 01       	movw	r30, r22
    2ce8:	dc 01       	movw	r26, r24
    2cea:	04 c0       	rjmp	.+8      	; 0x2cf4 <memcmp+0xe>
    2cec:	8d 91       	ld	r24, X+
    2cee:	01 90       	ld	r0, Z+
    2cf0:	80 19       	sub	r24, r0
    2cf2:	21 f4       	brne	.+8      	; 0x2cfc <memcmp+0x16>
    2cf4:	41 50       	subi	r20, 0x01	; 1
    2cf6:	50 40       	sbci	r21, 0x00	; 0
    2cf8:	c8 f7       	brcc	.-14     	; 0x2cec <memcmp+0x6>
    2cfa:	88 1b       	sub	r24, r24
    2cfc:	99 0b       	sbc	r25, r25
    2cfe:	08 95       	ret

00002d00 <memcpy>:
    2d00:	fb 01       	movw	r30, r22
    2d02:	dc 01       	movw	r26, r24
    2d04:	02 c0       	rjmp	.+4      	; 0x2d0a <memcpy+0xa>
    2d06:	01 90       	ld	r0, Z+
    2d08:	0d 92       	st	X+, r0
    2d0a:	41 50       	subi	r20, 0x01	; 1
    2d0c:	50 40       	sbci	r21, 0x00	; 0
    2d0e:	d8 f7       	brcc	.-10     	; 0x2d06 <memcpy+0x6>
    2d10:	08 95       	ret

00002d12 <memmove>:
    2d12:	68 17       	cp	r22, r24
    2d14:	79 07       	cpc	r23, r25
    2d16:	68 f4       	brcc	.+26     	; 0x2d32 <memmove+0x20>
    2d18:	fb 01       	movw	r30, r22
    2d1a:	dc 01       	movw	r26, r24
    2d1c:	e4 0f       	add	r30, r20
    2d1e:	f5 1f       	adc	r31, r21
    2d20:	a4 0f       	add	r26, r20
    2d22:	b5 1f       	adc	r27, r21
    2d24:	02 c0       	rjmp	.+4      	; 0x2d2a <memmove+0x18>
    2d26:	02 90       	ld	r0, -Z
    2d28:	0e 92       	st	-X, r0
    2d2a:	41 50       	subi	r20, 0x01	; 1
    2d2c:	50 40       	sbci	r21, 0x00	; 0
    2d2e:	d8 f7       	brcc	.-10     	; 0x2d26 <memmove+0x14>
    2d30:	08 95       	ret
    2d32:	e6 cf       	rjmp	.-52     	; 0x2d00 <memcpy>

00002d34 <strncmp>:
    2d34:	fb 01       	movw	r30, r22
    2d36:	dc 01       	movw	r26, r24
    2d38:	41 50       	subi	r20, 0x01	; 1
    2d3a:	50 40       	sbci	r21, 0x00	; 0
    2d3c:	30 f0       	brcs	.+12     	; 0x2d4a <strncmp+0x16>
    2d3e:	8d 91       	ld	r24, X+
    2d40:	01 90       	ld	r0, Z+
    2d42:	80 19       	sub	r24, r0
    2d44:	19 f4       	brne	.+6      	; 0x2d4c <strncmp+0x18>
    2d46:	00 20       	and	r0, r0
    2d48:	b9 f7       	brne	.-18     	; 0x2d38 <strncmp+0x4>
    2d4a:	88 1b       	sub	r24, r24
    2d4c:	99 0b       	sbc	r25, r25
    2d4e:	08 95       	ret

00002d50 <_exit>:
    2d50:	f8 94       	cli

00002d52 <__stop_program>:
    2d52:	ff cf       	rjmp	.-2      	; 0x2d52 <__stop_program>
