
Webserver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000278  00800100  00007f5a  00007fee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007f5a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a60  00800378  00800378  00008266  2**0
                  ALLOC
  3 .stab         000018c0  00000000  00000000  00008268  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000769  00000000  00000000  00009b28  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000f98  00000000  00000000  0000a298  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001c66d  00000000  00000000  0000b230  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006377  00000000  00000000  0002789d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b095  00000000  00000000  0002dc14  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002eb4  00000000  00000000  00038cac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000802b  00000000  00000000  0003bb60  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00011d10  00000000  00000000  00043b8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001348  00000000  00000000  0005589b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	07 c2       	rjmp	.+1038   	; 0x410 <__ctors_end>
       2:	00 00       	nop
       4:	24 c2       	rjmp	.+1096   	; 0x44e <__bad_interrupt>
       6:	00 00       	nop
       8:	22 c2       	rjmp	.+1092   	; 0x44e <__bad_interrupt>
       a:	00 00       	nop
       c:	20 c2       	rjmp	.+1088   	; 0x44e <__bad_interrupt>
       e:	00 00       	nop
      10:	1e c2       	rjmp	.+1084   	; 0x44e <__bad_interrupt>
      12:	00 00       	nop
      14:	1c c2       	rjmp	.+1080   	; 0x44e <__bad_interrupt>
      16:	00 00       	nop
      18:	1a c2       	rjmp	.+1076   	; 0x44e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	18 c2       	rjmp	.+1072   	; 0x44e <__bad_interrupt>
      1e:	00 00       	nop
      20:	16 c2       	rjmp	.+1068   	; 0x44e <__bad_interrupt>
      22:	00 00       	nop
      24:	14 c2       	rjmp	.+1064   	; 0x44e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 37 2d 	jmp	0x5a6e	; 0x5a6e <__vector_10>
      2c:	0c 94 94 2e 	jmp	0x5d28	; 0x5d28 <__vector_11>
      30:	0e c2       	rjmp	.+1052   	; 0x44e <__bad_interrupt>
      32:	00 00       	nop
      34:	0c c2       	rjmp	.+1048   	; 0x44e <__bad_interrupt>
      36:	00 00       	nop
      38:	0a c2       	rjmp	.+1044   	; 0x44e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	08 c2       	rjmp	.+1040   	; 0x44e <__bad_interrupt>
      3e:	00 00       	nop
      40:	06 c2       	rjmp	.+1036   	; 0x44e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 0a 1c 	jmp	0x3814	; 0x3814 <__vector_17>
      48:	02 c2       	rjmp	.+1028   	; 0x44e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	00 c2       	rjmp	.+1024   	; 0x44e <__bad_interrupt>
      4e:	00 00       	nop
      50:	fe c1       	rjmp	.+1020   	; 0x44e <__bad_interrupt>
      52:	00 00       	nop
      54:	fc c1       	rjmp	.+1016   	; 0x44e <__bad_interrupt>
      56:	00 00       	nop
      58:	fa c1       	rjmp	.+1012   	; 0x44e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	f8 c1       	rjmp	.+1008   	; 0x44e <__bad_interrupt>
      5e:	00 00       	nop
      60:	f6 c1       	rjmp	.+1004   	; 0x44e <__bad_interrupt>
      62:	00 00       	nop
      64:	f4 c1       	rjmp	.+1000   	; 0x44e <__bad_interrupt>
      66:	00 00       	nop
      68:	f2 c1       	rjmp	.+996    	; 0x44e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f0 c1       	rjmp	.+992    	; 0x44e <__bad_interrupt>
      6e:	00 00       	nop
      70:	ee c1       	rjmp	.+988    	; 0x44e <__bad_interrupt>
      72:	00 00       	nop
      74:	ec c1       	rjmp	.+984    	; 0x44e <__bad_interrupt>
      76:	00 00       	nop
      78:	ea c1       	rjmp	.+980    	; 0x44e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e8 c1       	rjmp	.+976    	; 0x44e <__bad_interrupt>
      7e:	00 00       	nop
      80:	e6 c1       	rjmp	.+972    	; 0x44e <__bad_interrupt>
      82:	00 00       	nop
      84:	e4 c1       	rjmp	.+968    	; 0x44e <__bad_interrupt>
      86:	00 00       	nop
      88:	e2 c1       	rjmp	.+964    	; 0x44e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e0 c1       	rjmp	.+960    	; 0x44e <__bad_interrupt>
      8e:	00 00       	nop
      90:	de c1       	rjmp	.+956    	; 0x44e <__bad_interrupt>
      92:	00 00       	nop
      94:	dc c1       	rjmp	.+952    	; 0x44e <__bad_interrupt>
      96:	00 00       	nop

00000098 <ProductString>:
      98:	1e 03 4c 00 55 00 46 00 41 00 20 00 57 00 65 00     ..L.U.F.A. .W.e.
      a8:	62 00 73 00 65 00 72 00 76 00 65 00 72 00 00 00     b.s.e.r.v.e.r...

000000b8 <ManufacturerString>:
      b8:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      c8:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000d2 <LanguageString>:
      d2:	04 03 09 04                                         ....

000000d6 <ConfigurationDescriptor>:
      d6:	09 02 5d 00 03 01 00 80 32 08 0b 00 02 02 02 ff     ..].....2.......
      e6:	00 09 04 00 00 01 02 02 ff 00 05 24 00 10 01 04     ...........$....
      f6:	24 02 00 05 24 06 00 01 07 05 85 03 08 00 ff 09     $...$...........
     106:	04 01 00 02 0a 00 00 00 07 05 02 02 40 00 05 07     ............@...
     116:	05 81 02 40 00 05 09 04 02 00 02 08 06 50 00 07     ...@.........P..
     126:	05 83 02 40 00 05 07 05 04 02 40 00 05              ...@......@..

00000133 <DeviceDescriptor>:
     133:	12 01 10 01 ef 02 01 08 eb 03 69 20 01 00 01 02     ..........i ....
     143:	dc 01                                               ..

00000145 <DefaultMIMEType>:
     145:	74 65 78 74 2f 70 6c 61 69 6e 00                    text/plain.

00000150 <DefaultDirFileName>:
     150:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

0000015a <HTTP404Header>:
     15a:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     16a:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     17a:	4c 55 46 41 20 31 33 30 33 30 33 0d 0a 43 6f 6e     LUFA 130303..Con
     18a:	6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a     nection: close..
     19a:	4d 49 4d 45 2d 76 65 72 73 69 6f 6e 3a 20 31 2e     MIME-version: 1.
     1aa:	30 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     0..Content-Type:
     1ba:	20 74 65 78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 45      text/plain....E
     1ca:	72 72 6f 72 20 34 30 34 3a 20 46 69 6c 65 20 4e     rror 404: File N
     1da:	6f 74 20 46 6f 75 6e 64 3a 20 2f 00                 ot Found: /.

000001e6 <HTTP200Header>:
     1e6:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     1f6:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 31 33     .Server: LUFA 13
     206:	30 33 30 33 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     0303..Connection
     216:	3a 20 63 6c 6f 73 65 0d 0a 4d 49 4d 45 2d 76 65     : close..MIME-ve
     226:	72 73 69 6f 6e 3a 20 31 2e 30 0d 0a 43 6f 6e 74     rsion: 1.0..Cont
     236:	65 6e 74 2d 54 79 70 65 3a 20 00                    ent-Type: .

00000241 <__c.2077>:
     241:	47 45 54 00                                         GET.

00000245 <__c.2091>:
     245:	0d 0a 0d 0a 00                                      .....

0000024a <CurrentConnectionsHeader>:
     24a:	0d 0a 2a 20 43 75 72 72 65 6e 74 20 54 43 50 20     ..* Current TCP 
     25a:	43 6f 6e 6e 65 63 74 69 6f 6e 73 3a 20 2a 0d 0a     Connections: *..
     26a:	00                                                  .

0000026b <TELNETMenu>:
     26b:	0d 0a 20 20 3d 3d 20 41 76 61 69 6c 61 62 6c 65     ..  == Available
     27b:	20 43 6f 6d 6d 61 6e 64 73 3a 20 3d 3d 0d 0a 20      Commands: ==.. 
     28b:	20 20 20 20 63 29 20 4c 69 73 74 20 41 63 74 69         c) List Acti
     29b:	76 65 20 54 43 50 20 43 6f 6e 6e 65 63 74 69 6f     ve TCP Connectio
     2ab:	6e 73 0d 0a 20 20 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ns..  ==========
     2bb:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d     ===============.
     2cb:	0a 0d 0a 3e 00                                      ...>.

000002d0 <WelcomeHeader>:
     2d0:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     2e0:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     2f0:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 2a 20     ************..* 
     300:	20 20 20 20 20 20 4c 55 46 41 20 75 49 50 20 57           LUFA uIP W
     310:	65 62 73 65 72 76 65 72 20 28 54 45 4c 4e 45 54     ebserver (TELNET
     320:	29 20 20 20 20 20 20 20 20 2a 0d 0a 2a 2a 2a 2a     )        *..****
     330:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     340:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     350:	2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 00                    ********...

0000035b <__c.2217>:
     35b:	49 6e 76 61 6c 69 64 20 43 6f 6d 6d 61 6e 64 2e     Invalid Command.
     36b:	0d 0a 00                                            ...

0000036e <__c.2227>:
     36e:	25 75 29 20 25 64 2e 25 64 2e 25 64 2e 25 64 20     %u) %d.%d.%d.%d 
     37e:	28 4c 6f 63 61 6c 20 50 6f 72 74 20 25 75 20 3c     (Local Port %u <
     38e:	3d 3e 20 52 65 6d 6f 74 65 20 50 6f 72 74 20 25     => Remote Port %
     39e:	75 29 0d 0a 00                                      u)...

000003a3 <AdapterSupportedOIDList>:
     3a3:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3b3:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3c3:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3d3:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3e3:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     3f3:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     403:	01 01 02 01 02 01 02 01 03 01 02 01 00              .............

00000410 <__ctors_end>:
     410:	11 24       	eor	r1, r1
     412:	1f be       	out	0x3f, r1	; 63
     414:	cf ef       	ldi	r28, 0xFF	; 255
     416:	d0 e2       	ldi	r29, 0x20	; 32
     418:	de bf       	out	0x3e, r29	; 62
     41a:	cd bf       	out	0x3d, r28	; 61

0000041c <__do_copy_data>:
     41c:	13 e0       	ldi	r17, 0x03	; 3
     41e:	a0 e0       	ldi	r26, 0x00	; 0
     420:	b1 e0       	ldi	r27, 0x01	; 1
     422:	ea e5       	ldi	r30, 0x5A	; 90
     424:	ff e7       	ldi	r31, 0x7F	; 127
     426:	00 e0       	ldi	r16, 0x00	; 0
     428:	0b bf       	out	0x3b, r16	; 59
     42a:	02 c0       	rjmp	.+4      	; 0x430 <__do_copy_data+0x14>
     42c:	07 90       	elpm	r0, Z+
     42e:	0d 92       	st	X+, r0
     430:	a8 37       	cpi	r26, 0x78	; 120
     432:	b1 07       	cpc	r27, r17
     434:	d9 f7       	brne	.-10     	; 0x42c <__do_copy_data+0x10>
     436:	1b be       	out	0x3b, r1	; 59

00000438 <__do_clear_bss>:
     438:	1d e0       	ldi	r17, 0x0D	; 13
     43a:	a8 e7       	ldi	r26, 0x78	; 120
     43c:	b3 e0       	ldi	r27, 0x03	; 3
     43e:	01 c0       	rjmp	.+2      	; 0x442 <.do_clear_bss_start>

00000440 <.do_clear_bss_loop>:
     440:	1d 92       	st	X+, r1

00000442 <.do_clear_bss_start>:
     442:	a8 3d       	cpi	r26, 0xD8	; 216
     444:	b1 07       	cpc	r27, r17
     446:	e1 f7       	brne	.-8      	; 0x440 <.do_clear_bss_loop>
     448:	33 d0       	rcall	.+102    	; 0x4b0 <main>
     44a:	0c 94 ab 3f 	jmp	0x7f56	; 0x7f56 <_exit>

0000044e <__bad_interrupt>:
     44e:	d8 cd       	rjmp	.-1104   	; 0x0 <__vectors>

00000450 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     450:	84 b7       	in	r24, 0x34	; 52
     452:	87 7f       	andi	r24, 0xF7	; 247
     454:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     456:	88 e1       	ldi	r24, 0x18	; 24
     458:	0f b6       	in	r0, 0x3f	; 63
     45a:	f8 94       	cli
     45c:	80 93 60 00 	sts	0x0060, r24
     460:	10 92 60 00 	sts	0x0060, r1
     464:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     466:	90 e0       	ldi	r25, 0x00	; 0
     468:	80 e8       	ldi	r24, 0x80	; 128
     46a:	0f b6       	in	r0, 0x3f	; 63
     46c:	f8 94       	cli
     46e:	80 93 61 00 	sts	0x0061, r24
     472:	90 93 61 00 	sts	0x0061, r25
     476:	0f be       	out	0x3f, r0	; 63
			 *                         \c SPI_SCK_*, \c SPI_SAMPLE_*, \c SPI_ORDER_* and \c SPI_MODE_* masks.
			 */
			static inline void SPI_Init(const uint8_t SPIOptions)
			{
				/* Prevent high rise times on PB.0 (/SS) from forcing a change to SPI slave mode */
				DDRB  |= (1 << 0);
     478:	20 9a       	sbi	0x04, 0	; 4
				PORTB |= (1 << 0);
     47a:	28 9a       	sbi	0x05, 0	; 5

				DDRB  |=  ((1 << 1) | (1 << 2));
     47c:	84 b1       	in	r24, 0x04	; 4
     47e:	86 60       	ori	r24, 0x06	; 6
     480:	84 b9       	out	0x04, r24	; 4
				DDRB  &= ~(1 << 3);
     482:	23 98       	cbi	0x04, 3	; 4
				PORTB |=  (1 << 3);
     484:	2b 9a       	sbi	0x05, 3	; 5

				if (SPIOptions & SPI_USE_DOUBLESPEED)
				  SPSR |= (1 << SPI2X);
     486:	8d b5       	in	r24, 0x2d	; 45
     488:	81 60       	ori	r24, 0x01	; 1
     48a:	8d bd       	out	0x2d, r24	; 45
				else
				  SPSR &= ~(1 << SPI2X);

				/* Switch /SS to input mode after configuration to allow for forced mode changes */
				DDRB &= ~(1 << 0);
     48c:	20 98       	cbi	0x04, 0	; 4

				SPCR  = ((1 << SPE) | SPIOptions);
     48e:	8c e5       	ldi	r24, 0x5C	; 92
     490:	8c bd       	out	0x2c, r24	; 44
			/** Initializes the dataflash driver so that commands and data may be sent to an attached dataflash IC.
			 *  The microcontroller's SPI driver MUST be initialized before any of the dataflash commands are used.
			 */
			static inline void Dataflash_Init(void)
			{
				DATAFLASH_CHIPCS_DDR  |= DATAFLASH_CHIPCS_MASK;
     492:	8d b1       	in	r24, 0x0d	; 13
     494:	83 60       	ori	r24, 0x03	; 3
     496:	8d b9       	out	0x0d, r24	; 13
				DATAFLASH_CHIPCS_PORT |= DATAFLASH_CHIPCS_MASK;
     498:	8e b1       	in	r24, 0x0e	; 14
     49a:	83 60       	ori	r24, 0x03	; 3
     49c:	8e b9       	out	0x0e, r24	; 14

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     49e:	8a b1       	in	r24, 0x0a	; 10
     4a0:	80 6f       	ori	r24, 0xF0	; 240
     4a2:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4a4:	8b b1       	in	r24, 0x0b	; 11
     4a6:	8f 70       	andi	r24, 0x0F	; 15
     4a8:	8b b9       	out	0x0b, r24	; 11

	/* Hardware Initialization */
	SPI_Init(SPI_SPEED_FCPU_DIV_2 | SPI_SCK_LEAD_FALLING | SPI_SAMPLE_TRAILING | SPI_MODE_MASTER);
	Dataflash_Init();
	LEDs_Init();
	USB_Init(USB_MODE_UID);
     4aa:	83 e0       	ldi	r24, 0x03	; 3
     4ac:	0c 94 f9 2c 	jmp	0x59f2	; 0x59f2 <USB_Init>

000004b0 <main>:
}
     4b0:	cf df       	rcall	.-98     	; 0x450 <SetupHardware>
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     4b2:	8b b1       	in	r24, 0x0b	; 11
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     4b4:	8f 70       	andi	r24, 0x0F	; 15
     4b6:	80 61       	ori	r24, 0x10	; 16
     4b8:	8b b9       	out	0x0b, r24	; 11
     4ba:	78 94       	sei
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     4bc:	80 91 fb 03 	lds	r24, 0x03FB
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	GlobalInterruptEnable();

	for (;;)
	{
		if (USB_CurrentMode == USB_MODE_Host)
     4c0:	82 30       	cpi	r24, 0x02	; 2
     4c2:	11 f4       	brne	.+4      	; 0x4c8 <main+0x18>
     4c4:	7d d0       	rcall	.+250    	; 0x5c0 <USBHostMode_USBTask>
		  USBHostMode_USBTask();
     4c6:	01 c0       	rjmp	.+2      	; 0x4ca <main+0x1a>
     4c8:	34 d0       	rcall	.+104    	; 0x532 <USBDeviceMode_USBTask>
     4ca:	0e 94 29 32 	call	0x6452	; 0x6452 <USB_USBTask>
		else
		  USBDeviceMode_USBTask();
     4ce:	f6 cf       	rjmp	.-20     	; 0x4bc <main+0xc>

000004d0 <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     4d0:	92 30       	cpi	r25, 0x02	; 2
     4d2:	29 f0       	breq	.+10     	; 0x4de <CALLBACK_USB_GetDescriptor+0xe>
     4d4:	93 30       	cpi	r25, 0x03	; 3
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <CALLBACK_USB_GetDescriptor+0x18>
     4d8:	91 30       	cpi	r25, 0x01	; 1
     4da:	e9 f4       	brne	.+58     	; 0x516 <CALLBACK_USB_GetDescriptor+0x46>
     4dc:	17 c0       	rjmp	.+46     	; 0x50c <CALLBACK_USB_GetDescriptor+0x3c>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     4de:	8d e5       	ldi	r24, 0x5D	; 93
     4e0:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     4e2:	e6 ed       	ldi	r30, 0xD6	; 214
     4e4:	f0 e0       	ldi	r31, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     4e6:	1b c0       	rjmp	.+54     	; 0x51e <CALLBACK_USB_GetDescriptor+0x4e>
		case DTYPE_String:
			switch (DescriptorNumber)
     4e8:	81 30       	cpi	r24, 0x01	; 1
     4ea:	41 f0       	breq	.+16     	; 0x4fc <CALLBACK_USB_GetDescriptor+0x2c>
     4ec:	81 30       	cpi	r24, 0x01	; 1
     4ee:	18 f0       	brcs	.+6      	; 0x4f6 <CALLBACK_USB_GetDescriptor+0x26>
     4f0:	82 30       	cpi	r24, 0x02	; 2
     4f2:	89 f4       	brne	.+34     	; 0x516 <CALLBACK_USB_GetDescriptor+0x46>
     4f4:	06 c0       	rjmp	.+12     	; 0x502 <CALLBACK_USB_GetDescriptor+0x32>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     4f6:	e2 ed       	ldi	r30, 0xD2	; 210
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	05 c0       	rjmp	.+10     	; 0x506 <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     4fc:	e8 eb       	ldi	r30, 0xB8	; 184
     4fe:	f0 e0       	ldi	r31, 0x00	; 0
     500:	02 c0       	rjmp	.+4      	; 0x506 <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     502:	e8 e9       	ldi	r30, 0x98	; 152
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	84 91       	lpm	r24, Z
     508:	90 e0       	ldi	r25, 0x00	; 0
					break;
     50a:	09 c0       	rjmp	.+18     	; 0x51e <CALLBACK_USB_GetDescriptor+0x4e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     50c:	82 e1       	ldi	r24, 0x12	; 18
     50e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     510:	e3 e3       	ldi	r30, 0x33	; 51
     512:	f1 e0       	ldi	r31, 0x01	; 1
     514:	04 c0       	rjmp	.+8      	; 0x51e <CALLBACK_USB_GetDescriptor+0x4e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     516:	80 e0       	ldi	r24, 0x00	; 0
     518:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     51a:	e0 e0       	ldi	r30, 0x00	; 0
     51c:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     51e:	da 01       	movw	r26, r20
     520:	11 96       	adiw	r26, 0x01	; 1
     522:	fc 93       	st	X, r31
     524:	ee 93       	st	-X, r30
	return Size;
}
     526:	08 95       	ret

00000528 <LEDs_SetAllLEDs>:
     528:	9b b1       	in	r25, 0x0b	; 11
     52a:	9f 70       	andi	r25, 0x0F	; 15
     52c:	98 2b       	or	r25, r24
     52e:	9b b9       	out	0x0b, r25	; 11
			}
     530:	08 95       	ret

00000532 <USBDeviceMode_USBTask>:
/** USB device mode management task. This function manages the Mass Storage Device class driver when the device is
 *  initialized in USB device mode.
 */
void USBDeviceMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Device)
     532:	80 91 fb 03 	lds	r24, 0x03FB
     536:	81 30       	cpi	r24, 0x01	; 1
     538:	49 f4       	brne	.+18     	; 0x54c <USBDeviceMode_USBTask+0x1a>
	  return;

	uIPManagement_ManageNetwork();
     53a:	f3 d5       	rcall	.+3046   	; 0x1122 <uIPManagement_ManageNetwork>
     53c:	8c e4       	ldi	r24, 0x4C	; 76

	RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface_Device);
     53e:	91 e0       	ldi	r25, 0x01	; 1
     540:	0e 94 d8 36 	call	0x6db0	; 0x6db0 <RNDIS_Device_USBTask>
     544:	80 e0       	ldi	r24, 0x00	; 0
	MS_Device_USBTask(&Disk_MS_Interface);
     546:	91 e0       	ldi	r25, 0x01	; 1
     548:	0c 94 b5 32 	jmp	0x656a	; 0x656a <MS_Device_USBTask>
     54c:	08 95       	ret

0000054e <EVENT_USB_Device_Connect>:
     54e:	80 e3       	ldi	r24, 0x30	; 48
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     550:	eb df       	rcall	.-42     	; 0x528 <LEDs_SetAllLEDs>
     552:	8a c5       	rjmp	.+2836   	; 0x1068 <uIPManagement_Init>

00000554 <EVENT_USB_Device_Disconnect>:

	uIPManagement_Init();
     554:	80 e1       	ldi	r24, 0x10	; 16
     556:	e8 cf       	rjmp	.-48     	; 0x528 <LEDs_SetAllLEDs>

00000558 <EVENT_USB_Device_ConfigurationChanged>:
}
     558:	cf 93       	push	r28

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     55a:	8c e4       	ldi	r24, 0x4C	; 76
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     55c:	91 e0       	ldi	r25, 0x01	; 1
     55e:	0e 94 b1 36 	call	0x6d62	; 0x6d62 <RNDIS_Device_ConfigureEndpoints>
     562:	c8 2f       	mov	r28, r24
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     564:	80 e0       	ldi	r24, 0x00	; 0
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	0e 94 97 32 	call	0x652e	; 0x652e <MS_Device_ConfigureEndpoints>
     56c:	28 2f       	mov	r18, r24
     56e:	30 e0       	ldi	r19, 0x00	; 0
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     570:	8c 2f       	mov	r24, r28
     572:	90 e0       	ldi	r25, 0x00	; 0
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     574:	28 23       	and	r18, r24
     576:	39 23       	and	r19, r25

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     578:	21 15       	cp	r18, r1
     57a:	31 05       	cpc	r19, r1
     57c:	11 f0       	breq	.+4      	; 0x582 <EVENT_USB_Device_ConfigurationChanged+0x2a>
     57e:	80 e2       	ldi	r24, 0x20	; 32
     580:	01 c0       	rjmp	.+2      	; 0x584 <EVENT_USB_Device_ConfigurationChanged+0x2c>
     582:	80 e9       	ldi	r24, 0x90	; 144
     584:	d1 df       	rcall	.-94     	; 0x528 <LEDs_SetAllLEDs>
     586:	cf 91       	pop	r28
}
     588:	08 95       	ret

0000058a <EVENT_USB_Device_ControlRequest>:
     58a:	8c e4       	ldi	r24, 0x4C	; 76

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface_Device);
     58c:	91 e0       	ldi	r25, 0x01	; 1
     58e:	0e 94 dc 33 	call	0x67b8	; 0x67b8 <RNDIS_Device_ProcessControlRequest>
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
     592:	80 e0       	ldi	r24, 0x00	; 0
     594:	91 e0       	ldi	r25, 0x01	; 1
     596:	0c 94 58 32 	jmp	0x64b0	; 0x64b0 <MS_Device_ProcessControlRequest>

0000059a <CALLBACK_MS_Device_SCSICommandReceived>:
}
     59a:	cf 93       	push	r28
/** Mass Storage class driver callback function the reception of SCSI commands from the host, which must be processed.
 *
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface configuration structure being referenced
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     59c:	df 93       	push	r29
     59e:	ec 01       	movw	r28, r24
	bool CommandSuccess;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     5a0:	80 ed       	ldi	r24, 0xD0	; 208
     5a2:	c2 df       	rcall	.-124    	; 0x528 <LEDs_SetAllLEDs>
     5a4:	ce 01       	movw	r24, r28
	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
     5a6:	d0 d0       	rcall	.+416    	; 0x748 <SCSI_DecodeSCSICommand>
     5a8:	c8 2f       	mov	r28, r24
     5aa:	80 e2       	ldi	r24, 0x20	; 32
     5ac:	bd df       	rcall	.-134    	; 0x528 <LEDs_SetAllLEDs>
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
     5ae:	8c 2f       	mov	r24, r28
     5b0:	df 91       	pop	r29
     5b2:	cf 91       	pop	r28

	return CommandSuccess;
}
     5b4:	08 95       	ret

000005b6 <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     5b6:	9b b1       	in	r25, 0x0b	; 11
     5b8:	9f 70       	andi	r25, 0x0F	; 15
     5ba:	98 2b       	or	r25, r24
     5bc:	9b b9       	out	0x0b, r25	; 11
			}
     5be:	08 95       	ret

000005c0 <USBHostMode_USBTask>:
/** USB host mode management task. This function manages the RNDIS Host class driver and uIP stack when the device is
 *  initialized in USB host mode.
 */
void USBHostMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Host)
     5c0:	80 91 fb 03 	lds	r24, 0x03FB
     5c4:	82 30       	cpi	r24, 0x02	; 2
     5c6:	09 f4       	brne	.+2      	; 0x5ca <USBHostMode_USBTask+0xa>
	  return;

	uIPManagement_ManageNetwork();
     5c8:	ac c5       	rjmp	.+2904   	; 0x1122 <uIPManagement_ManageNetwork>
     5ca:	08 95       	ret

000005cc <EVENT_USB_Host_DeviceAttached>:
     5cc:	80 e3       	ldi	r24, 0x30	; 48
/** Event handler for the USB_DeviceAttached event. This indicates that a device has been attached to the host, and
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Host_DeviceAttached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     5ce:	f3 cf       	rjmp	.-26     	; 0x5b6 <LEDs_SetAllLEDs>

000005d0 <EVENT_USB_Host_DeviceUnattached>:
     5d0:	80 e1       	ldi	r24, 0x10	; 16
}
     5d2:	f1 cf       	rjmp	.-30     	; 0x5b6 <LEDs_SetAllLEDs>

000005d4 <EVENT_USB_Host_DeviceEnumerationComplete>:
/** Event handler for the USB_DeviceUnattached event. This indicates that a device has been removed from the host, and
 *  stops the library USB task management process.
 */
void EVENT_USB_Host_DeviceUnattached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     5d4:	0f 93       	push	r16
}
     5d6:	1f 93       	push	r17

/** Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully
 *  enumerated by the host and is now ready to be used by the application.
 */
void EVENT_USB_Host_DeviceEnumerationComplete(void)
{
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	c6 50       	subi	r28, 0x06	; 6
     5e2:	d2 40       	sbci	r29, 0x02	; 2
     5e4:	0f b6       	in	r0, 0x3f	; 63
     5e6:	f8 94       	cli
     5e8:	de bf       	out	0x3e, r29	; 62
     5ea:	0f be       	out	0x3f, r0	; 63
     5ec:	cd bf       	out	0x3d, r28	; 61
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     5ee:	80 e3       	ldi	r24, 0x30	; 48
     5f0:	e2 df       	rcall	.-60     	; 0x5b6 <LEDs_SetAllLEDs>
     5f2:	81 e0       	ldi	r24, 0x01	; 1

	uint16_t ConfigDescriptorSize;
	uint8_t  ConfigDescriptorData[512];

	if (USB_Host_GetDeviceConfigDescriptor(1, &ConfigDescriptorSize, ConfigDescriptorData,
     5f4:	be 01       	movw	r22, r28
     5f6:	6f 5f       	subi	r22, 0xFF	; 255
     5f8:	7f 4f       	sbci	r23, 0xFF	; 255
     5fa:	ae 01       	movw	r20, r28
     5fc:	49 5f       	subi	r20, 0xF9	; 249
     5fe:	5f 4f       	sbci	r21, 0xFF	; 255
     600:	20 e0       	ldi	r18, 0x00	; 0
     602:	32 e0       	ldi	r19, 0x02	; 2
     604:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <USB_Host_GetDeviceConfigDescriptor>
     608:	88 23       	and	r24, r24
     60a:	81 f4       	brne	.+32     	; 0x62c <EVENT_USB_Host_DeviceEnumerationComplete+0x58>
     60c:	69 81       	ldd	r22, Y+1	; 0x01
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (RNDIS_Host_ConfigurePipes(&Ethernet_RNDIS_Interface_Host,
     60e:	7a 81       	ldd	r23, Y+2	; 0x02
     610:	8a ee       	ldi	r24, 0xEA	; 234
     612:	91 e0       	ldi	r25, 0x01	; 1
     614:	ae 01       	movw	r20, r28
     616:	49 5f       	subi	r20, 0xF9	; 249
     618:	5f 4f       	sbci	r21, 0xFF	; 255
     61a:	0e 94 69 38 	call	0x70d2	; 0x70d2 <RNDIS_Host_ConfigurePipes>
     61e:	88 23       	and	r24, r24
     620:	29 f4       	brne	.+10     	; 0x62c <EVENT_USB_Host_DeviceEnumerationComplete+0x58>
     622:	81 e0       	ldi	r24, 0x01	; 1
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (USB_Host_SetDeviceConfiguration(1) != HOST_SENDCONTROL_Successful)
     624:	0e 94 05 32 	call	0x640a	; 0x640a <USB_Host_SetDeviceConfiguration>
     628:	88 23       	and	r24, r24
     62a:	11 f0       	breq	.+4      	; 0x630 <EVENT_USB_Host_DeviceEnumerationComplete+0x5c>
     62c:	80 e9       	ldi	r24, 0x90	; 144
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     62e:	33 c0       	rjmp	.+102    	; 0x696 <EVENT_USB_Host_DeviceEnumerationComplete+0xc2>
     630:	8a ee       	ldi	r24, 0xEA	; 234
		return;
	}

	if (RNDIS_Host_InitializeDevice(&Ethernet_RNDIS_Interface_Host) != HOST_SENDCONTROL_Successful)
     632:	91 e0       	ldi	r25, 0x01	; 1
     634:	0e 94 2d 39 	call	0x725a	; 0x725a <RNDIS_Host_InitializeDevice>
     638:	88 23       	and	r24, r24
     63a:	29 f5       	brne	.+74     	; 0x686 <EVENT_USB_Host_DeviceEnumerationComplete+0xb2>
     63c:	89 e0       	ldi	r24, 0x09	; 9
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	uint32_t PacketFilter = (REMOTE_NDIS_PACKET_DIRECTED | REMOTE_NDIS_PACKET_BROADCAST);
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	a0 e0       	ldi	r26, 0x00	; 0
     642:	b0 e0       	ldi	r27, 0x00	; 0
     644:	8b 83       	std	Y+3, r24	; 0x03
     646:	9c 83       	std	Y+4, r25	; 0x04
     648:	ad 83       	std	Y+5, r26	; 0x05
     64a:	be 83       	std	Y+6, r27	; 0x06
     64c:	8a ee       	ldi	r24, 0xEA	; 234
	if (RNDIS_Host_SetRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_GEN_CURRENT_PACKET_FILTER,
     64e:	91 e0       	ldi	r25, 0x01	; 1
     650:	4e e0       	ldi	r20, 0x0E	; 14
     652:	51 e0       	ldi	r21, 0x01	; 1
     654:	61 e0       	ldi	r22, 0x01	; 1
     656:	70 e0       	ldi	r23, 0x00	; 0
     658:	9e 01       	movw	r18, r28
     65a:	2d 5f       	subi	r18, 0xFD	; 253
     65c:	3f 4f       	sbci	r19, 0xFF	; 255
     65e:	04 e0       	ldi	r16, 0x04	; 4
     660:	10 e0       	ldi	r17, 0x00	; 0
     662:	0e 94 a3 39 	call	0x7346	; 0x7346 <RNDIS_Host_SetRNDISProperty>
     666:	88 23       	and	r24, r24
     668:	71 f4       	brne	.+28     	; 0x686 <EVENT_USB_Host_DeviceEnumerationComplete+0xb2>
     66a:	8a ee       	ldi	r24, 0xEA	; 234
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	if (RNDIS_Host_QueryRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_802_3_CURRENT_ADDRESS,
     66c:	91 e0       	ldi	r25, 0x01	; 1
     66e:	42 e0       	ldi	r20, 0x02	; 2
     670:	51 e0       	ldi	r21, 0x01	; 1
     672:	61 e0       	ldi	r22, 0x01	; 1
     674:	71 e0       	ldi	r23, 0x01	; 1
     676:	2e ef       	ldi	r18, 0xFE	; 254
     678:	33 e0       	ldi	r19, 0x03	; 3
     67a:	06 e0       	ldi	r16, 0x06	; 6
     67c:	10 e0       	ldi	r17, 0x00	; 0
     67e:	0e 94 4e 3a 	call	0x749c	; 0x749c <RNDIS_Host_QueryRNDISProperty>
     682:	88 23       	and	r24, r24
     684:	31 f0       	breq	.+12     	; 0x692 <EVENT_USB_Host_DeviceEnumerationComplete+0xbe>
     686:	80 e9       	ldi	r24, 0x90	; 144
	                                  &MACAddress, sizeof(MACAddress)) != HOST_SENDCONTROL_Successful)
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     688:	96 df       	rcall	.-212    	; 0x5b6 <LEDs_SetAllLEDs>
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	0e 94 05 32 	call	0x640a	; 0x640a <USB_Host_SetDeviceConfiguration>
		USB_Host_SetDeviceConfiguration(0);
     690:	03 c0       	rjmp	.+6      	; 0x698 <EVENT_USB_Host_DeviceEnumerationComplete+0xc4>
     692:	ea d4       	rcall	.+2516   	; 0x1068 <uIPManagement_Init>
		return;
     694:	80 e2       	ldi	r24, 0x20	; 32
	}

	/* Initialize uIP stack */
	uIPManagement_Init();
     696:	8f df       	rcall	.-226    	; 0x5b6 <LEDs_SetAllLEDs>
     698:	ca 5f       	subi	r28, 0xFA	; 250

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
     69a:	dd 4f       	sbci	r29, 0xFD	; 253
     69c:	0f b6       	in	r0, 0x3f	; 63
     69e:	f8 94       	cli
}
     6a0:	de bf       	out	0x3e, r29	; 62
     6a2:	0f be       	out	0x3f, r0	; 63
     6a4:	cd bf       	out	0x3d, r28	; 61
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	1f 91       	pop	r17
     6ac:	0f 91       	pop	r16
     6ae:	08 95       	ret

000006b0 <EVENT_USB_Host_HostError>:
     6b0:	0e 94 52 2c 	call	0x58a4	; 0x58a4 <USB_Disable>
     6b4:	80 e9       	ldi	r24, 0x90	; 144
     6b6:	7f df       	rcall	.-258    	; 0x5b6 <LEDs_SetAllLEDs>
/** Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */
void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
{
	USB_Disable();

	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     6b8:	ff cf       	rjmp	.-2      	; 0x6b8 <EVENT_USB_Host_HostError+0x8>

000006ba <EVENT_USB_Host_DeviceEnumerationFailed>:
     6ba:	80 e9       	ldi	r24, 0x90	; 144
/** Event handler for the USB_DeviceEnumerationFailed event. This indicates that a problem occurred while
 *  enumerating an attached USB device.
 */
void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode, const uint8_t SubErrorCode)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     6bc:	7c cf       	rjmp	.-264    	; 0x5b6 <LEDs_SetAllLEDs>

000006be <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
     6be:	0f 93       	push	r16
     6c0:	1f 93       	push	r17
     6c2:	cf 93       	push	r28
     6c4:	df 93       	push	r29
     6c6:	ec 01       	movw	r28, r24
     6c8:	86 2f       	mov	r24, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
     6ca:	48 a1       	lds	r20, 0x48
     6cc:	5f 8d       	ldd	r21, Y+31	; 0x1f
     6ce:	6e 8d       	ldd	r22, Y+30	; 0x1e
     6d0:	7d 8d       	ldd	r23, Y+29	; 0x1d

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     6d2:	0b a1       	lds	r16, 0x4b
     6d4:	1a a1       	lds	r17, 0x4a

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)
     6d6:	40 30       	cpi	r20, 0x00	; 0
     6d8:	90 e8       	ldi	r25, 0x80	; 128
     6da:	59 07       	cpc	r21, r25
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	69 07       	cpc	r22, r25
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	79 07       	cpc	r23, r25
     6e4:	68 f0       	brcs	.+26     	; 0x700 <SCSI_Command_ReadWrite_10+0x42>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     6e6:	80 91 0c 02 	lds	r24, 0x020C
     6ea:	80 7f       	andi	r24, 0xF0	; 240
     6ec:	85 60       	ori	r24, 0x05	; 5
     6ee:	80 93 0c 02 	sts	0x020C, r24
     6f2:	81 e2       	ldi	r24, 0x21	; 33
     6f4:	80 93 16 02 	sts	0x0216, r24
     6f8:	10 92 17 02 	sts	0x0217, r1
		               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
     6fc:	80 e0       	ldi	r24, 0x00	; 0
     6fe:	1f c0       	rjmp	.+62     	; 0x73e <SCSI_Command_ReadWrite_10+0x80>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
     700:	88 23       	and	r24, r24
     702:	21 f0       	breq	.+8      	; 0x70c <SCSI_Command_ReadWrite_10+0x4e>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     704:	ce 01       	movw	r24, r28
     706:	98 01       	movw	r18, r16
     708:	dd d2       	rcall	.+1466   	; 0xcc4 <DataflashManager_ReadBlocks>
     70a:	03 c0       	rjmp	.+6      	; 0x712 <SCSI_Command_ReadWrite_10+0x54>
     70c:	ce 01       	movw	r24, r28
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     70e:	98 01       	movw	r18, r16
     710:	8c d1       	rcall	.+792    	; 0xa2a <DataflashManager_WriteBlocks>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
     716:	89 e0       	ldi	r24, 0x09	; 9
     718:	00 0f       	add	r16, r16
     71a:	11 1f       	adc	r17, r17
     71c:	22 1f       	adc	r18, r18
     71e:	33 1f       	adc	r19, r19
     720:	8a 95       	dec	r24
     722:	d1 f7       	brne	.-12     	; 0x718 <SCSI_Command_ReadWrite_10+0x5a>
     724:	8c 89       	ldd	r24, Y+20	; 0x14
     726:	9d 89       	ldd	r25, Y+21	; 0x15
     728:	ae 89       	ldd	r26, Y+22	; 0x16
     72a:	bf 89       	ldd	r27, Y+23	; 0x17
     72c:	80 1b       	sub	r24, r16
     72e:	91 0b       	sbc	r25, r17
     730:	a2 0b       	sbc	r26, r18
     732:	b3 0b       	sbc	r27, r19
     734:	8c 8b       	std	Y+20, r24	; 0x14
     736:	9d 8b       	std	Y+21, r25	; 0x15
     738:	ae 8b       	std	Y+22, r26	; 0x16
     73a:	bf 8b       	std	Y+23, r27	; 0x17
     73c:	81 e0       	ldi	r24, 0x01	; 1
     73e:	df 91       	pop	r29

	return true;
     740:	cf 91       	pop	r28
}
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	08 95       	ret

00000748 <SCSI_DecodeSCSICommand>:
     748:	cf 92       	push	r12
     74a:	df 92       	push	r13
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     74c:	ef 92       	push	r14
     74e:	ff 92       	push	r15
     750:	0f 93       	push	r16
     752:	1f 93       	push	r17
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	cd b7       	in	r28, 0x3d	; 61
     75a:	de b7       	in	r29, 0x3e	; 62
     75c:	28 97       	sbiw	r28, 0x08	; 8
     75e:	0f b6       	in	r0, 0x3f	; 63
     760:	f8 94       	cli
     762:	de bf       	out	0x3e, r29	; 62
     764:	0f be       	out	0x3f, r0	; 63
     766:	cd bf       	out	0x3d, r28	; 61
     768:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     76a:	fc 01       	movw	r30, r24
     76c:	83 8d       	ldd	r24, Z+27	; 0x1b
     76e:	8d 31       	cpi	r24, 0x1D	; 29
     770:	09 f4       	brne	.+2      	; 0x774 <SCSI_DecodeSCSICommand+0x2c>
     772:	af c0       	rjmp	.+350    	; 0x8d2 <SCSI_DecodeSCSICommand+0x18a>
     774:	8e 31       	cpi	r24, 0x1E	; 30
     776:	78 f4       	brcc	.+30     	; 0x796 <SCSI_DecodeSCSICommand+0x4e>
     778:	83 30       	cpi	r24, 0x03	; 3
     77a:	09 f4       	brne	.+2      	; 0x77e <SCSI_DecodeSCSICommand+0x36>
     77c:	55 c0       	rjmp	.+170    	; 0x828 <SCSI_DecodeSCSICommand+0xe0>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	20 f4       	brcc	.+8      	; 0x78a <SCSI_DecodeSCSICommand+0x42>
     782:	88 23       	and	r24, r24
     784:	09 f4       	brne	.+2      	; 0x788 <SCSI_DecodeSCSICommand+0x40>
     786:	e2 c0       	rjmp	.+452    	; 0x94c <SCSI_DecodeSCSICommand+0x204>
     788:	e7 c0       	rjmp	.+462    	; 0x958 <SCSI_DecodeSCSICommand+0x210>
     78a:	82 31       	cpi	r24, 0x12	; 18
     78c:	b9 f0       	breq	.+46     	; 0x7bc <SCSI_DecodeSCSICommand+0x74>
     78e:	8a 31       	cpi	r24, 0x1A	; 26
     790:	09 f0       	breq	.+2      	; 0x794 <SCSI_DecodeSCSICommand+0x4c>
     792:	e2 c0       	rjmp	.+452    	; 0x958 <SCSI_DecodeSCSICommand+0x210>
     794:	c1 c0       	rjmp	.+386    	; 0x918 <SCSI_DecodeSCSICommand+0x1d0>
     796:	88 32       	cpi	r24, 0x28	; 40
     798:	09 f4       	brne	.+2      	; 0x79c <SCSI_DecodeSCSICommand+0x54>
     79a:	b8 c0       	rjmp	.+368    	; 0x90c <SCSI_DecodeSCSICommand+0x1c4>
     79c:	89 32       	cpi	r24, 0x29	; 41
     79e:	38 f4       	brcc	.+14     	; 0x7ae <SCSI_DecodeSCSICommand+0x66>
     7a0:	8e 31       	cpi	r24, 0x1E	; 30
     7a2:	09 f4       	brne	.+2      	; 0x7a6 <SCSI_DecodeSCSICommand+0x5e>
     7a4:	d3 c0       	rjmp	.+422    	; 0x94c <SCSI_DecodeSCSICommand+0x204>
     7a6:	85 32       	cpi	r24, 0x25	; 37
     7a8:	09 f0       	breq	.+2      	; 0x7ac <SCSI_DecodeSCSICommand+0x64>
     7aa:	d6 c0       	rjmp	.+428    	; 0x958 <SCSI_DecodeSCSICommand+0x210>
     7ac:	64 c0       	rjmp	.+200    	; 0x876 <SCSI_DecodeSCSICommand+0x12e>
     7ae:	8a 32       	cpi	r24, 0x2A	; 42
     7b0:	09 f4       	brne	.+2      	; 0x7b4 <SCSI_DecodeSCSICommand+0x6c>
     7b2:	a9 c0       	rjmp	.+338    	; 0x906 <SCSI_DecodeSCSICommand+0x1be>
     7b4:	8f 32       	cpi	r24, 0x2F	; 47
     7b6:	09 f0       	breq	.+2      	; 0x7ba <SCSI_DecodeSCSICommand+0x72>
     7b8:	cf c0       	rjmp	.+414    	; 0x958 <SCSI_DecodeSCSICommand+0x210>
     7ba:	c8 c0       	rjmp	.+400    	; 0x94c <SCSI_DecodeSCSICommand+0x204>
     7bc:	f8 01       	movw	r30, r16
     7be:	c7 8c       	ldd	r12, Z+31	; 0x1f
     7c0:	d6 8c       	ldd	r13, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
     7c2:	84 8d       	ldd	r24, Z+28	; 0x1c
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	83 70       	andi	r24, 0x03	; 3
     7c8:	90 70       	andi	r25, 0x00	; 0
     7ca:	00 97       	sbiw	r24, 0x00	; 0
     7cc:	09 f0       	breq	.+2      	; 0x7d0 <SCSI_DecodeSCSICommand+0x88>
     7ce:	85 c0       	rjmp	.+266    	; 0x8da <SCSI_DecodeSCSICommand+0x192>
     7d0:	85 8d       	ldd	r24, Z+29	; 0x1d
     7d2:	88 23       	and	r24, r24
     7d4:	09 f0       	breq	.+2      	; 0x7d8 <SCSI_DecodeSCSICommand+0x90>
     7d6:	81 c0       	rjmp	.+258    	; 0x8da <SCSI_DecodeSCSICommand+0x192>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
     7d8:	76 01       	movw	r14, r12
     7da:	f5 e2       	ldi	r31, 0x25	; 37
     7dc:	cf 16       	cp	r12, r31
     7de:	d1 04       	cpc	r13, r1
     7e0:	18 f0       	brcs	.+6      	; 0x7e8 <SCSI_DecodeSCSICommand+0xa0>
     7e2:	24 e2       	ldi	r18, 0x24	; 36
     7e4:	e2 2e       	mov	r14, r18
     7e6:	f1 2c       	mov	r15, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
     7e8:	8c e1       	ldi	r24, 0x1C	; 28
     7ea:	92 e0       	ldi	r25, 0x02	; 2
     7ec:	b7 01       	movw	r22, r14
     7ee:	40 e0       	ldi	r20, 0x00	; 0
     7f0:	50 e0       	ldi	r21, 0x00	; 0
     7f2:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     7f6:	c6 01       	movw	r24, r12
     7f8:	8e 19       	sub	r24, r14
     7fa:	9f 09       	sbc	r25, r15
     7fc:	60 e0       	ldi	r22, 0x00	; 0
     7fe:	70 e0       	ldi	r23, 0x00	; 0
     800:	0e 94 a9 25 	call	0x4b52	; 0x4b52 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     804:	80 91 e8 00 	lds	r24, 0x00E8
     808:	8e 77       	andi	r24, 0x7E	; 126
     80a:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     80e:	a7 01       	movw	r20, r14
     810:	60 e0       	ldi	r22, 0x00	; 0
     812:	70 e0       	ldi	r23, 0x00	; 0
     814:	f8 01       	movw	r30, r16
     816:	84 89       	ldd	r24, Z+20	; 0x14
     818:	95 89       	ldd	r25, Z+21	; 0x15
     81a:	a6 89       	ldd	r26, Z+22	; 0x16
     81c:	b7 89       	ldd	r27, Z+23	; 0x17
     81e:	84 1b       	sub	r24, r20
     820:	95 0b       	sbc	r25, r21
     822:	a6 0b       	sbc	r26, r22
     824:	b7 0b       	sbc	r27, r23
     826:	8d c0       	rjmp	.+282    	; 0x942 <SCSI_DecodeSCSICommand+0x1fa>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
     828:	f8 01       	movw	r30, r16
     82a:	c7 8c       	ldd	r12, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
     82c:	ec 2c       	mov	r14, r12
     82e:	f2 e1       	ldi	r31, 0x12	; 18
     830:	fc 15       	cp	r31, r12
     832:	10 f4       	brcc	.+4      	; 0x838 <SCSI_DecodeSCSICommand+0xf0>
     834:	92 e1       	ldi	r25, 0x12	; 18
     836:	e9 2e       	mov	r14, r25

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
     838:	8a e0       	ldi	r24, 0x0A	; 10
     83a:	92 e0       	ldi	r25, 0x02	; 2
     83c:	6e 2d       	mov	r22, r14
     83e:	70 e0       	ldi	r23, 0x00	; 0
     840:	40 e0       	ldi	r20, 0x00	; 0
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     848:	8c 2d       	mov	r24, r12
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	8e 19       	sub	r24, r14
     84e:	91 09       	sbc	r25, r1
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	0e 94 a9 25 	call	0x4b52	; 0x4b52 <Endpoint_Null_Stream>
     858:	80 91 e8 00 	lds	r24, 0x00E8
     85c:	8e 77       	andi	r24, 0x7E	; 126
     85e:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     862:	f8 01       	movw	r30, r16
     864:	84 89       	ldd	r24, Z+20	; 0x14
     866:	95 89       	ldd	r25, Z+21	; 0x15
     868:	a6 89       	ldd	r26, Z+22	; 0x16
     86a:	b7 89       	ldd	r27, Z+23	; 0x17
     86c:	8e 19       	sub	r24, r14
     86e:	91 09       	sbc	r25, r1
     870:	a1 09       	sbc	r26, r1
     872:	b1 09       	sbc	r27, r1
     874:	66 c0       	rjmp	.+204    	; 0x942 <SCSI_DecodeSCSICommand+0x1fa>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
     876:	8f ef       	ldi	r24, 0xFF	; 255
     878:	9f e7       	ldi	r25, 0x7F	; 127
     87a:	a0 e0       	ldi	r26, 0x00	; 0
     87c:	b0 e0       	ldi	r27, 0x00	; 0
     87e:	8d 83       	std	Y+5, r24	; 0x05
     880:	9e 83       	std	Y+6, r25	; 0x06
     882:	af 83       	std	Y+7, r26	; 0x07
     884:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
     886:	80 e0       	ldi	r24, 0x00	; 0
     888:	92 e0       	ldi	r25, 0x02	; 2
     88a:	a0 e0       	ldi	r26, 0x00	; 0
     88c:	b0 e0       	ldi	r27, 0x00	; 0
     88e:	89 83       	std	Y+1, r24	; 0x01
     890:	9a 83       	std	Y+2, r25	; 0x02
     892:	ab 83       	std	Y+3, r26	; 0x03
     894:	bc 83       	std	Y+4, r27	; 0x04

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
     896:	ce 01       	movw	r24, r28
     898:	05 96       	adiw	r24, 0x05	; 5
     89a:	64 e0       	ldi	r22, 0x04	; 4
     89c:	70 e0       	ldi	r23, 0x00	; 0
     89e:	40 e0       	ldi	r20, 0x00	; 0
     8a0:	50 e0       	ldi	r21, 0x00	; 0
     8a2:	0e 94 3d 26 	call	0x4c7a	; 0x4c7a <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
     8a6:	ce 01       	movw	r24, r28
     8a8:	01 96       	adiw	r24, 0x01	; 1
     8aa:	64 e0       	ldi	r22, 0x04	; 4
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	40 e0       	ldi	r20, 0x00	; 0
     8b0:	50 e0       	ldi	r21, 0x00	; 0
     8b2:	0e 94 3d 26 	call	0x4c7a	; 0x4c7a <Endpoint_Write_Stream_BE>
     8b6:	80 91 e8 00 	lds	r24, 0x00E8
     8ba:	8e 77       	andi	r24, 0x7E	; 126
     8bc:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
     8c0:	f8 01       	movw	r30, r16
     8c2:	84 89       	ldd	r24, Z+20	; 0x14
     8c4:	95 89       	ldd	r25, Z+21	; 0x15
     8c6:	a6 89       	ldd	r26, Z+22	; 0x16
     8c8:	b7 89       	ldd	r27, Z+23	; 0x17
     8ca:	08 97       	sbiw	r24, 0x08	; 8
     8cc:	a1 09       	sbc	r26, r1
     8ce:	b1 09       	sbc	r27, r1
     8d0:	38 c0       	rjmp	.+112    	; 0x942 <SCSI_DecodeSCSICommand+0x1fa>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
     8d2:	f8 01       	movw	r30, r16
     8d4:	84 8d       	ldd	r24, Z+28	; 0x1c
     8d6:	82 fd       	sbrc	r24, 2
     8d8:	08 c0       	rjmp	.+16     	; 0x8ea <SCSI_DecodeSCSICommand+0x1a2>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     8da:	80 91 0c 02 	lds	r24, 0x020C
     8de:	80 7f       	andi	r24, 0xF0	; 240
     8e0:	85 60       	ori	r24, 0x05	; 5
     8e2:	80 93 0c 02 	sts	0x020C, r24
     8e6:	84 e2       	ldi	r24, 0x24	; 36
     8e8:	3e c0       	rjmp	.+124    	; 0x966 <SCSI_DecodeSCSICommand+0x21e>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
     8ea:	8e d3       	rcall	.+1820   	; 0x1008 <DataflashManager_CheckDataflashOperation>
     8ec:	88 23       	and	r24, r24
     8ee:	71 f5       	brne	.+92     	; 0x94c <SCSI_DecodeSCSICommand+0x204>
     8f0:	80 91 0c 02 	lds	r24, 0x020C
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
     8f4:	80 7f       	andi	r24, 0xF0	; 240
     8f6:	84 60       	ori	r24, 0x04	; 4
     8f8:	80 93 0c 02 	sts	0x020C, r24
     8fc:	10 92 16 02 	sts	0x0216, r1
     900:	10 92 17 02 	sts	0x0217, r1
     904:	3e c0       	rjmp	.+124    	; 0x982 <SCSI_DecodeSCSICommand+0x23a>
     906:	c8 01       	movw	r24, r16
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
     908:	60 e0       	ldi	r22, 0x00	; 0
     90a:	02 c0       	rjmp	.+4      	; 0x910 <SCSI_DecodeSCSICommand+0x1c8>
     90c:	c8 01       	movw	r24, r16
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
     90e:	61 e0       	ldi	r22, 0x01	; 1
     910:	d6 de       	rcall	.-596    	; 0x6be <SCSI_Command_ReadWrite_10>
     912:	88 23       	and	r24, r24
     914:	b1 f1       	breq	.+108    	; 0x982 <SCSI_DecodeSCSICommand+0x23a>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     916:	2a c0       	rjmp	.+84     	; 0x96c <SCSI_DecodeSCSICommand+0x224>
     918:	10 92 f1 00 	sts	0x00F1, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     91c:	10 92 f1 00 	sts	0x00F1, r1
     920:	10 92 f1 00 	sts	0x00F1, r1
     924:	10 92 f1 00 	sts	0x00F1, r1
     928:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     92c:	8e 77       	andi	r24, 0x7E	; 126
     92e:	80 93 e8 00 	sts	0x00E8, r24
     932:	f8 01       	movw	r30, r16
     934:	84 89       	ldd	r24, Z+20	; 0x14
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
     936:	95 89       	ldd	r25, Z+21	; 0x15
     938:	a6 89       	ldd	r26, Z+22	; 0x16
     93a:	b7 89       	ldd	r27, Z+23	; 0x17
     93c:	04 97       	sbiw	r24, 0x04	; 4
     93e:	a1 09       	sbc	r26, r1
     940:	b1 09       	sbc	r27, r1
     942:	84 8b       	std	Z+20, r24	; 0x14
     944:	95 8b       	std	Z+21, r25	; 0x15
     946:	a6 8b       	std	Z+22, r26	; 0x16
     948:	b7 8b       	std	Z+23, r27	; 0x17
     94a:	10 c0       	rjmp	.+32     	; 0x96c <SCSI_DecodeSCSICommand+0x224>
     94c:	f8 01       	movw	r30, r16
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
     94e:	14 8a       	std	Z+20, r1	; 0x14
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
     950:	15 8a       	std	Z+21, r1	; 0x15
     952:	16 8a       	std	Z+22, r1	; 0x16
     954:	17 8a       	std	Z+23, r1	; 0x17
     956:	0a c0       	rjmp	.+20     	; 0x96c <SCSI_DecodeSCSICommand+0x224>
     958:	80 91 0c 02 	lds	r24, 0x020C
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     95c:	80 7f       	andi	r24, 0xF0	; 240
     95e:	85 60       	ori	r24, 0x05	; 5
     960:	80 93 0c 02 	sts	0x020C, r24
     964:	80 e2       	ldi	r24, 0x20	; 32
     966:	80 93 16 02 	sts	0x0216, r24
     96a:	ca cf       	rjmp	.-108    	; 0x900 <SCSI_DecodeSCSICommand+0x1b8>
     96c:	80 91 0c 02 	lds	r24, 0x020C
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
     970:	80 7f       	andi	r24, 0xF0	; 240
     972:	80 93 0c 02 	sts	0x020C, r24
     976:	10 92 16 02 	sts	0x0216, r1
     97a:	10 92 17 02 	sts	0x0217, r1
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	01 c0       	rjmp	.+2      	; 0x984 <SCSI_DecodeSCSICommand+0x23c>
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
     982:	80 e0       	ldi	r24, 0x00	; 0
     984:	28 96       	adiw	r28, 0x08	; 8
	}

	return false;
     986:	0f b6       	in	r0, 0x3f	; 63
}
     988:	f8 94       	cli
     98a:	de bf       	out	0x3e, r29	; 62
     98c:	0f be       	out	0x3f, r0	; 63
     98e:	cd bf       	out	0x3d, r28	; 61
     990:	df 91       	pop	r29
     992:	cf 91       	pop	r28
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	ff 90       	pop	r15
     99a:	ef 90       	pop	r14
     99c:	df 90       	pop	r13
     99e:	cf 90       	pop	r12
     9a0:	08 95       	ret

000009a2 <Dataflash_ToggleSelectedChipCS>:
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     9a2:	8e b1       	in	r24, 0x0e	; 14
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     9a4:	9e b1       	in	r25, 0x0e	; 14
     9a6:	93 60       	ori	r25, 0x03	; 3
     9a8:	9e b9       	out	0x0e, r25	; 14
     9aa:	9e b1       	in	r25, 0x0e	; 14
     9ac:	8c 6f       	ori	r24, 0xFC	; 252
     9ae:	93 60       	ori	r25, 0x03	; 3
     9b0:	89 23       	and	r24, r25
     9b2:	8e b9       	out	0x0e, r24	; 14
			{
				uint8_t SelectedChipMask = Dataflash_GetSelectedChip();

				Dataflash_DeselectChip();
				Dataflash_SelectChip(SelectedChipMask);
			}
     9b4:	08 95       	ret

000009b6 <Dataflash_WaitWhileBusy>:
			/** Spin-loops while the currently selected dataflash is busy executing a command, such as a main
			 *  memory page program or main memory to buffer transfer.
			 */
			static inline void Dataflash_WaitWhileBusy(void)
			{
				Dataflash_ToggleSelectedChipCS();
     9b6:	f5 df       	rcall	.-22     	; 0x9a2 <Dataflash_ToggleSelectedChipCS>
     9b8:	87 ed       	ldi	r24, 0xD7	; 215
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9ba:	8e bd       	out	0x2e, r24	; 46
     9bc:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     9be:	07 fe       	sbrs	r0, 7
     9c0:	fd cf       	rjmp	.-6      	; 0x9bc <Dataflash_WaitWhileBusy+0x6>
     9c2:	1e bc       	out	0x2e, r1	; 46
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     9c4:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     9c6:	07 fe       	sbrs	r0, 7
     9c8:	fd cf       	rjmp	.-6      	; 0x9c4 <Dataflash_WaitWhileBusy+0xe>
     9ca:	0e b4       	in	r0, 0x2e	; 46
				Dataflash_SendByte(DF_CMD_GETSTATUS);
				while (!(Dataflash_ReceiveByte() & DF_STATUS_READY));
     9cc:	07 fe       	sbrs	r0, 7
     9ce:	f9 cf       	rjmp	.-14     	; 0x9c2 <Dataflash_WaitWhileBusy+0xc>
     9d0:	e8 cf       	rjmp	.-48     	; 0x9a2 <Dataflash_ToggleSelectedChipCS>

000009d2 <Dataflash_SendAddressBytes>:
				Dataflash_ToggleSelectedChipCS();
     9d2:	9c 01       	movw	r18, r24
     9d4:	36 95       	lsr	r19
			}
     9d6:	27 95       	ror	r18
			{
				#if (DATAFLASH_TOTALCHIPS == 2)
					PageAddress >>= 1;
				#endif
				
				Dataflash_SendByte(PageAddress >> 5);
     9d8:	56 e0       	ldi	r21, 0x06	; 6
     9da:	96 95       	lsr	r25
     9dc:	87 95       	ror	r24
     9de:	5a 95       	dec	r21
     9e0:	e1 f7       	brne	.-8      	; 0x9da <Dataflash_SendAddressBytes+0x8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9e2:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     9e4:	0d b4       	in	r0, 0x2d	; 45
     9e6:	07 fe       	sbrs	r0, 7
     9e8:	fd cf       	rjmp	.-6      	; 0x9e4 <Dataflash_SendAddressBytes+0x12>
				Dataflash_SendByte((PageAddress << 3) | (BufferByte >> 8));
     9ea:	22 0f       	add	r18, r18
     9ec:	22 0f       	add	r18, r18
     9ee:	22 0f       	add	r18, r18
     9f0:	27 2b       	or	r18, r23
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9f2:	2e bd       	out	0x2e, r18	; 46
				while (!(SPSR & (1 << SPIF)));
     9f4:	0d b4       	in	r0, 0x2d	; 45
     9f6:	07 fe       	sbrs	r0, 7
     9f8:	fd cf       	rjmp	.-6      	; 0x9f4 <Dataflash_SendAddressBytes+0x22>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9fa:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
     9fc:	0d b4       	in	r0, 0x2d	; 45
     9fe:	07 fe       	sbrs	r0, 7
     a00:	fd cf       	rjmp	.-6      	; 0x9fc <Dataflash_SendAddressBytes+0x2a>
				Dataflash_SendByte(BufferByte);
			}
     a02:	08 95       	ret

00000a04 <Dataflash_SelectChipFromPage>:
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     a04:	2e b1       	in	r18, 0x0e	; 14
     a06:	23 60       	ori	r18, 0x03	; 3
     a08:	2e b9       	out	0x0e, r18	; 14
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
				Dataflash_DeselectChip();

				if (PageAddress >= (DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS))
     a0a:	20 e4       	ldi	r18, 0x40	; 64
     a0c:	80 30       	cpi	r24, 0x00	; 0
     a0e:	92 07       	cpc	r25, r18
     a10:	58 f4       	brcc	.+22     	; 0xa28 <Dataflash_SelectChipFromPage+0x24>
				  return;

				#if (DATAFLASH_TOTALCHIPS == 2)
					if (PageAddress & 0x01)
     a12:	80 ff       	sbrs	r24, 0
     a14:	05 c0       	rjmp	.+10     	; 0xa20 <Dataflash_SelectChipFromPage+0x1c>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     a16:	8e b1       	in	r24, 0x0e	; 14
     a18:	83 60       	ori	r24, 0x03	; 3
     a1a:	8d 7f       	andi	r24, 0xFD	; 253
     a1c:	8e b9       	out	0x0e, r24	; 14
     a1e:	08 95       	ret
     a20:	8e b1       	in	r24, 0x0e	; 14
     a22:	83 60       	ori	r24, 0x03	; 3
     a24:	8e 7f       	andi	r24, 0xFE	; 254
     a26:	8e b9       	out	0x0e, r24	; 14
     a28:	08 95       	ret

00000a2a <DataflashManager_WriteBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
     a2a:	3f 92       	push	r3
     a2c:	4f 92       	push	r4
     a2e:	5f 92       	push	r5
     a30:	6f 92       	push	r6
     a32:	7f 92       	push	r7
     a34:	8f 92       	push	r8
     a36:	9f 92       	push	r9
     a38:	af 92       	push	r10
     a3a:	bf 92       	push	r11
     a3c:	cf 92       	push	r12
     a3e:	df 92       	push	r13
     a40:	ef 92       	push	r14
     a42:	ff 92       	push	r15
     a44:	0f 93       	push	r16
     a46:	1f 93       	push	r17
     a48:	cf 93       	push	r28
     a4a:	df 93       	push	r29
     a4c:	0f 92       	push	r0
     a4e:	cd b7       	in	r28, 0x3d	; 61
     a50:	de b7       	in	r29, 0x3e	; 62
     a52:	2c 01       	movw	r4, r24
     a54:	b2 2e       	mov	r11, r18
     a56:	c3 2e       	mov	r12, r19
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     a58:	db 01       	movw	r26, r22
     a5a:	ca 01       	movw	r24, r20
     a5c:	f9 e0       	ldi	r31, 0x09	; 9
     a5e:	88 0f       	add	r24, r24
     a60:	99 1f       	adc	r25, r25
     a62:	aa 1f       	adc	r26, r26
     a64:	bb 1f       	adc	r27, r27
     a66:	fa 95       	dec	r31
     a68:	d1 f7       	brne	.-12     	; 0xa5e <DataflashManager_WriteBlocks+0x34>
     a6a:	1a e0       	ldi	r17, 0x0A	; 10
     a6c:	b6 95       	lsr	r27
     a6e:	a7 95       	ror	r26
     a70:	97 95       	ror	r25
     a72:	87 95       	ror	r24
     a74:	1a 95       	dec	r17
     a76:	d1 f7       	brne	.-12     	; 0xa6c <DataflashManager_WriteBlocks+0x42>
     a78:	7c 01       	movw	r14, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     a7a:	8a 01       	movw	r16, r20
     a7c:	10 2f       	mov	r17, r16
     a7e:	00 27       	eor	r16, r16
     a80:	11 0f       	add	r17, r17
     a82:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     a84:	bf df       	rcall	.-130    	; 0xa04 <Dataflash_SelectChipFromPage>
     a86:	83 e5       	ldi	r24, 0x53	; 83
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a88:	8e bd       	out	0x2e, r24	; 46
     a8a:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     a8c:	07 fe       	sbrs	r0, 7
     a8e:	fd cf       	rjmp	.-6      	; 0xa8a <DataflashManager_WriteBlocks+0x60>
     a90:	c7 01       	movw	r24, r14

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
     a92:	60 e0       	ldi	r22, 0x00	; 0
     a94:	70 e0       	ldi	r23, 0x00	; 0
     a96:	9d df       	rcall	.-198    	; 0x9d2 <Dataflash_SendAddressBytes>
     a98:	8e df       	rcall	.-228    	; 0x9b6 <Dataflash_WaitWhileBusy>
     a9a:	84 e8       	ldi	r24, 0x84	; 132
	Dataflash_WaitWhileBusy();
     a9c:	8e bd       	out	0x2e, r24	; 46
     a9e:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     aa0:	07 fe       	sbrs	r0, 7
     aa2:	fd cf       	rjmp	.-6      	; 0xa9e <DataflashManager_WriteBlocks+0x74>
				while (!(SPSR & (1 << SPIF)));
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	b8 01       	movw	r22, r16
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
     aaa:	93 df       	rcall	.-218    	; 0x9d2 <Dataflash_SendAddressBytes>
     aac:	0e 94 6d 28 	call	0x50da	; 0x50da <Endpoint_WaitUntilReady>
     ab0:	88 23       	and	r24, r24
     ab2:	09 f0       	breq	.+2      	; 0xab6 <DataflashManager_WriteBlocks+0x8c>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     ab4:	f4 c0       	rjmp	.+488    	; 0xc9e <DataflashManager_WriteBlocks+0x274>
     ab6:	a8 01       	movw	r20, r16
     ab8:	74 e0       	ldi	r23, 0x04	; 4
     aba:	56 95       	lsr	r21
     abc:	47 95       	ror	r20
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     abe:	7a 95       	dec	r23
     ac0:	e1 f7       	brne	.-8      	; 0xaba <DataflashManager_WriteBlocks+0x90>
     ac2:	0b 2d       	mov	r16, r11
     ac4:	1c 2d       	mov	r17, r12
     ac6:	cc 24       	eor	r12, r12
     ac8:	dd 24       	eor	r13, r13
     aca:	33 24       	eor	r3, r3
     acc:	38 01       	movw	r6, r16
     ace:	e5 e0       	ldi	r30, 0x05	; 5
     ad0:	66 0c       	add	r6, r6
     ad2:	77 1c       	adc	r7, r7
 *
 *  \param[in] MSInterfaceInfo  Pointer to a structure containing a Mass Storage Class configuration and state
 *  \param[in] BlockAddress  Data block starting address for the write sequence
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
     ad4:	ea 95       	dec	r30
     ad6:	e1 f7       	brne	.-8      	; 0xad0 <DataflashManager_WriteBlocks+0xa6>
     ad8:	bb 24       	eor	r11, r11
     ada:	b3 94       	inc	r11
     adc:	c1 c0       	rjmp	.+386    	; 0xc60 <DataflashManager_WriteBlocks+0x236>
     ade:	60 e2       	ldi	r22, 0x20	; 32
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
				  UsingSecondBuffer = !(UsingSecondBuffer);
     ae0:	a6 2e       	mov	r10, r22
     ae2:	46 01       	movw	r8, r12
     ae4:	86 0c       	add	r8, r6

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     ae6:	97 1c       	adc	r9, r7
     ae8:	80 91 e8 00 	lds	r24, 0x00E8
				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
     aec:	85 fd       	sbrc	r24, 5
     aee:	0c c0       	rjmp	.+24     	; 0xb08 <DataflashManager_WriteBlocks+0xde>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     af0:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently empty */
			if (!(Endpoint_IsReadWriteAllowed()))
     af4:	8b 77       	andi	r24, 0x7B	; 123
     af6:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     afa:	49 83       	std	Y+1, r20	; 0x01
     afc:	0e 94 6d 28 	call	0x50da	; 0x50da <Endpoint_WaitUntilReady>
     b00:	49 81       	ldd	r20, Y+1	; 0x01
			{
				/* Clear the current endpoint bank */
				Endpoint_ClearOUT();

				/* Wait until the host has sent another packet */
				if (Endpoint_WaitUntilReady())
     b02:	88 23       	and	r24, r24
     b04:	09 f0       	breq	.+2      	; 0xb08 <DataflashManager_WriteBlocks+0xde>
     b06:	cb c0       	rjmp	.+406    	; 0xc9e <DataflashManager_WriteBlocks+0x274>
     b08:	40 34       	cpi	r20, 0x40	; 64
     b0a:	09 f0       	breq	.+2      	; 0xb0e <DataflashManager_WriteBlocks+0xe4>
     b0c:	3b c0       	rjmp	.+118    	; 0xb84 <DataflashManager_WriteBlocks+0x15a>
     b0e:	53 df       	rcall	.-346    	; 0x9b6 <Dataflash_WaitWhileBusy>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     b10:	33 20       	and	r3, r3
     b12:	11 f0       	breq	.+4      	; 0xb18 <DataflashManager_WriteBlocks+0xee>
     b14:	86 e8       	ldi	r24, 0x86	; 134
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
     b16:	01 c0       	rjmp	.+2      	; 0xb1a <DataflashManager_WriteBlocks+0xf0>
     b18:	83 e8       	ldi	r24, 0x83	; 131
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     b1a:	8e bd       	out	0x2e, r24	; 46
     b1c:	0d b4       	in	r0, 0x2d	; 45
     b1e:	07 fe       	sbrs	r0, 7
     b20:	fd cf       	rjmp	.-6      	; 0xb1c <DataflashManager_WriteBlocks+0xf2>
     b22:	c7 01       	movw	r24, r14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b24:	60 e0       	ldi	r22, 0x00	; 0
				while (!(SPSR & (1 << SPIF)));
     b26:	70 e0       	ldi	r23, 0x00	; 0
     b28:	54 df       	rcall	.-344    	; 0x9d2 <Dataflash_SendAddressBytes>
     b2a:	08 94       	sec
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     b2c:	e1 1c       	adc	r14, r1
     b2e:	f1 1c       	adc	r15, r1
     b30:	8e b1       	in	r24, 0x0e	; 14
     b32:	80 95       	com	r24
     b34:	83 70       	andi	r24, 0x03	; 3

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     b36:	82 30       	cpi	r24, 0x02	; 2
     b38:	09 f4       	brne	.+2      	; 0xb3c <DataflashManager_WriteBlocks+0x112>
     b3a:	3b 24       	eor	r3, r11
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     b3c:	c7 01       	movw	r24, r14
     b3e:	62 df       	rcall	.-316    	; 0xa04 <Dataflash_SelectChipFromPage>
     b40:	80 e4       	ldi	r24, 0x40	; 64

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
     b42:	88 16       	cp	r8, r24
     b44:	91 04       	cpc	r9, r1
				  UsingSecondBuffer = !(UsingSecondBuffer);
     b46:	78 f4       	brcc	.+30     	; 0xb66 <DataflashManager_WriteBlocks+0x13c>

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     b48:	36 df       	rcall	.-404    	; 0x9b6 <Dataflash_WaitWhileBusy>
     b4a:	33 20       	and	r3, r3
     b4c:	11 f0       	breq	.+4      	; 0xb52 <DataflashManager_WriteBlocks+0x128>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
     b4e:	85 e5       	ldi	r24, 0x55	; 85
     b50:	01 c0       	rjmp	.+2      	; 0xb54 <DataflashManager_WriteBlocks+0x12a>
     b52:	83 e5       	ldi	r24, 0x53	; 83
     b54:	8e bd       	out	0x2e, r24	; 46
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
     b56:	0d b4       	in	r0, 0x2d	; 45
     b58:	07 fe       	sbrs	r0, 7
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
     b5a:	fd cf       	rjmp	.-6      	; 0xb56 <DataflashManager_WriteBlocks+0x12c>
     b5c:	c7 01       	movw	r24, r14
     b5e:	60 e0       	ldi	r22, 0x00	; 0
     b60:	70 e0       	ldi	r23, 0x00	; 0
     b62:	37 df       	rcall	.-402    	; 0x9d2 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b64:	28 df       	rcall	.-432    	; 0x9b6 <Dataflash_WaitWhileBusy>
				while (!(SPSR & (1 << SPIF)));
     b66:	33 20       	and	r3, r3
     b68:	11 f0       	breq	.+4      	; 0xb6e <DataflashManager_WriteBlocks+0x144>
     b6a:	87 e8       	ldi	r24, 0x87	; 135
					Dataflash_SendAddressBytes(CurrDFPage, 0);
     b6c:	01 c0       	rjmp	.+2      	; 0xb70 <DataflashManager_WriteBlocks+0x146>
     b6e:	84 e8       	ldi	r24, 0x84	; 132
     b70:	8e bd       	out	0x2e, r24	; 46
     b72:	0d b4       	in	r0, 0x2d	; 45
     b74:	07 fe       	sbrs	r0, 7
					Dataflash_WaitWhileBusy();
     b76:	fd cf       	rjmp	.-6      	; 0xb72 <DataflashManager_WriteBlocks+0x148>
     b78:	80 e0       	ldi	r24, 0x00	; 0
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
     b7a:	90 e0       	ldi	r25, 0x00	; 0
     b7c:	60 e0       	ldi	r22, 0x00	; 0
     b7e:	70 e0       	ldi	r23, 0x00	; 0
     b80:	28 df       	rcall	.-432    	; 0x9d2 <Dataflash_SendAddressBytes>
     b82:	40 e0       	ldi	r20, 0x00	; 0
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b84:	80 91 f1 00 	lds	r24, 0x00F1
				while (!(SPSR & (1 << SPIF)));
     b88:	8e bd       	out	0x2e, r24	; 46
     b8a:	0d b4       	in	r0, 0x2d	; 45
				Dataflash_SendAddressBytes(0, 0);
     b8c:	07 fe       	sbrs	r0, 7
     b8e:	fd cf       	rjmp	.-6      	; 0xb8a <DataflashManager_WriteBlocks+0x160>
     b90:	80 91 f1 00 	lds	r24, 0x00F1
     b94:	8e bd       	out	0x2e, r24	; 46
     b96:	0d b4       	in	r0, 0x2d	; 45
				Dataflash_WaitWhileBusy();
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
				Dataflash_SendAddressBytes(CurrDFPage, 0);

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     b98:	07 fe       	sbrs	r0, 7
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     b9a:	fd cf       	rjmp	.-6      	; 0xb96 <DataflashManager_WriteBlocks+0x16c>
     b9c:	80 91 f1 00 	lds	r24, 0x00F1
     ba0:	8e bd       	out	0x2e, r24	; 46
     ba2:	0d b4       	in	r0, 0x2d	; 45
     ba4:	07 fe       	sbrs	r0, 7
     ba6:	fd cf       	rjmp	.-6      	; 0xba2 <DataflashManager_WriteBlocks+0x178>
     ba8:	80 91 f1 00 	lds	r24, 0x00F1
     bac:	8e bd       	out	0x2e, r24	; 46
     bae:	0d b4       	in	r0, 0x2d	; 45
     bb0:	07 fe       	sbrs	r0, 7
     bb2:	fd cf       	rjmp	.-6      	; 0xbae <DataflashManager_WriteBlocks+0x184>
     bb4:	80 91 f1 00 	lds	r24, 0x00F1
     bb8:	8e bd       	out	0x2e, r24	; 46
     bba:	0d b4       	in	r0, 0x2d	; 45
     bbc:	07 fe       	sbrs	r0, 7
     bbe:	fd cf       	rjmp	.-6      	; 0xbba <DataflashManager_WriteBlocks+0x190>
     bc0:	80 91 f1 00 	lds	r24, 0x00F1
     bc4:	8e bd       	out	0x2e, r24	; 46
     bc6:	0d b4       	in	r0, 0x2d	; 45
     bc8:	07 fe       	sbrs	r0, 7
     bca:	fd cf       	rjmp	.-6      	; 0xbc6 <DataflashManager_WriteBlocks+0x19c>
     bcc:	80 91 f1 00 	lds	r24, 0x00F1
     bd0:	8e bd       	out	0x2e, r24	; 46
     bd2:	0d b4       	in	r0, 0x2d	; 45
     bd4:	07 fe       	sbrs	r0, 7
     bd6:	fd cf       	rjmp	.-6      	; 0xbd2 <DataflashManager_WriteBlocks+0x1a8>
     bd8:	80 91 f1 00 	lds	r24, 0x00F1
     bdc:	8e bd       	out	0x2e, r24	; 46
     bde:	0d b4       	in	r0, 0x2d	; 45
     be0:	07 fe       	sbrs	r0, 7
     be2:	fd cf       	rjmp	.-6      	; 0xbde <DataflashManager_WriteBlocks+0x1b4>
     be4:	80 91 f1 00 	lds	r24, 0x00F1
     be8:	8e bd       	out	0x2e, r24	; 46
     bea:	0d b4       	in	r0, 0x2d	; 45
     bec:	07 fe       	sbrs	r0, 7
     bee:	fd cf       	rjmp	.-6      	; 0xbea <DataflashManager_WriteBlocks+0x1c0>
     bf0:	80 91 f1 00 	lds	r24, 0x00F1
     bf4:	8e bd       	out	0x2e, r24	; 46
     bf6:	0d b4       	in	r0, 0x2d	; 45
     bf8:	07 fe       	sbrs	r0, 7
     bfa:	fd cf       	rjmp	.-6      	; 0xbf6 <DataflashManager_WriteBlocks+0x1cc>
     bfc:	80 91 f1 00 	lds	r24, 0x00F1
     c00:	8e bd       	out	0x2e, r24	; 46
     c02:	0d b4       	in	r0, 0x2d	; 45
     c04:	07 fe       	sbrs	r0, 7
     c06:	fd cf       	rjmp	.-6      	; 0xc02 <DataflashManager_WriteBlocks+0x1d8>
     c08:	80 91 f1 00 	lds	r24, 0x00F1
     c0c:	8e bd       	out	0x2e, r24	; 46
     c0e:	0d b4       	in	r0, 0x2d	; 45
     c10:	07 fe       	sbrs	r0, 7
     c12:	fd cf       	rjmp	.-6      	; 0xc0e <DataflashManager_WriteBlocks+0x1e4>
     c14:	80 91 f1 00 	lds	r24, 0x00F1
     c18:	8e bd       	out	0x2e, r24	; 46
     c1a:	0d b4       	in	r0, 0x2d	; 45
     c1c:	07 fe       	sbrs	r0, 7
     c1e:	fd cf       	rjmp	.-6      	; 0xc1a <DataflashManager_WriteBlocks+0x1f0>
     c20:	80 91 f1 00 	lds	r24, 0x00F1
     c24:	8e bd       	out	0x2e, r24	; 46
     c26:	0d b4       	in	r0, 0x2d	; 45
     c28:	07 fe       	sbrs	r0, 7
     c2a:	fd cf       	rjmp	.-6      	; 0xc26 <DataflashManager_WriteBlocks+0x1fc>
     c2c:	80 91 f1 00 	lds	r24, 0x00F1
     c30:	8e bd       	out	0x2e, r24	; 46
     c32:	0d b4       	in	r0, 0x2d	; 45
     c34:	07 fe       	sbrs	r0, 7
     c36:	fd cf       	rjmp	.-6      	; 0xc32 <DataflashManager_WriteBlocks+0x208>
     c38:	80 91 f1 00 	lds	r24, 0x00F1
     c3c:	8e bd       	out	0x2e, r24	; 46
     c3e:	0d b4       	in	r0, 0x2d	; 45
     c40:	07 fe       	sbrs	r0, 7
     c42:	fd cf       	rjmp	.-6      	; 0xc3e <DataflashManager_WriteBlocks+0x214>
     c44:	f2 01       	movw	r30, r4
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c46:	80 ad       	sts	0x60, r24
				while (!(SPSR & (1 << SPIF)));
     c48:	88 23       	and	r24, r24
     c4a:	49 f5       	brne	.+82     	; 0xc9e <DataflashManager_WriteBlocks+0x274>
     c4c:	4f 5f       	subi	r20, 0xFF	; 255
     c4e:	aa 94       	dec	r10
     c50:	09 f0       	breq	.+2      	; 0xc54 <DataflashManager_WriteBlocks+0x22a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c52:	4a cf       	rjmp	.-364    	; 0xae8 <DataflashManager_WriteBlocks+0xbe>
				while (!(SPSR & (1 << SPIF)));
     c54:	01 50       	subi	r16, 0x01	; 1
     c56:	10 40       	sbci	r17, 0x00	; 0
     c58:	80 ee       	ldi	r24, 0xE0	; 224

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     c5a:	9f ef       	ldi	r25, 0xFF	; 255
     c5c:	c8 0e       	add	r12, r24
     c5e:	d9 1e       	adc	r13, r25
     c60:	01 15       	cp	r16, r1
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     c62:	11 05       	cpc	r17, r1
     c64:	09 f0       	breq	.+2      	; 0xc68 <DataflashManager_WriteBlocks+0x23e>
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     c66:	3b cf       	rjmp	.-394    	; 0xade <DataflashManager_WriteBlocks+0xb4>
     c68:	a6 de       	rcall	.-692    	; 0x9b6 <Dataflash_WaitWhileBusy>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     c6a:	33 20       	and	r3, r3
     c6c:	11 f0       	breq	.+4      	; 0xc72 <DataflashManager_WriteBlocks+0x248>
     c6e:	86 e8       	ldi	r24, 0x86	; 134
     c70:	01 c0       	rjmp	.+2      	; 0xc74 <DataflashManager_WriteBlocks+0x24a>
     c72:	83 e8       	ldi	r24, 0x83	; 131
     c74:	8e bd       	out	0x2e, r24	; 46

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     c76:	0d b4       	in	r0, 0x2d	; 45
     c78:	07 fe       	sbrs	r0, 7
     c7a:	fd cf       	rjmp	.-6      	; 0xc76 <DataflashManager_WriteBlocks+0x24c>
     c7c:	c7 01       	movw	r24, r14
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
     c7e:	60 e0       	ldi	r22, 0x00	; 0
     c80:	70 e0       	ldi	r23, 0x00	; 0
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     c82:	a7 de       	rcall	.-690    	; 0x9d2 <Dataflash_SendAddressBytes>
     c84:	98 de       	rcall	.-720    	; 0x9b6 <Dataflash_WaitWhileBusy>
     c86:	80 91 e8 00 	lds	r24, 0x00E8
     c8a:	85 fd       	sbrc	r24, 5
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <DataflashManager_WriteBlocks+0x26e>
				while (!(SPSR & (1 << SPIF)));
     c8e:	80 91 e8 00 	lds	r24, 0x00E8
     c92:	8b 77       	andi	r24, 0x7B	; 123
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
     c94:	80 93 e8 00 	sts	0x00E8, r24
     c98:	8e b1       	in	r24, 0x0e	; 14
     c9a:	83 60       	ori	r24, 0x03	; 3
     c9c:	8e b9       	out	0x0e, r24	; 14
	Dataflash_WaitWhileBusy();
     c9e:	0f 90       	pop	r0
     ca0:	df 91       	pop	r29
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     ca2:	cf 91       	pop	r28
     ca4:	1f 91       	pop	r17

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     ca6:	0f 91       	pop	r16
     ca8:	ff 90       	pop	r15
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     caa:	ef 90       	pop	r14
     cac:	df 90       	pop	r13
     cae:	cf 90       	pop	r12
     cb0:	bf 90       	pop	r11
     cb2:	af 90       	pop	r10
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     cb4:	9f 90       	pop	r9
     cb6:	8f 90       	pop	r8
     cb8:	7f 90       	pop	r7
	  Endpoint_ClearOUT();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     cba:	6f 90       	pop	r6
     cbc:	5f 90       	pop	r5
     cbe:	4f 90       	pop	r4
     cc0:	3f 90       	pop	r3
     cc2:	08 95       	ret

00000cc4 <DataflashManager_ReadBlocks>:
     cc4:	bf 92       	push	r11
     cc6:	cf 92       	push	r12
     cc8:	df 92       	push	r13
     cca:	ef 92       	push	r14
     ccc:	ff 92       	push	r15
     cce:	0f 93       	push	r16
     cd0:	1f 93       	push	r17
     cd2:	cf 93       	push	r28
     cd4:	df 93       	push	r29
     cd6:	6c 01       	movw	r12, r24
     cd8:	79 01       	movw	r14, r18
     cda:	db 01       	movw	r26, r22
     cdc:	ca 01       	movw	r24, r20
     cde:	e9 e0       	ldi	r30, 0x09	; 9
 */
void DataflashManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     ce0:	88 0f       	add	r24, r24
     ce2:	99 1f       	adc	r25, r25
     ce4:	aa 1f       	adc	r26, r26
     ce6:	bb 1f       	adc	r27, r27
     ce8:	ea 95       	dec	r30
     cea:	d1 f7       	brne	.-12     	; 0xce0 <DataflashManager_ReadBlocks+0x1c>
     cec:	fa e0       	ldi	r31, 0x0A	; 10
     cee:	b6 95       	lsr	r27
     cf0:	a7 95       	ror	r26
     cf2:	97 95       	ror	r25
     cf4:	87 95       	ror	r24
     cf6:	fa 95       	dec	r31
     cf8:	d1 f7       	brne	.-12     	; 0xcee <DataflashManager_ReadBlocks+0x2a>
     cfa:	8c 01       	movw	r16, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     cfc:	ea 01       	movw	r28, r20
     cfe:	dc 2f       	mov	r29, r28
     d00:	cc 27       	eor	r28, r28
     d02:	dd 0f       	add	r29, r29
     d04:	d3 70       	andi	r29, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     d06:	7e de       	rcall	.-772    	; 0xa04 <Dataflash_SelectChipFromPage>
     d08:	82 ed       	ldi	r24, 0xD2	; 210
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d0a:	8e bd       	out	0x2e, r24	; 46
     d0c:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     d0e:	07 fe       	sbrs	r0, 7
     d10:	fd cf       	rjmp	.-6      	; 0xd0c <DataflashManager_ReadBlocks+0x48>
     d12:	c8 01       	movw	r24, r16

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     d14:	be 01       	movw	r22, r28
     d16:	5d de       	rcall	.-838    	; 0x9d2 <Dataflash_SendAddressBytes>
     d18:	1e bc       	out	0x2e, r1	; 46
     d1a:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d1c:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d1e:	fd cf       	rjmp	.-6      	; 0xd1a <DataflashManager_ReadBlocks+0x56>
     d20:	1e bc       	out	0x2e, r1	; 46
     d22:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d24:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d26:	fd cf       	rjmp	.-6      	; 0xd22 <DataflashManager_ReadBlocks+0x5e>
     d28:	1e bc       	out	0x2e, r1	; 46
     d2a:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d2c:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d2e:	fd cf       	rjmp	.-6      	; 0xd2a <DataflashManager_ReadBlocks+0x66>
     d30:	1e bc       	out	0x2e, r1	; 46
     d32:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d34:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d36:	fd cf       	rjmp	.-6      	; 0xd32 <DataflashManager_ReadBlocks+0x6e>
     d38:	0e 94 6d 28 	call	0x50da	; 0x50da <Endpoint_WaitUntilReady>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     d3c:	88 23       	and	r24, r24
     d3e:	09 f0       	breq	.+2      	; 0xd42 <DataflashManager_ReadBlocks+0x7e>
     d40:	c1 c0       	rjmp	.+386    	; 0xec4 <DataflashManager_ReadBlocks+0x200>
     d42:	34 e0       	ldi	r19, 0x04	; 4
     d44:	d6 95       	lsr	r29
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     d46:	c7 95       	ror	r28
     d48:	3a 95       	dec	r19
     d4a:	e1 f7       	brne	.-8      	; 0xd44 <DataflashManager_ReadBlocks+0x80>
     d4c:	42 ed       	ldi	r20, 0xD2	; 210
     d4e:	b4 2e       	mov	r11, r20
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d50:	a9 c0       	rjmp	.+338    	; 0xea4 <DataflashManager_ReadBlocks+0x1e0>
     d52:	d0 e2       	ldi	r29, 0x20	; 32
     d54:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     d58:	85 fd       	sbrc	r24, 5
     d5a:	0a c0       	rjmp	.+20     	; 0xd70 <DataflashManager_ReadBlocks+0xac>

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently full */
			if (!(Endpoint_IsReadWriteAllowed()))
     d5c:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     d60:	8e 77       	andi	r24, 0x7E	; 126
     d62:	80 93 e8 00 	sts	0x00E8, r24
     d66:	0e 94 6d 28 	call	0x50da	; 0x50da <Endpoint_WaitUntilReady>
			{
				/* Clear the endpoint bank to send its contents to the host */
				Endpoint_ClearIN();

				/* Wait until the endpoint is ready for more data */
				if (Endpoint_WaitUntilReady())
     d6a:	88 23       	and	r24, r24
     d6c:	09 f0       	breq	.+2      	; 0xd70 <DataflashManager_ReadBlocks+0xac>
     d6e:	aa c0       	rjmp	.+340    	; 0xec4 <DataflashManager_ReadBlocks+0x200>
     d70:	c0 34       	cpi	r28, 0x40	; 64
     d72:	e9 f4       	brne	.+58     	; 0xdae <DataflashManager_ReadBlocks+0xea>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     d74:	0f 5f       	subi	r16, 0xFF	; 255
     d76:	1f 4f       	sbci	r17, 0xFF	; 255
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     d78:	c8 01       	movw	r24, r16
     d7a:	44 de       	rcall	.-888    	; 0xa04 <Dataflash_SelectChipFromPage>

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     d7c:	be bc       	out	0x2e, r11	; 46
     d7e:	0d b4       	in	r0, 0x2d	; 45
     d80:	07 fe       	sbrs	r0, 7
     d82:	fd cf       	rjmp	.-6      	; 0xd7e <DataflashManager_ReadBlocks+0xba>
				while (!(SPSR & (1 << SPIF)));
     d84:	c8 01       	movw	r24, r16
     d86:	60 e0       	ldi	r22, 0x00	; 0
     d88:	70 e0       	ldi	r23, 0x00	; 0

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     d8a:	23 de       	rcall	.-954    	; 0x9d2 <Dataflash_SendAddressBytes>
     d8c:	1e bc       	out	0x2e, r1	; 46
     d8e:	0d b4       	in	r0, 0x2d	; 45
     d90:	07 fe       	sbrs	r0, 7
     d92:	fd cf       	rjmp	.-6      	; 0xd8e <DataflashManager_ReadBlocks+0xca>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d94:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d96:	0d b4       	in	r0, 0x2d	; 45
     d98:	07 fe       	sbrs	r0, 7
     d9a:	fd cf       	rjmp	.-6      	; 0xd96 <DataflashManager_ReadBlocks+0xd2>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d9c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d9e:	0d b4       	in	r0, 0x2d	; 45
     da0:	07 fe       	sbrs	r0, 7
     da2:	fd cf       	rjmp	.-6      	; 0xd9e <DataflashManager_ReadBlocks+0xda>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     da4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     da6:	0d b4       	in	r0, 0x2d	; 45
     da8:	07 fe       	sbrs	r0, 7
     daa:	fd cf       	rjmp	.-6      	; 0xda6 <DataflashManager_ReadBlocks+0xe2>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     dac:	c0 e0       	ldi	r28, 0x00	; 0
				while (!(SPSR & (1 << SPIF)));
     dae:	1e bc       	out	0x2e, r1	; 46
     db0:	0d b4       	in	r0, 0x2d	; 45
     db2:	07 fe       	sbrs	r0, 7

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     db4:	fd cf       	rjmp	.-6      	; 0xdb0 <DataflashManager_ReadBlocks+0xec>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     db6:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     db8:	80 93 f1 00 	sts	0x00F1, r24
     dbc:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dbe:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     dc0:	07 fe       	sbrs	r0, 7
     dc2:	fd cf       	rjmp	.-6      	; 0xdbe <DataflashManager_ReadBlocks+0xfa>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dc4:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     dc6:	80 93 f1 00 	sts	0x00F1, r24
     dca:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dcc:	0d b4       	in	r0, 0x2d	; 45
     dce:	07 fe       	sbrs	r0, 7
     dd0:	fd cf       	rjmp	.-6      	; 0xdcc <DataflashManager_ReadBlocks+0x108>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dd2:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     dd4:	80 93 f1 00 	sts	0x00F1, r24
     dd8:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dda:	0d b4       	in	r0, 0x2d	; 45
     ddc:	07 fe       	sbrs	r0, 7
     dde:	fd cf       	rjmp	.-6      	; 0xdda <DataflashManager_ReadBlocks+0x116>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     de0:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     de2:	80 93 f1 00 	sts	0x00F1, r24
     de6:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     de8:	0d b4       	in	r0, 0x2d	; 45
     dea:	07 fe       	sbrs	r0, 7
     dec:	fd cf       	rjmp	.-6      	; 0xde8 <DataflashManager_ReadBlocks+0x124>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dee:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     df0:	80 93 f1 00 	sts	0x00F1, r24
     df4:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     df6:	0d b4       	in	r0, 0x2d	; 45
     df8:	07 fe       	sbrs	r0, 7
     dfa:	fd cf       	rjmp	.-6      	; 0xdf6 <DataflashManager_ReadBlocks+0x132>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dfc:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     dfe:	80 93 f1 00 	sts	0x00F1, r24
     e02:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e04:	0d b4       	in	r0, 0x2d	; 45
     e06:	07 fe       	sbrs	r0, 7
     e08:	fd cf       	rjmp	.-6      	; 0xe04 <DataflashManager_ReadBlocks+0x140>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e0a:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e0c:	80 93 f1 00 	sts	0x00F1, r24
     e10:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e12:	0d b4       	in	r0, 0x2d	; 45
     e14:	07 fe       	sbrs	r0, 7
     e16:	fd cf       	rjmp	.-6      	; 0xe12 <DataflashManager_ReadBlocks+0x14e>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e18:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e1a:	80 93 f1 00 	sts	0x00F1, r24
     e1e:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e20:	0d b4       	in	r0, 0x2d	; 45
     e22:	07 fe       	sbrs	r0, 7
     e24:	fd cf       	rjmp	.-6      	; 0xe20 <DataflashManager_ReadBlocks+0x15c>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e26:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e28:	80 93 f1 00 	sts	0x00F1, r24
     e2c:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e2e:	0d b4       	in	r0, 0x2d	; 45
     e30:	07 fe       	sbrs	r0, 7
     e32:	fd cf       	rjmp	.-6      	; 0xe2e <DataflashManager_ReadBlocks+0x16a>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e34:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e36:	80 93 f1 00 	sts	0x00F1, r24
     e3a:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e3c:	0d b4       	in	r0, 0x2d	; 45
     e3e:	07 fe       	sbrs	r0, 7
     e40:	fd cf       	rjmp	.-6      	; 0xe3c <DataflashManager_ReadBlocks+0x178>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e42:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e44:	80 93 f1 00 	sts	0x00F1, r24
     e48:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e4a:	0d b4       	in	r0, 0x2d	; 45
     e4c:	07 fe       	sbrs	r0, 7
     e4e:	fd cf       	rjmp	.-6      	; 0xe4a <DataflashManager_ReadBlocks+0x186>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e50:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e52:	80 93 f1 00 	sts	0x00F1, r24
     e56:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e58:	0d b4       	in	r0, 0x2d	; 45
     e5a:	07 fe       	sbrs	r0, 7
     e5c:	fd cf       	rjmp	.-6      	; 0xe58 <DataflashManager_ReadBlocks+0x194>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e5e:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e60:	80 93 f1 00 	sts	0x00F1, r24
     e64:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e66:	0d b4       	in	r0, 0x2d	; 45
     e68:	07 fe       	sbrs	r0, 7
     e6a:	fd cf       	rjmp	.-6      	; 0xe66 <DataflashManager_ReadBlocks+0x1a2>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e6c:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e6e:	80 93 f1 00 	sts	0x00F1, r24
     e72:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e74:	0d b4       	in	r0, 0x2d	; 45
     e76:	07 fe       	sbrs	r0, 7
     e78:	fd cf       	rjmp	.-6      	; 0xe74 <DataflashManager_ReadBlocks+0x1b0>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e7a:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e7c:	80 93 f1 00 	sts	0x00F1, r24
     e80:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e82:	0d b4       	in	r0, 0x2d	; 45
     e84:	07 fe       	sbrs	r0, 7
     e86:	fd cf       	rjmp	.-6      	; 0xe82 <DataflashManager_ReadBlocks+0x1be>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e88:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e8a:	80 93 f1 00 	sts	0x00F1, r24
     e8e:	f6 01       	movw	r30, r12
				return SPDR;
     e90:	80 ad       	sts	0x60, r24
     e92:	88 23       	and	r24, r24
     e94:	b9 f4       	brne	.+46     	; 0xec4 <DataflashManager_ReadBlocks+0x200>

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     e96:	cf 5f       	subi	r28, 0xFF	; 255
     e98:	d1 50       	subi	r29, 0x01	; 1
     e9a:	09 f0       	breq	.+2      	; 0xe9e <DataflashManager_ReadBlocks+0x1da>
     e9c:	5b cf       	rjmp	.-330    	; 0xd54 <DataflashManager_ReadBlocks+0x90>
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     e9e:	08 94       	sec
     ea0:	e1 08       	sbc	r14, r1
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     ea2:	f1 08       	sbc	r15, r1
     ea4:	e1 14       	cp	r14, r1
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     ea6:	f1 04       	cpc	r15, r1
     ea8:	09 f0       	breq	.+2      	; 0xeac <DataflashManager_ReadBlocks+0x1e8>
     eaa:	53 cf       	rjmp	.-346    	; 0xd52 <DataflashManager_ReadBlocks+0x8e>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     eac:	80 91 e8 00 	lds	r24, 0x00E8
     eb0:	85 fd       	sbrc	r24, 5
     eb2:	05 c0       	rjmp	.+10     	; 0xebe <DataflashManager_ReadBlocks+0x1fa>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     eb4:	80 91 e8 00 	lds	r24, 0x00E8
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     eb8:	8e 77       	andi	r24, 0x7E	; 126
     eba:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     ebe:	8e b1       	in	r24, 0x0e	; 14
     ec0:	83 60       	ori	r24, 0x03	; 3
     ec2:	8e b9       	out	0x0e, r24	; 14
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	1f 91       	pop	r17
     eca:	0f 91       	pop	r16
	  Endpoint_ClearIN();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     ecc:	ff 90       	pop	r15
     ece:	ef 90       	pop	r14
     ed0:	df 90       	pop	r13
     ed2:	cf 90       	pop	r12
     ed4:	bf 90       	pop	r11
     ed6:	08 95       	ret

00000ed8 <DataflashManager_ReadBlocks_RAM>:
     ed8:	8f 92       	push	r8
     eda:	9f 92       	push	r9
     edc:	af 92       	push	r10
     ede:	bf 92       	push	r11
 *  \param[out] BufferPtr    Pointer to the data destination RAM buffer
 */
void DataflashManager_ReadBlocks_RAM(const uint32_t BlockAddress,
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
     ee0:	cf 92       	push	r12
     ee2:	df 92       	push	r13
     ee4:	ef 92       	push	r14
     ee6:	ff 92       	push	r15
     ee8:	0f 93       	push	r16
     eea:	1f 93       	push	r17
     eec:	cf 93       	push	r28
     eee:	df 93       	push	r29
     ef0:	dc 01       	movw	r26, r24
     ef2:	cb 01       	movw	r24, r22
     ef4:	4a 01       	movw	r8, r20
     ef6:	59 01       	movw	r10, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     ef8:	ac 01       	movw	r20, r24
     efa:	bd 01       	movw	r22, r26
     efc:	e9 e0       	ldi	r30, 0x09	; 9
     efe:	44 0f       	add	r20, r20
     f00:	55 1f       	adc	r21, r21
     f02:	66 1f       	adc	r22, r22
     f04:	77 1f       	adc	r23, r23
     f06:	ea 95       	dec	r30
     f08:	d1 f7       	brne	.-12     	; 0xefe <DataflashManager_ReadBlocks_RAM+0x26>
     f0a:	fa e0       	ldi	r31, 0x0A	; 10
     f0c:	76 95       	lsr	r23
     f0e:	67 95       	ror	r22
     f10:	57 95       	ror	r21
     f12:	47 95       	ror	r20
     f14:	fa 95       	dec	r31
     f16:	d1 f7       	brne	.-12     	; 0xf0c <DataflashManager_ReadBlocks_RAM+0x34>
     f18:	6a 01       	movw	r12, r20
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     f1a:	8c 01       	movw	r16, r24
     f1c:	10 2f       	mov	r17, r16
     f1e:	00 27       	eor	r16, r16
     f20:	11 0f       	add	r17, r17
     f22:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     f24:	c8 01       	movw	r24, r16
     f26:	d4 e0       	ldi	r29, 0x04	; 4
     f28:	96 95       	lsr	r25
     f2a:	87 95       	ror	r24
     f2c:	da 95       	dec	r29
     f2e:	e1 f7       	brne	.-8      	; 0xf28 <DataflashManager_ReadBlocks_RAM+0x50>
     f30:	c8 2f       	mov	r28, r24

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     f32:	ca 01       	movw	r24, r20
     f34:	67 dd       	rcall	.-1330   	; 0xa04 <Dataflash_SelectChipFromPage>
     f36:	82 ed       	ldi	r24, 0xD2	; 210
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f38:	8e bd       	out	0x2e, r24	; 46
     f3a:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     f3c:	07 fe       	sbrs	r0, 7
     f3e:	fd cf       	rjmp	.-6      	; 0xf3a <DataflashManager_ReadBlocks_RAM+0x62>
     f40:	c6 01       	movw	r24, r12

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     f42:	b8 01       	movw	r22, r16
     f44:	46 dd       	rcall	.-1396   	; 0x9d2 <Dataflash_SendAddressBytes>
     f46:	1e bc       	out	0x2e, r1	; 46
     f48:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f4a:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f4c:	fd cf       	rjmp	.-6      	; 0xf48 <DataflashManager_ReadBlocks_RAM+0x70>
     f4e:	1e bc       	out	0x2e, r1	; 46
     f50:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f52:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f54:	fd cf       	rjmp	.-6      	; 0xf50 <DataflashManager_ReadBlocks_RAM+0x78>
     f56:	1e bc       	out	0x2e, r1	; 46
     f58:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f5a:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f5c:	fd cf       	rjmp	.-6      	; 0xf58 <DataflashManager_ReadBlocks_RAM+0x80>
     f5e:	1e bc       	out	0x2e, r1	; 46
     f60:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f62:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f64:	fd cf       	rjmp	.-6      	; 0xf60 <DataflashManager_ReadBlocks_RAM+0x88>
     f66:	3b c0       	rjmp	.+118    	; 0xfde <DataflashManager_ReadBlocks_RAM+0x106>
     f68:	75 01       	movw	r14, r10
     f6a:	00 e2       	ldi	r16, 0x20	; 32
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     f6c:	c0 34       	cpi	r28, 0x40	; 64
     f6e:	f1 f4       	brne	.+60     	; 0xfac <DataflashManager_ReadBlocks_RAM+0xd4>

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     f70:	08 94       	sec
     f72:	c1 1c       	adc	r12, r1
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     f74:	d1 1c       	adc	r13, r1
     f76:	c6 01       	movw	r24, r12
     f78:	45 dd       	rcall	.-1398   	; 0xa04 <Dataflash_SelectChipFromPage>

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     f7a:	de bd       	out	0x2e, r29	; 46
     f7c:	0d b4       	in	r0, 0x2d	; 45
     f7e:	07 fe       	sbrs	r0, 7
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f80:	fd cf       	rjmp	.-6      	; 0xf7c <DataflashManager_ReadBlocks_RAM+0xa4>
				while (!(SPSR & (1 << SPIF)));
     f82:	c6 01       	movw	r24, r12
     f84:	60 e0       	ldi	r22, 0x00	; 0
     f86:	70 e0       	ldi	r23, 0x00	; 0

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     f88:	24 dd       	rcall	.-1464   	; 0x9d2 <Dataflash_SendAddressBytes>
     f8a:	1e bc       	out	0x2e, r1	; 46
     f8c:	0d b4       	in	r0, 0x2d	; 45
     f8e:	07 fe       	sbrs	r0, 7
     f90:	fd cf       	rjmp	.-6      	; 0xf8c <DataflashManager_ReadBlocks_RAM+0xb4>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f92:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f94:	0d b4       	in	r0, 0x2d	; 45
     f96:	07 fe       	sbrs	r0, 7
     f98:	fd cf       	rjmp	.-6      	; 0xf94 <DataflashManager_ReadBlocks_RAM+0xbc>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f9a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f9c:	0d b4       	in	r0, 0x2d	; 45
     f9e:	07 fe       	sbrs	r0, 7
     fa0:	fd cf       	rjmp	.-6      	; 0xf9c <DataflashManager_ReadBlocks_RAM+0xc4>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fa2:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     fa4:	0d b4       	in	r0, 0x2d	; 45
     fa6:	07 fe       	sbrs	r0, 7
     fa8:	fd cf       	rjmp	.-6      	; 0xfa4 <DataflashManager_ReadBlocks_RAM+0xcc>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     faa:	c0 e0       	ldi	r28, 0x00	; 0
				while (!(SPSR & (1 << SPIF)));
     fac:	f7 01       	movw	r30, r14
     fae:	80 e1       	ldi	r24, 0x10	; 16
     fb0:	1e bc       	out	0x2e, r1	; 46
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     fb2:	0d b4       	in	r0, 0x2d	; 45
     fb4:	07 fe       	sbrs	r0, 7
     fb6:	fd cf       	rjmp	.-6      	; 0xfb2 <DataflashManager_ReadBlocks_RAM+0xda>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     fb8:	9e b5       	in	r25, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     fba:	91 93       	st	Z+, r25
     fbc:	81 50       	subi	r24, 0x01	; 1
     fbe:	c1 f7       	brne	.-16     	; 0xfb0 <DataflashManager_ReadBlocks_RAM+0xd8>
				return SPDR;
     fc0:	80 e1       	ldi	r24, 0x10	; 16
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  *(BufferPtr++) = Dataflash_ReceiveByte();
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	e8 0e       	add	r14, r24
				Dataflash_SendByte(0x00);
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
     fc6:	f9 1e       	adc	r15, r25
     fc8:	cf 5f       	subi	r28, 0xFF	; 255
     fca:	01 50       	subi	r16, 0x01	; 1
     fcc:	79 f6       	brne	.-98     	; 0xf6c <DataflashManager_ReadBlocks_RAM+0x94>
     fce:	80 e0       	ldi	r24, 0x00	; 0
			  *(BufferPtr++) = Dataflash_ReceiveByte();

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     fd0:	92 e0       	ldi	r25, 0x02	; 2
     fd2:	a8 0e       	add	r10, r24
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     fd4:	b9 1e       	adc	r11, r25
     fd6:	08 94       	sec
     fd8:	81 08       	sbc	r8, r1
     fda:	91 08       	sbc	r9, r1
     fdc:	01 c0       	rjmp	.+2      	; 0xfe0 <DataflashManager_ReadBlocks_RAM+0x108>
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     fde:	d2 ed       	ldi	r29, 0xD2	; 210
     fe0:	81 14       	cp	r8, r1
     fe2:	91 04       	cpc	r9, r1
     fe4:	09 f0       	breq	.+2      	; 0xfe8 <DataflashManager_ReadBlocks_RAM+0x110>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fe6:	c0 cf       	rjmp	.-128    	; 0xf68 <DataflashManager_ReadBlocks_RAM+0x90>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     fe8:	8e b1       	in	r24, 0x0e	; 14
     fea:	83 60       	ori	r24, 0x03	; 3
     fec:	8e b9       	out	0x0e, r24	; 14
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
		TotalBlocks--;
	}

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     ff6:	ff 90       	pop	r15
     ff8:	ef 90       	pop	r14
     ffa:	df 90       	pop	r13
     ffc:	cf 90       	pop	r12
     ffe:	bf 90       	pop	r11
    1000:	af 90       	pop	r10
    1002:	9f 90       	pop	r9
    1004:	8f 90       	pop	r8
    1006:	08 95       	ret

00001008 <DataflashManager_CheckDataflashOperation>:
    1008:	8e b1       	in	r24, 0x0e	; 14
    100a:	83 60       	ori	r24, 0x03	; 3
    100c:	8e 7f       	andi	r24, 0xFE	; 254
    100e:	8e b9       	out	0x0e, r24	; 14
    1010:	8f e9       	ldi	r24, 0x9F	; 159
    1012:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    1014:	0d b4       	in	r0, 0x2d	; 45
    1016:	07 fe       	sbrs	r0, 7
    1018:	fd cf       	rjmp	.-6      	; 0x1014 <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    101a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    101c:	0d b4       	in	r0, 0x2d	; 45
    101e:	07 fe       	sbrs	r0, 7
    1020:	fd cf       	rjmp	.-6      	; 0x101c <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
    1022:	9e b5       	in	r25, 0x2e	; 46
    1024:	8e b1       	in	r24, 0x0e	; 14
    1026:	83 60       	ori	r24, 0x03	; 3
    1028:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
    102a:	9f 31       	cpi	r25, 0x1F	; 31
    102c:	b1 f4       	brne	.+44     	; 0x105a <DataflashManager_CheckDataflashOperation+0x52>
    102e:	8e b1       	in	r24, 0x0e	; 14
    1030:	83 60       	ori	r24, 0x03	; 3
    1032:	8d 7f       	andi	r24, 0xFD	; 253
    1034:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    1036:	8f e9       	ldi	r24, 0x9F	; 159
    1038:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    103a:	0d b4       	in	r0, 0x2d	; 45
    103c:	07 fe       	sbrs	r0, 7
    103e:	fd cf       	rjmp	.-6      	; 0x103a <DataflashManager_CheckDataflashOperation+0x32>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    1040:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    1042:	0d b4       	in	r0, 0x2d	; 45
    1044:	07 fe       	sbrs	r0, 7
    1046:	fd cf       	rjmp	.-6      	; 0x1042 <DataflashManager_CheckDataflashOperation+0x3a>
				return SPDR;
    1048:	9e b5       	in	r25, 0x2e	; 46
    104a:	8e b1       	in	r24, 0x0e	; 14
    104c:	83 60       	ori	r24, 0x03	; 3
    104e:	8e b9       	out	0x0e, r24	; 14

/** Performs a simple test on the attached Dataflash IC(s) to ensure that they are working.
 *
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool DataflashManager_CheckDataflashOperation(void)
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	9f 31       	cpi	r25, 0x1F	; 31
    1054:	19 f0       	breq	.+6      	; 0x105c <DataflashManager_CheckDataflashOperation+0x54>
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	08 95       	ret
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
    105a:	80 e0       	ldi	r24, 0x00	; 0
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
    105c:	08 95       	ret

0000105e <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
    105e:	9b b1       	in	r25, 0x0b	; 11
    1060:	9f 70       	andi	r25, 0x0F	; 15
    1062:	98 2b       	or	r25, r24
    1064:	9b b9       	out	0x0b, r25	; 11
			}
    1066:	08 95       	ret

00001068 <uIPManagement_Init>:
struct uip_eth_addr MACAddress;


/** Configures the uIP stack ready for network traffic processing. */
void uIPManagement_Init(void)
{
    1068:	cf 93       	push	r28
	/* uIP Timing Initialization */
	clock_init();
    106a:	0e 94 21 1c 	call	0x3842	; 0x3842 <clock_init>
	timer_set(&ConnectionTimer, CLOCK_SECOND / 2);
    106e:	88 e7       	ldi	r24, 0x78	; 120
    1070:	93 e0       	ldi	r25, 0x03	; 3
    1072:	62 e3       	ldi	r22, 0x32	; 50
    1074:	70 e0       	ldi	r23, 0x00	; 0
    1076:	0e 94 df 1b 	call	0x37be	; 0x37be <timer_set>
	timer_set(&ARPTimer, CLOCK_SECOND * 10);
    107a:	8c e7       	ldi	r24, 0x7C	; 124
    107c:	93 e0       	ldi	r25, 0x03	; 3
    107e:	68 ee       	ldi	r22, 0xE8	; 232
    1080:	73 e0       	ldi	r23, 0x03	; 3
    1082:	0e 94 df 1b 	call	0x37be	; 0x37be <timer_set>

	/* uIP Stack Initialization */
	uip_init();
    1086:	0e 94 61 10 	call	0x20c2	; 0x20c2 <uip_init>
	uip_arp_init();
    108a:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <uip_arp_init>

	/* DHCP/Server IP Settings Initialization */
	if (USB_CurrentMode == USB_MODE_Device)
    108e:	c0 91 fb 03 	lds	r28, 0x03FB
    1092:	c1 30       	cpi	r28, 0x01	; 1
    1094:	49 f5       	brne	.+82     	; 0x10e8 <uIPManagement_Init+0x80>
	{
		MACAddress.addr[0] = SERVER_MAC_ADDRESS[0];
    1096:	c0 93 fe 03 	sts	0x03FE, r28
		MACAddress.addr[1] = SERVER_MAC_ADDRESS[1];
    109a:	10 92 ff 03 	sts	0x03FF, r1
		MACAddress.addr[2] = SERVER_MAC_ADDRESS[2];
    109e:	c0 93 00 04 	sts	0x0400, r28
		MACAddress.addr[3] = SERVER_MAC_ADDRESS[3];
    10a2:	10 92 01 04 	sts	0x0401, r1
		MACAddress.addr[4] = SERVER_MAC_ADDRESS[4];
    10a6:	c0 93 02 04 	sts	0x0402, r28
		MACAddress.addr[5] = SERVER_MAC_ADDRESS[5];
    10aa:	10 92 03 04 	sts	0x0403, r1

		#if defined(ENABLE_DHCP_SERVER)
		DHCPServerApp_Init();
    10ae:	a8 d3       	rcall	.+1872   	; 0x1800 <DHCPServerApp_Init>
    10b0:	9a e0       	ldi	r25, 0x0A	; 10

		uip_ipaddr_t IPAddress, Netmask, GatewayIPAddress;
		uip_ipaddr(&IPAddress,        DEVICE_IP_ADDRESS[0], DEVICE_IP_ADDRESS[1], DEVICE_IP_ADDRESS[2], DEVICE_IP_ADDRESS[3]);
		uip_ipaddr(&Netmask,          DEVICE_NETMASK[0],    DEVICE_NETMASK[1],    DEVICE_NETMASK[2],    DEVICE_NETMASK[3]);
		uip_ipaddr(&GatewayIPAddress, DEVICE_GATEWAY[0],    DEVICE_GATEWAY[1],    DEVICE_GATEWAY[2],    DEVICE_GATEWAY[3]);
		uip_sethostaddr(&IPAddress);
    10b2:	90 93 bb 07 	sts	0x07BB, r25
    10b6:	10 92 bc 07 	sts	0x07BC, r1
    10ba:	10 92 bd 07 	sts	0x07BD, r1
    10be:	82 e0       	ldi	r24, 0x02	; 2
    10c0:	80 93 be 07 	sts	0x07BE, r24
    10c4:	8f ef       	ldi	r24, 0xFF	; 255
		uip_setnetmask(&Netmask);
    10c6:	80 93 b7 07 	sts	0x07B7, r24
    10ca:	80 93 b8 07 	sts	0x07B8, r24
    10ce:	80 93 b9 07 	sts	0x07B9, r24
    10d2:	10 92 ba 07 	sts	0x07BA, r1
    10d6:	90 93 b3 07 	sts	0x07B3, r25
		uip_setdraddr(&GatewayIPAddress);
    10da:	10 92 b4 07 	sts	0x07B4, r1
    10de:	10 92 b5 07 	sts	0x07B5, r1
    10e2:	c0 93 b6 07 	sts	0x07B6, r28
    10e6:	01 c0       	rjmp	.+2      	; 0x10ea <uIPManagement_Init+0x82>
    10e8:	bd d1       	rcall	.+890    	; 0x1464 <DHCPClientApp_Init>
	}
	else
	{
		#if defined(ENABLE_DHCP_CLIENT)
		DHCPClientApp_Init();
    10ea:	80 91 fe 03 	lds	r24, 0x03FE
		uip_setdraddr(&GatewayIPAddress);
		#endif
	}

	/* Virtual Webserver Ethernet Address Configuration */
	uip_setethaddr(MACAddress);
    10ee:	80 93 80 03 	sts	0x0380, r24
    10f2:	80 91 ff 03 	lds	r24, 0x03FF
    10f6:	80 93 81 03 	sts	0x0381, r24
    10fa:	80 91 00 04 	lds	r24, 0x0400
    10fe:	80 93 82 03 	sts	0x0382, r24
    1102:	80 91 01 04 	lds	r24, 0x0401
    1106:	80 93 83 03 	sts	0x0383, r24
    110a:	80 91 02 04 	lds	r24, 0x0402
    110e:	80 93 84 03 	sts	0x0384, r24
    1112:	80 91 03 04 	lds	r24, 0x0403
    1116:	80 93 85 03 	sts	0x0385, r24
    111a:	bf d4       	rcall	.+2430   	; 0x1a9a <HTTPServerApp_Init>
    111c:	52 d6       	rcall	.+3236   	; 0x1dc2 <TELNETServerApp_Init>

	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();
    111e:	cf 91       	pop	r28
    1120:	08 95       	ret

00001122 <uIPManagement_ManageNetwork>:

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
    1122:	0f 93       	push	r16
    1124:	1f 93       	push	r17
	#endif
}
    1126:	cf 93       	push	r28
    1128:	df 93       	push	r29
/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    112a:	80 91 fb 03 	lds	r24, 0x03FB
    112e:	82 30       	cpi	r24, 0x02	; 2
    1130:	19 f4       	brne	.+6      	; 0x1138 <uIPManagement_ManageNetwork+0x16>
    1132:	8e b3       	in	r24, 0x1e	; 30
    1134:	8b 30       	cpi	r24, 0x0B	; 11
    1136:	49 f0       	breq	.+18     	; 0x114a <uIPManagement_ManageNetwork+0x28>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    1138:	80 91 fb 03 	lds	r24, 0x03FB
/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    113c:	81 30       	cpi	r24, 0x01	; 1
    113e:	09 f0       	breq	.+2      	; 0x1142 <uIPManagement_ManageNetwork+0x20>
    1140:	c5 c0       	rjmp	.+394    	; 0x12cc <uIPManagement_ManageNetwork+0x1aa>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    1142:	8e b3       	in	r24, 0x1e	; 30
    1144:	84 30       	cpi	r24, 0x04	; 4
    1146:	09 f0       	breq	.+2      	; 0x114a <uIPManagement_ManageNetwork+0x28>
    1148:	c1 c0       	rjmp	.+386    	; 0x12cc <uIPManagement_ManageNetwork+0x1aa>

/** Processes Incoming packets to the server from the connected RNDIS device, creating responses as needed. */
static void uIPManagement_ProcessIncomingPacket(void)
{
	/* Determine which USB mode the system is currently initialized in */
	if (USB_CurrentMode == USB_MODE_Device)
    114a:	80 91 fb 03 	lds	r24, 0x03FB
    114e:	81 30       	cpi	r24, 0x01	; 1
    1150:	91 f4       	brne	.+36     	; 0x1176 <uIPManagement_ManageNetwork+0x54>
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface_Device)))
    1152:	8c e4       	ldi	r24, 0x4C	; 76
    1154:	91 e0       	ldi	r25, 0x01	; 1
    1156:	0e 94 1b 37 	call	0x6e36	; 0x6e36 <RNDIS_Device_IsPacketReceived>
    115a:	88 23       	and	r24, r24
    115c:	09 f4       	brne	.+2      	; 0x1160 <uIPManagement_ManageNetwork+0x3e>
    115e:	45 c0       	rjmp	.+138    	; 0x11ea <uIPManagement_ManageNetwork+0xc8>
		  return;

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    1160:	80 ed       	ldi	r24, 0xD0	; 208
    1162:	7d df       	rcall	.-262    	; 0x105e <LEDs_SetAllLEDs>
    1164:	8c e4       	ldi	r24, 0x4C	; 76

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, &uip_len);
    1166:	91 e0       	ldi	r25, 0x01	; 1
    1168:	6f eb       	ldi	r22, 0xBF	; 191
    116a:	77 e0       	ldi	r23, 0x07	; 7
    116c:	47 e4       	ldi	r20, 0x47	; 71
    116e:	56 e0       	ldi	r21, 0x06	; 6
    1170:	0e 94 32 37 	call	0x6e64	; 0x6e64 <RNDIS_Device_ReadPacket>
    1174:	10 c0       	rjmp	.+32     	; 0x1196 <uIPManagement_ManageNetwork+0x74>
    1176:	8a ee       	ldi	r24, 0xEA	; 234
	}
	else
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Host_IsPacketReceived(&Ethernet_RNDIS_Interface_Host)))
    1178:	91 e0       	ldi	r25, 0x01	; 1
    117a:	0e 94 ed 3a 	call	0x75da	; 0x75da <RNDIS_Host_IsPacketReceived>
    117e:	88 23       	and	r24, r24
    1180:	a1 f1       	breq	.+104    	; 0x11ea <uIPManagement_ManageNetwork+0xc8>
    1182:	80 ed       	ldi	r24, 0xD0	; 208
		  return;

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    1184:	6c df       	rcall	.-296    	; 0x105e <LEDs_SetAllLEDs>
    1186:	8a ee       	ldi	r24, 0xEA	; 234
    1188:	91 e0       	ldi	r25, 0x01	; 1

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Host_ReadPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, &uip_len);
    118a:	6f eb       	ldi	r22, 0xBF	; 191
    118c:	77 e0       	ldi	r23, 0x07	; 7
    118e:	47 e4       	ldi	r20, 0x47	; 71
    1190:	56 e0       	ldi	r21, 0x06	; 6
    1192:	0e 94 0a 3b 	call	0x7614	; 0x7614 <RNDIS_Host_ReadPacket>
    1196:	80 91 47 06 	lds	r24, 0x0647
	}

	/* If the packet contains an Ethernet frame, process it */
	if (uip_len > 0)
    119a:	90 91 48 06 	lds	r25, 0x0648
    119e:	00 97       	sbiw	r24, 0x00	; 0
    11a0:	11 f1       	breq	.+68     	; 0x11e6 <uIPManagement_ManageNetwork+0xc4>
    11a2:	80 91 cb 07 	lds	r24, 0x07CB
	{
		switch (((struct uip_eth_hdr*)uip_buf)->type)
    11a6:	90 91 cc 07 	lds	r25, 0x07CC
    11aa:	88 30       	cpi	r24, 0x08	; 8
    11ac:	91 05       	cpc	r25, r1
    11ae:	29 f0       	breq	.+10     	; 0x11ba <uIPManagement_ManageNetwork+0x98>
    11b0:	26 e0       	ldi	r18, 0x06	; 6
    11b2:	88 30       	cpi	r24, 0x08	; 8
    11b4:	92 07       	cpc	r25, r18
    11b6:	b9 f4       	brne	.+46     	; 0x11e6 <uIPManagement_ManageNetwork+0xc4>
    11b8:	0c c0       	rjmp	.+24     	; 0x11d2 <uIPManagement_ManageNetwork+0xb0>
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	0e 94 43 11 	call	0x2286	; 0x2286 <uip_process>
			case HTONS(UIP_ETHTYPE_IP):
				/* Filter packet by MAC destination */
				uip_arp_ipin();

				/* Process Incoming packet */
				uip_input();
    11c0:	80 91 47 06 	lds	r24, 0x0647

				/* If a response was generated, send it */
				if (uip_len > 0)
    11c4:	90 91 48 06 	lds	r25, 0x0648
    11c8:	00 97       	sbiw	r24, 0x00	; 0
    11ca:	69 f0       	breq	.+26     	; 0x11e6 <uIPManagement_ManageNetwork+0xc4>
    11cc:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <uip_arp_out>
				{
					/* Add destination MAC to outgoing packet */
					uip_arp_out();
    11d0:	08 c0       	rjmp	.+16     	; 0x11e2 <uIPManagement_ManageNetwork+0xc0>
    11d2:	0e 94 31 1a 	call	0x3462	; 0x3462 <uip_arp_arpin>
				}

				break;
			case HTONS(UIP_ETHTYPE_ARP):
				/* Process ARP packet */
				uip_arp_arpin();
    11d6:	80 91 47 06 	lds	r24, 0x0647

				/* If a response was generated, send it */
				if (uip_len > 0)
    11da:	90 91 48 06 	lds	r25, 0x0648
    11de:	00 97       	sbiw	r24, 0x00	; 0
    11e0:	11 f0       	breq	.+4      	; 0x11e6 <uIPManagement_ManageNetwork+0xc4>
    11e2:	0e 94 35 1c 	call	0x386a	; 0x386a <uip_split_output>
				  uip_split_output();
    11e6:	80 e2       	ldi	r24, 0x20	; 32
    11e8:	3a df       	rcall	.-396    	; 0x105e <LEDs_SetAllLEDs>

				break;
		}
	}

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
    11ea:	c0 e0       	ldi	r28, 0x00	; 0
    11ec:	d0 e0       	ldi	r29, 0x00	; 0
    11ee:	01 e7       	ldi	r16, 0x71	; 113

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    11f0:	10 e0       	ldi	r17, 0x00	; 0
    11f2:	c0 9f       	mul	r28, r16
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		uip_poll_conn(&uip_conns[i]);
    11f4:	c0 01       	movw	r24, r0
    11f6:	c1 9f       	mul	r28, r17
    11f8:	90 0d       	add	r25, r0
    11fa:	d0 9f       	mul	r29, r16
    11fc:	90 0d       	add	r25, r0
    11fe:	11 24       	eor	r1, r1
    1200:	8a 5a       	subi	r24, 0xAA	; 170
    1202:	99 4f       	sbci	r25, 0xF9	; 249
    1204:	90 93 55 06 	sts	0x0655, r25
    1208:	80 93 54 06 	sts	0x0654, r24
    120c:	83 e0       	ldi	r24, 0x03	; 3
    120e:	0e 94 43 11 	call	0x2286	; 0x2286 <uip_process>
    1212:	80 91 47 06 	lds	r24, 0x0647
    1216:	90 91 48 06 	lds	r25, 0x0648

		/* If a response was generated, send it */
		if (uip_len > 0)
    121a:	00 97       	sbiw	r24, 0x00	; 0
    121c:	21 f0       	breq	.+8      	; 0x1226 <uIPManagement_ManageNetwork+0x104>
    121e:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <uip_arp_out>
    1222:	0e 94 35 1c 	call	0x386a	; 0x386a <uip_split_output>
		{
			/* Add destination MAC to outgoing packet */
			uip_arp_out();
    1226:	21 96       	adiw	r28, 0x01	; 1

			/* Split and send the outgoing packet */
			uip_split_output();
    1228:	c3 30       	cpi	r28, 0x03	; 3
    122a:	d1 05       	cpc	r29, r1
    122c:	11 f7       	brne	.-60     	; 0x11f2 <uIPManagement_ManageNetwork+0xd0>

/** Manages the currently open network connections, including TCP and (if enabled) UDP. */
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    122e:	88 e7       	ldi	r24, 0x78	; 120
    1230:	93 e0       	ldi	r25, 0x03	; 3
    1232:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <timer_expired>
			uip_split_output();
		}
	}

	/* Manage open connections for timeouts */
	if (timer_expired(&ConnectionTimer))
    1236:	00 97       	sbiw	r24, 0x00	; 0
    1238:	09 f4       	brne	.+2      	; 0x123c <uIPManagement_ManageNetwork+0x11a>
    123a:	3c c0       	rjmp	.+120    	; 0x12b4 <uIPManagement_ManageNetwork+0x192>
    123c:	88 e7       	ldi	r24, 0x78	; 120
    123e:	93 e0       	ldi	r25, 0x03	; 3
    1240:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <timer_reset>
	{
		timer_reset(&ConnectionTimer);
    1244:	80 ed       	ldi	r24, 0xD0	; 208
    1246:	0b df       	rcall	.-490    	; 0x105e <LEDs_SetAllLEDs>
    1248:	c0 e0       	ldi	r28, 0x00	; 0

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    124a:	d0 e0       	ldi	r29, 0x00	; 0
    124c:	01 e7       	ldi	r16, 0x71	; 113
    124e:	10 e0       	ldi	r17, 0x00	; 0
    1250:	c0 9f       	mul	r28, r16
    1252:	c0 01       	movw	r24, r0

		for (uint8_t i = 0; i < UIP_CONNS; i++)
		{
			/* Run periodic connection management for each TCP connection */
			uip_periodic(i);
    1254:	c1 9f       	mul	r28, r17
    1256:	90 0d       	add	r25, r0
    1258:	d0 9f       	mul	r29, r16
    125a:	90 0d       	add	r25, r0
    125c:	11 24       	eor	r1, r1
    125e:	8a 5a       	subi	r24, 0xAA	; 170
    1260:	99 4f       	sbci	r25, 0xF9	; 249
    1262:	90 93 55 06 	sts	0x0655, r25
    1266:	80 93 54 06 	sts	0x0654, r24
    126a:	82 e0       	ldi	r24, 0x02	; 2
    126c:	0e 94 43 11 	call	0x2286	; 0x2286 <uip_process>
    1270:	80 91 47 06 	lds	r24, 0x0647
    1274:	90 91 48 06 	lds	r25, 0x0648

			/* If a response was generated, send it */
			if (uip_len > 0)
    1278:	00 97       	sbiw	r24, 0x00	; 0
    127a:	21 f0       	breq	.+8      	; 0x1284 <uIPManagement_ManageNetwork+0x162>
    127c:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <uip_arp_out>
    1280:	0e 94 35 1c 	call	0x386a	; 0x386a <uip_split_output>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    1284:	21 96       	adiw	r28, 0x01	; 1
    1286:	c3 30       	cpi	r28, 0x03	; 3

				/* Split and send the outgoing packet */
				uip_split_output();
    1288:	d1 05       	cpc	r29, r1
    128a:	11 f7       	brne	.-60     	; 0x1250 <uIPManagement_ManageNetwork+0x12e>
    128c:	8d ea       	ldi	r24, 0xAD	; 173
	{
		timer_reset(&ConnectionTimer);

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
    128e:	9d e0       	ldi	r25, 0x0D	; 13
    1290:	90 93 51 06 	sts	0x0651, r25

		#if defined(ENABLE_DHCP_CLIENT)
		for (uint8_t i = 0; i < UIP_UDP_CONNS; i++)
		{
			/* Run periodic connection management for each UDP connection */
			uip_udp_periodic(i);
    1294:	80 93 50 06 	sts	0x0650, r24
    1298:	85 e0       	ldi	r24, 0x05	; 5
    129a:	f5 d7       	rcall	.+4074   	; 0x2286 <uip_process>
    129c:	80 91 47 06 	lds	r24, 0x0647
    12a0:	90 91 48 06 	lds	r25, 0x0648
    12a4:	00 97       	sbiw	r24, 0x00	; 0

			/* If a response was generated, send it */
			if (uip_len > 0)
    12a6:	21 f0       	breq	.+8      	; 0x12b0 <uIPManagement_ManageNetwork+0x18e>
    12a8:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <uip_arp_out>
    12ac:	0e 94 35 1c 	call	0x386a	; 0x386a <uip_split_output>
    12b0:	80 e2       	ldi	r24, 0x20	; 32
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    12b2:	d5 de       	rcall	.-598    	; 0x105e <LEDs_SetAllLEDs>
    12b4:	8c e7       	ldi	r24, 0x7C	; 124

				/* Split and send the outgoing packet */
				uip_split_output();
    12b6:	93 e0       	ldi	r25, 0x03	; 3
    12b8:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <timer_expired>
			}
		}
		#endif

		LEDs_SetAllLEDs(LEDMASK_USB_READY);
    12bc:	00 97       	sbiw	r24, 0x00	; 0
    12be:	31 f0       	breq	.+12     	; 0x12cc <uIPManagement_ManageNetwork+0x1aa>
	}

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
    12c0:	8c e7       	ldi	r24, 0x7C	; 124
    12c2:	93 e0       	ldi	r25, 0x03	; 3
    12c4:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <timer_reset>
    12c8:	0e 94 f5 19 	call	0x33ea	; 0x33ea <uip_arp_timer>
	{
		timer_reset(&ARPTimer);
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	1f 91       	pop	r17
    12d2:	0f 91       	pop	r16
		uip_arp_timer();
    12d4:	08 95       	ret

000012d6 <uIPManagement_TCPCallback>:
    12d6:	e0 91 54 06 	lds	r30, 0x0654
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    12da:	f0 91 55 06 	lds	r31, 0x0655
    12de:	84 81       	ldd	r24, Z+4	; 0x04
    12e0:	95 81       	ldd	r25, Z+5	; 0x05
 *  to the appropriate TCP protocol application based on the connection's listen port number.
 */
void uIPManagement_TCPCallback(void)
{
	/* Call the correct TCP application based on the port number the connection is listening on */
	switch (uip_conn->lport)
    12e2:	27 e1       	ldi	r18, 0x17	; 23
    12e4:	80 30       	cpi	r24, 0x00	; 0
    12e6:	92 07       	cpc	r25, r18
    12e8:	29 f0       	breq	.+10     	; 0x12f4 <uIPManagement_TCPCallback+0x1e>
    12ea:	20 e5       	ldi	r18, 0x50	; 80
    12ec:	80 30       	cpi	r24, 0x00	; 0
    12ee:	92 07       	cpc	r25, r18
    12f0:	11 f4       	brne	.+4      	; 0x12f6 <uIPManagement_TCPCallback+0x20>
	{
		case HTONS(HTTP_SERVER_PORT):
			HTTPServerApp_Callback();
    12f2:	db c3       	rjmp	.+1974   	; 0x1aaa <HTTPServerApp_Callback>
    12f4:	69 c5       	rjmp	.+2770   	; 0x1dc8 <TELNETServerApp_Callback>
			break;
    12f6:	08 95       	ret

000012f8 <uIPManagement_UDPCallback>:
		#if defined(ENABLE_TELNET_SERVER)
		case HTONS(TELNET_SERVER_PORT):
			TELNETServerApp_Callback();
    12f8:	e0 91 50 06 	lds	r30, 0x0650
    12fc:	f0 91 51 06 	lds	r31, 0x0651
 *  to the appropriate UDP protocol application based on the connection's listen port number.
 */
void uIPManagement_UDPCallback(void)
{
	/* Call the correct UDP application based on the port number the connection is listening on */
	switch (uip_udp_conn->lport)
    1300:	84 81       	ldd	r24, Z+4	; 0x04
    1302:	95 81       	ldd	r25, Z+5	; 0x05
    1304:	23 e4       	ldi	r18, 0x43	; 67
    1306:	80 30       	cpi	r24, 0x00	; 0
    1308:	92 07       	cpc	r25, r18
    130a:	29 f0       	breq	.+10     	; 0x1316 <uIPManagement_UDPCallback+0x1e>
    130c:	24 e4       	ldi	r18, 0x44	; 68
    130e:	80 30       	cpi	r24, 0x00	; 0
    1310:	92 07       	cpc	r25, r18
    1312:	11 f4       	brne	.+4      	; 0x1318 <uIPManagement_UDPCallback+0x20>
	{
		#if defined(ENABLE_DHCP_CLIENT)
		case HTONS(DHCP_CLIENT_PORT):
			DHCPClientApp_Callback();
    1314:	ba c0       	rjmp	.+372    	; 0x148a <DHCPClientApp_Callback>
    1316:	8d c2       	rjmp	.+1306   	; 0x1832 <DHCPServerApp_Callback>
			break;
    1318:	08 95       	ret

0000131a <DHCPCommon_SetOption>:
 */
uint8_t DHCPCommon_SetOption(uint8_t* DHCPOptionList,
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
    131a:	0f 93       	push	r16
    131c:	1f 93       	push	r17
    131e:	cf 93       	push	r28
    1320:	df 93       	push	r29
    1322:	ec 01       	movw	r28, r24
    1324:	14 2f       	mov	r17, r20
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1326:	05 c0       	rjmp	.+10     	; 0x1332 <DHCPCommon_SetOption+0x18>
	  DHCPOptionList += (DHCPOptionList[1] + 2);
    1328:	89 81       	ldd	r24, Y+1	; 0x01
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	02 96       	adiw	r24, 0x02	; 2
    132e:	c8 0f       	add	r28, r24
    1330:	d9 1f       	adc	r29, r25
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1332:	08 81       	ld	r16, Y
    1334:	0f 3f       	cpi	r16, 0xFF	; 255
    1336:	c1 f7       	brne	.-16     	; 0x1328 <DHCPCommon_SetOption+0xe>
	  DHCPOptionList += (DHCPOptionList[1] + 2);

	/* Overwrite the existing terminator with the new option, add a new terminator at the end of the list */
	DHCPOptionList[0] = Option;
    1338:	68 83       	st	Y, r22
	DHCPOptionList[1] = DataLen;
    133a:	19 83       	std	Y+1, r17	; 0x01
	memcpy(&DHCPOptionList[2], OptionData, DataLen);
    133c:	ce 01       	movw	r24, r28
    133e:	02 96       	adiw	r24, 0x02	; 2
    1340:	b9 01       	movw	r22, r18
    1342:	41 2f       	mov	r20, r17
    1344:	50 e0       	ldi	r21, 0x00	; 0
    1346:	0e 94 79 3c 	call	0x78f2	; 0x78f2 <memcpy>
	DHCPOptionList[2 + DataLen] = DHCP_OPTION_END;
    134a:	c1 0f       	add	r28, r17
    134c:	d1 1d       	adc	r29, r1
    134e:	0a 83       	std	Y+2, r16	; 0x02

	/* Calculate the total number of bytes added to the outgoing packet */
	return (2 + DataLen);
}
    1350:	81 2f       	mov	r24, r17
    1352:	8e 5f       	subi	r24, 0xFE	; 254
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	08 95       	ret

0000135e <DHCPCommon_GetOption>:
 *  \return Boolean true if the option was found in the DHCP packet's options list, false otherwise
 */
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
    135e:	fc 01       	movw	r30, r24
    1360:	ca 01       	movw	r24, r20
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1362:	12 c0       	rjmp	.+36     	; 0x1388 <DHCPCommon_GetOption+0x2a>
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
    1364:	26 17       	cp	r18, r22
    1366:	51 f4       	brne	.+20     	; 0x137c <DHCPCommon_GetOption+0x1e>
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    1368:	21 81       	ldd	r18, Z+1	; 0x01
    136a:	bf 01       	movw	r22, r30
    136c:	6e 5f       	subi	r22, 0xFE	; 254
    136e:	7f 4f       	sbci	r23, 0xFF	; 255
    1370:	42 2f       	mov	r20, r18
    1372:	50 e0       	ldi	r21, 0x00	; 0
    1374:	0e 94 79 3c 	call	0x78f2	; 0x78f2 <memcpy>

			/* Indicate that the requested option data was successfully retrieved */
			return true;
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	08 95       	ret
		}

		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
    137c:	21 81       	ldd	r18, Z+1	; 0x01
    137e:	30 e0       	ldi	r19, 0x00	; 0
    1380:	2e 5f       	subi	r18, 0xFE	; 254
    1382:	3f 4f       	sbci	r19, 0xFF	; 255
    1384:	e2 0f       	add	r30, r18
    1386:	f3 1f       	adc	r31, r19
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1388:	20 81       	ld	r18, Z
    138a:	2f 3f       	cpi	r18, 0xFF	; 255
    138c:	59 f7       	brne	.-42     	; 0x1364 <DHCPCommon_GetOption+0x6>
		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
	}

	/* Requested option not found in the incoming packet's DHCP options list */
	return false;
    138e:	80 e0       	ldi	r24, 0x00	; 0
}
    1390:	08 95       	ret

00001392 <DHCPClientApp_FillDHCPHeader>:
 *  \return Size in bytes of the created DHCP packet
 */
static uint16_t DHCPClientApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             uip_udp_appstate_t* const AppState)
{
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	fc 01       	movw	r30, r24
    1398:	86 2f       	mov	r24, r22
    139a:	da 01       	movw	r26, r20
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    139c:	90 ef       	ldi	r25, 0xF0	; 240
    139e:	ef 01       	movw	r28, r30
    13a0:	19 92       	st	Y+, r1
    13a2:	9a 95       	dec	r25
    13a4:	e9 f7       	brne	.-6      	; 0x13a0 <DHCPClientApp_FillDHCPHeader+0xe>

	/* Fill out the DHCP packet header */
	DHCPHeader->Operation             = DHCP_OP_BOOTREQUEST;
    13a6:	91 e0       	ldi	r25, 0x01	; 1
    13a8:	90 83       	st	Z, r25
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    13aa:	91 83       	std	Z+1, r25	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    13ac:	96 e0       	ldi	r25, 0x06	; 6
    13ae:	92 83       	std	Z+2, r25	; 0x02
	DHCPHeader->Hops                  = 0;
    13b0:	13 82       	std	Z+3, r1	; 0x03
	DHCPHeader->TransactionID         = DHCP_TRANSACTION_ID;
    13b2:	46 e6       	ldi	r20, 0x66	; 102
    13b4:	54 e5       	ldi	r21, 0x54	; 84
    13b6:	64 e2       	ldi	r22, 0x24	; 36
    13b8:	73 e1       	ldi	r23, 0x13	; 19
    13ba:	44 83       	std	Z+4, r20	; 0x04
    13bc:	55 83       	std	Z+5, r21	; 0x05
    13be:	66 83       	std	Z+6, r22	; 0x06
    13c0:	77 83       	std	Z+7, r23	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    13c2:	11 86       	std	Z+9, r1	; 0x09
    13c4:	10 86       	std	Z+8, r1	; 0x08
	DHCPHeader->Flags                 = HTONS(BOOTP_BROADCAST);
    13c6:	20 e8       	ldi	r18, 0x80	; 128
    13c8:	30 e0       	ldi	r19, 0x00	; 0
    13ca:	33 87       	std	Z+11, r19	; 0x0b
    13cc:	22 87       	std	Z+10, r18	; 0x0a
	memcpy(&DHCPHeader->ClientIP,     &uip_hostaddr,        sizeof(uip_ipaddr_t));
    13ce:	40 91 bb 07 	lds	r20, 0x07BB
    13d2:	50 91 bc 07 	lds	r21, 0x07BC
    13d6:	60 91 bd 07 	lds	r22, 0x07BD
    13da:	70 91 be 07 	lds	r23, 0x07BE
    13de:	44 87       	std	Z+12, r20	; 0x0c
    13e0:	55 87       	std	Z+13, r21	; 0x0d
    13e2:	66 87       	std	Z+14, r22	; 0x0e
    13e4:	77 87       	std	Z+15, r23	; 0x0f
	memcpy(&DHCPHeader->YourIP,       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, sizeof(uip_ipaddr_t));
    13e6:	15 96       	adiw	r26, 0x05	; 5
    13e8:	4d 91       	ld	r20, X+
    13ea:	5d 91       	ld	r21, X+
    13ec:	6d 91       	ld	r22, X+
    13ee:	7c 91       	ld	r23, X
    13f0:	18 97       	sbiw	r26, 0x08	; 8
    13f2:	40 8b       	std	Z+16, r20	; 0x10
    13f4:	51 8b       	std	Z+17, r21	; 0x11
    13f6:	62 8b       	std	Z+18, r22	; 0x12
    13f8:	73 8b       	std	Z+19, r23	; 0x13
	memcpy(&DHCPHeader->NextServerIP, &AppState->DHCPClient.DHCPOffer_Data.ServerIP,    sizeof(uip_ipaddr_t));
    13fa:	51 96       	adiw	r26, 0x11	; 17
    13fc:	4d 91       	ld	r20, X+
    13fe:	5d 91       	ld	r21, X+
    1400:	6d 91       	ld	r22, X+
    1402:	7c 91       	ld	r23, X
    1404:	54 97       	sbiw	r26, 0x14	; 20
    1406:	44 8b       	std	Z+20, r20	; 0x14
    1408:	55 8b       	std	Z+21, r21	; 0x15
    140a:	66 8b       	std	Z+22, r22	; 0x16
    140c:	77 8b       	std	Z+23, r23	; 0x17
	memcpy(&DHCPHeader->ClientHardwareAddress, &MACAddress, sizeof(struct uip_eth_addr));
    140e:	ef 01       	movw	r28, r30
    1410:	6c 96       	adiw	r28, 0x1c	; 28
    1412:	ae ef       	ldi	r26, 0xFE	; 254
    1414:	b3 e0       	ldi	r27, 0x03	; 3
    1416:	0d 90       	ld	r0, X+
    1418:	09 92       	st	Y+, r0
    141a:	91 50       	subi	r25, 0x01	; 1
    141c:	e1 f7       	brne	.-8      	; 0x1416 <DHCPClientApp_FillDHCPHeader+0x84>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    141e:	df 01       	movw	r26, r30
    1420:	a4 51       	subi	r26, 0x14	; 20
    1422:	bf 4f       	sbci	r27, 0xFF	; 255
    1424:	43 e6       	ldi	r20, 0x63	; 99
    1426:	52 e8       	ldi	r21, 0x82	; 130
    1428:	63 e5       	ldi	r22, 0x53	; 83
    142a:	73 e6       	ldi	r23, 0x63	; 99
    142c:	4d 93       	st	X+, r20
    142e:	5d 93       	st	X+, r21
    1430:	6d 93       	st	X+, r22
    1432:	7c 93       	st	X, r23
    1434:	13 97       	sbiw	r26, 0x03	; 3

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    1436:	df 01       	movw	r26, r30
    1438:	a0 51       	subi	r26, 0x10	; 16
    143a:	bf 4f       	sbci	r27, 0xFF	; 255
    143c:	95 e3       	ldi	r25, 0x35	; 53
    143e:	9c 93       	st	X, r25
	DHCPHeader->Options[1]            = 1;
    1440:	df 01       	movw	r26, r30
    1442:	af 50       	subi	r26, 0x0F	; 15
    1444:	bf 4f       	sbci	r27, 0xFF	; 255
    1446:	91 e0       	ldi	r25, 0x01	; 1
    1448:	9c 93       	st	X, r25
	DHCPHeader->Options[2]            = DHCPMessageType;
    144a:	df 01       	movw	r26, r30
    144c:	ae 50       	subi	r26, 0x0E	; 14
    144e:	bf 4f       	sbci	r27, 0xFF	; 255
    1450:	8c 93       	st	X, r24
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    1452:	ed 50       	subi	r30, 0x0D	; 13
    1454:	ff 4f       	sbci	r31, 0xFF	; 255
    1456:	8f ef       	ldi	r24, 0xFF	; 255
    1458:	80 83       	st	Z, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    145a:	84 ef       	ldi	r24, 0xF4	; 244
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	df 91       	pop	r29
    1460:	cf 91       	pop	r28
    1462:	08 95       	ret

00001464 <DHCPClientApp_Init>:

/** Initialization function for the DHCP client. */
void DHCPClientApp_Init(void)
{
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* Connection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_SERVER_PORT));
    1464:	84 e2       	ldi	r24, 0x24	; 36
    1466:	93 e0       	ldi	r25, 0x03	; 3
    1468:	60 e0       	ldi	r22, 0x00	; 0
    146a:	73 e4       	ldi	r23, 0x43	; 67
    146c:	74 d6       	rcall	.+3304   	; 0x2156 <uip_udp_new>
    146e:	00 97       	sbiw	r24, 0x00	; 0

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (Connection != NULL)
    1470:	59 f0       	breq	.+22     	; 0x1488 <DHCPClientApp_Init+0x24>
    1472:	20 e0       	ldi	r18, 0x00	; 0
	{
		uip_udp_appstate_t* const AppState = &Connection->appstate;
		uip_udp_bind(Connection, HTONS(DHCP_CLIENT_PORT));
    1474:	34 e4       	ldi	r19, 0x44	; 68
    1476:	fc 01       	movw	r30, r24
    1478:	35 83       	std	Z+5, r19	; 0x05
    147a:	24 83       	std	Z+4, r18	; 0x04
    147c:	11 86       	std	Z+9, r1	; 0x09

		/* Set the initial client state */
		AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    147e:	0a 96       	adiw	r24, 0x0a	; 10

		/* Set timeout period to half a second for a DHCP server to respond */
		timer_set(&AppState->DHCPClient.Timeout, CLOCK_SECOND / 2);
    1480:	62 e3       	ldi	r22, 0x32	; 50
    1482:	70 e0       	ldi	r23, 0x00	; 0
    1484:	0c 94 df 1b 	jmp	0x37be	; 0x37be <timer_set>
    1488:	08 95       	ret

0000148a <DHCPClientApp_Callback>:
    148a:	af 92       	push	r10

/** uIP stack application callback for the DHCP client. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPClientApp_Callback(void)
{
    148c:	bf 92       	push	r11
    148e:	cf 92       	push	r12
    1490:	df 92       	push	r13
    1492:	ef 92       	push	r14
    1494:	ff 92       	push	r15
    1496:	0f 93       	push	r16
    1498:	1f 93       	push	r17
    149a:	cf 93       	push	r28
    149c:	df 93       	push	r29
    149e:	00 d0       	rcall	.+0      	; 0x14a0 <DHCPClientApp_Callback+0x16>
    14a0:	00 d0       	rcall	.+0      	; 0x14a2 <DHCPClientApp_Callback+0x18>
    14a2:	0f 92       	push	r0
    14a4:	cd b7       	in	r28, 0x3d	; 61
    14a6:	de b7       	in	r29, 0x3e	; 62
	uip_udp_appstate_t* const AppState    = &uip_udp_conn->appstate;
    14a8:	00 91 50 06 	lds	r16, 0x0650
    14ac:	10 91 51 06 	lds	r17, 0x0651
    14b0:	a8 01       	movw	r20, r16
    14b2:	47 5f       	subi	r20, 0xF7	; 247
    14b4:	5f 4f       	sbci	r21, 0xFF	; 255
	DHCP_Header_t*      const AppData     = (DHCP_Header_t*)uip_appdata;
    14b6:	e0 90 52 06 	lds	r14, 0x0652
    14ba:	f0 90 53 06 	lds	r15, 0x0653
	uint16_t                  AppDataSize = 0;

	switch (AppState->DHCPClient.CurrentState)
    14be:	d8 01       	movw	r26, r16
    14c0:	19 96       	adiw	r26, 0x09	; 9
    14c2:	8c 91       	ld	r24, X
    14c4:	19 97       	sbiw	r26, 0x09	; 9
    14c6:	81 30       	cpi	r24, 0x01	; 1
    14c8:	09 f4       	brne	.+2      	; 0x14cc <DHCPClientApp_Callback+0x42>
    14ca:	43 c0       	rjmp	.+134    	; 0x1552 <DHCPClientApp_Callback+0xc8>
    14cc:	81 30       	cpi	r24, 0x01	; 1
    14ce:	38 f0       	brcs	.+14     	; 0x14de <DHCPClientApp_Callback+0x54>
    14d0:	82 30       	cpi	r24, 0x02	; 2
    14d2:	09 f4       	brne	.+2      	; 0x14d6 <DHCPClientApp_Callback+0x4c>
    14d4:	88 c0       	rjmp	.+272    	; 0x15e6 <DHCPClientApp_Callback+0x15c>
    14d6:	83 30       	cpi	r24, 0x03	; 3
    14d8:	09 f0       	breq	.+2      	; 0x14dc <DHCPClientApp_Callback+0x52>
    14da:	01 c1       	rjmp	.+514    	; 0x16de <DHCPClientApp_Callback+0x254>
    14dc:	b1 c0       	rjmp	.+354    	; 0x1640 <DHCPClientApp_Callback+0x1b6>
	{
		case DHCP_STATE_SendDiscover:
			/* Clear all DHCP settings, reset client IP address */
			memset(&AppState->DHCPClient.DHCPOffer_Data, 0x00, sizeof(AppState->DHCPClient.DHCPOffer_Data));
    14de:	c8 01       	movw	r24, r16
    14e0:	0e 96       	adiw	r24, 0x0e	; 14
    14e2:	fc 01       	movw	r30, r24
    14e4:	80 e1       	ldi	r24, 0x10	; 16
    14e6:	df 01       	movw	r26, r30
    14e8:	1d 92       	st	X+, r1
    14ea:	8a 95       	dec	r24
    14ec:	e9 f7       	brne	.-6      	; 0x14e8 <DHCPClientApp_Callback+0x5e>
			uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    14ee:	f8 01       	movw	r30, r16
    14f0:	86 85       	ldd	r24, Z+14	; 0x0e
    14f2:	97 85       	ldd	r25, Z+15	; 0x0f
    14f4:	a0 89       	ldd	r26, Z+16	; 0x10
    14f6:	b1 89       	ldd	r27, Z+17	; 0x11
    14f8:	80 93 bb 07 	sts	0x07BB, r24
    14fc:	90 93 bc 07 	sts	0x07BC, r25
    1500:	a0 93 bd 07 	sts	0x07BD, r26
    1504:	b0 93 be 07 	sts	0x07BE, r27

			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_DISCOVER, AppState);
    1508:	c7 01       	movw	r24, r14
    150a:	61 e0       	ldi	r22, 0x01	; 1
    150c:	42 df       	rcall	.-380    	; 0x1392 <DHCPClientApp_FillDHCPHeader>
    150e:	6c 01       	movw	r12, r24
    1510:	fe 01       	movw	r30, r28

			/* Add the required DHCP options list to the packet */
			uint8_t RequiredOptionList[] = {DHCP_OPTION_SUBNET_MASK, DHCP_OPTION_ROUTER, DHCP_OPTION_DNS_SERVER};
    1512:	33 96       	adiw	r30, 0x03	; 3
    1514:	a0 e4       	ldi	r26, 0x40	; 64
    1516:	b2 e0       	ldi	r27, 0x02	; 2
    1518:	83 e0       	ldi	r24, 0x03	; 3
    151a:	0d 90       	ld	r0, X+
    151c:	01 92       	st	Z+, r0
    151e:	81 50       	subi	r24, 0x01	; 1
    1520:	e1 f7       	brne	.-8      	; 0x151a <DHCPClientApp_Callback+0x90>
    1522:	c7 01       	movw	r24, r14
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_LIST, sizeof(RequiredOptionList),
    1524:	80 51       	subi	r24, 0x10	; 16
    1526:	9f 4f       	sbci	r25, 0xFF	; 255
    1528:	67 e3       	ldi	r22, 0x37	; 55
    152a:	43 e0       	ldi	r20, 0x03	; 3
    152c:	9e 01       	movw	r18, r28
    152e:	2d 5f       	subi	r18, 0xFD	; 253
    1530:	3f 4f       	sbci	r19, 0xFF	; 255
    1532:	f3 de       	rcall	.-538    	; 0x131a <DHCPCommon_SetOption>
    1534:	b6 01       	movw	r22, r12
    1536:	68 0f       	add	r22, r24
    1538:	71 1d       	adc	r23, r1
    153a:	80 91 52 06 	lds	r24, 0x0652
			                                    RequiredOptionList);

			/* Send the DHCP DISCOVER packet */
			uip_udp_send(AppDataSize);
    153e:	90 91 53 06 	lds	r25, 0x0653
    1542:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>
    1546:	c8 01       	movw	r24, r16
    1548:	0a 96       	adiw	r24, 0x0a	; 10

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    154a:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <timer_reset>
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	72 c0       	rjmp	.+228    	; 0x1636 <DHCPClientApp_Callback+0x1ac>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForOffer;
    1552:	80 91 4f 06 	lds	r24, 0x064F

			break;
		case DHCP_STATE_WaitForOffer:
			if (!(uip_newdata()))
    1556:	81 ff       	sbrs	r24, 1
    1558:	77 c0       	rjmp	.+238    	; 0x1648 <DHCPClientApp_Callback+0x1be>
    155a:	f7 01       	movw	r30, r14
    155c:	84 81       	ldd	r24, Z+4	; 0x04

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    155e:	95 81       	ldd	r25, Z+5	; 0x05
    1560:	a6 81       	ldd	r26, Z+6	; 0x06
    1562:	b7 81       	ldd	r27, Z+7	; 0x07
    1564:	86 36       	cpi	r24, 0x66	; 102
    1566:	f4 e5       	ldi	r31, 0x54	; 84
    1568:	9f 07       	cpc	r25, r31
    156a:	f4 e2       	ldi	r31, 0x24	; 36
    156c:	af 07       	cpc	r26, r31
    156e:	f3 e1       	ldi	r31, 0x13	; 19
    1570:	bf 07       	cpc	r27, r31
    1572:	09 f0       	breq	.+2      	; 0x1576 <DHCPClientApp_Callback+0xec>
    1574:	b4 c0       	rjmp	.+360    	; 0x16de <DHCPClientApp_Callback+0x254>
    1576:	80 ef       	ldi	r24, 0xF0	; 240
    1578:	c8 2e       	mov	r12, r24
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    157a:	d1 2c       	mov	r13, r1
    157c:	ce 0c       	add	r12, r14
    157e:	df 1c       	adc	r13, r15
    1580:	c6 01       	movw	r24, r12
    1582:	65 e3       	ldi	r22, 0x35	; 53
    1584:	ae 01       	movw	r20, r28
    1586:	4e 5f       	subi	r20, 0xFE	; 254
    1588:	5f 4f       	sbci	r21, 0xFF	; 255
    158a:	e9 de       	rcall	.-558    	; 0x135e <DHCPCommon_GetOption>
    158c:	88 23       	and	r24, r24
    158e:	09 f4       	brne	.+2      	; 0x1592 <DHCPClientApp_Callback+0x108>
    1590:	a6 c0       	rjmp	.+332    	; 0x16de <DHCPClientApp_Callback+0x254>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1592:	ba 80       	ldd	r11, Y+2	; 0x02
    1594:	22 e0       	ldi	r18, 0x02	; 2
    1596:	b2 16       	cp	r11, r18
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    1598:	09 f0       	breq	.+2      	; 0x159c <DHCPClientApp_Callback+0x112>
    159a:	a1 c0       	rjmp	.+322    	; 0x16de <DHCPClientApp_Callback+0x254>
    159c:	f7 01       	movw	r30, r14
    159e:	80 89       	ldd	r24, Z+16	; 0x10
    15a0:	91 89       	ldd	r25, Z+17	; 0x11
			    (OfferResponse_MessageType == DHCP_OFFER))
			{
				/* Received a DHCP offer for an IP address, copy over values for later request */
				memcpy(&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, &AppData->YourIP, sizeof(uip_ipaddr_t));
    15a2:	a2 89       	ldd	r26, Z+18	; 0x12
    15a4:	b3 89       	ldd	r27, Z+19	; 0x13
    15a6:	f8 01       	movw	r30, r16
    15a8:	86 87       	std	Z+14, r24	; 0x0e
    15aa:	97 87       	std	Z+15, r25	; 0x0f
    15ac:	a0 8b       	std	Z+16, r26	; 0x10
    15ae:	b1 8b       	std	Z+17, r27	; 0x11
    15b0:	a8 01       	movw	r20, r16
    15b2:	4e 5e       	subi	r20, 0xEE	; 238
    15b4:	5f 4f       	sbci	r21, 0xFF	; 255
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK, &AppState->DHCPClient.DHCPOffer_Data.Netmask);
    15b6:	c6 01       	movw	r24, r12
    15b8:	61 e0       	ldi	r22, 0x01	; 1
    15ba:	d1 de       	rcall	.-606    	; 0x135e <DHCPCommon_GetOption>
    15bc:	a8 01       	movw	r20, r16
    15be:	4a 5e       	subi	r20, 0xEA	; 234
    15c0:	5f 4f       	sbci	r21, 0xFF	; 255
    15c2:	c6 01       	movw	r24, r12
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_ROUTER,      &AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    15c4:	63 e0       	ldi	r22, 0x03	; 3
    15c6:	cb de       	rcall	.-618    	; 0x135e <DHCPCommon_GetOption>
    15c8:	a8 01       	movw	r20, r16
    15ca:	46 5e       	subi	r20, 0xE6	; 230
    15cc:	5f 4f       	sbci	r21, 0xFF	; 255
    15ce:	c6 01       	movw	r24, r12
    15d0:	66 e3       	ldi	r22, 0x36	; 54
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SERVER_ID,   &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    15d2:	c5 de       	rcall	.-630    	; 0x135e <DHCPCommon_GetOption>
    15d4:	c8 01       	movw	r24, r16
    15d6:	0a 96       	adiw	r24, 0x0a	; 10
    15d8:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <timer_reset>
    15dc:	d8 01       	movw	r26, r16
    15de:	19 96       	adiw	r26, 0x09	; 9

				timer_reset(&AppState->DHCPClient.Timeout);
    15e0:	bc 92       	st	X, r11
    15e2:	19 97       	sbiw	r26, 0x09	; 9
    15e4:	7c c0       	rjmp	.+248    	; 0x16de <DHCPClientApp_Callback+0x254>
    15e6:	c7 01       	movw	r24, r14
				AppState->DHCPClient.CurrentState = DHCP_STATE_SendRequest;
    15e8:	63 e0       	ldi	r22, 0x03	; 3
    15ea:	d3 de       	rcall	.-602    	; 0x1392 <DHCPClientApp_FillDHCPHeader>
    15ec:	5c 01       	movw	r10, r24
    15ee:	e0 ef       	ldi	r30, 0xF0	; 240
    15f0:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);
    15f2:	ee 0e       	add	r14, r30
    15f4:	ff 1e       	adc	r15, r31
    15f6:	98 01       	movw	r18, r16
    15f8:	22 5f       	subi	r18, 0xF2	; 242
    15fa:	3f 4f       	sbci	r19, 0xFF	; 255

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15fc:	c7 01       	movw	r24, r14
    15fe:	62 e3       	ldi	r22, 0x32	; 50
    1600:	44 e0       	ldi	r20, 0x04	; 4
    1602:	8b de       	rcall	.-746    	; 0x131a <DHCPCommon_SetOption>
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    1604:	c8 2e       	mov	r12, r24
    1606:	98 01       	movw	r18, r16
    1608:	26 5e       	subi	r18, 0xE6	; 230
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    160a:	3f 4f       	sbci	r19, 0xFF	; 255
    160c:	c7 01       	movw	r24, r14
    160e:	66 e3       	ldi	r22, 0x36	; 54
    1610:	44 e0       	ldi	r20, 0x04	; 4
    1612:	83 de       	rcall	.-762    	; 0x131a <DHCPCommon_SetOption>
    1614:	68 2f       	mov	r22, r24
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    1616:	70 e0       	ldi	r23, 0x00	; 0
    1618:	6c 0d       	add	r22, r12
    161a:	71 1d       	adc	r23, r1
			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    161c:	6a 0d       	add	r22, r10
    161e:	7b 1d       	adc	r23, r11
    1620:	80 91 52 06 	lds	r24, 0x0652
    1624:	90 91 53 06 	lds	r25, 0x0653
    1628:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    162c:	c8 01       	movw	r24, r16
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    162e:	0a 96       	adiw	r24, 0x0a	; 10
    1630:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <timer_reset>
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);

			/* Send the DHCP REQUEST packet */
			uip_udp_send(AppDataSize);
    1634:	83 e0       	ldi	r24, 0x03	; 3
    1636:	d8 01       	movw	r26, r16
    1638:	19 96       	adiw	r26, 0x09	; 9
    163a:	8c 93       	st	X, r24
    163c:	19 97       	sbiw	r26, 0x09	; 9

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    163e:	4f c0       	rjmp	.+158    	; 0x16de <DHCPClientApp_Callback+0x254>
    1640:	80 91 4f 06 	lds	r24, 0x064F
    1644:	81 fd       	sbrc	r24, 1
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForACK;
    1646:	0a c0       	rjmp	.+20     	; 0x165c <DHCPClientApp_Callback+0x1d2>
    1648:	c8 01       	movw	r24, r16
    164a:	0a 96       	adiw	r24, 0x0a	; 10
    164c:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <timer_expired>

			break;
    1650:	00 97       	sbiw	r24, 0x00	; 0
		case DHCP_STATE_WaitForACK:
			if (!(uip_newdata()))
    1652:	09 f4       	brne	.+2      	; 0x1656 <DHCPClientApp_Callback+0x1cc>
    1654:	44 c0       	rjmp	.+136    	; 0x16de <DHCPClientApp_Callback+0x254>
    1656:	f8 01       	movw	r30, r16
    1658:	11 86       	std	Z+9, r1	; 0x09
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    165a:	41 c0       	rjmp	.+130    	; 0x16de <DHCPClientApp_Callback+0x254>
    165c:	f7 01       	movw	r30, r14
    165e:	84 81       	ldd	r24, Z+4	; 0x04
    1660:	95 81       	ldd	r25, Z+5	; 0x05
    1662:	a6 81       	ldd	r26, Z+6	; 0x06
    1664:	b7 81       	ldd	r27, Z+7	; 0x07
    1666:	86 36       	cpi	r24, 0x66	; 102
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1668:	f4 e5       	ldi	r31, 0x54	; 84
    166a:	9f 07       	cpc	r25, r31
    166c:	f4 e2       	ldi	r31, 0x24	; 36

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    166e:	af 07       	cpc	r26, r31
    1670:	f3 e1       	ldi	r31, 0x13	; 19
    1672:	bf 07       	cpc	r27, r31
    1674:	a1 f5       	brne	.+104    	; 0x16de <DHCPClientApp_Callback+0x254>
    1676:	c7 01       	movw	r24, r14
    1678:	80 51       	subi	r24, 0x10	; 16
    167a:	9f 4f       	sbci	r25, 0xFF	; 255
    167c:	65 e3       	ldi	r22, 0x35	; 53
    167e:	ae 01       	movw	r20, r28
    1680:	4f 5f       	subi	r20, 0xFF	; 255
    1682:	5f 4f       	sbci	r21, 0xFF	; 255
    1684:	6c de       	rcall	.-808    	; 0x135e <DHCPCommon_GetOption>
    1686:	88 23       	and	r24, r24
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1688:	51 f1       	breq	.+84     	; 0x16de <DHCPClientApp_Callback+0x254>
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	85 30       	cpi	r24, 0x05	; 5
    168e:	39 f5       	brne	.+78     	; 0x16de <DHCPClientApp_Callback+0x254>
    1690:	f8 01       	movw	r30, r16
    1692:	86 85       	ldd	r24, Z+14	; 0x0e
    1694:	97 85       	ldd	r25, Z+15	; 0x0f
    1696:	a0 89       	ldd	r26, Z+16	; 0x10
    1698:	b1 89       	ldd	r27, Z+17	; 0x11

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    169a:	80 93 bb 07 	sts	0x07BB, r24
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    169e:	90 93 bc 07 	sts	0x07BC, r25
    16a2:	a0 93 bd 07 	sts	0x07BD, r26
			    (RequestResponse_MessageType == DHCP_ACK))
			{
				/* Set the new network parameters from the DHCP server */
				uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    16a6:	b0 93 be 07 	sts	0x07BE, r27
    16aa:	82 89       	ldd	r24, Z+18	; 0x12
    16ac:	93 89       	ldd	r25, Z+19	; 0x13
    16ae:	a4 89       	ldd	r26, Z+20	; 0x14
    16b0:	b5 89       	ldd	r27, Z+21	; 0x15
    16b2:	80 93 b7 07 	sts	0x07B7, r24
    16b6:	90 93 b8 07 	sts	0x07B8, r25
    16ba:	a0 93 b9 07 	sts	0x07B9, r26
				uip_setnetmask((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.Netmask);
    16be:	b0 93 ba 07 	sts	0x07BA, r27
    16c2:	86 89       	ldd	r24, Z+22	; 0x16
    16c4:	97 89       	ldd	r25, Z+23	; 0x17
    16c6:	a0 8d       	ldd	r26, Z+24	; 0x18
    16c8:	b1 8d       	ldd	r27, Z+25	; 0x19
    16ca:	80 93 b3 07 	sts	0x07B3, r24
    16ce:	90 93 b4 07 	sts	0x07B4, r25
    16d2:	a0 93 b5 07 	sts	0x07B5, r26
				uip_setdraddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    16d6:	b0 93 b6 07 	sts	0x07B6, r27
    16da:	84 e0       	ldi	r24, 0x04	; 4
    16dc:	81 87       	std	Z+9, r24	; 0x09
    16de:	0f 90       	pop	r0
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	0f 90       	pop	r0
    16e6:	0f 90       	pop	r0
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17

				AppState->DHCPClient.CurrentState = DHCP_STATE_AddressLeased;
    16ee:	0f 91       	pop	r16
    16f0:	ff 90       	pop	r15
			}

			break;
	}
}
    16f2:	ef 90       	pop	r14
    16f4:	df 90       	pop	r13
    16f6:	cf 90       	pop	r12
    16f8:	bf 90       	pop	r11
    16fa:	af 90       	pop	r10
    16fc:	08 95       	ret

000016fe <DHCPServerApp_FillDHCPHeader>:
static uint16_t DHCPServerApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             const struct uip_eth_addr* const ClientHardwareAddress,
											 const uip_ipaddr_t* const PreferredClientIP,
                                             const uint32_t TransactionID)
{
    16fe:	df 92       	push	r13
    1700:	ef 92       	push	r14
    1702:	ff 92       	push	r15
    1704:	0f 93       	push	r16
    1706:	1f 93       	push	r17
    1708:	cf 93       	push	r28
    170a:	df 93       	push	r29
    170c:	fc 01       	movw	r30, r24
    170e:	d6 2e       	mov	r13, r22
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    1710:	60 ef       	ldi	r22, 0xF0	; 240
    1712:	ef 01       	movw	r28, r30
    1714:	19 92       	st	Y+, r1
    1716:	6a 95       	dec	r22
    1718:	e9 f7       	brne	.-6      	; 0x1714 <DHCPServerApp_FillDHCPHeader+0x16>

	DHCPHeader->Operation             = DHCPMessageType;
    171a:	d0 82       	st	Z, r13
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	61 83       	std	Z+1, r22	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    1720:	66 e0       	ldi	r22, 0x06	; 6
    1722:	62 83       	std	Z+2, r22	; 0x02
	DHCPHeader->Hops                  = 0;
    1724:	13 82       	std	Z+3, r1	; 0x03
	DHCPHeader->TransactionID         = TransactionID;
    1726:	e4 82       	std	Z+4, r14	; 0x04
    1728:	f5 82       	std	Z+5, r15	; 0x05
    172a:	06 83       	std	Z+6, r16	; 0x06
    172c:	17 83       	std	Z+7, r17	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    172e:	11 86       	std	Z+9, r1	; 0x09
    1730:	10 86       	std	Z+8, r1	; 0x08
	DHCPHeader->Flags                 = 0;
    1732:	13 86       	std	Z+11, r1	; 0x0b
    1734:	12 86       	std	Z+10, r1	; 0x0a
	memcpy(&DHCPHeader->NextServerIP, &uip_hostaddr, sizeof(uip_ipaddr_t));
    1736:	80 91 bb 07 	lds	r24, 0x07BB
    173a:	90 91 bc 07 	lds	r25, 0x07BC
    173e:	a0 91 bd 07 	lds	r26, 0x07BD
    1742:	b0 91 be 07 	lds	r27, 0x07BE
    1746:	84 8b       	std	Z+20, r24	; 0x14
    1748:	95 8b       	std	Z+21, r25	; 0x15
    174a:	a6 8b       	std	Z+22, r26	; 0x16
    174c:	b7 8b       	std	Z+23, r27	; 0x17
	memcpy(&DHCPHeader->YourIP, PreferredClientIP, sizeof(uip_ipaddr_t));
    174e:	e9 01       	movw	r28, r18
    1750:	88 81       	ld	r24, Y
    1752:	99 81       	ldd	r25, Y+1	; 0x01
    1754:	aa 81       	ldd	r26, Y+2	; 0x02
    1756:	bb 81       	ldd	r27, Y+3	; 0x03
    1758:	80 8b       	std	Z+16, r24	; 0x10
    175a:	91 8b       	std	Z+17, r25	; 0x11
    175c:	a2 8b       	std	Z+18, r26	; 0x12
    175e:	b3 8b       	std	Z+19, r27	; 0x13
	memcpy(&DHCPHeader->ClientHardwareAddress, ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1760:	ef 01       	movw	r28, r30
    1762:	6c 96       	adiw	r28, 0x1c	; 28
    1764:	da 01       	movw	r26, r20
    1766:	86 e0       	ldi	r24, 0x06	; 6
    1768:	0d 90       	ld	r0, X+
    176a:	09 92       	st	Y+, r0
    176c:	81 50       	subi	r24, 0x01	; 1
    176e:	e1 f7       	brne	.-8      	; 0x1768 <DHCPServerApp_FillDHCPHeader+0x6a>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    1770:	df 01       	movw	r26, r30
    1772:	a4 51       	subi	r26, 0x14	; 20
    1774:	bf 4f       	sbci	r27, 0xFF	; 255
    1776:	43 e6       	ldi	r20, 0x63	; 99
    1778:	52 e8       	ldi	r21, 0x82	; 130
    177a:	63 e5       	ldi	r22, 0x53	; 83
    177c:	73 e6       	ldi	r23, 0x63	; 99
    177e:	4d 93       	st	X+, r20
    1780:	5d 93       	st	X+, r21
    1782:	6d 93       	st	X+, r22
    1784:	7c 93       	st	X, r23
    1786:	13 97       	sbiw	r26, 0x03	; 3

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    1788:	df 01       	movw	r26, r30
    178a:	a0 51       	subi	r26, 0x10	; 16
    178c:	bf 4f       	sbci	r27, 0xFF	; 255
    178e:	85 e3       	ldi	r24, 0x35	; 53
    1790:	8c 93       	st	X, r24
	DHCPHeader->Options[1]            = 1;
    1792:	df 01       	movw	r26, r30
    1794:	af 50       	subi	r26, 0x0F	; 15
    1796:	bf 4f       	sbci	r27, 0xFF	; 255
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	8c 93       	st	X, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    179c:	df 01       	movw	r26, r30
    179e:	ae 50       	subi	r26, 0x0E	; 14
    17a0:	bf 4f       	sbci	r27, 0xFF	; 255
    17a2:	dc 92       	st	X, r13
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    17a4:	ed 50       	subi	r30, 0x0D	; 13
    17a6:	ff 4f       	sbci	r31, 0xFF	; 255
    17a8:	8f ef       	ldi	r24, 0xFF	; 255
    17aa:	80 83       	st	Z, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    17ac:	84 ef       	ldi	r24, 0xF4	; 244
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	df 91       	pop	r29
    17b2:	cf 91       	pop	r28
    17b4:	1f 91       	pop	r17
    17b6:	0f 91       	pop	r16
    17b8:	ff 90       	pop	r15
    17ba:	ef 90       	pop	r14
    17bc:	df 90       	pop	r13
    17be:	08 95       	ret

000017c0 <DHCPServerApp_CheckIfIPLeased.isra.0>:
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    17c0:	88 23       	and	r24, r24
    17c2:	d1 f0       	breq	.+52     	; 0x17f8 <DHCPServerApp_CheckIfIPLeased.isra.0+0x38>
    17c4:	90 91 be 07 	lds	r25, 0x07BE
    17c8:	89 17       	cp	r24, r25
    17ca:	c1 f0       	breq	.+48     	; 0x17fc <DHCPServerApp_CheckIfIPLeased.isra.0+0x3c>
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    17cc:	98 2f       	mov	r25, r24
    17ce:	97 70       	andi	r25, 0x07	; 7
    17d0:	21 e0       	ldi	r18, 0x01	; 1
    17d2:	30 e0       	ldi	r19, 0x00	; 0
    17d4:	02 c0       	rjmp	.+4      	; 0x17da <DHCPServerApp_CheckIfIPLeased.isra.0+0x1a>
    17d6:	22 0f       	add	r18, r18
    17d8:	33 1f       	adc	r19, r19
    17da:	9a 95       	dec	r25
    17dc:	e2 f7       	brpl	.-8      	; 0x17d6 <DHCPServerApp_CheckIfIPLeased.isra.0+0x16>
 *
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    17de:	86 95       	lsr	r24
    17e0:	86 95       	lsr	r24
    17e2:	86 95       	lsr	r24
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    17e4:	e8 2f       	mov	r30, r24
    17e6:	f0 e0       	ldi	r31, 0x00	; 0
    17e8:	ec 5f       	subi	r30, 0xFC	; 252
    17ea:	fb 4f       	sbci	r31, 0xFB	; 251
    17ec:	90 81       	ld	r25, Z
    17ee:	92 23       	and	r25, r18
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 *
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	29 f4       	brne	.+10     	; 0x17fe <DHCPServerApp_CheckIfIPLeased.isra.0+0x3e>
    17f4:	80 e0       	ldi	r24, 0x00	; 0
    17f6:	08 95       	ret

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
	  return false;
	else
	  return true;
    17f8:	81 e0       	ldi	r24, 0x01	; 1
    17fa:	08 95       	ret
    17fc:	81 e0       	ldi	r24, 0x01	; 1
}
    17fe:	08 95       	ret

00001800 <DHCPServerApp_Init>:

/** Initialization function for the DHCP server. */
void DHCPServerApp_Init(void)
{
	/* Listen on port 67 for DHCP server connections from hosts */
	uip_listen(HTONS(DHCP_SERVER_PORT));
    1800:	80 e0       	ldi	r24, 0x00	; 0
    1802:	93 e4       	ldi	r25, 0x43	; 67
    1804:	8a d4       	rcall	.+2324   	; 0x211a <uip_listen>
    1806:	84 e2       	ldi	r24, 0x24	; 36

	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* BroadcastConnection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_CLIENT_PORT));
    1808:	93 e0       	ldi	r25, 0x03	; 3
    180a:	60 e0       	ldi	r22, 0x00	; 0
    180c:	74 e4       	ldi	r23, 0x44	; 68
    180e:	a3 d4       	rcall	.+2374   	; 0x2156 <uip_udp_new>
    1810:	00 97       	sbiw	r24, 0x00	; 0
    1812:	39 f0       	breq	.+14     	; 0x1822 <DHCPServerApp_Init+0x22>

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (BroadcastConnection != NULL)
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	33 e4       	ldi	r19, 0x43	; 67
	  uip_udp_bind(BroadcastConnection, HTONS(DHCP_SERVER_PORT));
    1818:	dc 01       	movw	r26, r24
    181a:	15 96       	adiw	r26, 0x05	; 5
    181c:	3c 93       	st	X, r19
    181e:	2e 93       	st	-X, r18
    1820:	14 97       	sbiw	r26, 0x04	; 4
    1822:	8f e1       	ldi	r24, 0x1F	; 31
    1824:	e4 e0       	ldi	r30, 0x04	; 4

	/* Set all IP addresses as unleased */
	memset(LeasedIPs, 0x00, sizeof(LeasedIPs));
    1826:	f4 e0       	ldi	r31, 0x04	; 4
    1828:	df 01       	movw	r26, r30
    182a:	1d 92       	st	X+, r1
    182c:	8a 95       	dec	r24
    182e:	e9 f7       	brne	.-6      	; 0x182a <DHCPServerApp_Init+0x2a>
    1830:	08 95       	ret

00001832 <DHCPServerApp_Callback>:
    1832:	af 92       	push	r10
}
    1834:	bf 92       	push	r11

/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
    1836:	cf 92       	push	r12
    1838:	df 92       	push	r13
    183a:	ef 92       	push	r14
    183c:	ff 92       	push	r15
    183e:	0f 93       	push	r16
    1840:	1f 93       	push	r17
    1842:	cf 93       	push	r28
    1844:	df 93       	push	r29
    1846:	cd b7       	in	r28, 0x3d	; 61
    1848:	de b7       	in	r29, 0x3e	; 62
    184a:	64 97       	sbiw	r28, 0x14	; 20
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	de bf       	out	0x3e, r29	; 62
    1852:	0f be       	out	0x3f, r0	; 63
    1854:	cd bf       	out	0x3d, r28	; 61
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
    1856:	c0 90 52 06 	lds	r12, 0x0652
    185a:	d0 90 53 06 	lds	r13, 0x0653
	uint16_t             AppDataSize = 0;

	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
    185e:	80 91 4f 06 	lds	r24, 0x064F
    1862:	81 ff       	sbrs	r24, 1
    1864:	09 c1       	rjmp	.+530    	; 0x1a78 <DHCPServerApp_Callback+0x246>
	{
		/* Get the DHCP message type (if present), otherwise early-abort */
		uint8_t DHCPMessageType;
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &DHCPMessageType)))
    1866:	80 ef       	ldi	r24, 0xF0	; 240
    1868:	a8 2e       	mov	r10, r24
    186a:	b1 2c       	mov	r11, r1
    186c:	ac 0c       	add	r10, r12
    186e:	bd 1c       	adc	r11, r13
    1870:	c5 01       	movw	r24, r10
    1872:	65 e3       	ldi	r22, 0x35	; 53
    1874:	ae 01       	movw	r20, r28
    1876:	4f 5f       	subi	r20, 0xFF	; 255
    1878:	5f 4f       	sbci	r21, 0xFF	; 255
    187a:	71 dd       	rcall	.-1310   	; 0x135e <DHCPCommon_GetOption>
    187c:	88 23       	and	r24, r24
    187e:	09 f4       	brne	.+2      	; 0x1882 <DHCPServerApp_Callback+0x50>
    1880:	fb c0       	rjmp	.+502    	; 0x1a78 <DHCPServerApp_Callback+0x246>
    1882:	80 91 b7 07 	lds	r24, 0x07B7
		uip_ipaddr_t        Netmask, GatewayIPAddress, PreferredClientIP;
		struct uip_eth_addr RemoteMACAddress;
		uint32_t            TransactionID;

		/* Get configured network mask, gateway IP and extract out DHCP transaction ID and remote IP */
		uip_getnetmask(&Netmask);
    1886:	90 91 b8 07 	lds	r25, 0x07B8
    188a:	a0 91 b9 07 	lds	r26, 0x07B9
    188e:	b0 91 ba 07 	lds	r27, 0x07BA
    1892:	8a 87       	std	Y+10, r24	; 0x0a
    1894:	9b 87       	std	Y+11, r25	; 0x0b
    1896:	ac 87       	std	Y+12, r26	; 0x0c
    1898:	bd 87       	std	Y+13, r27	; 0x0d
    189a:	80 91 b3 07 	lds	r24, 0x07B3
		uip_getdraddr(&GatewayIPAddress);
    189e:	90 91 b4 07 	lds	r25, 0x07B4
    18a2:	a0 91 b5 07 	lds	r26, 0x07B5
    18a6:	b0 91 b6 07 	lds	r27, 0x07B6
    18aa:	8e 83       	std	Y+6, r24	; 0x06
    18ac:	9f 83       	std	Y+7, r25	; 0x07
    18ae:	a8 87       	std	Y+8, r26	; 0x08
    18b0:	b9 87       	std	Y+9, r27	; 0x09
    18b2:	de 01       	movw	r26, r28
		memcpy(&RemoteMACAddress, &AppData->ClientHardwareAddress, sizeof(struct uip_eth_addr));
    18b4:	1e 96       	adiw	r26, 0x0e	; 14
    18b6:	f6 01       	movw	r30, r12
    18b8:	7c 96       	adiw	r30, 0x1c	; 28
    18ba:	86 e0       	ldi	r24, 0x06	; 6
    18bc:	01 90       	ld	r0, Z+
    18be:	0d 92       	st	X+, r0
    18c0:	81 50       	subi	r24, 0x01	; 1
    18c2:	e1 f7       	brne	.-8      	; 0x18bc <DHCPServerApp_Callback+0x8a>
    18c4:	f6 01       	movw	r30, r12
		TransactionID = AppData->TransactionID;
    18c6:	e4 80       	ldd	r14, Z+4	; 0x04
    18c8:	f5 80       	ldd	r15, Z+5	; 0x05
    18ca:	06 81       	ldd	r16, Z+6	; 0x06
    18cc:	17 81       	ldd	r17, Z+7	; 0x07
    18ce:	c5 01       	movw	r24, r10

		/* Try to extract out the client's preferred IP address if it is indicated in the packet */
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, &PreferredClientIP)))
    18d0:	62 e3       	ldi	r22, 0x32	; 50
    18d2:	ae 01       	movw	r20, r28
    18d4:	4e 5f       	subi	r20, 0xFE	; 254
    18d6:	5f 4f       	sbci	r21, 0xFF	; 255
    18d8:	42 dd       	rcall	.-1404   	; 0x135e <DHCPCommon_GetOption>
    18da:	88 23       	and	r24, r24
    18dc:	61 f4       	brne	.+24     	; 0x18f6 <DHCPServerApp_Callback+0xc4>
    18de:	80 91 20 03 	lds	r24, 0x0320
		  memcpy(&PreferredClientIP, &uip_all_zeroes_addr, sizeof(uip_ipaddr_t));
    18e2:	90 91 21 03 	lds	r25, 0x0321
    18e6:	a0 91 22 03 	lds	r26, 0x0322
    18ea:	b0 91 23 03 	lds	r27, 0x0323
    18ee:	8a 83       	std	Y+2, r24	; 0x02
    18f0:	9b 83       	std	Y+3, r25	; 0x03
    18f2:	ac 83       	std	Y+4, r26	; 0x04
    18f4:	bd 83       	std	Y+5, r27	; 0x05
    18f6:	89 81       	ldd	r24, Y+1	; 0x01
    18f8:	83 30       	cpi	r24, 0x03	; 3

		switch (DHCPMessageType)
    18fa:	09 f4       	brne	.+2      	; 0x18fe <DHCPServerApp_Callback+0xcc>
    18fc:	41 c0       	rjmp	.+130    	; 0x1980 <DHCPServerApp_Callback+0x14e>
    18fe:	87 30       	cpi	r24, 0x07	; 7
    1900:	09 f4       	brne	.+2      	; 0x1904 <DHCPServerApp_Callback+0xd2>
    1902:	a1 c0       	rjmp	.+322    	; 0x1a46 <DHCPServerApp_Callback+0x214>
    1904:	81 30       	cpi	r24, 0x01	; 1
    1906:	09 f0       	breq	.+2      	; 0x190a <DHCPServerApp_Callback+0xd8>
    1908:	b7 c0       	rjmp	.+366    	; 0x1a78 <DHCPServerApp_Callback+0x246>
    190a:	8d 81       	ldd	r24, Y+5	; 0x05
    190c:	59 df       	rcall	.-334    	; 0x17c0 <DHCPServerApp_CheckIfIPLeased.isra.0>
		{
			case DHCP_DISCOVER:
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
    190e:	88 23       	and	r24, r24
    1910:	b9 f0       	breq	.+46     	; 0x1940 <DHCPServerApp_Callback+0x10e>
    1912:	80 91 bb 07 	lds	r24, 0x07BB
    1916:	90 91 bc 07 	lds	r25, 0x07BC
 *
 *  \param[out] NewIPAddress  Location where the generated IP Address should be stored
 */
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
    191a:	a0 91 bd 07 	lds	r26, 0x07BD
    191e:	b0 91 be 07 	lds	r27, 0x07BE
    1922:	8a 83       	std	Y+2, r24	; 0x02
    1924:	9b 83       	std	Y+3, r25	; 0x03
    1926:	ac 83       	std	Y+4, r26	; 0x04
    1928:	bd 83       	std	Y+5, r27	; 0x05
    192a:	91 e0       	ldi	r25, 0x01	; 1
    192c:	9d 83       	std	Y+5, r25	; 0x05
    192e:	89 2f       	mov	r24, r25

	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    1930:	9c 8b       	std	Y+20, r25	; 0x14
	{
		/* Update new IP address to lease with the current IP address to test */
		NewIPAddress->u8[3] = IP;
    1932:	46 df       	rcall	.-372    	; 0x17c0 <DHCPServerApp_CheckIfIPLeased.isra.0>

		/* If we've found an unleased IP, abort with the updated IP stored for the called */
		if (!(DHCPServerApp_CheckIfIPLeased(NewIPAddress)))
    1934:	9c 89       	ldd	r25, Y+20	; 0x14
    1936:	88 23       	and	r24, r24
    1938:	19 f0       	breq	.+6      	; 0x1940 <DHCPServerApp_Callback+0x10e>
    193a:	9f 5f       	subi	r25, 0xFF	; 255
    193c:	9e 3f       	cpi	r25, 0xFE	; 254
    193e:	b1 f7       	brne	.-20     	; 0x192c <DHCPServerApp_Callback+0xfa>
    1940:	c6 01       	movw	r24, r12
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);

	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    1942:	62 e0       	ldi	r22, 0x02	; 2
    1944:	ae 01       	movw	r20, r28
    1946:	42 5f       	subi	r20, 0xF2	; 242
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
				  DHCPServerApp_GetUnleasedIP(&PreferredClientIP);

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    1948:	5f 4f       	sbci	r21, 0xFF	; 255
    194a:	9e 01       	movw	r18, r28
    194c:	2e 5f       	subi	r18, 0xFE	; 254
    194e:	3f 4f       	sbci	r19, 0xFF	; 255
    1950:	d6 de       	rcall	.-596    	; 0x16fe <DHCPServerApp_FillDHCPHeader>
    1952:	6c 01       	movw	r12, r24
    1954:	c5 01       	movw	r24, r10
    1956:	61 e0       	ldi	r22, 0x01	; 1
    1958:	44 e0       	ldi	r20, 0x04	; 4
    195a:	9e 01       	movw	r18, r28
    195c:	26 5f       	subi	r18, 0xF6	; 246

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    195e:	3f 4f       	sbci	r19, 0xFF	; 255
    1960:	dc dc       	rcall	.-1608   	; 0x131a <DHCPCommon_SetOption>
    1962:	e8 2e       	mov	r14, r24
    1964:	c5 01       	movw	r24, r10
    1966:	63 e0       	ldi	r22, 0x03	; 3
    1968:	44 e0       	ldi	r20, 0x04	; 4
    196a:	9e 01       	movw	r18, r28
    196c:	2a 5f       	subi	r18, 0xFA	; 250
    196e:	3f 4f       	sbci	r19, 0xFF	; 255
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1970:	d4 dc       	rcall	.-1624   	; 0x131a <DHCPCommon_SetOption>
    1972:	08 2f       	mov	r16, r24
    1974:	10 e0       	ldi	r17, 0x00	; 0
    1976:	0e 0d       	add	r16, r14
    1978:	11 1d       	adc	r17, r1
    197a:	0c 0d       	add	r16, r12
    197c:	1d 1d       	adc	r17, r13
    197e:	41 c0       	rjmp	.+130    	; 0x1a02 <DHCPServerApp_Callback+0x1d0>
    1980:	8d 81       	ldd	r24, Y+5	; 0x05
    1982:	1e df       	rcall	.-452    	; 0x17c0 <DHCPServerApp_CheckIfIPLeased.isra.0>

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1984:	88 23       	and	r24, r24
    1986:	a1 f5       	brne	.+104    	; 0x19f0 <DHCPServerApp_Callback+0x1be>
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1988:	c6 01       	movw	r24, r12
    198a:	65 e0       	ldi	r22, 0x05	; 5
    198c:	ae 01       	movw	r20, r28
				uip_udp_send(AppDataSize);

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    198e:	42 5f       	subi	r20, 0xF2	; 242
    1990:	5f 4f       	sbci	r21, 0xFF	; 255
    1992:	9e 01       	movw	r18, r28
    1994:	2e 5f       	subi	r18, 0xFE	; 254
    1996:	3f 4f       	sbci	r19, 0xFF	; 255
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    1998:	b2 de       	rcall	.-668    	; 0x16fe <DHCPServerApp_FillDHCPHeader>
    199a:	6c 01       	movw	r12, r24
    199c:	c5 01       	movw	r24, r10
    199e:	61 e0       	ldi	r22, 0x01	; 1
    19a0:	44 e0       	ldi	r20, 0x04	; 4
    19a2:	9e 01       	movw	r18, r28
    19a4:	26 5f       	subi	r18, 0xF6	; 246
    19a6:	3f 4f       	sbci	r19, 0xFF	; 255
    19a8:	b8 dc       	rcall	.-1680   	; 0x131a <DHCPCommon_SetOption>
    19aa:	e8 2e       	mov	r14, r24
    19ac:	c5 01       	movw	r24, r10

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    19ae:	63 e0       	ldi	r22, 0x03	; 3
    19b0:	44 e0       	ldi	r20, 0x04	; 4
    19b2:	9e 01       	movw	r18, r28
    19b4:	2a 5f       	subi	r18, 0xFA	; 250
    19b6:	3f 4f       	sbci	r19, 0xFF	; 255
    19b8:	b0 dc       	rcall	.-1696   	; 0x131a <DHCPCommon_SetOption>
    19ba:	08 2f       	mov	r16, r24
    19bc:	10 e0       	ldi	r17, 0x00	; 0
    19be:	0e 0d       	add	r16, r14
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    19c0:	11 1d       	adc	r17, r1
    19c2:	0c 0d       	add	r16, r12
    19c4:	1d 1d       	adc	r17, r13
    19c6:	8d 81       	ldd	r24, Y+5	; 0x05
    19c8:	e8 2f       	mov	r30, r24
    19ca:	e6 95       	lsr	r30
    19cc:	e6 95       	lsr	r30
    19ce:	e6 95       	lsr	r30
    19d0:	f0 e0       	ldi	r31, 0x00	; 0
    19d2:	ec 5f       	subi	r30, 0xFC	; 252
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    19d4:	fb 4f       	sbci	r31, 0xFB	; 251
    19d6:	28 2f       	mov	r18, r24
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    19d8:	27 70       	andi	r18, 0x07	; 7
    19da:	81 e0       	ldi	r24, 0x01	; 1
					                                    sizeof(uip_ipaddr_t), &GatewayIPAddress);

					/* Mark the requested IP as leased to a client */
					DHCPServerApp_LeaseIP(&PreferredClientIP);
    19dc:	90 e0       	ldi	r25, 0x00	; 0
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    19de:	02 c0       	rjmp	.+4      	; 0x19e4 <DHCPServerApp_Callback+0x1b2>
    19e0:	88 0f       	add	r24, r24
    19e2:	99 1f       	adc	r25, r25
    19e4:	2a 95       	dec	r18
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    19e6:	e2 f7       	brpl	.-8      	; 0x19e0 <DHCPServerApp_Callback+0x1ae>
    19e8:	90 81       	ld	r25, Z
    19ea:	98 2b       	or	r25, r24
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    19ec:	90 83       	st	Z, r25
    19ee:	09 c0       	rjmp	.+18     	; 0x1a02 <DHCPServerApp_Callback+0x1d0>
    19f0:	c6 01       	movw	r24, r12
    19f2:	66 e0       	ldi	r22, 0x06	; 6
    19f4:	ae 01       	movw	r20, r28
    19f6:	42 5f       	subi	r20, 0xF2	; 242
    19f8:	5f 4f       	sbci	r21, 0xFF	; 255
    19fa:	20 e2       	ldi	r18, 0x20	; 32
    19fc:	33 e0       	ldi	r19, 0x03	; 3

	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    19fe:	7f de       	rcall	.-770    	; 0x16fe <DHCPServerApp_FillDHCPHeader>
    1a00:	8c 01       	movw	r16, r24
    1a02:	80 91 23 04 	lds	r24, 0x0423
					DHCPServerApp_LeaseIP(&PreferredClientIP);
				}
				else
				{
					/* Create a new DHCP NAK packet to reject the requested allocation */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_NAK, &RemoteMACAddress, &uip_all_zeroes_addr, TransactionID);
    1a06:	90 91 24 04 	lds	r25, 0x0424
    1a0a:	90 93 55 06 	sts	0x0655, r25
    1a0e:	80 93 54 06 	sts	0x0654, r24
    1a12:	83 e0       	ldi	r24, 0x03	; 3
    1a14:	38 d4       	rcall	.+2160   	; 0x2286 <uip_process>
    1a16:	e0 91 50 06 	lds	r30, 0x0650
				}

				/* Send the DHCP ACK or NAK packet */
				uip_poll_conn(BroadcastConnection);
    1a1a:	f0 91 51 06 	lds	r31, 0x0651
    1a1e:	80 91 24 03 	lds	r24, 0x0324
    1a22:	90 91 25 03 	lds	r25, 0x0325
    1a26:	a0 91 26 03 	lds	r26, 0x0326
    1a2a:	b0 91 27 03 	lds	r27, 0x0327
    1a2e:	80 83       	st	Z, r24
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    1a30:	91 83       	std	Z+1, r25	; 0x01
    1a32:	a2 83       	std	Z+2, r26	; 0x02
    1a34:	b3 83       	std	Z+3, r27	; 0x03
    1a36:	80 91 52 06 	lds	r24, 0x0652
    1a3a:	90 91 53 06 	lds	r25, 0x0653
    1a3e:	b8 01       	movw	r22, r16
    1a40:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>
    1a44:	19 c0       	rjmp	.+50     	; 0x1a78 <DHCPServerApp_Callback+0x246>
    1a46:	e0 91 50 06 	lds	r30, 0x0650
    1a4a:	f0 91 51 06 	lds	r31, 0x0651
    1a4e:	83 81       	ldd	r24, Z+3	; 0x03
				uip_udp_send(AppDataSize);
    1a50:	e8 2f       	mov	r30, r24
    1a52:	e6 95       	lsr	r30
    1a54:	e6 95       	lsr	r30
    1a56:	e6 95       	lsr	r30
    1a58:	f0 e0       	ldi	r31, 0x00	; 0
    1a5a:	ec 5f       	subi	r30, 0xFC	; 252
    1a5c:	fb 4f       	sbci	r31, 0xFB	; 251

				break;
    1a5e:	28 2f       	mov	r18, r24
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
}
    1a60:	27 70       	andi	r18, 0x07	; 7
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	90 e0       	ldi	r25, 0x00	; 0
    1a66:	02 c0       	rjmp	.+4      	; 0x1a6c <DHCPServerApp_Callback+0x23a>
    1a68:	88 0f       	add	r24, r24
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    1a6a:	99 1f       	adc	r25, r25
    1a6c:	2a 95       	dec	r18
    1a6e:	e2 f7       	brpl	.-8      	; 0x1a68 <DHCPServerApp_Callback+0x236>
    1a70:	80 95       	com	r24
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1a72:	90 81       	ld	r25, Z
    1a74:	89 23       	and	r24, r25
    1a76:	80 83       	st	Z, r24
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    1a78:	64 96       	adiw	r28, 0x14	; 20
    1a7a:	0f b6       	in	r0, 0x3f	; 63
    1a7c:	f8 94       	cli
    1a7e:	de bf       	out	0x3e, r29	; 62
    1a80:	0f be       	out	0x3f, r0	; 63
    1a82:	cd bf       	out	0x3d, r28	; 61
    1a84:	df 91       	pop	r29
    1a86:	cf 91       	pop	r28
    1a88:	1f 91       	pop	r17

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1a8a:	0f 91       	pop	r16
    1a8c:	ff 90       	pop	r15
    1a8e:	ef 90       	pop	r14
    1a90:	df 90       	pop	r13
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
				break;
		}
	}
}
    1a92:	cf 90       	pop	r12
    1a94:	bf 90       	pop	r11
    1a96:	af 90       	pop	r10
    1a98:	08 95       	ret

00001a9a <HTTPServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void HTTPServerApp_Init(void)
{
	/* Listen on port 80 for HTTP connections from hosts */
	uip_listen(HTONS(HTTP_SERVER_PORT));
    1a9a:	80 e0       	ldi	r24, 0x00	; 0
    1a9c:	90 e5       	ldi	r25, 0x50	; 80
    1a9e:	3d d3       	rcall	.+1658   	; 0x211a <uip_listen>
    1aa0:	80 e0       	ldi	r24, 0x00	; 0

	/* Mount the Dataflash disk via FatFS */
	f_mount(0, &DiskFATState);
    1aa2:	65 e2       	ldi	r22, 0x25	; 37
    1aa4:	74 e0       	ldi	r23, 0x04	; 4
    1aa6:	0c 94 11 1f 	jmp	0x3e22	; 0x3e22 <f_mount>

00001aaa <HTTPServerApp_Callback>:
    1aaa:	af 92       	push	r10
}
    1aac:	bf 92       	push	r11

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
{
    1aae:	cf 92       	push	r12
    1ab0:	df 92       	push	r13
    1ab2:	ef 92       	push	r14
    1ab4:	ff 92       	push	r15
    1ab6:	0f 93       	push	r16
    1ab8:	1f 93       	push	r17
    1aba:	cf 93       	push	r28
    1abc:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState = &uip_conn->appstate;
    1abe:	c0 91 54 06 	lds	r28, 0x0654
    1ac2:	d0 91 55 06 	lds	r29, 0x0655

	if (uip_aborted() || uip_timedout() || uip_closed())
    1ac6:	80 91 4f 06 	lds	r24, 0x064F
    1aca:	28 2f       	mov	r18, r24
    1acc:	85 fd       	sbrc	r24, 5
    1ace:	04 c0       	rjmp	.+8      	; 0x1ad8 <HTTPServerApp_Callback+0x2e>
    1ad0:	87 fd       	sbrc	r24, 7
    1ad2:	02 c0       	rjmp	.+4      	; 0x1ad8 <HTTPServerApp_Callback+0x2e>
    1ad4:	84 ff       	sbrs	r24, 4
    1ad6:	03 c0       	rjmp	.+6      	; 0x1ade <HTTPServerApp_Callback+0x34>
	{
		/* Lock to the closed state so that no further processing will occur on the connection */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_Closing;
    1ad8:	83 e0       	ldi	r24, 0x03	; 3
    1ada:	8c 8f       	std	Y+28, r24	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_Closing;
    1adc:	8d 8f       	std	Y+29, r24	; 0x1d
	}

	if (uip_connected())
    1ade:	26 ff       	sbrs	r18, 6
    1ae0:	12 c0       	rjmp	.+36     	; 0x1b06 <HTTPServerApp_Callback+0x5c>
	{
		/* New connection - initialize connection state values */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_OpenRequestedFile;
    1ae2:	1c 8e       	std	Y+28, r1	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_OpenRequestedFile;
    1ae4:	1d 8e       	std	Y+29, r1	; 0x1d
		AppState->HTTPServer.FileOpen      = false;
    1ae6:	fe 01       	movw	r30, r28
    1ae8:	e6 59       	subi	r30, 0x96	; 150
    1aea:	ff 4f       	sbci	r31, 0xFF	; 255
    1aec:	10 82       	st	Z, r1
		AppState->HTTPServer.ACKedFilePos  = 0;
    1aee:	fe 01       	movw	r30, r28
    1af0:	e5 59       	subi	r30, 0x95	; 149
    1af2:	ff 4f       	sbci	r31, 0xFF	; 255
    1af4:	10 82       	st	Z, r1
    1af6:	11 82       	std	Z+1, r1	; 0x01
    1af8:	12 82       	std	Z+2, r1	; 0x02
    1afa:	13 82       	std	Z+3, r1	; 0x03
		AppState->HTTPServer.SentChunkSize = 0;
    1afc:	fe 01       	movw	r30, r28
    1afe:	e1 59       	subi	r30, 0x91	; 145
    1b00:	ff 4f       	sbci	r31, 0xFF	; 255
    1b02:	11 82       	std	Z+1, r1	; 0x01
    1b04:	10 82       	st	Z, r1
	}

	if (uip_acked())
    1b06:	20 ff       	sbrs	r18, 0
    1b08:	19 c0       	rjmp	.+50     	; 0x1b3c <HTTPServerApp_Callback+0x92>
	{
		/* Add the amount of ACKed file data to the total sent file bytes counter */
		AppState->HTTPServer.ACKedFilePos += AppState->HTTPServer.SentChunkSize;
    1b0a:	8e 01       	movw	r16, r28
    1b0c:	05 59       	subi	r16, 0x95	; 149
    1b0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b10:	fe 01       	movw	r30, r28
    1b12:	e1 59       	subi	r30, 0x91	; 145
    1b14:	ff 4f       	sbci	r31, 0xFF	; 255
    1b16:	80 81       	ld	r24, Z
    1b18:	91 81       	ldd	r25, Z+1	; 0x01
    1b1a:	a0 e0       	ldi	r26, 0x00	; 0
    1b1c:	b0 e0       	ldi	r27, 0x00	; 0
    1b1e:	f8 01       	movw	r30, r16
    1b20:	40 81       	ld	r20, Z
    1b22:	51 81       	ldd	r21, Z+1	; 0x01
    1b24:	62 81       	ldd	r22, Z+2	; 0x02
    1b26:	73 81       	ldd	r23, Z+3	; 0x03
    1b28:	84 0f       	add	r24, r20
    1b2a:	95 1f       	adc	r25, r21
    1b2c:	a6 1f       	adc	r26, r22
    1b2e:	b7 1f       	adc	r27, r23
    1b30:	80 83       	st	Z, r24
    1b32:	91 83       	std	Z+1, r25	; 0x01
    1b34:	a2 83       	std	Z+2, r26	; 0x02
    1b36:	b3 83       	std	Z+3, r27	; 0x03

		/* Progress to the next state once the current state's data has been ACKed */
		AppState->HTTPServer.CurrentState = AppState->HTTPServer.NextState;
    1b38:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b3a:	8c 8f       	std	Y+28, r24	; 0x1c
	}

	if (uip_rexmit())
    1b3c:	22 ff       	sbrs	r18, 2
    1b3e:	0c c0       	rjmp	.+24     	; 0x1b58 <HTTPServerApp_Callback+0xae>
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
    1b40:	fe 01       	movw	r30, r28
    1b42:	e5 59       	subi	r30, 0x95	; 149
    1b44:	ff 4f       	sbci	r31, 0xFF	; 255
    1b46:	40 81       	ld	r20, Z
    1b48:	51 81       	ldd	r21, Z+1	; 0x01
    1b4a:	62 81       	ldd	r22, Z+2	; 0x02
    1b4c:	73 81       	ldd	r23, Z+3	; 0x03
    1b4e:	ce 01       	movw	r24, r28
    1b50:	80 5b       	subi	r24, 0xB0	; 176
    1b52:	9f 4f       	sbci	r25, 0xFF	; 255
    1b54:	0e 94 47 24 	call	0x488e	; 0x488e <f_lseek>
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1b58:	20 91 4f 06 	lds	r18, 0x064F
    1b5c:	30 e0       	ldi	r19, 0x00	; 0
    1b5e:	22 fd       	sbrc	r18, 2
    1b60:	0b c0       	rjmp	.+22     	; 0x1b78 <HTTPServerApp_Callback+0xce>
}

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
    1b62:	c9 01       	movw	r24, r18
    1b64:	83 70       	andi	r24, 0x03	; 3
    1b66:	90 70       	andi	r25, 0x00	; 0
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1b68:	00 97       	sbiw	r24, 0x00	; 0
    1b6a:	31 f4       	brne	.+12     	; 0x1b78 <HTTPServerApp_Callback+0xce>
}

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
    1b6c:	c9 01       	movw	r24, r18
    1b6e:	88 74       	andi	r24, 0x48	; 72
    1b70:	90 70       	andi	r25, 0x00	; 0
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1b72:	00 97       	sbiw	r24, 0x00	; 0
    1b74:	09 f4       	brne	.+2      	; 0x1b78 <HTTPServerApp_Callback+0xce>
    1b76:	1a c1       	rjmp	.+564    	; 0x1dac <HTTPServerApp_Callback+0x302>
	{
		switch (AppState->HTTPServer.CurrentState)
    1b78:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b7a:	81 30       	cpi	r24, 0x01	; 1
    1b7c:	09 f4       	brne	.+2      	; 0x1b80 <HTTPServerApp_Callback+0xd6>
    1b7e:	6a c0       	rjmp	.+212    	; 0x1c54 <HTTPServerApp_Callback+0x1aa>
    1b80:	81 30       	cpi	r24, 0x01	; 1
    1b82:	38 f0       	brcs	.+14     	; 0x1b92 <HTTPServerApp_Callback+0xe8>
    1b84:	82 30       	cpi	r24, 0x02	; 2
    1b86:	09 f4       	brne	.+2      	; 0x1b8a <HTTPServerApp_Callback+0xe0>
    1b88:	dc c0       	rjmp	.+440    	; 0x1d42 <HTTPServerApp_Callback+0x298>
    1b8a:	83 30       	cpi	r24, 0x03	; 3
    1b8c:	09 f0       	breq	.+2      	; 0x1b90 <HTTPServerApp_Callback+0xe6>
    1b8e:	0e c1       	rjmp	.+540    	; 0x1dac <HTTPServerApp_Callback+0x302>
    1b90:	fe c0       	rjmp	.+508    	; 0x1d8e <HTTPServerApp_Callback+0x2e4>
/** HTTP Server State handler for the Request Process state. This state manages the processing of incoming HTTP
 *  GET requests to the server from the receiving HTTP client.
 */
static void HTTPServerApp_OpenRequestedFile(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1b92:	00 91 54 06 	lds	r16, 0x0654
    1b96:	10 91 55 06 	lds	r17, 0x0655
	char*               const AppData     = (char*)uip_appdata;
    1b9a:	80 91 52 06 	lds	r24, 0x0652
    1b9e:	90 91 53 06 	lds	r25, 0x0653

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
    1ba2:	21 ff       	sbrs	r18, 1
    1ba4:	03 c1       	rjmp	.+518    	; 0x1dac <HTTPServerApp_Callback+0x302>
	  return;

	char* RequestToken      = strtok(AppData, " ");
    1ba6:	63 e4       	ldi	r22, 0x43	; 67
    1ba8:	72 e0       	ldi	r23, 0x02	; 2
    1baa:	0e 94 76 3c 	call	0x78ec	; 0x78ec <strtok>
    1bae:	7c 01       	movw	r14, r24
	char* RequestedFileName = strtok(NULL, " ");
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	63 e4       	ldi	r22, 0x43	; 67
    1bb6:	72 e0       	ldi	r23, 0x02	; 2
    1bb8:	0e 94 76 3c 	call	0x78ec	; 0x78ec <strtok>
    1bbc:	ec 01       	movw	r28, r24

	/* Must be a GET request, abort otherwise */
	if (strcmp_P(RequestToken, PSTR("GET")) != 0)
    1bbe:	c7 01       	movw	r24, r14
    1bc0:	61 e4       	ldi	r22, 0x41	; 65
    1bc2:	72 e0       	ldi	r23, 0x02	; 2
    1bc4:	0e 94 52 3c 	call	0x78a4	; 0x78a4 <strcmp_P>
    1bc8:	00 97       	sbiw	r24, 0x00	; 0
    1bca:	21 f0       	breq	.+8      	; 0x1bd4 <HTTPServerApp_Callback+0x12a>
	{
		uip_abort();
    1bcc:	80 e2       	ldi	r24, 0x20	; 32
    1bce:	80 93 4f 06 	sts	0x064F, r24
    1bd2:	ec c0       	rjmp	.+472    	; 0x1dac <HTTPServerApp_Callback+0x302>
		return;
	}

	/* Copy over the requested filename */
	strlcpy(AppState->HTTPServer.FileName, &RequestedFileName[1], sizeof(AppState->HTTPServer.FileName));
    1bd4:	2e e1       	ldi	r18, 0x1E	; 30
    1bd6:	e2 2e       	mov	r14, r18
    1bd8:	f1 2c       	mov	r15, r1
    1bda:	e0 0e       	add	r14, r16
    1bdc:	f1 1e       	adc	r15, r17
    1bde:	be 01       	movw	r22, r28
    1be0:	6f 5f       	subi	r22, 0xFF	; 255
    1be2:	7f 4f       	sbci	r23, 0xFF	; 255
    1be4:	c7 01       	movw	r24, r14
    1be6:	42 e3       	ldi	r20, 0x32	; 50
    1be8:	50 e0       	ldi	r21, 0x00	; 0
    1bea:	0e 94 a8 3c 	call	0x7950	; 0x7950 <strlcpy>

	/* Determine the length of the URI so that it can be checked to see if it is a directory */
	uint8_t FileNameLen = strlen(AppState->HTTPServer.FileName);
    1bee:	d7 01       	movw	r26, r14
    1bf0:	0d 90       	ld	r0, X+
    1bf2:	00 20       	and	r0, r0
    1bf4:	e9 f7       	brne	.-6      	; 0x1bf0 <HTTPServerApp_Callback+0x146>
    1bf6:	11 97       	sbiw	r26, 0x01	; 1
    1bf8:	ae 19       	sub	r26, r14

	/* If the URI is a directory, append the default filename */
	if ((AppState->HTTPServer.FileName[FileNameLen - 1] == '/') || !(FileNameLen))
    1bfa:	2a 2f       	mov	r18, r26
    1bfc:	30 e0       	ldi	r19, 0x00	; 0
    1bfe:	f8 01       	movw	r30, r16
    1c00:	e2 0f       	add	r30, r18
    1c02:	f3 1f       	adc	r31, r19
    1c04:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c06:	8f 32       	cpi	r24, 0x2F	; 47
    1c08:	11 f0       	breq	.+4      	; 0x1c0e <HTTPServerApp_Callback+0x164>
    1c0a:	aa 23       	and	r26, r26
    1c0c:	61 f4       	brne	.+24     	; 0x1c26 <HTTPServerApp_Callback+0x17c>
	{
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
    1c0e:	c8 01       	movw	r24, r16
    1c10:	82 0f       	add	r24, r18
    1c12:	93 1f       	adc	r25, r19
    1c14:	42 e3       	ldi	r20, 0x32	; 50
    1c16:	50 e0       	ldi	r21, 0x00	; 0
    1c18:	42 1b       	sub	r20, r18
    1c1a:	53 0b       	sbc	r21, r19
    1c1c:	4e 96       	adiw	r24, 0x1e	; 30
    1c1e:	60 e5       	ldi	r22, 0x50	; 80
    1c20:	71 e0       	ldi	r23, 0x01	; 1
    1c22:	0e 94 62 3c 	call	0x78c4	; 0x78c4 <strlcpy_P>
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1c26:	c8 01       	movw	r24, r16
    1c28:	80 5b       	subi	r24, 0xB0	; 176
    1c2a:	9f 4f       	sbci	r25, 0xFF	; 255
    1c2c:	b7 01       	movw	r22, r14
    1c2e:	41 e0       	ldi	r20, 0x01	; 1
    1c30:	0e 94 27 1f 	call	0x3e4e	; 0x3e4e <f_open>
    1c34:	f8 01       	movw	r30, r16
    1c36:	e6 59       	subi	r30, 0x96	; 150
    1c38:	ff 4f       	sbci	r31, 0xFF	; 255
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);
    1c3a:	91 e0       	ldi	r25, 0x01	; 1
    1c3c:	81 11       	cpse	r24, r1
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1c40:	90 83       	st	Z, r25
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);

	/* Lock to the SendResponseHeader state until connection terminated */
	AppState->HTTPServer.CurrentState = WEBSERVER_STATE_SendResponseHeader;
    1c42:	81 e0       	ldi	r24, 0x01	; 1
    1c44:	d8 01       	movw	r26, r16
    1c46:	5c 96       	adiw	r26, 0x1c	; 28
    1c48:	8c 93       	st	X, r24
    1c4a:	5c 97       	sbiw	r26, 0x1c	; 28
	AppState->HTTPServer.NextState    = WEBSERVER_STATE_SendResponseHeader;
    1c4c:	5d 96       	adiw	r26, 0x1d	; 29
    1c4e:	8c 93       	st	X, r24
    1c50:	5d 97       	sbiw	r26, 0x1d	; 29
    1c52:	ac c0       	rjmp	.+344    	; 0x1dac <HTTPServerApp_Callback+0x302>
/** HTTP Server State handler for the HTTP Response Header Send state. This state manages the transmission of
 *  the HTTP response header to the receiving HTTP client.
 */
static void HTTPServerApp_SendResponseHeader(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1c54:	a0 90 54 06 	lds	r10, 0x0654
    1c58:	b0 90 55 06 	lds	r11, 0x0655
	char*               const AppData     = (char*)uip_appdata;
    1c5c:	c0 91 52 06 	lds	r28, 0x0652
    1c60:	d0 91 53 06 	lds	r29, 0x0653

	char* Extension     = strpbrk(AppState->HTTPServer.FileName, ".");
    1c64:	85 01       	movw	r16, r10
    1c66:	02 5e       	subi	r16, 0xE2	; 226
    1c68:	1f 4f       	sbci	r17, 0xFF	; 255
    1c6a:	c8 01       	movw	r24, r16
    1c6c:	6e e2       	ldi	r22, 0x2E	; 46
    1c6e:	70 e0       	ldi	r23, 0x00	; 0
    1c70:	0e 94 94 3c 	call	0x7928	; 0x7928 <strchr>
    1c74:	6c 01       	movw	r12, r24
	bool  FoundMIMEType = false;

	/* If the file isn't already open, it wasn't found - send back a 404 error response and abort */
	if (!(AppState->HTTPServer.FileOpen))
    1c76:	f5 01       	movw	r30, r10
    1c78:	e6 59       	subi	r30, 0x96	; 150
    1c7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c7c:	80 81       	ld	r24, Z
    1c7e:	88 23       	and	r24, r24
    1c80:	c1 f4       	brne	.+48     	; 0x1cb2 <HTTPServerApp_Callback+0x208>
	{
		/* Copy over the HTTP 404 response header and send it to the receiving client */
		strcpy_P(AppData, HTTP404Header);
    1c82:	ce 01       	movw	r24, r28
    1c84:	6a e5       	ldi	r22, 0x5A	; 90
    1c86:	71 e0       	ldi	r23, 0x01	; 1
    1c88:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <strcpy_P>
		strcat(AppData, AppState->HTTPServer.FileName);
    1c8c:	ce 01       	movw	r24, r28
    1c8e:	b8 01       	movw	r22, r16
    1c90:	0e 94 89 3c 	call	0x7912	; 0x7912 <strcat>
		uip_send(AppData, strlen(AppData));
    1c94:	fe 01       	movw	r30, r28
    1c96:	df 01       	movw	r26, r30
    1c98:	0d 90       	ld	r0, X+
    1c9a:	00 20       	and	r0, r0
    1c9c:	e9 f7       	brne	.-6      	; 0x1c98 <HTTPServerApp_Callback+0x1ee>
    1c9e:	bd 01       	movw	r22, r26
    1ca0:	61 50       	subi	r22, 0x01	; 1
    1ca2:	70 40       	sbci	r23, 0x00	; 0
    1ca4:	6e 1b       	sub	r22, r30
    1ca6:	7f 0b       	sbc	r23, r31
    1ca8:	ce 01       	movw	r24, r28
    1caa:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>

		AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1cae:	83 e0       	ldi	r24, 0x03	; 3
    1cb0:	46 c0       	rjmp	.+140    	; 0x1d3e <HTTPServerApp_Callback+0x294>
		return;
	}

	/* Copy over the HTTP 200 response header and send it to the receiving client */
	strcpy_P(AppData, HTTP200Header);
    1cb2:	ce 01       	movw	r24, r28
    1cb4:	66 ee       	ldi	r22, 0xE6	; 230
    1cb6:	71 e0       	ldi	r23, 0x01	; 1
    1cb8:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <strcpy_P>

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
    1cbc:	c1 14       	cp	r12, r1
    1cbe:	d1 04       	cpc	r13, r1
    1cc0:	39 f1       	breq	.+78     	; 0x1d10 <HTTPServerApp_Callback+0x266>
    1cc2:	98 ef       	ldi	r25, 0xF8	; 248
    1cc4:	e9 2e       	mov	r14, r25
    1cc6:	92 e0       	ldi	r25, 0x02	; 2
    1cc8:	f9 2e       	mov	r15, r25
    1cca:	00 e0       	ldi	r16, 0x00	; 0
    1ccc:	10 e0       	ldi	r17, 0x00	; 0
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
		{
			if (strcmp(&Extension[1], MIMETypes[i].Extension) == 0)
    1cce:	08 94       	sec
    1cd0:	c1 1c       	adc	r12, r1
    1cd2:	d1 1c       	adc	r13, r1
    1cd4:	d7 01       	movw	r26, r14
    1cd6:	6d 91       	ld	r22, X+
    1cd8:	7c 91       	ld	r23, X
    1cda:	c6 01       	movw	r24, r12
    1cdc:	0e 94 9f 3c 	call	0x793e	; 0x793e <strcmp>
    1ce0:	00 97       	sbiw	r24, 0x00	; 0
    1ce2:	69 f4       	brne	.+26     	; 0x1cfe <HTTPServerApp_Callback+0x254>
			{
				strcat(AppData, MIMETypes[i].MIMEType);
    1ce4:	f8 01       	movw	r30, r16
    1ce6:	ee 0f       	add	r30, r30
    1ce8:	ff 1f       	adc	r31, r31
    1cea:	ee 0f       	add	r30, r30
    1cec:	ff 1f       	adc	r31, r31
    1cee:	e8 50       	subi	r30, 0x08	; 8
    1cf0:	fd 4f       	sbci	r31, 0xFD	; 253
    1cf2:	62 81       	ldd	r22, Z+2	; 0x02
    1cf4:	73 81       	ldd	r23, Z+3	; 0x03
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	0e 94 89 3c 	call	0x7912	; 0x7912 <strcat>
    1cfc:	0e c0       	rjmp	.+28     	; 0x1d1a <HTTPServerApp_Callback+0x270>
    1cfe:	0f 5f       	subi	r16, 0xFF	; 255
    1d00:	1f 4f       	sbci	r17, 0xFF	; 255
    1d02:	e4 e0       	ldi	r30, 0x04	; 4
    1d04:	f0 e0       	ldi	r31, 0x00	; 0
    1d06:	ee 0e       	add	r14, r30
    1d08:	ff 1e       	adc	r15, r31

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
    1d0a:	0a 30       	cpi	r16, 0x0A	; 10
    1d0c:	11 05       	cpc	r17, r1
    1d0e:	11 f7       	brne	.-60     	; 0x1cd4 <HTTPServerApp_Callback+0x22a>

	/* Check if a MIME type was found and copied to the output buffer */
	if (!(FoundMIMEType))
	{
		/* MIME type not found - copy over the default MIME type */
		strcat_P(AppData, DefaultMIMEType);
    1d10:	ce 01       	movw	r24, r28
    1d12:	65 e4       	ldi	r22, 0x45	; 69
    1d14:	71 e0       	ldi	r23, 0x01	; 1
    1d16:	0e 94 47 3c 	call	0x788e	; 0x788e <strcat_P>
	}

	/* Add the end-of-line terminator and end-of-headers terminator after the MIME type */
	strcat_P(AppData, PSTR("\r\n\r\n"));
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	65 e4       	ldi	r22, 0x45	; 69
    1d1e:	72 e0       	ldi	r23, 0x02	; 2
    1d20:	0e 94 47 3c 	call	0x788e	; 0x788e <strcat_P>

	/* Send the MIME header to the receiving client */
	uip_send(AppData, strlen(AppData));
    1d24:	de 01       	movw	r26, r28
    1d26:	0d 90       	ld	r0, X+
    1d28:	00 20       	and	r0, r0
    1d2a:	e9 f7       	brne	.-6      	; 0x1d26 <HTTPServerApp_Callback+0x27c>
    1d2c:	bd 01       	movw	r22, r26
    1d2e:	61 50       	subi	r22, 0x01	; 1
    1d30:	70 40       	sbci	r23, 0x00	; 0
    1d32:	6c 1b       	sub	r22, r28
    1d34:	7d 0b       	sbc	r23, r29
    1d36:	ce 01       	movw	r24, r28
    1d38:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>

	/* When the MIME header is ACKed, progress to the data send stage */
	AppState->HTTPServer.NextState = WEBSERVER_STATE_SendData;
    1d3c:	82 e0       	ldi	r24, 0x02	; 2
    1d3e:	f5 01       	movw	r30, r10
    1d40:	24 c0       	rjmp	.+72     	; 0x1d8a <HTTPServerApp_Callback+0x2e0>
/** HTTP Server State handler for the Data Send state. This state manages the transmission of file chunks
 *  to the receiving HTTP client.
 */
static void HTTPServerApp_SendData(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1d42:	00 91 54 06 	lds	r16, 0x0654
    1d46:	10 91 55 06 	lds	r17, 0x0655
	char*               const AppData     = (char*)uip_appdata;
    1d4a:	e0 90 52 06 	lds	r14, 0x0652
    1d4e:	f0 90 53 06 	lds	r15, 0x0653

	/* Get the maximum segment size for the current packet */
	uint16_t MaxChunkSize = uip_mss();
    1d52:	d8 01       	movw	r26, r16
    1d54:	52 96       	adiw	r26, 0x12	; 18
    1d56:	cd 90       	ld	r12, X+
    1d58:	dc 90       	ld	r13, X
    1d5a:	53 97       	sbiw	r26, 0x13	; 19

	/* Read the next chunk of data from the open file */
	f_read(&AppState->HTTPServer.FileHandle, AppData, MaxChunkSize, &AppState->HTTPServer.SentChunkSize);
    1d5c:	e8 01       	movw	r28, r16
    1d5e:	c1 59       	subi	r28, 0x91	; 145
    1d60:	df 4f       	sbci	r29, 0xFF	; 255
    1d62:	c8 01       	movw	r24, r16
    1d64:	80 5b       	subi	r24, 0xB0	; 176
    1d66:	9f 4f       	sbci	r25, 0xFF	; 255
    1d68:	b7 01       	movw	r22, r14
    1d6a:	a6 01       	movw	r20, r12
    1d6c:	9e 01       	movw	r18, r28
    1d6e:	0e 94 0a 23 	call	0x4614	; 0x4614 <f_read>

	/* Send the next file chunk to the receiving client */
	uip_send(AppData, AppState->HTTPServer.SentChunkSize);
    1d72:	68 81       	ld	r22, Y
    1d74:	79 81       	ldd	r23, Y+1	; 0x01
    1d76:	c7 01       	movw	r24, r14
    1d78:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>

	/* Check if we are at the last chunk of the file, if so next ACK should close the connection */
	if (MaxChunkSize != AppState->HTTPServer.SentChunkSize)
    1d7c:	88 81       	ld	r24, Y
    1d7e:	99 81       	ldd	r25, Y+1	; 0x01
    1d80:	c8 16       	cp	r12, r24
    1d82:	d9 06       	cpc	r13, r25
    1d84:	99 f0       	breq	.+38     	; 0x1dac <HTTPServerApp_Callback+0x302>
	  AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1d86:	83 e0       	ldi	r24, 0x03	; 3
    1d88:	f8 01       	movw	r30, r16
    1d8a:	85 8f       	std	Z+29, r24	; 0x1d
    1d8c:	0f c0       	rjmp	.+30     	; 0x1dac <HTTPServerApp_Callback+0x302>
			case WEBSERVER_STATE_SendData:
				HTTPServerApp_SendData();
				break;
			case WEBSERVER_STATE_Closing:
				/* Connection is being terminated for some reason - close file handle */
				f_close(&AppState->HTTPServer.FileHandle);
    1d8e:	ce 01       	movw	r24, r28
    1d90:	80 5b       	subi	r24, 0xB0	; 176
    1d92:	9f 4f       	sbci	r25, 0xFF	; 255
    1d94:	0e 94 3c 24 	call	0x4878	; 0x4878 <f_close>
				AppState->HTTPServer.FileOpen = false;
    1d98:	fe 01       	movw	r30, r28
    1d9a:	e6 59       	subi	r30, 0x96	; 150
    1d9c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d9e:	10 82       	st	Z, r1

				/* If connection is not already closed, close it */
				uip_close();
    1da0:	80 e1       	ldi	r24, 0x10	; 16
    1da2:	80 93 4f 06 	sts	0x064F, r24

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1da6:	84 e0       	ldi	r24, 0x04	; 4
    1da8:	8c 8f       	std	Y+28, r24	; 0x1c
				AppState->HTTPServer.NextState    = WEBSERVER_STATE_Closed;
    1daa:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	1f 91       	pop	r17
    1db2:	0f 91       	pop	r16
    1db4:	ff 90       	pop	r15
    1db6:	ef 90       	pop	r14
    1db8:	df 90       	pop	r13
    1dba:	cf 90       	pop	r12
    1dbc:	bf 90       	pop	r11
    1dbe:	af 90       	pop	r10
    1dc0:	08 95       	ret

00001dc2 <TELNETServerApp_Init>:

/** Initialization function for the simple TELNET webserver. */
void TELNETServerApp_Init(void)
{
	/* Listen on port 23 for TELNET connections from hosts */
	uip_listen(HTONS(TELNET_SERVER_PORT));
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
    1dc4:	97 e1       	ldi	r25, 0x17	; 23
    1dc6:	a9 c1       	rjmp	.+850    	; 0x211a <uip_listen>

00001dc8 <TELNETServerApp_Callback>:
    1dc8:	4f 92       	push	r4
}
    1dca:	5f 92       	push	r5

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
    1dcc:	6f 92       	push	r6
    1dce:	7f 92       	push	r7
    1dd0:	8f 92       	push	r8
    1dd2:	9f 92       	push	r9
    1dd4:	af 92       	push	r10
    1dd6:	bf 92       	push	r11
    1dd8:	df 92       	push	r13
    1dda:	ef 92       	push	r14
    1ddc:	ff 92       	push	r15
    1dde:	0f 93       	push	r16
    1de0:	1f 93       	push	r17
    1de2:	cf 93       	push	r28
    1de4:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
    1de6:	e0 90 54 06 	lds	r14, 0x0654
    1dea:	f0 90 55 06 	lds	r15, 0x0655
	char*               const AppData    = (char*)uip_appdata;
    1dee:	00 91 52 06 	lds	r16, 0x0652
    1df2:	10 91 53 06 	lds	r17, 0x0653

	if (uip_connected())
    1df6:	80 91 4f 06 	lds	r24, 0x064F
    1dfa:	90 e0       	ldi	r25, 0x00	; 0
    1dfc:	86 ff       	sbrs	r24, 6
    1dfe:	04 c0       	rjmp	.+8      	; 0x1e08 <TELNETServerApp_Callback+0x40>
	{
		/* New connection - initialize connection state values */
		AppState->TELNETServer.CurrentState = TELNET_STATE_SendHeader;
    1e00:	d7 01       	movw	r26, r14
    1e02:	5c 96       	adiw	r26, 0x1c	; 28
    1e04:	1c 92       	st	X, r1
    1e06:	5c 97       	sbiw	r26, 0x1c	; 28
	}

	if (uip_acked())
    1e08:	80 ff       	sbrs	r24, 0
    1e0a:	03 c0       	rjmp	.+6      	; 0x1e12 <TELNETServerApp_Callback+0x4a>
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
    1e0c:	e7 01       	movw	r28, r14
    1e0e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1e10:	2c 8f       	std	Y+28, r18	; 0x1c
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e12:	82 fd       	sbrc	r24, 2
    1e14:	0b c0       	rjmp	.+22     	; 0x1e2c <TELNETServerApp_Callback+0x64>
}

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
    1e16:	9c 01       	movw	r18, r24
    1e18:	23 70       	andi	r18, 0x03	; 3
    1e1a:	30 70       	andi	r19, 0x00	; 0
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e1c:	21 15       	cp	r18, r1
    1e1e:	31 05       	cpc	r19, r1
    1e20:	29 f4       	brne	.+10     	; 0x1e2c <TELNETServerApp_Callback+0x64>
}

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
    1e22:	88 74       	andi	r24, 0x48	; 72
    1e24:	90 70       	andi	r25, 0x00	; 0
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e26:	00 97       	sbiw	r24, 0x00	; 0
    1e28:	09 f4       	brne	.+2      	; 0x1e2c <TELNETServerApp_Callback+0x64>
    1e2a:	c5 c0       	rjmp	.+394    	; 0x1fb6 <TELNETServerApp_Callback+0x1ee>
	{
		switch (AppState->TELNETServer.CurrentState)
    1e2c:	f7 01       	movw	r30, r14
    1e2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e30:	81 30       	cpi	r24, 0x01	; 1
    1e32:	61 f0       	breq	.+24     	; 0x1e4c <TELNETServerApp_Callback+0x84>
    1e34:	81 30       	cpi	r24, 0x01	; 1
    1e36:	30 f0       	brcs	.+12     	; 0x1e44 <TELNETServerApp_Callback+0x7c>
    1e38:	82 30       	cpi	r24, 0x02	; 2
    1e3a:	d9 f0       	breq	.+54     	; 0x1e72 <TELNETServerApp_Callback+0xaa>
    1e3c:	83 30       	cpi	r24, 0x03	; 3
    1e3e:	09 f0       	breq	.+2      	; 0x1e42 <TELNETServerApp_Callback+0x7a>
    1e40:	ba c0       	rjmp	.+372    	; 0x1fb6 <TELNETServerApp_Callback+0x1ee>
    1e42:	29 c0       	rjmp	.+82     	; 0x1e96 <TELNETServerApp_Callback+0xce>
		{
			case TELNET_STATE_SendHeader:
				/* Copy over and send the TELNET welcome message upon first connection */
				strcpy_P(AppData, WelcomeHeader);
    1e44:	c8 01       	movw	r24, r16
    1e46:	60 ed       	ldi	r22, 0xD0	; 208
    1e48:	72 e0       	ldi	r23, 0x02	; 2
    1e4a:	a4 c0       	rjmp	.+328    	; 0x1f94 <TELNETServerApp_Callback+0x1cc>

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
				break;
			case TELNET_STATE_SendMenu:
				/* Copy over and send the TELNET menu to the client */
				strcpy_P(AppData, TELNETMenu);
    1e4c:	c8 01       	movw	r24, r16
    1e4e:	6b e6       	ldi	r22, 0x6B	; 107
    1e50:	72 e0       	ldi	r23, 0x02	; 2
    1e52:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1e56:	d8 01       	movw	r26, r16
    1e58:	0d 90       	ld	r0, X+
    1e5a:	00 20       	and	r0, r0
    1e5c:	e9 f7       	brne	.-6      	; 0x1e58 <TELNETServerApp_Callback+0x90>
    1e5e:	bd 01       	movw	r22, r26
    1e60:	61 50       	subi	r22, 0x01	; 1
    1e62:	70 40       	sbci	r23, 0x00	; 0
    1e64:	60 1b       	sub	r22, r16
    1e66:	71 0b       	sbc	r23, r17
    1e68:	c8 01       	movw	r24, r16
    1e6a:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_GetCommand;
    1e6e:	82 e0       	ldi	r24, 0x02	; 2
    1e70:	a0 c0       	rjmp	.+320    	; 0x1fb2 <TELNETServerApp_Callback+0x1ea>
				break;
			case TELNET_STATE_GetCommand:
				if (!(uip_datalen()))
    1e72:	80 91 47 06 	lds	r24, 0x0647
    1e76:	90 91 48 06 	lds	r25, 0x0648
    1e7a:	00 97       	sbiw	r24, 0x00	; 0
    1e7c:	09 f4       	brne	.+2      	; 0x1e80 <TELNETServerApp_Callback+0xb8>
    1e7e:	9b c0       	rjmp	.+310    	; 0x1fb6 <TELNETServerApp_Callback+0x1ee>
				  break;

				/* Save the issued command for later processing */
				AppState->TELNETServer.IssuedCommand = AppData[0];
    1e80:	f8 01       	movw	r30, r16
    1e82:	80 81       	ld	r24, Z
    1e84:	d7 01       	movw	r26, r14
    1e86:	5e 96       	adiw	r26, 0x1e	; 30
    1e88:	8c 93       	st	X, r24
    1e8a:	5e 97       	sbiw	r26, 0x1e	; 30

				AppState->TELNETServer.CurrentState  = TELNET_STATE_SendResponse;
    1e8c:	83 e0       	ldi	r24, 0x03	; 3
    1e8e:	5c 96       	adiw	r26, 0x1c	; 28
    1e90:	8c 93       	st	X, r24
    1e92:	5c 97       	sbiw	r26, 0x1c	; 28
				break;
    1e94:	90 c0       	rjmp	.+288    	; 0x1fb6 <TELNETServerApp_Callback+0x1ee>
			case TELNET_STATE_SendResponse:
				/* Determine which command was issued, perform command processing */
				switch (AppState->TELNETServer.IssuedCommand)
    1e96:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e98:	83 36       	cpi	r24, 0x63	; 99
    1e9a:	09 f0       	breq	.+2      	; 0x1e9e <TELNETServerApp_Callback+0xd6>
    1e9c:	78 c0       	rjmp	.+240    	; 0x1f8e <TELNETServerApp_Callback+0x1c6>
/** Sends a list of active TCP connections to the TELNET client. */
static void TELNETServerApp_DisplayTCPConnections(void)
{
	char* const AppData    = (char*)uip_appdata;

	strcpy_P(AppData, CurrentConnectionsHeader);
    1e9e:	c8 01       	movw	r24, r16
    1ea0:	6a e4       	ldi	r22, 0x4A	; 74
    1ea2:	72 e0       	ldi	r23, 0x02	; 2
    1ea4:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <strcpy_P>

	uint16_t ResponseLen     = strlen(AppData);
    1ea8:	d8 01       	movw	r26, r16
    1eaa:	0d 90       	ld	r0, X+
    1eac:	00 20       	and	r0, r0
    1eae:	e9 f7       	brne	.-6      	; 0x1eaa <TELNETServerApp_Callback+0xe2>
    1eb0:	2d 01       	movw	r4, r26
    1eb2:	08 94       	sec
    1eb4:	41 08       	sbc	r4, r1
    1eb6:	51 08       	sbc	r5, r1
    1eb8:	40 1a       	sub	r4, r16
    1eba:	51 0a       	sbc	r5, r17
    1ebc:	aa 24       	eor	r10, r10
    1ebe:	bb 24       	eor	r11, r11
	uint8_t  ActiveConnCount = 0;
    1ec0:	dd 24       	eor	r13, r13

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];
    1ec2:	81 e7       	ldi	r24, 0x71	; 113
    1ec4:	88 2e       	mov	r8, r24
    1ec6:	91 2c       	mov	r9, r1

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1ec8:	9e e6       	ldi	r25, 0x6E	; 110
    1eca:	69 2e       	mov	r6, r25
    1ecc:	93 e0       	ldi	r25, 0x03	; 3
    1ece:	79 2e       	mov	r7, r25
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];
    1ed0:	a8 9c       	mul	r10, r8
    1ed2:	d0 01       	movw	r26, r0
    1ed4:	a9 9c       	mul	r10, r9
    1ed6:	b0 0d       	add	r27, r0
    1ed8:	b8 9c       	mul	r11, r8
    1eda:	b0 0d       	add	r27, r0
    1edc:	11 24       	eor	r1, r1
    1ede:	aa 5a       	subi	r26, 0xAA	; 170
    1ee0:	b9 4f       	sbci	r27, 0xF9	; 249

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
    1ee2:	59 96       	adiw	r26, 0x19	; 25
    1ee4:	8c 91       	ld	r24, X
    1ee6:	59 97       	sbiw	r26, 0x19	; 25
    1ee8:	88 23       	and	r24, r24
    1eea:	09 f4       	brne	.+2      	; 0x1eee <TELNETServerApp_Callback+0x126>
    1eec:	45 c0       	rjmp	.+138    	; 0x1f78 <TELNETServerApp_Callback+0x1b0>
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1eee:	d3 94       	inc	r13
    1ef0:	cd b7       	in	r28, 0x3d	; 61
    1ef2:	de b7       	in	r29, 0x3e	; 62
    1ef4:	62 97       	sbiw	r28, 0x12	; 18
    1ef6:	0f b6       	in	r0, 0x3f	; 63
    1ef8:	f8 94       	cli
    1efa:	de bf       	out	0x3e, r29	; 62
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	cd bf       	out	0x3d, r28	; 61
    1f00:	ed b7       	in	r30, 0x3d	; 61
    1f02:	fe b7       	in	r31, 0x3e	; 62
    1f04:	31 96       	adiw	r30, 0x01	; 1
    1f06:	c8 01       	movw	r24, r16
    1f08:	84 0d       	add	r24, r4
    1f0a:	95 1d       	adc	r25, r5
    1f0c:	9a 83       	std	Y+2, r25	; 0x02
    1f0e:	89 83       	std	Y+1, r24	; 0x01
    1f10:	73 82       	std	Z+3, r7	; 0x03
    1f12:	62 82       	std	Z+2, r6	; 0x02
    1f14:	d4 82       	std	Z+4, r13	; 0x04
    1f16:	15 82       	std	Z+5, r1	; 0x05
    1f18:	8c 91       	ld	r24, X
    1f1a:	86 83       	std	Z+6, r24	; 0x06
    1f1c:	17 82       	std	Z+7, r1	; 0x07
    1f1e:	11 96       	adiw	r26, 0x01	; 1
    1f20:	8c 91       	ld	r24, X
    1f22:	11 97       	sbiw	r26, 0x01	; 1
    1f24:	80 87       	std	Z+8, r24	; 0x08
    1f26:	11 86       	std	Z+9, r1	; 0x09
    1f28:	12 96       	adiw	r26, 0x02	; 2
    1f2a:	8c 91       	ld	r24, X
    1f2c:	12 97       	sbiw	r26, 0x02	; 2
    1f2e:	82 87       	std	Z+10, r24	; 0x0a
    1f30:	13 86       	std	Z+11, r1	; 0x0b
    1f32:	13 96       	adiw	r26, 0x03	; 3
    1f34:	8c 91       	ld	r24, X
    1f36:	13 97       	sbiw	r26, 0x03	; 3
    1f38:	84 87       	std	Z+12, r24	; 0x0c
    1f3a:	15 86       	std	Z+13, r1	; 0x0d
    1f3c:	14 96       	adiw	r26, 0x04	; 4
    1f3e:	8d 91       	ld	r24, X+
    1f40:	9c 91       	ld	r25, X
    1f42:	15 97       	sbiw	r26, 0x05	; 5
    1f44:	98 27       	eor	r25, r24
    1f46:	89 27       	eor	r24, r25
    1f48:	98 27       	eor	r25, r24
    1f4a:	97 87       	std	Z+15, r25	; 0x0f
    1f4c:	86 87       	std	Z+14, r24	; 0x0e
    1f4e:	16 96       	adiw	r26, 0x06	; 6
    1f50:	8d 91       	ld	r24, X+
    1f52:	9c 91       	ld	r25, X
    1f54:	17 97       	sbiw	r26, 0x07	; 7
    1f56:	98 27       	eor	r25, r24
    1f58:	89 27       	eor	r24, r25
    1f5a:	98 27       	eor	r25, r24
    1f5c:	91 8b       	std	Z+17, r25	; 0x11
    1f5e:	80 8b       	std	Z+16, r24	; 0x10
    1f60:	0e 94 e3 3c 	call	0x79c6	; 0x79c6 <sprintf_P>
    1f64:	48 0e       	add	r4, r24
    1f66:	59 1e       	adc	r5, r25
    1f68:	ed b7       	in	r30, 0x3d	; 61
    1f6a:	fe b7       	in	r31, 0x3e	; 62
    1f6c:	72 96       	adiw	r30, 0x12	; 18
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	f8 94       	cli
    1f72:	fe bf       	out	0x3e, r31	; 62
    1f74:	0f be       	out	0x3f, r0	; 63
    1f76:	ed bf       	out	0x3d, r30	; 61
    1f78:	08 94       	sec
    1f7a:	a1 1c       	adc	r10, r1
    1f7c:	b1 1c       	adc	r11, r1

	uint16_t ResponseLen     = strlen(AppData);
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1f7e:	f3 e0       	ldi	r31, 0x03	; 3
    1f80:	af 16       	cp	r10, r31
    1f82:	b1 04       	cpc	r11, r1
    1f84:	09 f0       	breq	.+2      	; 0x1f88 <TELNETServerApp_Callback+0x1c0>
    1f86:	a4 cf       	rjmp	.-184    	; 0x1ed0 <TELNETServerApp_Callback+0x108>
			                         CurrConnection->ripaddr.u8[3],
			                         HTONS(CurrConnection->lport), HTONS(CurrConnection->rport));
		}
	}

	uip_send(AppData, ResponseLen);
    1f88:	c8 01       	movw	r24, r16
    1f8a:	b2 01       	movw	r22, r4
    1f8c:	0f c0       	rjmp	.+30     	; 0x1fac <TELNETServerApp_Callback+0x1e4>
				{
					case 'c':
						TELNETServerApp_DisplayTCPConnections();
						break;
					default:
						strcpy_P(AppData, PSTR("Invalid Command.\r\n"));
    1f8e:	c8 01       	movw	r24, r16
    1f90:	6b e5       	ldi	r22, 0x5B	; 91
    1f92:	73 e0       	ldi	r23, 0x03	; 3
    1f94:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <strcpy_P>
						uip_send(AppData, strlen(AppData));
    1f98:	d8 01       	movw	r26, r16
    1f9a:	0d 90       	ld	r0, X+
    1f9c:	00 20       	and	r0, r0
    1f9e:	e9 f7       	brne	.-6      	; 0x1f9a <TELNETServerApp_Callback+0x1d2>
    1fa0:	bd 01       	movw	r22, r26
    1fa2:	61 50       	subi	r22, 0x01	; 1
    1fa4:	70 40       	sbci	r23, 0x00	; 0
    1fa6:	60 1b       	sub	r22, r16
    1fa8:	71 0b       	sbc	r23, r17
    1faa:	c8 01       	movw	r24, r16
    1fac:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <uip_send>
						break;
				}

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	e7 01       	movw	r28, r14
    1fb4:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	ff 90       	pop	r15
    1fc0:	ef 90       	pop	r14
    1fc2:	df 90       	pop	r13
    1fc4:	bf 90       	pop	r11
    1fc6:	af 90       	pop	r10
    1fc8:	9f 90       	pop	r9
    1fca:	8f 90       	pop	r8
    1fcc:	7f 90       	pop	r7
    1fce:	6f 90       	pop	r6
    1fd0:	5f 90       	pop	r5
    1fd2:	4f 90       	pop	r4
    1fd4:	08 95       	ret

00001fd6 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    1fd6:	9c 01       	movw	r18, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    1fd8:	41 50       	subi	r20, 0x01	; 1
    1fda:	50 40       	sbci	r21, 0x00	; 0
    1fdc:	46 0f       	add	r20, r22
    1fde:	57 1f       	adc	r21, r23
{
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
    1fe0:	fb 01       	movw	r30, r22
  last_byte = data + len - 1;

  while(dataptr < last_byte) {	/* At least two more bytes */
    1fe2:	0e c0       	rjmp	.+28     	; 0x2000 <chksum+0x2a>
    t = (dataptr[0] << 8) + dataptr[1];
    1fe4:	b0 81       	ld	r27, Z
    1fe6:	a0 e0       	ldi	r26, 0x00	; 0
    1fe8:	81 81       	ldd	r24, Z+1	; 0x01
    1fea:	bd 01       	movw	r22, r26
    1fec:	68 0f       	add	r22, r24
    1fee:	71 1d       	adc	r23, r1
    sum += t;
    1ff0:	26 0f       	add	r18, r22
    1ff2:	37 1f       	adc	r19, r23
    if(sum < t) {
    1ff4:	26 17       	cp	r18, r22
    1ff6:	37 07       	cpc	r19, r23
    1ff8:	10 f4       	brcc	.+4      	; 0x1ffe <chksum+0x28>
      sum++;		/* carry */
    1ffa:	2f 5f       	subi	r18, 0xFF	; 255
    1ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    1ffe:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;

  while(dataptr < last_byte) {	/* At least two more bytes */
    2000:	e4 17       	cp	r30, r20
    2002:	f5 07       	cpc	r31, r21
    2004:	78 f3       	brcs	.-34     	; 0x1fe4 <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }

  if(dataptr == last_byte) {
    2006:	e4 17       	cp	r30, r20
    2008:	f5 07       	cpc	r31, r21
    200a:	49 f4       	brne	.+18     	; 0x201e <chksum+0x48>
    t = (dataptr[0] << 8) + 0;
    200c:	90 81       	ld	r25, Z
    200e:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    2010:	28 0f       	add	r18, r24
    2012:	39 1f       	adc	r19, r25
    if(sum < t) {
    2014:	28 17       	cp	r18, r24
    2016:	39 07       	cpc	r19, r25
    2018:	10 f4       	brcc	.+4      	; 0x201e <chksum+0x48>
      sum++;		/* carry */
    201a:	2f 5f       	subi	r18, 0xFF	; 255
    201c:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    201e:	c9 01       	movw	r24, r18
    2020:	08 95       	ret

00002022 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    2022:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    2024:	43 81       	ldd	r20, Z+3	; 0x03
    2026:	46 0f       	add	r20, r22
    2028:	40 93 4e 06 	sts	0x064E, r20
  uip_acc32[2] = op32[2] + (op16 >> 8);
    202c:	87 2f       	mov	r24, r23
    202e:	99 27       	eor	r25, r25
    2030:	22 81       	ldd	r18, Z+2	; 0x02
    2032:	28 0f       	add	r18, r24
    2034:	20 93 4d 06 	sts	0x064D, r18
  uip_acc32[1] = op32[1];
    2038:	a1 81       	ldd	r26, Z+1	; 0x01
    203a:	a0 93 4c 06 	sts	0x064C, r26
  uip_acc32[0] = op32[0];
    203e:	50 81       	ld	r21, Z
    2040:	50 93 4b 06 	sts	0x064B, r21

  if(uip_acc32[2] < (op16 >> 8)) {
    2044:	30 e0       	ldi	r19, 0x00	; 0
    2046:	28 17       	cp	r18, r24
    2048:	39 07       	cpc	r19, r25
    204a:	48 f4       	brcc	.+18     	; 0x205e <uip_add32+0x3c>
    ++uip_acc32[1];
    204c:	8a 2f       	mov	r24, r26
    204e:	8f 5f       	subi	r24, 0xFF	; 255
    2050:	80 93 4c 06 	sts	0x064C, r24
    if(uip_acc32[1] == 0) {
    2054:	88 23       	and	r24, r24
    2056:	19 f4       	brne	.+6      	; 0x205e <uip_add32+0x3c>
      ++uip_acc32[0];
    2058:	5f 5f       	subi	r21, 0xFF	; 255
    205a:	50 93 4b 06 	sts	0x064B, r21
    }
  }


  if(uip_acc32[3] < (op16 & 0xff)) {
    205e:	84 2f       	mov	r24, r20
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	70 70       	andi	r23, 0x00	; 0
    2064:	86 17       	cp	r24, r22
    2066:	97 07       	cpc	r25, r23
    2068:	98 f4       	brcc	.+38     	; 0x2090 <uip_add32+0x6e>
    ++uip_acc32[2];
    206a:	80 91 4d 06 	lds	r24, 0x064D
    206e:	8f 5f       	subi	r24, 0xFF	; 255
    2070:	80 93 4d 06 	sts	0x064D, r24
    if(uip_acc32[2] == 0) {
    2074:	88 23       	and	r24, r24
    2076:	61 f4       	brne	.+24     	; 0x2090 <uip_add32+0x6e>
      ++uip_acc32[1];
    2078:	80 91 4c 06 	lds	r24, 0x064C
    207c:	8f 5f       	subi	r24, 0xFF	; 255
    207e:	80 93 4c 06 	sts	0x064C, r24
      if(uip_acc32[1] == 0) {
    2082:	88 23       	and	r24, r24
    2084:	29 f4       	brne	.+10     	; 0x2090 <uip_add32+0x6e>
	++uip_acc32[0];
    2086:	80 91 4b 06 	lds	r24, 0x064B
    208a:	8f 5f       	subi	r24, 0xFF	; 255
    208c:	80 93 4b 06 	sts	0x064B, r24
    2090:	08 95       	ret

00002092 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    2092:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    2094:	80 91 54 06 	lds	r24, 0x0654
    2098:	90 91 55 06 	lds	r25, 0x0655
    209c:	08 96       	adiw	r24, 0x08	; 8
    209e:	c1 df       	rcall	.-126    	; 0x2022 <uip_add32>
    20a0:	e0 91 54 06 	lds	r30, 0x0654
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    20a4:	f0 91 55 06 	lds	r31, 0x0655
    20a8:	80 91 4b 06 	lds	r24, 0x064B
    20ac:	80 87       	std	Z+8, r24	; 0x08
    20ae:	80 91 4c 06 	lds	r24, 0x064C
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    20b2:	81 87       	std	Z+9, r24	; 0x09
    20b4:	80 91 4d 06 	lds	r24, 0x064D
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    20b8:	82 87       	std	Z+10, r24	; 0x0a
    20ba:	80 91 4e 06 	lds	r24, 0x064E
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    20be:	83 87       	std	Z+11, r24	; 0x0b
    20c0:	08 95       	ret

000020c2 <uip_init>:
}
    20c2:	80 e0       	ldi	r24, 0x00	; 0
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    20c4:	e8 2f       	mov	r30, r24
    20c6:	f0 e0       	ldi	r31, 0x00	; 0
    20c8:	ee 0f       	add	r30, r30
    20ca:	ff 1f       	adc	r31, r31
    20cc:	e7 55       	subi	r30, 0x57	; 87
    20ce:	f8 4f       	sbci	r31, 0xF8	; 248
    20d0:	11 82       	std	Z+1, r1	; 0x01
    20d2:	10 82       	st	Z, r1
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    20d4:	8f 5f       	subi	r24, 0xFF	; 255
    20d6:	85 30       	cpi	r24, 0x05	; 5
    20d8:	a8 f3       	brcs	.-22     	; 0x20c4 <uip_init+0x2>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    20da:	40 e0       	ldi	r20, 0x00	; 0
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    20dc:	81 e7       	ldi	r24, 0x71	; 113
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	24 2f       	mov	r18, r20
    20e2:	30 e0       	ldi	r19, 0x00	; 0
    20e4:	28 9f       	mul	r18, r24
    20e6:	f0 01       	movw	r30, r0
    20e8:	29 9f       	mul	r18, r25
    20ea:	f0 0d       	add	r31, r0
    20ec:	38 9f       	mul	r19, r24
    20ee:	f0 0d       	add	r31, r0
    20f0:	11 24       	eor	r1, r1
    20f2:	ea 5a       	subi	r30, 0xAA	; 170
    20f4:	f9 4f       	sbci	r31, 0xF9	; 249
    20f6:	11 8e       	std	Z+25, r1	; 0x19
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    20f8:	4f 5f       	subi	r20, 0xFF	; 255
    20fa:	43 30       	cpi	r20, 0x03	; 3
    20fc:	88 f3       	brcs	.-30     	; 0x20e0 <uip_init+0x1e>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    20fe:	80 e0       	ldi	r24, 0x00	; 0
    2100:	94 e0       	ldi	r25, 0x04	; 4
    2102:	90 93 8a 03 	sts	0x038A, r25
    2106:	80 93 89 03 	sts	0x0389, r24
    210a:	81 e0       	ldi	r24, 0x01	; 1
    210c:	80 93 88 03 	sts	0x0388, r24
    2110:	10 92 b2 0d 	sts	0x0DB2, r1
    2114:	10 92 b1 0d 	sts	0x0DB1, r1
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    2118:	08 95       	ret

0000211a <uip_listen>:
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    211a:	40 e0       	ldi	r20, 0x00	; 0
    211c:	13 c0       	rjmp	.+38     	; 0x2144 <uip_listen+0x2a>
    if(uip_listenports[c] == 0) {
    211e:	e4 2f       	mov	r30, r20
    2120:	f0 e0       	ldi	r31, 0x00	; 0
    2122:	54 2f       	mov	r21, r20
    2124:	5f 5f       	subi	r21, 0xFF	; 255
    2126:	ee 0f       	add	r30, r30
    2128:	ff 1f       	adc	r31, r31
    212a:	e7 55       	subi	r30, 0x57	; 87
    212c:	f8 4f       	sbci	r31, 0xF8	; 248
    212e:	20 81       	ld	r18, Z
    2130:	31 81       	ldd	r19, Z+1	; 0x01
    2132:	21 15       	cp	r18, r1
    2134:	31 05       	cpc	r19, r1
    2136:	29 f4       	brne	.+10     	; 0x2142 <uip_listen+0x28>
    2138:	40 93 88 03 	sts	0x0388, r20
      uip_listenports[c] = port;
    213c:	91 83       	std	Z+1, r25	; 0x01
    213e:	80 83       	st	Z, r24
      return;
    2140:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
    2142:	45 2f       	mov	r20, r21
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2144:	45 30       	cpi	r20, 0x05	; 5
    2146:	58 f3       	brcs	.-42     	; 0x211e <uip_listen+0x4>
    2148:	40 93 88 03 	sts	0x0388, r20
    214c:	08 95       	ret

0000214e <htons>:
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    214e:	98 27       	eor	r25, r24
    2150:	89 27       	eor	r24, r25
    2152:	98 27       	eor	r25, r24
}
    2154:	08 95       	ret

00002156 <uip_udp_new>:
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(const uip_ipaddr_t *ripaddr, u16_t rport)
{
    2156:	cf 92       	push	r12
    2158:	df 92       	push	r13
    215a:	ef 92       	push	r14
    215c:	ff 92       	push	r15
    215e:	0f 93       	push	r16
    2160:	1f 93       	push	r17
    2162:	cf 93       	push	r28
    2164:	df 93       	push	r29
    2166:	7c 01       	movw	r14, r24
    2168:	6b 01       	movw	r12, r22
  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    216a:	00 91 b1 0d 	lds	r16, 0x0DB1
    216e:	10 91 b2 0d 	lds	r17, 0x0DB2
    2172:	c0 91 89 03 	lds	r28, 0x0389
    2176:	d0 91 8a 03 	lds	r29, 0x038A
{
  register struct uip_udp_conn *conn;

  /* Find an unused local port. */
 again:
  ++lastport;
    217a:	21 96       	adiw	r28, 0x01	; 1

  if(lastport >= 32000) {
    217c:	8d e7       	ldi	r24, 0x7D	; 125
    217e:	c0 30       	cpi	r28, 0x00	; 0
    2180:	d8 07       	cpc	r29, r24
    2182:	10 f0       	brcs	.+4      	; 0x2188 <uip_udp_new+0x32>
    lastport = 4096;
    2184:	c0 e0       	ldi	r28, 0x00	; 0
    2186:	d0 e1       	ldi	r29, 0x10	; 16
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    2188:	ce 01       	movw	r24, r28
    218a:	e1 df       	rcall	.-62     	; 0x214e <htons>
    218c:	08 17       	cp	r16, r24
    218e:	19 07       	cpc	r17, r25
    2190:	a1 f3       	breq	.-24     	; 0x217a <uip_udp_new+0x24>
    2192:	d0 93 8a 03 	sts	0x038A, r29
    2196:	c0 93 89 03 	sts	0x0389, r28
    219a:	80 91 b1 0d 	lds	r24, 0x0DB1
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    219e:	90 91 b2 0d 	lds	r25, 0x0DB2
    21a2:	00 97       	sbiw	r24, 0x00	; 0
    21a4:	99 f4       	brne	.+38     	; 0x21cc <uip_udp_new+0x76>
    21a6:	10 92 88 03 	sts	0x0388, r1
    21aa:	8d ea       	ldi	r24, 0xAD	; 173
      conn = &uip_udp_conns[c];
    21ac:	9d e0       	ldi	r25, 0x0D	; 13
    21ae:	dc 27       	eor	r29, r28

  if(conn == 0) {
    return 0;
  }

  conn->lport = HTONS(lastport);
    21b0:	cd 27       	eor	r28, r29
    21b2:	dc 27       	eor	r29, r28
    21b4:	d0 93 b2 0d 	sts	0x0DB2, r29
    21b8:	c0 93 b1 0d 	sts	0x0DB1, r28
    21bc:	d0 92 b4 0d 	sts	0x0DB4, r13
  conn->rport = rport;
    21c0:	c0 92 b3 0d 	sts	0x0DB3, r12
    21c4:	e1 14       	cp	r14, r1
  if(ripaddr == NULL) {
    21c6:	f1 04       	cpc	r15, r1
    21c8:	81 f4       	brne	.+32     	; 0x21ea <uip_udp_new+0x94>
    21ca:	06 c0       	rjmp	.+12     	; 0x21d8 <uip_udp_new+0x82>
    21cc:	81 e0       	ldi	r24, 0x01	; 1
      conn = &uip_udp_conns[c];
      break;
    }
  }

  if(conn == 0) {
    21ce:	80 93 88 03 	sts	0x0388, r24
    21d2:	80 e0       	ldi	r24, 0x00	; 0
    return 0;
    21d4:	90 e0       	ldi	r25, 0x00	; 0
    21d6:	19 c0       	rjmp	.+50     	; 0x220a <uip_udp_new+0xb4>
    21d8:	10 92 ad 0d 	sts	0x0DAD, r1
  }

  conn->lport = HTONS(lastport);
  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    21dc:	10 92 ae 0d 	sts	0x0DAE, r1
    21e0:	10 92 af 0d 	sts	0x0DAF, r1
    21e4:	10 92 b0 0d 	sts	0x0DB0, r1
    21e8:	0d c0       	rjmp	.+26     	; 0x2204 <uip_udp_new+0xae>
    21ea:	f7 01       	movw	r30, r14
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    21ec:	40 81       	ld	r20, Z
    21ee:	51 81       	ldd	r21, Z+1	; 0x01
    21f0:	62 81       	ldd	r22, Z+2	; 0x02
    21f2:	73 81       	ldd	r23, Z+3	; 0x03
    21f4:	40 93 ad 0d 	sts	0x0DAD, r20
    21f8:	50 93 ae 0d 	sts	0x0DAE, r21
    21fc:	60 93 af 0d 	sts	0x0DAF, r22
    2200:	70 93 b0 0d 	sts	0x0DB0, r23
    2204:	20 e4       	ldi	r18, 0x40	; 64
  }
  conn->ttl = UIP_TTL;
    2206:	20 93 b5 0d 	sts	0x0DB5, r18
    220a:	df 91       	pop	r29

  return conn;
}
    220c:	cf 91       	pop	r28
    220e:	1f 91       	pop	r17
    2210:	0f 91       	pop	r16
    2212:	ff 90       	pop	r15
    2214:	ef 90       	pop	r14
    2216:	df 90       	pop	r13
    2218:	cf 90       	pop	r12
    221a:	08 95       	ret

0000221c <uip_ipchksum>:
    221c:	80 e0       	ldi	r24, 0x00	; 0
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    221e:	90 e0       	ldi	r25, 0x00	; 0
    2220:	6d ec       	ldi	r22, 0xCD	; 205
    2222:	77 e0       	ldi	r23, 0x07	; 7
    2224:	44 e1       	ldi	r20, 0x14	; 20
    2226:	50 e0       	ldi	r21, 0x00	; 0
    2228:	d6 de       	rcall	.-596    	; 0x1fd6 <chksum>
    222a:	00 97       	sbiw	r24, 0x00	; 0
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    222c:	09 f0       	breq	.+2      	; 0x2230 <uip_ipchksum+0x14>
    222e:	8f cf       	rjmp	.-226    	; 0x214e <htons>
    2230:	8f ef       	ldi	r24, 0xFF	; 255
    2232:	9f ef       	ldi	r25, 0xFF	; 255
    2234:	08 95       	ret

00002236 <uip_chksum>:
    2236:	9c 01       	movw	r18, r24
    2238:	ab 01       	movw	r20, r22
}
    223a:	80 e0       	ldi	r24, 0x00	; 0
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
  return htons(chksum(0, (u8_t *)data, len));
    223c:	90 e0       	ldi	r25, 0x00	; 0
    223e:	b9 01       	movw	r22, r18
    2240:	ca de       	rcall	.-620    	; 0x1fd6 <chksum>
    2242:	85 cf       	rjmp	.-246    	; 0x214e <htons>

00002244 <uip_tcpchksum>:
    2244:	cf 93       	push	r28
    2246:	df 93       	push	r29
}
    2248:	80 91 cf 07 	lds	r24, 0x07CF
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    224c:	d8 2f       	mov	r29, r24
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	c8 2f       	mov	r28, r24
    2252:	80 91 d0 07 	lds	r24, 0x07D0
    2256:	c8 0f       	add	r28, r24
    2258:	d1 1d       	adc	r29, r1
  /* First sum pseudo-header. */

  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    225a:	ce 01       	movw	r24, r28
    225c:	0e 97       	sbiw	r24, 0x0e	; 14
    225e:	69 ed       	ldi	r22, 0xD9	; 217
    2260:	77 e0       	ldi	r23, 0x07	; 7
    2262:	48 e0       	ldi	r20, 0x08	; 8
    2264:	50 e0       	ldi	r21, 0x00	; 0
    2266:	b7 de       	rcall	.-658    	; 0x1fd6 <chksum>
    2268:	ae 01       	movw	r20, r28
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    226a:	44 51       	subi	r20, 0x14	; 20
    226c:	50 40       	sbci	r21, 0x00	; 0
    226e:	61 ee       	ldi	r22, 0xE1	; 225
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    2270:	77 e0       	ldi	r23, 0x07	; 7
    2272:	b1 de       	rcall	.-670    	; 0x1fd6 <chksum>
    2274:	00 97       	sbiw	r24, 0x00	; 0
    2276:	11 f0       	breq	.+4      	; 0x227c <uip_tcpchksum+0x38>
	       upper_layer_len);

  return (sum == 0) ? 0xffff : htons(sum);
    2278:	6a df       	rcall	.-300    	; 0x214e <htons>
    227a:	02 c0       	rjmp	.+4      	; 0x2280 <uip_tcpchksum+0x3c>
    227c:	8f ef       	ldi	r24, 0xFF	; 255
    227e:	9f ef       	ldi	r25, 0xFF	; 255
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	08 95       	ret

00002286 <uip_process>:
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    2286:	af 92       	push	r10
    2288:	bf 92       	push	r11
    228a:	cf 92       	push	r12
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    228c:	df 92       	push	r13
    228e:	ef 92       	push	r14
    2290:	ff 92       	push	r15
    2292:	0f 93       	push	r16
    2294:	1f 93       	push	r17
    2296:	cf 93       	push	r28
    2298:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    229a:	c0 91 54 06 	lds	r28, 0x0654
    229e:	d0 91 55 06 	lds	r29, 0x0655

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    22a2:	84 30       	cpi	r24, 0x04	; 4
    22a4:	09 f4       	brne	.+2      	; 0x22a8 <uip_process+0x22>
    22a6:	66 c2       	rjmp	.+1228   	; 0x2774 <uip_process+0x4ee>
    goto udp_send;
  }
#endif /* UIP_UDP */

  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    22a8:	25 ef       	ldi	r18, 0xF5	; 245
    22aa:	37 e0       	ldi	r19, 0x07	; 7
    22ac:	30 93 53 06 	sts	0x0653, r19
    22b0:	20 93 52 06 	sts	0x0652, r18
    22b4:	30 93 4a 06 	sts	0x064A, r19
    22b8:	20 93 49 06 	sts	0x0649, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    22bc:	83 30       	cpi	r24, 0x03	; 3
    22be:	99 f4       	brne	.+38     	; 0x22e6 <uip_process+0x60>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    22c0:	89 8d       	ldd	r24, Y+25	; 0x19
    22c2:	8f 70       	andi	r24, 0x0F	; 15
    22c4:	83 30       	cpi	r24, 0x03	; 3
    22c6:	09 f0       	breq	.+2      	; 0x22ca <uip_process+0x44>
    22c8:	7c c7       	rjmp	.+3832   	; 0x31c2 <uip_process+0xf3c>
    22ca:	88 89       	ldd	r24, Y+16	; 0x10
    22cc:	99 89       	ldd	r25, Y+17	; 0x11
    22ce:	00 97       	sbiw	r24, 0x00	; 0
    22d0:	09 f0       	breq	.+2      	; 0x22d4 <uip_process+0x4e>
    22d2:	77 c7       	rjmp	.+3822   	; 0x31c2 <uip_process+0xf3c>
       !uip_outstanding(uip_connr)) {
	uip_len = uip_slen = 0;
    22d4:	10 92 ac 0d 	sts	0x0DAC, r1
    22d8:	10 92 ab 0d 	sts	0x0DAB, r1
    22dc:	10 92 48 06 	sts	0x0648, r1
    22e0:	10 92 47 06 	sts	0x0647, r1
    22e4:	8d c0       	rjmp	.+282    	; 0x2400 <uip_process+0x17a>
	goto appsend;
    }
    goto drop;

    /* Check if we were invoked because of the periodic timer firing. */
  } else if(flag == UIP_TIMER) {
    22e6:	82 30       	cpi	r24, 0x02	; 2
    22e8:	09 f0       	breq	.+2      	; 0x22ec <uip_process+0x66>
    22ea:	8e c0       	rjmp	.+284    	; 0x2408 <uip_process+0x182>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    22ec:	80 91 8e 03 	lds	r24, 0x038E
    22f0:	8f 5f       	subi	r24, 0xFF	; 255
    22f2:	80 93 8e 03 	sts	0x038E, r24
    22f6:	88 23       	and	r24, r24
    22f8:	99 f4       	brne	.+38     	; 0x2320 <uip_process+0x9a>
      if(++iss[2] == 0) {
    22fa:	80 91 8d 03 	lds	r24, 0x038D
    22fe:	8f 5f       	subi	r24, 0xFF	; 255
    2300:	80 93 8d 03 	sts	0x038D, r24
    2304:	88 23       	and	r24, r24
    2306:	61 f4       	brne	.+24     	; 0x2320 <uip_process+0x9a>
	if(++iss[1] == 0) {
    2308:	80 91 8c 03 	lds	r24, 0x038C
    230c:	8f 5f       	subi	r24, 0xFF	; 255
    230e:	80 93 8c 03 	sts	0x038C, r24
    2312:	88 23       	and	r24, r24
    2314:	29 f4       	brne	.+10     	; 0x2320 <uip_process+0x9a>
	  ++iss[0];
    2316:	80 91 8b 03 	lds	r24, 0x038B
    231a:	8f 5f       	subi	r24, 0xFF	; 255
    231c:	80 93 8b 03 	sts	0x038B, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    2320:	10 92 48 06 	sts	0x0648, r1
    2324:	10 92 47 06 	sts	0x0647, r1
    uip_slen = 0;
    2328:	10 92 ac 0d 	sts	0x0DAC, r1
    232c:	10 92 ab 0d 	sts	0x0DAB, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    2330:	89 8d       	ldd	r24, Y+25	; 0x19
    2332:	87 30       	cpi	r24, 0x07	; 7
    2334:	11 f0       	breq	.+4      	; 0x233a <uip_process+0xb4>
    2336:	85 30       	cpi	r24, 0x05	; 5
    2338:	41 f4       	brne	.+16     	; 0x234a <uip_process+0xc4>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    233a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    233c:	8f 5f       	subi	r24, 0xFF	; 255
    233e:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    2340:	88 37       	cpi	r24, 0x78	; 120
    2342:	09 f0       	breq	.+2      	; 0x2346 <uip_process+0xc0>
    2344:	3e c7       	rjmp	.+3708   	; 0x31c2 <uip_process+0xf3c>
	uip_connr->tcpstateflags = UIP_CLOSED;
    2346:	19 8e       	std	Y+25, r1	; 0x19
    2348:	3c c7       	rjmp	.+3704   	; 0x31c2 <uip_process+0xf3c>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    234a:	88 23       	and	r24, r24
    234c:	09 f4       	brne	.+2      	; 0x2350 <uip_process+0xca>
    234e:	39 c7       	rjmp	.+3698   	; 0x31c2 <uip_process+0xf3c>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    2350:	28 89       	ldd	r18, Y+16	; 0x10
    2352:	39 89       	ldd	r19, Y+17	; 0x11
    2354:	21 15       	cp	r18, r1
    2356:	31 05       	cpc	r19, r1
    2358:	09 f4       	brne	.+2      	; 0x235c <uip_process+0xd6>
    235a:	4e c0       	rjmp	.+156    	; 0x23f8 <uip_process+0x172>
	if(uip_connr->timer-- == 0) {
    235c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    235e:	29 2f       	mov	r18, r25
    2360:	21 50       	subi	r18, 0x01	; 1
    2362:	2a 8f       	std	Y+26, r18	; 0x1a
    2364:	99 23       	and	r25, r25
    2366:	09 f0       	breq	.+2      	; 0x236a <uip_process+0xe4>
    2368:	2c c7       	rjmp	.+3672   	; 0x31c2 <uip_process+0xf3c>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    236a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    236c:	98 30       	cpi	r25, 0x08	; 8
    236e:	31 f0       	breq	.+12     	; 0x237c <uip_process+0xf6>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    2370:	28 2f       	mov	r18, r24
    2372:	21 50       	subi	r18, 0x01	; 1
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    2374:	22 30       	cpi	r18, 0x02	; 2
    2376:	48 f4       	brcc	.+18     	; 0x238a <uip_process+0x104>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    2378:	95 30       	cpi	r25, 0x05	; 5
    237a:	39 f4       	brne	.+14     	; 0x238a <uip_process+0x104>
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    237c:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    237e:	80 e8       	ldi	r24, 0x80	; 128
    2380:	80 93 4f 06 	sts	0x064F, r24
	    UIP_APPCALL();
    2384:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
    2388:	d7 c5       	rjmp	.+2990   	; 0x2f38 <uip_process+0xcb2>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential back-off. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    238a:	95 30       	cpi	r25, 0x05	; 5
    238c:	48 f4       	brcc	.+18     	; 0x23a0 <uip_process+0x11a>
    238e:	23 e0       	ldi	r18, 0x03	; 3
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	09 2e       	mov	r0, r25
    2394:	02 c0       	rjmp	.+4      	; 0x239a <uip_process+0x114>
    2396:	22 0f       	add	r18, r18
    2398:	33 1f       	adc	r19, r19
    239a:	0a 94       	dec	r0
    239c:	e2 f7       	brpl	.-8      	; 0x2396 <uip_process+0x110>
    239e:	01 c0       	rjmp	.+2      	; 0x23a2 <uip_process+0x11c>
    23a0:	20 e3       	ldi	r18, 0x30	; 48
    23a2:	2a 8f       	std	Y+26, r18	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    23a4:	9f 5f       	subi	r25, 0xFF	; 255
    23a6:	9b 8f       	std	Y+27, r25	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	8f 70       	andi	r24, 0x0F	; 15
    23ac:	90 70       	andi	r25, 0x00	; 0
    23ae:	83 30       	cpi	r24, 0x03	; 3
    23b0:	91 05       	cpc	r25, r1
    23b2:	e1 f0       	breq	.+56     	; 0x23ec <uip_process+0x166>
    23b4:	84 30       	cpi	r24, 0x04	; 4
    23b6:	91 05       	cpc	r25, r1
    23b8:	4c f4       	brge	.+18     	; 0x23cc <uip_process+0x146>
    23ba:	81 30       	cpi	r24, 0x01	; 1
    23bc:	91 05       	cpc	r25, r1
    23be:	09 f4       	brne	.+2      	; 0x23c2 <uip_process+0x13c>
    23c0:	c5 c3       	rjmp	.+1930   	; 0x2b4c <uip_process+0x8c6>
    23c2:	82 30       	cpi	r24, 0x02	; 2
    23c4:	91 05       	cpc	r25, r1
    23c6:	09 f0       	breq	.+2      	; 0x23ca <uip_process+0x144>
    23c8:	fc c6       	rjmp	.+3576   	; 0x31c2 <uip_process+0xf3c>
    23ca:	0d c0       	rjmp	.+26     	; 0x23e6 <uip_process+0x160>
    23cc:	86 30       	cpi	r24, 0x06	; 6
    23ce:	91 05       	cpc	r25, r1
    23d0:	09 f4       	brne	.+2      	; 0x23d4 <uip_process+0x14e>
    23d2:	c1 c5       	rjmp	.+2946   	; 0x2f56 <uip_process+0xcd0>
    23d4:	88 30       	cpi	r24, 0x08	; 8
    23d6:	91 05       	cpc	r25, r1
    23d8:	09 f4       	brne	.+2      	; 0x23dc <uip_process+0x156>
    23da:	bd c5       	rjmp	.+2938   	; 0x2f56 <uip_process+0xcd0>
    23dc:	84 30       	cpi	r24, 0x04	; 4
    23de:	91 05       	cpc	r25, r1
    23e0:	09 f0       	breq	.+2      	; 0x23e4 <uip_process+0x15e>
    23e2:	ef c6       	rjmp	.+3550   	; 0x31c2 <uip_process+0xf3c>
    23e4:	b8 c5       	rjmp	.+2928   	; 0x2f56 <uip_process+0xcd0>
	    goto tcp_send_synack;

#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    23e6:	10 92 ee 07 	sts	0x07EE, r1
	    goto tcp_send_syn;
    23ea:	b3 c3       	rjmp	.+1894   	; 0x2b52 <uip_process+0x8cc>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    23ec:	84 e0       	ldi	r24, 0x04	; 4
    23ee:	80 93 4f 06 	sts	0x064F, r24
	    UIP_APPCALL();
    23f2:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
	    goto apprexmit;
    23f6:	d5 c5       	rjmp	.+2986   	; 0x2fa2 <uip_process+0xd1c>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;

	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    23f8:	8f 70       	andi	r24, 0x0F	; 15
    23fa:	83 30       	cpi	r24, 0x03	; 3
    23fc:	09 f0       	breq	.+2      	; 0x2400 <uip_process+0x17a>
    23fe:	e1 c6       	rjmp	.+3522   	; 0x31c2 <uip_process+0xf3c>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_len = uip_slen = 0;
	uip_flags = UIP_POLL;
    2400:	88 e0       	ldi	r24, 0x08	; 8
    2402:	80 93 4f 06 	sts	0x064F, r24
    2406:	8d c5       	rjmp	.+2842   	; 0x2f22 <uip_process+0xc9c>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    2408:	85 30       	cpi	r24, 0x05	; 5
    240a:	19 f5       	brne	.+70     	; 0x2452 <uip_process+0x1cc>
    if(uip_udp_conn->lport != 0) {
    240c:	e0 91 50 06 	lds	r30, 0x0650
    2410:	f0 91 51 06 	lds	r31, 0x0651
    2414:	84 81       	ldd	r24, Z+4	; 0x04
    2416:	95 81       	ldd	r25, Z+5	; 0x05
    2418:	00 97       	sbiw	r24, 0x00	; 0
    241a:	09 f4       	brne	.+2      	; 0x241e <uip_process+0x198>
    241c:	d2 c6       	rjmp	.+3492   	; 0x31c2 <uip_process+0xf3c>
      uip_conn = NULL;
    241e:	10 92 55 06 	sts	0x0655, r1
    2422:	10 92 54 06 	sts	0x0654, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2426:	2c 50       	subi	r18, 0x0C	; 12
    2428:	30 40       	sbci	r19, 0x00	; 0
    242a:	30 93 53 06 	sts	0x0653, r19
    242e:	20 93 52 06 	sts	0x0652, r18
    2432:	30 93 4a 06 	sts	0x064A, r19
    2436:	20 93 49 06 	sts	0x0649, r18
      uip_len = uip_slen = 0;
    243a:	10 92 ac 0d 	sts	0x0DAC, r1
    243e:	10 92 ab 0d 	sts	0x0DAB, r1
    2442:	10 92 48 06 	sts	0x0648, r1
    2446:	10 92 47 06 	sts	0x0647, r1
      uip_flags = UIP_POLL;
    244a:	88 e0       	ldi	r24, 0x08	; 8
    244c:	80 93 4f 06 	sts	0x064F, r24
    2450:	8f c1       	rjmp	.+798    	; 0x2770 <uip_process+0x4ea>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    2452:	80 91 cd 07 	lds	r24, 0x07CD
    2456:	85 34       	cpi	r24, 0x45	; 69
    2458:	09 f0       	breq	.+2      	; 0x245c <uip_process+0x1d6>
    245a:	b3 c6       	rjmp	.+3430   	; 0x31c2 <uip_process+0xf3c>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    245c:	10 91 cf 07 	lds	r17, 0x07CF
    2460:	00 e0       	ldi	r16, 0x00	; 0
    2462:	80 91 d0 07 	lds	r24, 0x07D0
    2466:	08 0f       	add	r16, r24
    2468:	11 1d       	adc	r17, r1
    246a:	80 91 47 06 	lds	r24, 0x0647
    246e:	90 91 48 06 	lds	r25, 0x0648
    2472:	80 17       	cp	r24, r16
    2474:	91 07       	cpc	r25, r17
    2476:	08 f4       	brcc	.+2      	; 0x247a <uip_process+0x1f4>
    2478:	a4 c6       	rjmp	.+3400   	; 0x31c2 <uip_process+0xf3c>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    247a:	10 93 48 06 	sts	0x0648, r17
    247e:	00 93 47 06 	sts	0x0647, r16
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    2482:	80 91 d3 07 	lds	r24, 0x07D3
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	8f 73       	andi	r24, 0x3F	; 63
    248a:	90 70       	andi	r25, 0x00	; 0
    248c:	00 97       	sbiw	r24, 0x00	; 0
    248e:	09 f0       	breq	.+2      	; 0x2492 <uip_process+0x20c>
    2490:	98 c6       	rjmp	.+3376   	; 0x31c2 <uip_process+0xf3c>
    2492:	80 91 d4 07 	lds	r24, 0x07D4
    2496:	88 23       	and	r24, r24
    2498:	09 f0       	breq	.+2      	; 0x249c <uip_process+0x216>
    249a:	93 c6       	rjmp	.+3366   	; 0x31c2 <uip_process+0xf3c>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    249c:	60 91 bb 07 	lds	r22, 0x07BB
    24a0:	70 91 bc 07 	lds	r23, 0x07BC
    24a4:	e0 91 20 03 	lds	r30, 0x0320
    24a8:	f0 91 21 03 	lds	r31, 0x0321
    24ac:	6e 17       	cp	r22, r30
    24ae:	7f 07       	cpc	r23, r31
    24b0:	61 f4       	brne	.+24     	; 0x24ca <uip_process+0x244>
    24b2:	80 91 bd 07 	lds	r24, 0x07BD
    24b6:	90 91 be 07 	lds	r25, 0x07BE
    24ba:	20 91 22 03 	lds	r18, 0x0322
    24be:	30 91 23 03 	lds	r19, 0x0323
    24c2:	82 17       	cp	r24, r18
    24c4:	93 07       	cpc	r25, r19
    24c6:	09 f4       	brne	.+2      	; 0x24ca <uip_process+0x244>
    24c8:	48 c0       	rjmp	.+144    	; 0x255a <uip_process+0x2d4>
  } else {
    /* If IP broadcast support is configured, we check for a broadcast
       UDP packet, which may be destined to us. */
#if UIP_BROADCAST
    DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
    if(BUF->proto == UIP_PROTO_UDP &&
    24ca:	80 91 d6 07 	lds	r24, 0x07D6
    24ce:	40 91 dd 07 	lds	r20, 0x07DD
    24d2:	50 91 de 07 	lds	r21, 0x07DE
    24d6:	81 31       	cpi	r24, 0x11	; 17
    24d8:	81 f5       	brne	.+96     	; 0x253a <uip_process+0x2b4>
    24da:	80 91 24 03 	lds	r24, 0x0324
    24de:	90 91 25 03 	lds	r25, 0x0325
    24e2:	48 17       	cp	r20, r24
    24e4:	59 07       	cpc	r21, r25
    24e6:	49 f5       	brne	.+82     	; 0x253a <uip_process+0x2b4>
       uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
    24e8:	80 91 df 07 	lds	r24, 0x07DF
    24ec:	90 91 e0 07 	lds	r25, 0x07E0
    24f0:	20 91 26 03 	lds	r18, 0x0326
    24f4:	30 91 27 03 	lds	r19, 0x0327
    24f8:	82 17       	cp	r24, r18
    24fa:	93 07       	cpc	r25, r19
    24fc:	f1 f4       	brne	.+60     	; 0x253a <uip_process+0x2b4>
	{
		if (uip_ipaddr_cmp(&BUF->srcipaddr, &uip_all_zeroes_addr))
    24fe:	80 91 d9 07 	lds	r24, 0x07D9
    2502:	90 91 da 07 	lds	r25, 0x07DA
    2506:	8e 17       	cp	r24, r30
    2508:	9f 07       	cpc	r25, r31
    250a:	09 f0       	breq	.+2      	; 0x250e <uip_process+0x288>
    250c:	6d c0       	rjmp	.+218    	; 0x25e8 <uip_process+0x362>
    250e:	20 91 db 07 	lds	r18, 0x07DB
    2512:	30 91 dc 07 	lds	r19, 0x07DC
    2516:	80 91 22 03 	lds	r24, 0x0322
    251a:	90 91 23 03 	lds	r25, 0x0323
    251e:	28 17       	cp	r18, r24
    2520:	39 07       	cpc	r19, r25
    2522:	09 f0       	breq	.+2      	; 0x2526 <uip_process+0x2a0>
    2524:	61 c0       	rjmp	.+194    	; 0x25e8 <uip_process+0x362>
		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
    2526:	8f ef       	ldi	r24, 0xFF	; 255
    2528:	80 93 d9 07 	sts	0x07D9, r24
    252c:	80 93 da 07 	sts	0x07DA, r24
    2530:	80 93 db 07 	sts	0x07DB, r24
    2534:	80 93 dc 07 	sts	0x07DC, r24
    2538:	57 c0       	rjmp	.+174    	; 0x25e8 <uip_process+0x362>
    }
#endif /* UIP_BROADCAST */

    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    253a:	46 17       	cp	r20, r22
    253c:	57 07       	cpc	r21, r23
    253e:	09 f0       	breq	.+2      	; 0x2542 <uip_process+0x2bc>
    2540:	40 c6       	rjmp	.+3200   	; 0x31c2 <uip_process+0xf3c>
    2542:	20 91 df 07 	lds	r18, 0x07DF
    2546:	30 91 e0 07 	lds	r19, 0x07E0
    254a:	80 91 bd 07 	lds	r24, 0x07BD
    254e:	90 91 be 07 	lds	r25, 0x07BE
    2552:	28 17       	cp	r18, r24
    2554:	39 07       	cpc	r19, r25
    2556:	09 f0       	breq	.+2      	; 0x255a <uip_process+0x2d4>
    2558:	34 c6       	rjmp	.+3176   	; 0x31c2 <uip_process+0xf3c>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    255a:	60 de       	rcall	.-832    	; 0x221c <uip_ipchksum>
    255c:	2f ef       	ldi	r18, 0xFF	; 255
    255e:	8f 3f       	cpi	r24, 0xFF	; 255
    2560:	92 07       	cpc	r25, r18
    2562:	09 f0       	breq	.+2      	; 0x2566 <uip_process+0x2e0>
    2564:	2e c6       	rjmp	.+3164   	; 0x31c2 <uip_process+0xf3c>
    2566:	80 91 d6 07 	lds	r24, 0x07D6
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    256a:	86 30       	cpi	r24, 0x06	; 6
    256c:	09 f4       	brne	.+2      	; 0x2570 <uip_process+0x2ea>
    256e:	59 c1       	rjmp	.+690    	; 0x2822 <uip_process+0x59c>
    2570:	81 31       	cpi	r24, 0x11	; 17
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    2572:	d1 f1       	breq	.+116    	; 0x25e8 <uip_process+0x362>
    2574:	81 30       	cpi	r24, 0x01	; 1
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    2576:	09 f0       	breq	.+2      	; 0x257a <uip_process+0x2f4>
    2578:	24 c6       	rjmp	.+3144   	; 0x31c2 <uip_process+0xf3c>
    257a:	80 91 e1 07 	lds	r24, 0x07E1
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    257e:	88 30       	cpi	r24, 0x08	; 8
    2580:	09 f0       	breq	.+2      	; 0x2584 <uip_process+0x2fe>
    2582:	1f c6       	rjmp	.+3134   	; 0x31c2 <uip_process+0xf3c>
    2584:	10 92 e1 07 	sts	0x07E1, r1
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    2588:	80 91 e3 07 	lds	r24, 0x07E3

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    258c:	90 91 e4 07 	lds	r25, 0x07E4
    2590:	2f ef       	ldi	r18, 0xFF	; 255
    2592:	87 3f       	cpi	r24, 0xF7	; 247
    2594:	92 07       	cpc	r25, r18
    2596:	10 f0       	brcs	.+4      	; 0x259c <uip_process+0x316>
    2598:	09 96       	adiw	r24, 0x09	; 9
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    259a:	01 c0       	rjmp	.+2      	; 0x259e <uip_process+0x318>
    259c:	08 96       	adiw	r24, 0x08	; 8
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    259e:	90 93 e4 07 	sts	0x07E4, r25
    25a2:	80 93 e3 07 	sts	0x07E3, r24
    25a6:	ef eb       	ldi	r30, 0xBF	; 191
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    25a8:	f7 e0       	ldi	r31, 0x07	; 7
    25aa:	80 91 d9 07 	lds	r24, 0x07D9
    25ae:	90 91 da 07 	lds	r25, 0x07DA
    25b2:	a0 91 db 07 	lds	r26, 0x07DB
    25b6:	b0 91 dc 07 	lds	r27, 0x07DC
    25ba:	80 93 dd 07 	sts	0x07DD, r24
    25be:	90 93 de 07 	sts	0x07DE, r25
    25c2:	a0 93 df 07 	sts	0x07DF, r26
    25c6:	b0 93 e0 07 	sts	0x07E0, r27
    25ca:	80 91 bb 07 	lds	r24, 0x07BB
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    25ce:	90 91 bc 07 	lds	r25, 0x07BC
    25d2:	a0 91 bd 07 	lds	r26, 0x07BD
    25d6:	b0 91 be 07 	lds	r27, 0x07BE
    25da:	82 8f       	std	Z+26, r24	; 0x1a
    25dc:	93 8f       	std	Z+27, r25	; 0x1b
    25de:	a4 8f       	std	Z+28, r26	; 0x1c
    25e0:	b5 8f       	std	Z+29, r27	; 0x1d
    25e2:	80 e4       	ldi	r24, 0x40	; 64

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    25e4:	86 8b       	std	Z+22, r24	; 0x16
    25e6:	cb c5       	rjmp	.+2966   	; 0x317e <uip_process+0xef8>
  goto ip_send_nolen;
    25e8:	0c 51       	subi	r16, 0x1C	; 28
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
    25ea:	10 40       	sbci	r17, 0x00	; 0
    25ec:	10 93 48 06 	sts	0x0648, r17
    25f0:	00 93 47 06 	sts	0x0647, r16
    25f4:	8d ea       	ldi	r24, 0xAD	; 173
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    25f6:	9d e0       	ldi	r25, 0x0D	; 13
    25f8:	90 93 51 06 	sts	0x0651, r25
    25fc:	80 93 50 06 	sts	0x0650, r24
    2600:	40 91 e3 07 	lds	r20, 0x07E3
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    2604:	50 91 e4 07 	lds	r21, 0x07E4
    2608:	60 91 e1 07 	lds	r22, 0x07E1
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    260c:	70 91 e2 07 	lds	r23, 0x07E2
    2610:	a0 91 20 03 	lds	r26, 0x0320
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    2614:	b0 91 21 03 	lds	r27, 0x0321
    2618:	c0 91 22 03 	lds	r28, 0x0322
    261c:	d0 91 23 03 	lds	r29, 0x0323
    2620:	00 91 24 03 	lds	r16, 0x0324
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    2624:	10 91 25 03 	lds	r17, 0x0325
    2628:	e0 90 26 03 	lds	r14, 0x0326
    262c:	f0 90 27 03 	lds	r15, 0x0327
    2630:	c0 90 d9 07 	lds	r12, 0x07D9
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    2634:	d0 90 da 07 	lds	r13, 0x07DA
    2638:	a0 90 db 07 	lds	r10, 0x07DB
    263c:	b0 90 dc 07 	lds	r11, 0x07DC
    2640:	31 c0       	rjmp	.+98     	; 0x26a4 <uip_process+0x41e>
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    2642:	84 81       	ldd	r24, Z+4	; 0x04
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    2644:	95 81       	ldd	r25, Z+5	; 0x05
    2646:	00 97       	sbiw	r24, 0x00	; 0
    2648:	39 f1       	breq	.+78     	; 0x2698 <uip_process+0x412>
    264a:	48 17       	cp	r20, r24
    264c:	59 07       	cpc	r21, r25
    264e:	21 f5       	brne	.+72     	; 0x2698 <uip_process+0x412>
    2650:	86 81       	ldd	r24, Z+6	; 0x06
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
    2652:	97 81       	ldd	r25, Z+7	; 0x07
    2654:	00 97       	sbiw	r24, 0x00	; 0
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    2656:	19 f0       	breq	.+6      	; 0x265e <uip_process+0x3d8>
    2658:	68 17       	cp	r22, r24
       (uip_udp_conn->rport == 0 ||
    265a:	79 07       	cpc	r23, r25
    265c:	e9 f4       	brne	.+58     	; 0x2698 <uip_process+0x412>
    265e:	20 81       	ld	r18, Z
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    2660:	31 81       	ldd	r19, Z+1	; 0x01
    2662:	2a 17       	cp	r18, r26
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    2664:	3b 07       	cpc	r19, r27
    2666:	31 f4       	brne	.+12     	; 0x2674 <uip_process+0x3ee>
    2668:	82 81       	ldd	r24, Z+2	; 0x02
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    266a:	93 81       	ldd	r25, Z+3	; 0x03
    266c:	8c 17       	cp	r24, r28
    266e:	9d 07       	cpc	r25, r29
    2670:	09 f4       	brne	.+2      	; 0x2674 <uip_process+0x3ee>
    2672:	69 c0       	rjmp	.+210    	; 0x2746 <uip_process+0x4c0>
    2674:	20 17       	cp	r18, r16
    2676:	31 07       	cpc	r19, r17
    2678:	31 f4       	brne	.+12     	; 0x2686 <uip_process+0x400>
    267a:	82 81       	ldd	r24, Z+2	; 0x02
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    267c:	93 81       	ldd	r25, Z+3	; 0x03
    267e:	8e 15       	cp	r24, r14
    2680:	9f 05       	cpc	r25, r15
    2682:	09 f4       	brne	.+2      	; 0x2686 <uip_process+0x400>
    2684:	60 c0       	rjmp	.+192    	; 0x2746 <uip_process+0x4c0>
    2686:	c2 16       	cp	r12, r18
    2688:	d3 06       	cpc	r13, r19
    268a:	31 f4       	brne	.+12     	; 0x2698 <uip_process+0x412>
    268c:	82 81       	ldd	r24, Z+2	; 0x02
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    268e:	93 81       	ldd	r25, Z+3	; 0x03
    2690:	a8 16       	cp	r10, r24
    2692:	b9 06       	cpc	r11, r25
    2694:	09 f4       	brne	.+2      	; 0x2698 <uip_process+0x412>
    2696:	57 c0       	rjmp	.+174    	; 0x2746 <uip_process+0x4c0>
    2698:	cf 01       	movw	r24, r30
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    269a:	4e 96       	adiw	r24, 0x1e	; 30
    269c:	90 93 51 06 	sts	0x0651, r25
    26a0:	80 93 50 06 	sts	0x0650, r24
    26a4:	e0 91 50 06 	lds	r30, 0x0650
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    26a8:	f0 91 51 06 	lds	r31, 0x0651
    26ac:	8d e0       	ldi	r24, 0x0D	; 13
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    26ae:	eb 3c       	cpi	r30, 0xCB	; 203
    26b0:	f8 07       	cpc	r31, r24
    26b2:	38 f2       	brcs	.-114    	; 0x2642 <uip_process+0x3bc>
    26b4:	e9 ee       	ldi	r30, 0xE9	; 233
    }
  }
  UIP_LOG("udp: no matching connection found");
#if UIP_CONF_ICMP_DEST_UNREACH && !UIP_CONF_IPV6
  /* Copy fields from packet header into payload of this ICMP packet. */
  memcpy(&(ICMPBUF->payload[0]), ICMPBUF, UIP_IPH_LEN + 8);
    26b6:	f7 e0       	ldi	r31, 0x07	; 7
    26b8:	df 01       	movw	r26, r30
    26ba:	5c 97       	sbiw	r26, 0x1c	; 28
    26bc:	8c e1       	ldi	r24, 0x1C	; 28
    26be:	0d 90       	ld	r0, X+
    26c0:	01 92       	st	Z+, r0
    26c2:	81 50       	subi	r24, 0x01	; 1
    26c4:	e1 f7       	brne	.-8      	; 0x26be <uip_process+0x438>
    26c6:	83 e0       	ldi	r24, 0x03	; 3

  /* Set the ICMP type and code. */
  ICMPBUF->type = ICMP_DEST_UNREACHABLE;
    26c8:	80 93 e1 07 	sts	0x07E1, r24
    26cc:	80 93 e2 07 	sts	0x07E2, r24
  ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
    26d0:	10 92 e4 07 	sts	0x07E4, r1

  /* Calculate the ICMP checksum. */
  ICMPBUF->icmpchksum = 0;
    26d4:	10 92 e3 07 	sts	0x07E3, r1
    26d8:	81 ee       	ldi	r24, 0xE1	; 225
  ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
    26da:	97 e0       	ldi	r25, 0x07	; 7
    26dc:	64 e2       	ldi	r22, 0x24	; 36
    26de:	70 e0       	ldi	r23, 0x00	; 0
    26e0:	aa dd       	rcall	.-1196   	; 0x2236 <uip_chksum>
    26e2:	80 95       	com	r24
    26e4:	90 95       	com	r25
    26e6:	90 93 e4 07 	sts	0x07E4, r25
    26ea:	80 93 e3 07 	sts	0x07E3, r24
    26ee:	ef eb       	ldi	r30, 0xBF	; 191
    26f0:	f7 e0       	ldi	r31, 0x07	; 7

  /* Set the IP destination address to be the source address of the
     original packet. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    26f2:	80 91 d9 07 	lds	r24, 0x07D9
    26f6:	90 91 da 07 	lds	r25, 0x07DA
    26fa:	a0 91 db 07 	lds	r26, 0x07DB
    26fe:	b0 91 dc 07 	lds	r27, 0x07DC
    2702:	80 93 dd 07 	sts	0x07DD, r24
    2706:	90 93 de 07 	sts	0x07DE, r25
    270a:	a0 93 df 07 	sts	0x07DF, r26
    270e:	b0 93 e0 07 	sts	0x07E0, r27
    2712:	80 91 bb 07 	lds	r24, 0x07BB

  /* Set our IP address as the source address. */
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2716:	90 91 bc 07 	lds	r25, 0x07BC
    271a:	a0 91 bd 07 	lds	r26, 0x07BD
    271e:	b0 91 be 07 	lds	r27, 0x07BE
    2722:	82 8f       	std	Z+26, r24	; 0x1a
    2724:	93 8f       	std	Z+27, r25	; 0x1b
    2726:	a4 8f       	std	Z+28, r26	; 0x1c
    2728:	b5 8f       	std	Z+29, r27	; 0x1d
    272a:	88 e3       	ldi	r24, 0x38	; 56
    272c:	90 e0       	ldi	r25, 0x00	; 0

  /* The size of the ICMP destination unreachable packet is 36 + the
     size of the IP header (20) = 56. */
  uip_len = 36 + UIP_IPH_LEN;
    272e:	90 93 48 06 	sts	0x0648, r25
    2732:	80 93 47 06 	sts	0x0647, r24
    2736:	10 8a       	std	Z+16, r1	; 0x10
    2738:	88 e3       	ldi	r24, 0x38	; 56
  ICMPBUF->len[0] = 0;
    273a:	81 8b       	std	Z+17, r24	; 0x11
  ICMPBUF->len[1] = (u8_t)uip_len;
    273c:	80 e4       	ldi	r24, 0x40	; 64
    273e:	86 8b       	std	Z+22, r24	; 0x16
  ICMPBUF->ttl = UIP_TTL;
    2740:	81 e0       	ldi	r24, 0x01	; 1
    2742:	87 8b       	std	Z+23, r24	; 0x17
  ICMPBUF->proto = UIP_PROTO_ICMP;
    2744:	1c c5       	rjmp	.+2616   	; 0x317e <uip_process+0xef8>
    2746:	10 92 55 06 	sts	0x0655, r1
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */

 udp_found:
  uip_conn = NULL;
    274a:	10 92 54 06 	sts	0x0654, r1
    274e:	82 e0       	ldi	r24, 0x02	; 2
    2750:	80 93 4f 06 	sts	0x064F, r24
  uip_flags = UIP_NEWDATA;
    2754:	89 ee       	ldi	r24, 0xE9	; 233
    2756:	97 e0       	ldi	r25, 0x07	; 7
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2758:	90 93 53 06 	sts	0x0653, r25
    275c:	80 93 52 06 	sts	0x0652, r24
    2760:	90 93 4a 06 	sts	0x064A, r25
    2764:	80 93 49 06 	sts	0x0649, r24
    2768:	10 92 ac 0d 	sts	0x0DAC, r1
  uip_slen = 0;
    276c:	10 92 ab 0d 	sts	0x0DAB, r1
    2770:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <uIPManagement_UDPCallback>
  UIP_UDP_APPCALL();
    2774:	80 91 ab 0d 	lds	r24, 0x0DAB

 udp_send:
  if(uip_slen == 0) {
    2778:	90 91 ac 0d 	lds	r25, 0x0DAC
    277c:	00 97       	sbiw	r24, 0x00	; 0
    277e:	09 f4       	brne	.+2      	; 0x2782 <uip_process+0x4fc>
    2780:	20 c5       	rjmp	.+2624   	; 0x31c2 <uip_process+0xf3c>
    2782:	9c 01       	movw	r18, r24
    2784:	24 5e       	subi	r18, 0xE4	; 228
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    2786:	3f 4f       	sbci	r19, 0xFF	; 255
    2788:	30 93 48 06 	sts	0x0648, r19
    278c:	20 93 47 06 	sts	0x0647, r18
    2790:	30 93 cf 07 	sts	0x07CF, r19
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    2794:	20 93 d0 07 	sts	0x07D0, r18
  BUF->len[1] = (uip_len & 0xff);
    2798:	e0 91 50 06 	lds	r30, 0x0650
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    279c:	f0 91 51 06 	lds	r31, 0x0651
    27a0:	20 85       	ldd	r18, Z+8	; 0x08
    27a2:	20 93 d5 07 	sts	0x07D5, r18
    27a6:	21 e1       	ldi	r18, 0x11	; 17
    27a8:	20 93 d6 07 	sts	0x07D6, r18
  BUF->proto = UIP_PROTO_UDP;
    27ac:	08 96       	adiw	r24, 0x08	; 8
    27ae:	98 27       	eor	r25, r24

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
    27b0:	89 27       	eor	r24, r25
    27b2:	98 27       	eor	r25, r24
    27b4:	90 93 e6 07 	sts	0x07E6, r25
    27b8:	80 93 e5 07 	sts	0x07E5, r24
    27bc:	10 92 e8 07 	sts	0x07E8, r1
  UDPBUF->udpchksum = 0;
    27c0:	10 92 e7 07 	sts	0x07E7, r1
    27c4:	84 81       	ldd	r24, Z+4	; 0x04
    27c6:	95 81       	ldd	r25, Z+5	; 0x05

  BUF->srcport  = uip_udp_conn->lport;
    27c8:	90 93 e2 07 	sts	0x07E2, r25
    27cc:	80 93 e1 07 	sts	0x07E1, r24
    27d0:	86 81       	ldd	r24, Z+6	; 0x06
    27d2:	97 81       	ldd	r25, Z+7	; 0x07
  BUF->destport = uip_udp_conn->rport;
    27d4:	90 93 e4 07 	sts	0x07E4, r25
    27d8:	80 93 e3 07 	sts	0x07E3, r24
    27dc:	80 91 bb 07 	lds	r24, 0x07BB

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    27e0:	90 91 bc 07 	lds	r25, 0x07BC
    27e4:	a0 91 bd 07 	lds	r26, 0x07BD
    27e8:	b0 91 be 07 	lds	r27, 0x07BE
    27ec:	80 93 d9 07 	sts	0x07D9, r24
    27f0:	90 93 da 07 	sts	0x07DA, r25
    27f4:	a0 93 db 07 	sts	0x07DB, r26
    27f8:	b0 93 dc 07 	sts	0x07DC, r27
    27fc:	80 81       	ld	r24, Z
    27fe:	91 81       	ldd	r25, Z+1	; 0x01
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    2800:	a2 81       	ldd	r26, Z+2	; 0x02
    2802:	b3 81       	ldd	r27, Z+3	; 0x03
    2804:	80 93 dd 07 	sts	0x07DD, r24
    2808:	90 93 de 07 	sts	0x07DE, r25
    280c:	a0 93 df 07 	sts	0x07DF, r26
    2810:	b0 93 e0 07 	sts	0x07E0, r27
    2814:	85 ef       	ldi	r24, 0xF5	; 245
    2816:	97 e0       	ldi	r25, 0x07	; 7

  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    2818:	90 93 53 06 	sts	0x0653, r25
    281c:	80 93 52 06 	sts	0x0652, r24
    2820:	ae c4       	rjmp	.+2396   	; 0x317e <uip_process+0xef8>
    2822:	10 dd       	rcall	.-1504   	; 0x2244 <uip_tcpchksum>
  if(UDPBUF->udpchksum == 0) {
    UDPBUF->udpchksum = 0xffff;
  }
#endif /* UIP_UDP_CHECKSUMS */

  goto ip_send_nolen;
    2824:	2f ef       	ldi	r18, 0xFF	; 255
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */

  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    2826:	8f 3f       	cpi	r24, 0xFF	; 255
    2828:	92 07       	cpc	r25, r18
    282a:	09 f0       	breq	.+2      	; 0x282e <uip_process+0x5a8>
    282c:	ca c4       	rjmp	.+2452   	; 0x31c2 <uip_process+0xf3c>
    282e:	20 91 e3 07 	lds	r18, 0x07E3
    2832:	30 91 e4 07 	lds	r19, 0x07E4
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
    2836:	40 91 e1 07 	lds	r20, 0x07E1
    283a:	50 91 e2 07 	lds	r21, 0x07E2
       BUF->srcport == uip_connr->rport &&
    283e:	e0 91 d9 07 	lds	r30, 0x07D9
    2842:	f0 91 da 07 	lds	r31, 0x07DA
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    2846:	a0 91 db 07 	lds	r26, 0x07DB
    284a:	b0 91 dc 07 	lds	r27, 0x07DC
    284e:	c6 e5       	ldi	r28, 0x56	; 86
    2850:	d6 e0       	ldi	r29, 0x06	; 6
    2852:	69 8d       	ldd	r22, Y+25	; 0x19
    2854:	66 23       	and	r22, r22
    2856:	a9 f0       	breq	.+42     	; 0x2882 <uip_process+0x5fc>

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    2858:	8c 81       	ldd	r24, Y+4	; 0x04
    285a:	9d 81       	ldd	r25, Y+5	; 0x05
    285c:	28 17       	cp	r18, r24
    285e:	39 07       	cpc	r19, r25
    2860:	81 f4       	brne	.+32     	; 0x2882 <uip_process+0x5fc>
    2862:	8e 81       	ldd	r24, Y+6	; 0x06
    2864:	9f 81       	ldd	r25, Y+7	; 0x07
    2866:	48 17       	cp	r20, r24
       BUF->destport == uip_connr->lport &&
    2868:	59 07       	cpc	r21, r25
    286a:	59 f4       	brne	.+22     	; 0x2882 <uip_process+0x5fc>
    286c:	88 81       	ld	r24, Y
    286e:	99 81       	ldd	r25, Y+1	; 0x01
    2870:	e8 17       	cp	r30, r24
       BUF->srcport == uip_connr->rport &&
    2872:	f9 07       	cpc	r31, r25
    2874:	31 f4       	brne	.+12     	; 0x2882 <uip_process+0x5fc>
    2876:	8a 81       	ldd	r24, Y+2	; 0x02
    2878:	9b 81       	ldd	r25, Y+3	; 0x03
    287a:	a8 17       	cp	r26, r24
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    287c:	b9 07       	cpc	r27, r25
    287e:	09 f4       	brne	.+2      	; 0x2882 <uip_process+0x5fc>
    2880:	81 c1       	rjmp	.+770    	; 0x2b84 <uip_process+0x8fe>
    2882:	cf 58       	subi	r28, 0x8F	; 143
    2884:	df 4f       	sbci	r29, 0xFF	; 255
    2886:	87 e0       	ldi	r24, 0x07	; 7
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    2888:	c8 33       	cpi	r28, 0x38	; 56
    288a:	d8 07       	cpc	r29, r24
    goto drop;
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    288c:	11 f3       	breq	.-60     	; 0x2852 <uip_process+0x5cc>
    288e:	08 f3       	brcs	.-62     	; 0x2852 <uip_process+0x5cc>
    2890:	80 91 ee 07 	lds	r24, 0x07EE
    2894:	8f 73       	andi	r24, 0x3F	; 63

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    2896:	82 30       	cpi	r24, 0x02	; 2
    2898:	b9 f4       	brne	.+46     	; 0x28c8 <uip_process+0x642>
    289a:	30 93 90 03 	sts	0x0390, r19
    289e:	20 93 8f 03 	sts	0x038F, r18
    goto reset;
  }

  tmp16 = BUF->destport;
    28a2:	40 e0       	ldi	r20, 0x00	; 0
    28a4:	0d c0       	rjmp	.+26     	; 0x28c0 <uip_process+0x63a>
    28a6:	e4 2f       	mov	r30, r20
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    28a8:	f0 e0       	ldi	r31, 0x00	; 0
    28aa:	ee 0f       	add	r30, r30
    if(tmp16 == uip_listenports[c]) {
    28ac:	ff 1f       	adc	r31, r31
    28ae:	e7 55       	subi	r30, 0x57	; 87
    28b0:	f8 4f       	sbci	r31, 0xF8	; 248
    28b2:	80 81       	ld	r24, Z
    28b4:	91 81       	ldd	r25, Z+1	; 0x01
    28b6:	4f 5f       	subi	r20, 0xFF	; 255
    28b8:	28 17       	cp	r18, r24
    28ba:	39 07       	cpc	r19, r25
    28bc:	09 f4       	brne	.+2      	; 0x28c0 <uip_process+0x63a>
    28be:	7d c0       	rjmp	.+250    	; 0x29ba <uip_process+0x734>
    28c0:	45 30       	cpi	r20, 0x05	; 5
    28c2:	88 f3       	brcs	.-30     	; 0x28a6 <uip_process+0x620>
    28c4:	40 93 88 03 	sts	0x0388, r20
    goto reset;
  }

  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    28c8:	80 91 ee 07 	lds	r24, 0x07EE
    28cc:	82 fd       	sbrc	r24, 2
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    28ce:	79 c4       	rjmp	.+2290   	; 0x31c2 <uip_process+0xf3c>
    28d0:	84 e1       	ldi	r24, 0x14	; 20
    28d2:	80 93 ee 07 	sts	0x07EE, r24
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);

  BUF->flags = TCP_RST | TCP_ACK;
    28d6:	88 e2       	ldi	r24, 0x28	; 40
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	90 93 48 06 	sts	0x0648, r25
  uip_len = UIP_IPTCPH_LEN;
    28de:	80 93 47 06 	sts	0x0647, r24
    28e2:	80 e5       	ldi	r24, 0x50	; 80
    28e4:	80 93 ed 07 	sts	0x07ED, r24
  BUF->tcpoffset = 5 << 4;
    28e8:	80 91 e8 07 	lds	r24, 0x07E8
    28ec:	90 91 ec 07 	lds	r25, 0x07EC

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    28f0:	90 93 e8 07 	sts	0x07E8, r25
  BUF->seqno[3] = BUF->ackno[3];
    28f4:	30 91 e7 07 	lds	r19, 0x07E7
    28f8:	90 91 eb 07 	lds	r25, 0x07EB
  BUF->ackno[3] = c;

  c = BUF->seqno[2];
    28fc:	90 93 e7 07 	sts	0x07E7, r25
  BUF->seqno[2] = BUF->ackno[2];
    2900:	30 93 eb 07 	sts	0x07EB, r19
    2904:	20 91 e6 07 	lds	r18, 0x07E6
  BUF->ackno[2] = c;
    2908:	90 91 ea 07 	lds	r25, 0x07EA

  c = BUF->seqno[1];
    290c:	90 93 e6 07 	sts	0x07E6, r25
  BUF->seqno[1] = BUF->ackno[1];
    2910:	20 93 ea 07 	sts	0x07EA, r18
    2914:	90 91 e5 07 	lds	r25, 0x07E5
  BUF->ackno[1] = c;
    2918:	90 93 88 03 	sts	0x0388, r25

  c = BUF->seqno[0];
    291c:	40 91 e9 07 	lds	r20, 0x07E9
    2920:	40 93 e5 07 	sts	0x07E5, r20
  BUF->seqno[0] = BUF->ackno[0];
    2924:	90 93 e9 07 	sts	0x07E9, r25
    2928:	8f 5f       	subi	r24, 0xFF	; 255
  BUF->ackno[0] = c;
    292a:	80 93 ec 07 	sts	0x07EC, r24

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    292e:	88 23       	and	r24, r24
    2930:	79 f4       	brne	.+30     	; 0x2950 <uip_process+0x6ca>
    2932:	83 2f       	mov	r24, r19
    2934:	8f 5f       	subi	r24, 0xFF	; 255
    2936:	80 93 eb 07 	sts	0x07EB, r24
    if(++BUF->ackno[2] == 0) {
    293a:	88 23       	and	r24, r24
    293c:	49 f4       	brne	.+18     	; 0x2950 <uip_process+0x6ca>
    293e:	82 2f       	mov	r24, r18
    2940:	8f 5f       	subi	r24, 0xFF	; 255
    2942:	80 93 ea 07 	sts	0x07EA, r24
      if(++BUF->ackno[1] == 0) {
    2946:	88 23       	and	r24, r24
    2948:	19 f4       	brne	.+6      	; 0x2950 <uip_process+0x6ca>
    294a:	9f 5f       	subi	r25, 0xFF	; 255
    294c:	90 93 e9 07 	sts	0x07E9, r25
	++BUF->ackno[0];
    2950:	80 91 e1 07 	lds	r24, 0x07E1
    2954:	90 91 e2 07 	lds	r25, 0x07E2
      }
    }
  }

  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    2958:	90 93 90 03 	sts	0x0390, r25
    295c:	80 93 8f 03 	sts	0x038F, r24
    2960:	20 91 e3 07 	lds	r18, 0x07E3
    2964:	30 91 e4 07 	lds	r19, 0x07E4
  BUF->srcport = BUF->destport;
    2968:	30 93 e2 07 	sts	0x07E2, r19
    296c:	20 93 e1 07 	sts	0x07E1, r18
    2970:	90 93 e4 07 	sts	0x07E4, r25
    2974:	80 93 e3 07 	sts	0x07E3, r24
  BUF->destport = tmp16;
    2978:	80 91 d9 07 	lds	r24, 0x07D9
    297c:	90 91 da 07 	lds	r25, 0x07DA

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    2980:	a0 91 db 07 	lds	r26, 0x07DB
    2984:	b0 91 dc 07 	lds	r27, 0x07DC
    2988:	80 93 dd 07 	sts	0x07DD, r24
    298c:	90 93 de 07 	sts	0x07DE, r25
    2990:	a0 93 df 07 	sts	0x07DF, r26
    2994:	b0 93 e0 07 	sts	0x07E0, r27
    2998:	80 91 bb 07 	lds	r24, 0x07BB
    299c:	90 91 bc 07 	lds	r25, 0x07BC
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    29a0:	a0 91 bd 07 	lds	r26, 0x07BD
    29a4:	b0 91 be 07 	lds	r27, 0x07BE
    29a8:	80 93 d9 07 	sts	0x07D9, r24
    29ac:	90 93 da 07 	sts	0x07DA, r25
    29b0:	a0 93 db 07 	sts	0x07DB, r26
    29b4:	b0 93 dc 07 	sts	0x07DC, r27
    29b8:	c8 c3       	rjmp	.+1936   	; 0x314a <uip_process+0xec4>
    29ba:	10 92 88 03 	sts	0x0388, r1

  /* And send out the RST packet! */
  goto tcp_send_noconn;
    29be:	40 e0       	ldi	r20, 0x00	; 0
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    29c0:	c0 e0       	ldi	r28, 0x00	; 0
    29c2:	d0 e0       	ldi	r29, 0x00	; 0
    29c4:	21 e7       	ldi	r18, 0x71	; 113
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
    29c6:	30 e0       	ldi	r19, 0x00	; 0
    29c8:	26 c0       	rjmp	.+76     	; 0x2a16 <uip_process+0x790>
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    29ca:	84 2f       	mov	r24, r20
    29cc:	90 e0       	ldi	r25, 0x00	; 0
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    29ce:	82 9f       	mul	r24, r18
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    29d0:	f0 01       	movw	r30, r0
    29d2:	83 9f       	mul	r24, r19
    29d4:	f0 0d       	add	r31, r0
    29d6:	92 9f       	mul	r25, r18
    29d8:	f0 0d       	add	r31, r0
    29da:	11 24       	eor	r1, r1
    29dc:	ea 5a       	subi	r30, 0xAA	; 170
    29de:	f9 4f       	sbci	r31, 0xF9	; 249
    29e0:	81 8d       	ldd	r24, Z+25	; 0x19
    29e2:	88 23       	and	r24, r24
    29e4:	21 f4       	brne	.+8      	; 0x29ee <uip_process+0x768>
    29e6:	40 93 88 03 	sts	0x0388, r20
    29ea:	ef 01       	movw	r28, r30
    29ec:	18 c0       	rjmp	.+48     	; 0x2a1e <uip_process+0x798>
    29ee:	87 30       	cpi	r24, 0x07	; 7
      uip_connr = &uip_conns[c];
    29f0:	89 f4       	brne	.+34     	; 0x2a14 <uip_process+0x78e>
      break;
    29f2:	20 97       	sbiw	r28, 0x00	; 0
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    29f4:	21 f0       	breq	.+8      	; 0x29fe <uip_process+0x778>
    29f6:	92 8d       	ldd	r25, Z+26	; 0x1a
      if(uip_connr == 0 ||
    29f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29fa:	89 17       	cp	r24, r25
    29fc:	58 f4       	brcc	.+22     	; 0x2a14 <uip_process+0x78e>
    29fe:	84 2f       	mov	r24, r20
    2a00:	90 e0       	ldi	r25, 0x00	; 0
    2a02:	82 9f       	mul	r24, r18
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    2a04:	e0 01       	movw	r28, r0
    2a06:	83 9f       	mul	r24, r19
    2a08:	d0 0d       	add	r29, r0
    2a0a:	92 9f       	mul	r25, r18
    2a0c:	d0 0d       	add	r29, r0
    2a0e:	11 24       	eor	r1, r1
    2a10:	ca 5a       	subi	r28, 0xAA	; 170
    2a12:	d9 4f       	sbci	r29, 0xF9	; 249
    2a14:	4f 5f       	subi	r20, 0xFF	; 255
    2a16:	43 30       	cpi	r20, 0x03	; 3
    2a18:	c0 f2       	brcs	.-80     	; 0x29ca <uip_process+0x744>
    2a1a:	40 93 88 03 	sts	0x0388, r20
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2a1e:	20 97       	sbiw	r28, 0x00	; 0
    2a20:	09 f4       	brne	.+2      	; 0x2a24 <uip_process+0x79e>
    2a22:	cf c3       	rjmp	.+1950   	; 0x31c2 <uip_process+0xf3c>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    2a24:	d0 93 55 06 	sts	0x0655, r29
    2a28:	c0 93 54 06 	sts	0x0654, r28
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    2a2c:	83 e0       	ldi	r24, 0x03	; 3
    2a2e:	8a 8f       	std	Y+26, r24	; 0x1a
    2a30:	88 8f       	std	Y+24, r24	; 0x18

  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    2a32:	1e 8a       	std	Y+22, r1	; 0x16
    2a34:	84 e0       	ldi	r24, 0x04	; 4
    2a36:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->sa = 0;
    2a38:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->sv = 4;
    2a3a:	80 91 e3 07 	lds	r24, 0x07E3
  uip_connr->nrtx = 0;
    2a3e:	90 91 e4 07 	lds	r25, 0x07E4
  uip_connr->lport = BUF->destport;
    2a42:	9d 83       	std	Y+5, r25	; 0x05
    2a44:	8c 83       	std	Y+4, r24	; 0x04
    2a46:	80 91 e1 07 	lds	r24, 0x07E1
    2a4a:	90 91 e2 07 	lds	r25, 0x07E2
  uip_connr->rport = BUF->srcport;
    2a4e:	9f 83       	std	Y+7, r25	; 0x07
    2a50:	8e 83       	std	Y+6, r24	; 0x06
    2a52:	80 91 d9 07 	lds	r24, 0x07D9
    2a56:	90 91 da 07 	lds	r25, 0x07DA
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    2a5a:	a0 91 db 07 	lds	r26, 0x07DB
    2a5e:	b0 91 dc 07 	lds	r27, 0x07DC
    2a62:	88 83       	st	Y, r24
    2a64:	99 83       	std	Y+1, r25	; 0x01
    2a66:	aa 83       	std	Y+2, r26	; 0x02
    2a68:	bb 83       	std	Y+3, r27	; 0x03
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	89 8f       	std	Y+25, r24	; 0x19
    2a6e:	80 91 8b 03 	lds	r24, 0x038B
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    2a72:	8c 87       	std	Y+12, r24	; 0x0c

  uip_connr->snd_nxt[0] = iss[0];
    2a74:	80 91 8c 03 	lds	r24, 0x038C
    2a78:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[1] = iss[1];
    2a7a:	80 91 8d 03 	lds	r24, 0x038D
    2a7e:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[2] = iss[2];
    2a80:	80 91 8e 03 	lds	r24, 0x038E
    2a84:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->snd_nxt[3] = iss[3];
    2a86:	81 e0       	ldi	r24, 0x01	; 1
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	99 8b       	std	Y+17, r25	; 0x11
  uip_connr->len = 1;
    2a8c:	88 8b       	std	Y+16, r24	; 0x10
    2a8e:	80 91 e8 07 	lds	r24, 0x07E8
    2a92:	8b 87       	std	Y+11, r24	; 0x0b

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2a94:	80 91 e7 07 	lds	r24, 0x07E7
    2a98:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2a9a:	80 91 e6 07 	lds	r24, 0x07E6
    2a9e:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2aa0:	80 91 e5 07 	lds	r24, 0x07E5
    2aa4:	88 87       	std	Y+8, r24	; 0x08
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	f3 da       	rcall	.-2586   	; 0x2092 <uip_add_rcv_nxt>
  uip_add_rcv_nxt(1);
    2aac:	80 91 ed 07 	lds	r24, 0x07ED
    2ab0:	28 2f       	mov	r18, r24
    2ab2:	30 e0       	ldi	r19, 0x00	; 0

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    2ab4:	20 7f       	andi	r18, 0xF0	; 240
    2ab6:	30 70       	andi	r19, 0x00	; 0
    2ab8:	21 35       	cpi	r18, 0x51	; 81
    2aba:	31 05       	cpc	r19, r1
    2abc:	0c f4       	brge	.+2      	; 0x2ac0 <uip_process+0x83a>
    2abe:	46 c0       	rjmp	.+140    	; 0x2b4c <uip_process+0x8c6>
    2ac0:	82 95       	swap	r24
    2ac2:	8f 70       	andi	r24, 0x0F	; 15
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	05 97       	sbiw	r24, 0x05	; 5
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2ac8:	88 0f       	add	r24, r24
    2aca:	99 1f       	adc	r25, r25
    2acc:	88 0f       	add	r24, r24
    2ace:	99 1f       	adc	r25, r25
    2ad0:	30 91 91 03 	lds	r19, 0x0391
    2ad4:	20 e0       	ldi	r18, 0x00	; 0
    2ad6:	31 c0       	rjmp	.+98     	; 0x2b3a <uip_process+0x8b4>
    2ad8:	e1 54       	subi	r30, 0x41	; 65
    2ada:	f8 4f       	sbci	r31, 0xF8	; 248
    2adc:	36 a9       	sts	0x46, r19
    2ade:	33 23       	and	r19, r19
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    2ae0:	29 f4       	brne	.+10     	; 0x2aec <uip_process+0x866>
    2ae2:	20 93 88 03 	sts	0x0388, r18
      if(opt == TCP_OPT_END) {
    2ae6:	10 92 91 03 	sts	0x0391, r1
    2aea:	30 c0       	rjmp	.+96     	; 0x2b4c <uip_process+0x8c6>
    2aec:	31 30       	cpi	r19, 0x01	; 1
    2aee:	11 f4       	brne	.+4      	; 0x2af4 <uip_process+0x86e>
    2af0:	2f 5f       	subi	r18, 0xFF	; 255
    2af2:	23 c0       	rjmp	.+70     	; 0x2b3a <uip_process+0x8b4>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    2af4:	32 30       	cpi	r19, 0x02	; 2
    2af6:	e9 f4       	brne	.+58     	; 0x2b32 <uip_process+0x8ac>
	++c;
    2af8:	47 a9       	sts	0x47, r20
    2afa:	44 30       	cpi	r20, 0x04	; 4
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    2afc:	d1 f4       	brne	.+52     	; 0x2b32 <uip_process+0x8ac>
    2afe:	20 93 88 03 	sts	0x0388, r18
    2b02:	30 93 91 03 	sts	0x0391, r19
    2b06:	90 ad       	sts	0x60, r25
    2b08:	80 e0       	ldi	r24, 0x00	; 0
    2b0a:	21 ad       	sts	0x61, r18
    2b0c:	30 e0       	ldi	r19, 0x00	; 0
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2b0e:	28 2b       	or	r18, r24
    2b10:	39 2b       	or	r19, r25
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    2b12:	30 93 90 03 	sts	0x0390, r19
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2b16:	20 93 8f 03 	sts	0x038F, r18
    2b1a:	c9 01       	movw	r24, r18
    2b1c:	25 e0       	ldi	r18, 0x05	; 5
    2b1e:	85 3b       	cpi	r24, 0xB5	; 181
    2b20:	92 07       	cpc	r25, r18
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    2b22:	10 f0       	brcs	.+4      	; 0x2b28 <uip_process+0x8a2>
    2b24:	84 eb       	ldi	r24, 0xB4	; 180
    2b26:	95 e0       	ldi	r25, 0x05	; 5
    2b28:	9b 8b       	std	Y+19, r25	; 0x13
    2b2a:	8a 8b       	std	Y+18, r24	; 0x12
    2b2c:	9d 8b       	std	Y+21, r25	; 0x15
    2b2e:	8c 8b       	std	Y+20, r24	; 0x14
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    2b30:	0d c0       	rjmp	.+26     	; 0x2b4c <uip_process+0x8c6>
    2b32:	47 a9       	sts	0x47, r20
    2b34:	44 23       	and	r20, r20
    2b36:	31 f0       	breq	.+12     	; 0x2b44 <uip_process+0x8be>
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	/* And we are done processing options. */
	break;
    2b38:	24 0f       	add	r18, r20
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2b3a:	e2 2f       	mov	r30, r18
    2b3c:	f0 e0       	ldi	r31, 0x00	; 0
    2b3e:	e8 17       	cp	r30, r24
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2b40:	f9 07       	cpc	r31, r25
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2b42:	54 f2       	brlt	.-108    	; 0x2ad8 <uip_process+0x852>
    2b44:	20 93 88 03 	sts	0x0388, r18
    2b48:	30 93 91 03 	sts	0x0391, r19
    2b4c:	80 e1       	ldi	r24, 0x10	; 16
    2b4e:	80 93 ee 07 	sts	0x07EE, r24
    2b52:	80 91 ee 07 	lds	r24, 0x07EE
  }

  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    2b56:	82 60       	ori	r24, 0x02	; 2
    2b58:	80 93 ee 07 	sts	0x07EE, r24

 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    2b5c:	82 e0       	ldi	r24, 0x02	; 2
    2b5e:	80 93 f5 07 	sts	0x07F5, r24
    2b62:	84 e0       	ldi	r24, 0x04	; 4
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */

  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    2b64:	80 93 f6 07 	sts	0x07F6, r24
    2b68:	85 e0       	ldi	r24, 0x05	; 5
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    2b6a:	80 93 f7 07 	sts	0x07F7, r24
    2b6e:	84 eb       	ldi	r24, 0xB4	; 180
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    2b70:	80 93 f8 07 	sts	0x07F8, r24
    2b74:	8c e2       	ldi	r24, 0x2C	; 44
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	90 93 48 06 	sts	0x0648, r25
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    2b7c:	80 93 47 06 	sts	0x0647, r24
    2b80:	80 e6       	ldi	r24, 0x60	; 96
    2b82:	90 c2       	rjmp	.+1312   	; 0x30a4 <uip_process+0xe1e>
    2b84:	d0 93 55 06 	sts	0x0655, r29
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    2b88:	c0 93 54 06 	sts	0x0654, r28
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    2b8c:	10 92 4f 06 	sts	0x064F, r1
    2b90:	40 91 ee 07 	lds	r20, 0x07EE
  uip_flags = 0;
    2b94:	50 e0       	ldi	r21, 0x00	; 0
    2b96:	42 ff       	sbrs	r20, 2
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is within our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2b98:	03 c0       	rjmp	.+6      	; 0x2ba0 <uip_process+0x91a>
    2b9a:	19 8e       	std	Y+25, r1	; 0x19
    2b9c:	80 e2       	ldi	r24, 0x20	; 32
    2b9e:	2e c2       	rjmp	.+1116   	; 0x2ffc <uip_process+0xd76>
    2ba0:	80 91 ed 07 	lds	r24, 0x07ED
    uip_connr->tcpstateflags = UIP_CLOSED;
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2ba4:	82 95       	swap	r24
    2ba6:	8f 70       	andi	r24, 0x0F	; 15
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2ba8:	88 0f       	add	r24, r24
    2baa:	88 0f       	add	r24, r24
    2bac:	80 93 88 03 	sts	0x0388, r24
    2bb0:	98 01       	movw	r18, r16
    2bb2:	28 1b       	sub	r18, r24
    2bb4:	31 09       	sbc	r19, r1
    2bb6:	24 51       	subi	r18, 0x14	; 20
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    2bb8:	30 40       	sbci	r19, 0x00	; 0
    2bba:	30 93 48 06 	sts	0x0648, r19
    2bbe:	20 93 47 06 	sts	0x0647, r18
    2bc2:	6f 70       	andi	r22, 0x0F	; 15
    2bc4:	62 30       	cpi	r22, 0x02	; 2
    2bc6:	31 f4       	brne	.+12     	; 0x2bd4 <uip_process+0x94e>
    2bc8:	ca 01       	movw	r24, r20

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2bca:	8f 73       	andi	r24, 0x3F	; 63
    2bcc:	90 70       	andi	r25, 0x00	; 0
    2bce:	82 31       	cpi	r24, 0x12	; 18
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    2bd0:	91 05       	cpc	r25, r1
    2bd2:	01 f1       	breq	.+64     	; 0x2c14 <uip_process+0x98e>
    2bd4:	21 15       	cp	r18, r1
  uip_len = uip_len - c - UIP_IPH_LEN;

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2bd6:	31 05       	cpc	r19, r1
    2bd8:	29 f4       	brne	.+10     	; 0x2be4 <uip_process+0x95e>
    2bda:	ca 01       	movw	r24, r20
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    2bdc:	83 70       	andi	r24, 0x03	; 3
    2bde:	90 70       	andi	r25, 0x00	; 0
    2be0:	00 97       	sbiw	r24, 0x00	; 0
    2be2:	c1 f0       	breq	.+48     	; 0x2c14 <uip_process+0x98e>
    2be4:	90 91 e5 07 	lds	r25, 0x07E5
    2be8:	88 85       	ldd	r24, Y+8	; 0x08
    2bea:	98 17       	cp	r25, r24
    2bec:	09 f0       	breq	.+2      	; 0x2bf0 <uip_process+0x96a>
    2bee:	50 c2       	rjmp	.+1184   	; 0x3090 <uip_process+0xe0a>
    2bf0:	90 91 e6 07 	lds	r25, 0x07E6
    2bf4:	89 85       	ldd	r24, Y+9	; 0x09
    2bf6:	98 17       	cp	r25, r24
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
    2bf8:	09 f0       	breq	.+2      	; 0x2bfc <uip_process+0x976>
    2bfa:	4a c2       	rjmp	.+1172   	; 0x3090 <uip_process+0xe0a>
    2bfc:	90 91 e7 07 	lds	r25, 0x07E7
    2c00:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c02:	98 17       	cp	r25, r24
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
    2c04:	09 f0       	breq	.+2      	; 0x2c08 <uip_process+0x982>
    2c06:	44 c2       	rjmp	.+1160   	; 0x3090 <uip_process+0xe0a>
    2c08:	90 91 e8 07 	lds	r25, 0x07E8
    2c0c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2c0e:	98 17       	cp	r25, r24
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
    2c10:	09 f0       	breq	.+2      	; 0x2c14 <uip_process+0x98e>
    2c12:	3e c2       	rjmp	.+1148   	; 0x3090 <uip_process+0xe0a>
    2c14:	44 ff       	sbrs	r20, 4
    2c16:	49 c0       	rjmp	.+146    	; 0x2caa <uip_process+0xa24>
    2c18:	68 89       	ldd	r22, Y+16	; 0x10
    2c1a:	79 89       	ldd	r23, Y+17	; 0x11

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    2c1c:	61 15       	cp	r22, r1
    2c1e:	71 05       	cpc	r23, r1
    2c20:	09 f4       	brne	.+2      	; 0x2c24 <uip_process+0x99e>
    2c22:	43 c0       	rjmp	.+134    	; 0x2caa <uip_process+0xa24>
    2c24:	ce 01       	movw	r24, r28
    2c26:	0c 96       	adiw	r24, 0x0c	; 12
    2c28:	fc d9       	rcall	.-3080   	; 0x2022 <uip_add32>
    2c2a:	30 91 e9 07 	lds	r19, 0x07E9
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    2c2e:	80 91 4b 06 	lds	r24, 0x064B
    2c32:	38 17       	cp	r19, r24

    if(BUF->ackno[0] == uip_acc32[0] &&
    2c34:	d1 f5       	brne	.+116    	; 0x2caa <uip_process+0xa24>
    2c36:	20 91 ea 07 	lds	r18, 0x07EA
    2c3a:	80 91 4c 06 	lds	r24, 0x064C
    2c3e:	28 17       	cp	r18, r24
       BUF->ackno[1] == uip_acc32[1] &&
    2c40:	a1 f5       	brne	.+104    	; 0x2caa <uip_process+0xa24>
    2c42:	90 91 eb 07 	lds	r25, 0x07EB
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
    2c46:	80 91 4d 06 	lds	r24, 0x064D
    2c4a:	98 17       	cp	r25, r24
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    2c4c:	71 f5       	brne	.+92     	; 0x2caa <uip_process+0xa24>
    2c4e:	80 91 ec 07 	lds	r24, 0x07EC
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
    2c52:	40 91 4e 06 	lds	r20, 0x064E
    2c56:	84 17       	cp	r24, r20
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
    2c58:	41 f5       	brne	.+80     	; 0x2caa <uip_process+0xa24>
    2c5a:	3c 87       	std	Y+12, r19	; 0x0c
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    2c5c:	2d 87       	std	Y+13, r18	; 0x0d
    2c5e:	9e 87       	std	Y+14, r25	; 0x0e
    2c60:	8f 87       	std	Y+15, r24	; 0x0f
    2c62:	8b 8d       	ldd	r24, Y+27	; 0x1b
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2c64:	88 23       	and	r24, r24
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2c66:	d1 f4       	brne	.+52     	; 0x2c9c <uip_process+0xa16>
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2c68:	2e 89       	ldd	r18, Y+22	; 0x16
      uip_connr->snd_nxt[3] = uip_acc32[3];
    2c6a:	88 8d       	ldd	r24, Y+24	; 0x18

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    2c6c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2c6e:	89 1b       	sub	r24, r25
    2c70:	92 2f       	mov	r25, r18
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2c72:	96 95       	lsr	r25
      uip_connr->snd_nxt[3] = uip_acc32[3];

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
    2c74:	96 95       	lsr	r25
    2c76:	96 95       	lsr	r25
    2c78:	89 1b       	sub	r24, r25
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2c7a:	28 0f       	add	r18, r24
    2c7c:	2e 8b       	std	Y+22, r18	; 0x16
    2c7e:	87 fd       	sbrc	r24, 7
    2c80:	81 95       	neg	r24
    2c82:	9f 89       	ldd	r25, Y+23	; 0x17
	uip_connr->sa += m;
    2c84:	39 2f       	mov	r19, r25
    2c86:	36 95       	lsr	r19
	if(m < 0) {
	  m = -m;
    2c88:	36 95       	lsr	r19
    2c8a:	93 1b       	sub	r25, r19
	}
	m = m - (uip_connr->sv >> 2);
    2c8c:	98 0f       	add	r25, r24
    2c8e:	9f 8b       	std	Y+23, r25	; 0x17
    2c90:	82 2f       	mov	r24, r18
    2c92:	86 95       	lsr	r24
    2c94:	86 95       	lsr	r24
	uip_connr->sv += m;
    2c96:	86 95       	lsr	r24
    2c98:	89 0f       	add	r24, r25
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    2c9a:	88 8f       	std	Y+24, r24	; 0x18
    2c9c:	81 e0       	ldi	r24, 0x01	; 1
    2c9e:	80 93 4f 06 	sts	0x064F, r24
    2ca2:	88 8d       	ldd	r24, Y+24	; 0x18
    2ca4:	8a 8f       	std	Y+26, r24	; 0x1a

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    2ca6:	19 8a       	std	Y+17, r1	; 0x11
    2ca8:	18 8a       	std	Y+16, r1	; 0x10
    2caa:	49 8d       	ldd	r20, Y+25	; 0x19
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    2cac:	50 e0       	ldi	r21, 0x00	; 0
    2cae:	ca 01       	movw	r24, r20

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    2cb0:	8f 70       	andi	r24, 0x0F	; 15
    2cb2:	90 70       	andi	r25, 0x00	; 0
    }

  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    2cb4:	84 30       	cpi	r24, 0x04	; 4
    2cb6:	91 05       	cpc	r25, r1
    2cb8:	09 f4       	brne	.+2      	; 0x2cbc <uip_process+0xa36>
    2cba:	a5 c1       	rjmp	.+842    	; 0x3006 <uip_process+0xd80>
    2cbc:	85 30       	cpi	r24, 0x05	; 5
    2cbe:	91 05       	cpc	r25, r1
    2cc0:	64 f4       	brge	.+24     	; 0x2cda <uip_process+0xa54>
    2cc2:	82 30       	cpi	r24, 0x02	; 2
    2cc4:	91 05       	cpc	r25, r1
    2cc6:	89 f1       	breq	.+98     	; 0x2d2a <uip_process+0xaa4>
    2cc8:	83 30       	cpi	r24, 0x03	; 3
    2cca:	91 05       	cpc	r25, r1
    2ccc:	0c f0       	brlt	.+2      	; 0x2cd0 <uip_process+0xa4a>
    2cce:	ad c0       	rjmp	.+346    	; 0x2e2a <uip_process+0xba4>
    2cd0:	81 30       	cpi	r24, 0x01	; 1
    2cd2:	91 05       	cpc	r25, r1
    2cd4:	09 f0       	breq	.+2      	; 0x2cd8 <uip_process+0xa52>
    2cd6:	75 c2       	rjmp	.+1258   	; 0x31c2 <uip_process+0xf3c>
    2cd8:	11 c0       	rjmp	.+34     	; 0x2cfc <uip_process+0xa76>
    2cda:	86 30       	cpi	r24, 0x06	; 6
    2cdc:	91 05       	cpc	r25, r1
    2cde:	09 f4       	brne	.+2      	; 0x2ce2 <uip_process+0xa5c>
    2ce0:	cf c1       	rjmp	.+926    	; 0x3080 <uip_process+0xdfa>
    2ce2:	86 30       	cpi	r24, 0x06	; 6
    2ce4:	91 05       	cpc	r25, r1
    2ce6:	0c f4       	brge	.+2      	; 0x2cea <uip_process+0xa64>
    2ce8:	ad c1       	rjmp	.+858    	; 0x3044 <uip_process+0xdbe>
    2cea:	87 30       	cpi	r24, 0x07	; 7
    2cec:	91 05       	cpc	r25, r1
    2cee:	09 f4       	brne	.+2      	; 0x2cf2 <uip_process+0xa6c>
    2cf0:	cf c1       	rjmp	.+926    	; 0x3090 <uip_process+0xe0a>
    2cf2:	88 30       	cpi	r24, 0x08	; 8
    2cf4:	91 05       	cpc	r25, r1
    2cf6:	09 f0       	breq	.+2      	; 0x2cfa <uip_process+0xa74>
    2cf8:	64 c2       	rjmp	.+1224   	; 0x31c2 <uip_process+0xf3c>
    2cfa:	7a c1       	rjmp	.+756    	; 0x2ff0 <uip_process+0xd6a>
    2cfc:	80 91 4f 06 	lds	r24, 0x064F
    2d00:	80 ff       	sbrs	r24, 0
    2d02:	5f c2       	rjmp	.+1214   	; 0x31c2 <uip_process+0xf3c>
    2d04:	83 e0       	ldi	r24, 0x03	; 3
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    2d06:	89 8f       	std	Y+25, r24	; 0x19
    2d08:	80 e4       	ldi	r24, 0x40	; 64
    2d0a:	80 93 4f 06 	sts	0x064F, r24
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2d0e:	19 8a       	std	Y+17, r1	; 0x11
    2d10:	18 8a       	std	Y+16, r1	; 0x10
      uip_flags = UIP_CONNECTED;
    2d12:	80 91 47 06 	lds	r24, 0x0647
    2d16:	90 91 48 06 	lds	r25, 0x0648
      uip_connr->len = 0;
    2d1a:	00 97       	sbiw	r24, 0x00	; 0
      if(uip_len > 0) {
    2d1c:	09 f4       	brne	.+2      	; 0x2d20 <uip_process+0xa9a>
    2d1e:	fd c0       	rjmp	.+506    	; 0x2f1a <uip_process+0xc94>
    2d20:	22 e4       	ldi	r18, 0x42	; 66
    2d22:	20 93 4f 06 	sts	0x064F, r18
    2d26:	b5 d9       	rcall	.-3222   	; 0x2092 <uip_add_rcv_nxt>
    2d28:	f8 c0       	rjmp	.+496    	; 0x2f1a <uip_process+0xc94>
        uip_flags |= UIP_NEWDATA;
    2d2a:	80 91 4f 06 	lds	r24, 0x064F
    2d2e:	80 ff       	sbrs	r24, 0
        uip_add_rcv_nxt(uip_len);
    2d30:	71 c0       	rjmp	.+226    	; 0x2e14 <uip_process+0xb8e>
    2d32:	80 91 ee 07 	lds	r24, 0x07EE
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2d36:	8f 73       	andi	r24, 0x3F	; 63
    2d38:	82 31       	cpi	r24, 0x12	; 18
    2d3a:	09 f0       	breq	.+2      	; 0x2d3e <uip_process+0xab8>
    2d3c:	6b c0       	rjmp	.+214    	; 0x2e14 <uip_process+0xb8e>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
    2d3e:	80 91 ed 07 	lds	r24, 0x07ED
    2d42:	28 2f       	mov	r18, r24
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2d44:	30 e0       	ldi	r19, 0x00	; 0
    2d46:	20 7f       	andi	r18, 0xF0	; 240
    2d48:	30 70       	andi	r19, 0x00	; 0
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    2d4a:	21 35       	cpi	r18, 0x51	; 81
    2d4c:	31 05       	cpc	r19, r1
    2d4e:	0c f4       	brge	.+2      	; 0x2d52 <uip_process+0xacc>
    2d50:	46 c0       	rjmp	.+140    	; 0x2dde <uip_process+0xb58>
    2d52:	82 95       	swap	r24
    2d54:	8f 70       	andi	r24, 0x0F	; 15
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	05 97       	sbiw	r24, 0x05	; 5
    2d5a:	88 0f       	add	r24, r24
    2d5c:	99 1f       	adc	r25, r25
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2d5e:	88 0f       	add	r24, r24
    2d60:	99 1f       	adc	r25, r25
    2d62:	30 91 91 03 	lds	r19, 0x0391
    2d66:	20 e0       	ldi	r18, 0x00	; 0
    2d68:	31 c0       	rjmp	.+98     	; 0x2dcc <uip_process+0xb46>
    2d6a:	e1 54       	subi	r30, 0x41	; 65
    2d6c:	f8 4f       	sbci	r31, 0xF8	; 248
    2d6e:	36 a9       	sts	0x46, r19
    2d70:	33 23       	and	r19, r19
    2d72:	29 f4       	brne	.+10     	; 0x2d7e <uip_process+0xaf8>
    2d74:	20 93 88 03 	sts	0x0388, r18
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    2d78:	10 92 91 03 	sts	0x0391, r1
	  if(opt == TCP_OPT_END) {
    2d7c:	30 c0       	rjmp	.+96     	; 0x2dde <uip_process+0xb58>
    2d7e:	31 30       	cpi	r19, 0x01	; 1
    2d80:	11 f4       	brne	.+4      	; 0x2d86 <uip_process+0xb00>
    2d82:	2f 5f       	subi	r18, 0xFF	; 255
    2d84:	23 c0       	rjmp	.+70     	; 0x2dcc <uip_process+0xb46>
    2d86:	32 30       	cpi	r19, 0x02	; 2
    2d88:	e9 f4       	brne	.+58     	; 0x2dc4 <uip_process+0xb3e>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    2d8a:	47 a9       	sts	0x47, r20
    2d8c:	44 30       	cpi	r20, 0x04	; 4
	    ++c;
    2d8e:	d1 f4       	brne	.+52     	; 0x2dc4 <uip_process+0xb3e>
    2d90:	20 93 88 03 	sts	0x0388, r18
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    2d94:	30 93 91 03 	sts	0x0391, r19
    2d98:	90 ad       	sts	0x60, r25
    2d9a:	80 e0       	ldi	r24, 0x00	; 0
    2d9c:	21 ad       	sts	0x61, r18
    2d9e:	30 e0       	ldi	r19, 0x00	; 0
    2da0:	28 2b       	or	r18, r24
    2da2:	39 2b       	or	r19, r25
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2da4:	30 93 90 03 	sts	0x0390, r19
    2da8:	20 93 8f 03 	sts	0x038F, r18
    2dac:	c9 01       	movw	r24, r18
    2dae:	25 e0       	ldi	r18, 0x05	; 5
    2db0:	85 3b       	cpi	r24, 0xB5	; 181
    2db2:	92 07       	cpc	r25, r18
    2db4:	10 f0       	brcs	.+4      	; 0x2dba <uip_process+0xb34>
    2db6:	84 eb       	ldi	r24, 0xB4	; 180
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    2db8:	95 e0       	ldi	r25, 0x05	; 5
    2dba:	9b 8b       	std	Y+19, r25	; 0x13
    2dbc:	8a 8b       	std	Y+18, r24	; 0x12
    2dbe:	9d 8b       	std	Y+21, r25	; 0x15
    2dc0:	8c 8b       	std	Y+20, r24	; 0x14
    2dc2:	0d c0       	rjmp	.+26     	; 0x2dde <uip_process+0xb58>
    2dc4:	47 a9       	sts	0x47, r20
    2dc6:	44 23       	and	r20, r20
    2dc8:	31 f0       	breq	.+12     	; 0x2dd6 <uip_process+0xb50>
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    2dca:	24 0f       	add	r18, r20
    2dcc:	e2 2f       	mov	r30, r18
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
    2dce:	f0 e0       	ldi	r31, 0x00	; 0
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2dd0:	e8 17       	cp	r30, r24
    2dd2:	f9 07       	cpc	r31, r25
    2dd4:	54 f2       	brlt	.-108    	; 0x2d6a <uip_process+0xae4>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2dd6:	20 93 88 03 	sts	0x0388, r18
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2dda:	30 93 91 03 	sts	0x0391, r19
    2dde:	83 e0       	ldi	r24, 0x03	; 3
    2de0:	89 8f       	std	Y+25, r24	; 0x19
    2de2:	80 91 e5 07 	lds	r24, 0x07E5
    2de6:	88 87       	std	Y+8, r24	; 0x08
    2de8:	80 91 e6 07 	lds	r24, 0x07E6
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2dec:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2dee:	80 91 e7 07 	lds	r24, 0x07E7
    2df2:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2df4:	80 91 e8 07 	lds	r24, 0x07E8
    2df8:	8b 87       	std	Y+11, r24	; 0x0b
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2dfa:	81 e0       	ldi	r24, 0x01	; 1
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	49 d9       	rcall	.-3438   	; 0x2092 <uip_add_rcv_nxt>
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2e00:	82 e4       	ldi	r24, 0x42	; 66
    2e02:	80 93 4f 06 	sts	0x064F, r24
      uip_add_rcv_nxt(1);
    2e06:	19 8a       	std	Y+17, r1	; 0x11
    2e08:	18 8a       	std	Y+16, r1	; 0x10
    2e0a:	10 92 48 06 	sts	0x0648, r1
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    2e0e:	10 92 47 06 	sts	0x0647, r1
    2e12:	83 c0       	rjmp	.+262    	; 0x2f1a <uip_process+0xc94>
      uip_connr->len = 0;
    2e14:	80 e2       	ldi	r24, 0x20	; 32
    2e16:	80 93 4f 06 	sts	0x064F, r24
      uip_len = 0;
    2e1a:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
    2e1e:	e0 91 54 06 	lds	r30, 0x0654
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    2e22:	f0 91 55 06 	lds	r31, 0x0655
    2e26:	11 8e       	std	Z+25, r1	; 0x19
    UIP_APPCALL();
    2e28:	4f cd       	rjmp	.-1378   	; 0x28c8 <uip_process+0x642>
    2e2a:	80 91 ee 07 	lds	r24, 0x07EE
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    2e2e:	80 ff       	sbrs	r24, 0
    2e30:	24 c0       	rjmp	.+72     	; 0x2e7a <uip_process+0xbf4>
    2e32:	44 fd       	sbrc	r20, 4
    2e34:	22 c0       	rjmp	.+68     	; 0x2e7a <uip_process+0xbf4>
    goto reset;
    2e36:	88 89       	ldd	r24, Y+16	; 0x10
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2e38:	99 89       	ldd	r25, Y+17	; 0x11
    2e3a:	00 97       	sbiw	r24, 0x00	; 0
    2e3c:	09 f0       	breq	.+2      	; 0x2e40 <uip_process+0xbba>
    2e3e:	c1 c1       	rjmp	.+898    	; 0x31c2 <uip_process+0xf3c>
    2e40:	80 91 47 06 	lds	r24, 0x0647
      if(uip_outstanding(uip_connr)) {
    2e44:	90 91 48 06 	lds	r25, 0x0648
    2e48:	01 96       	adiw	r24, 0x01	; 1
    2e4a:	23 d9       	rcall	.-3514   	; 0x2092 <uip_add_rcv_nxt>
    2e4c:	20 91 4f 06 	lds	r18, 0x064F
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    2e50:	82 2f       	mov	r24, r18
    2e52:	80 61       	ori	r24, 0x10	; 16
    2e54:	80 93 4f 06 	sts	0x064F, r24
    2e58:	80 91 47 06 	lds	r24, 0x0647
      uip_flags |= UIP_CLOSE;
    2e5c:	90 91 48 06 	lds	r25, 0x0648
    2e60:	00 97       	sbiw	r24, 0x00	; 0
    2e62:	19 f0       	breq	.+6      	; 0x2e6a <uip_process+0xbe4>
    2e64:	22 61       	ori	r18, 0x12	; 18
    2e66:	20 93 4f 06 	sts	0x064F, r18
      if(uip_len > 0) {
    2e6a:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	99 8b       	std	Y+17, r25	; 0x11
	uip_flags |= UIP_NEWDATA;
    2e74:	88 8b       	std	Y+16, r24	; 0x10
    2e76:	88 e0       	ldi	r24, 0x08	; 8
    2e78:	6c c0       	rjmp	.+216    	; 0x2f52 <uip_process+0xccc>
      }
      UIP_APPCALL();
    2e7a:	85 ff       	sbrs	r24, 5
    2e7c:	1c c0       	rjmp	.+56     	; 0x2eb6 <uip_process+0xc30>
      uip_connr->len = 1;
    2e7e:	90 91 f3 07 	lds	r25, 0x07F3
    2e82:	80 e0       	ldi	r24, 0x00	; 0
    2e84:	20 91 f4 07 	lds	r18, 0x07F4
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    2e88:	30 e0       	ldi	r19, 0x00	; 0
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    2e8a:	28 2b       	or	r18, r24
    2e8c:	39 2b       	or	r19, r25
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    2e8e:	80 91 52 06 	lds	r24, 0x0652
    2e92:	90 91 53 06 	lds	r25, 0x0653
    2e96:	82 0f       	add	r24, r18
    2e98:	93 1f       	adc	r25, r19
    2e9a:	90 93 53 06 	sts	0x0653, r25
    2e9e:	80 93 52 06 	sts	0x0652, r24
    2ea2:	80 91 47 06 	lds	r24, 0x0647
    2ea6:	90 91 48 06 	lds	r25, 0x0648
    2eaa:	82 1b       	sub	r24, r18
    2eac:	93 0b       	sbc	r25, r19
    2eae:	90 93 48 06 	sts	0x0648, r25
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    2eb2:	80 93 47 06 	sts	0x0647, r24
    2eb6:	80 91 47 06 	lds	r24, 0x0647
    2eba:	90 91 48 06 	lds	r25, 0x0648
    2ebe:	00 97       	sbiw	r24, 0x00	; 0
    2ec0:	41 f0       	breq	.+16     	; 0x2ed2 <uip_process+0xc4c>
    2ec2:	44 fd       	sbrc	r20, 4
    2ec4:	06 c0       	rjmp	.+12     	; 0x2ed2 <uip_process+0xc4c>
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2ec6:	20 91 4f 06 	lds	r18, 0x064F
    2eca:	22 60       	ori	r18, 0x02	; 2
    2ecc:	20 93 4f 06 	sts	0x064F, r18
    2ed0:	e0 d8       	rcall	.-3648   	; 0x2092 <uip_add_rcv_nxt>
    2ed2:	90 91 ef 07 	lds	r25, 0x07EF
      uip_flags |= UIP_NEWDATA;
    2ed6:	80 e0       	ldi	r24, 0x00	; 0
    2ed8:	20 91 f0 07 	lds	r18, 0x07F0
    2edc:	82 0f       	add	r24, r18
    2ede:	91 1d       	adc	r25, r1
      uip_add_rcv_nxt(uip_len);
    2ee0:	90 93 90 03 	sts	0x0390, r25
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanism.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    2ee4:	80 93 8f 03 	sts	0x038F, r24
    2ee8:	2c 89       	ldd	r18, Y+20	; 0x14
    2eea:	3d 89       	ldd	r19, Y+21	; 0x15
    2eec:	28 17       	cp	r18, r24
    2eee:	39 07       	cpc	r19, r25
    2ef0:	10 f0       	brcs	.+4      	; 0x2ef6 <uip_process+0xc70>
    2ef2:	00 97       	sbiw	r24, 0x00	; 0
    2ef4:	21 f4       	brne	.+8      	; 0x2efe <uip_process+0xc78>
    2ef6:	30 93 90 03 	sts	0x0390, r19
    if(tmp16 > uip_connr->initialmss ||
    2efa:	20 93 8f 03 	sts	0x038F, r18
    2efe:	80 91 8f 03 	lds	r24, 0x038F
    2f02:	90 91 90 03 	lds	r25, 0x0390
    2f06:	9b 8b       	std	Y+19, r25	; 0x13
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    2f08:	8a 8b       	std	Y+18, r24	; 0x12
    2f0a:	80 91 4f 06 	lds	r24, 0x064F
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    }
    uip_connr->mss = tmp16;
    2f10:	83 70       	andi	r24, 0x03	; 3
    2f12:	90 70       	andi	r25, 0x00	; 0
    2f14:	00 97       	sbiw	r24, 0x00	; 0
    2f16:	09 f4       	brne	.+2      	; 0x2f1a <uip_process+0xc94>
    2f18:	54 c1       	rjmp	.+680    	; 0x31c2 <uip_process+0xf3c>
    2f1a:	10 92 ac 0d 	sts	0x0DAC, r1

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    2f1e:	10 92 ab 0d 	sts	0x0DAB, r1
    2f22:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
    2f26:	20 91 4f 06 	lds	r18, 0x064F
    2f2a:	25 ff       	sbrs	r18, 5
      uip_slen = 0;
    2f2c:	07 c0       	rjmp	.+14     	; 0x2f3c <uip_process+0xcb6>
    2f2e:	10 92 ac 0d 	sts	0x0DAC, r1
    2f32:	10 92 ab 0d 	sts	0x0DAB, r1
      UIP_APPCALL();
    2f36:	19 8e       	std	Y+25, r1	; 0x19

    appsend:

      if(uip_flags & UIP_ABORT) {
    2f38:	84 e1       	ldi	r24, 0x14	; 20
    2f3a:	ab c0       	rjmp	.+342    	; 0x3092 <uip_process+0xe0c>
    2f3c:	24 ff       	sbrs	r18, 4
    2f3e:	0d c0       	rjmp	.+26     	; 0x2f5a <uip_process+0xcd4>
	uip_slen = 0;
    2f40:	10 92 ac 0d 	sts	0x0DAC, r1
    2f44:	10 92 ab 0d 	sts	0x0DAB, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    2f48:	81 e0       	ldi	r24, 0x01	; 1
	BUF->flags = TCP_RST | TCP_ACK;
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	99 8b       	std	Y+17, r25	; 0x11
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    2f4e:	88 8b       	std	Y+16, r24	; 0x10
    2f50:	84 e0       	ldi	r24, 0x04	; 4
	uip_slen = 0;
    2f52:	89 8f       	std	Y+25, r24	; 0x19
    2f54:	1b 8e       	std	Y+27, r1	; 0x1b
    2f56:	81 e1       	ldi	r24, 0x11	; 17
    2f58:	9c c0       	rjmp	.+312    	; 0x3092 <uip_process+0xe0c>
	uip_connr->len = 1;
    2f5a:	80 91 ab 0d 	lds	r24, 0x0DAB
    2f5e:	90 91 ac 0d 	lds	r25, 0x0DAC
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    2f62:	00 97       	sbiw	r24, 0x00	; 0
    2f64:	e9 f0       	breq	.+58     	; 0x2fa0 <uip_process+0xd1a>
	uip_connr->nrtx = 0;
    2f66:	20 ff       	sbrs	r18, 0
	BUF->flags = TCP_FIN | TCP_ACK;
    2f68:	02 c0       	rjmp	.+4      	; 0x2f6e <uip_process+0xce8>
    2f6a:	19 8a       	std	Y+17, r1	; 0x11
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    2f6c:	18 8a       	std	Y+16, r1	; 0x10
    2f6e:	28 89       	ldd	r18, Y+16	; 0x10
    2f70:	39 89       	ldd	r19, Y+17	; 0x11
    2f72:	21 15       	cp	r18, r1
    2f74:	31 05       	cpc	r19, r1
    2f76:	81 f4       	brne	.+32     	; 0x2f98 <uip_process+0xd12>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    2f78:	2a 89       	ldd	r18, Y+18	; 0x12
    2f7a:	3b 89       	ldd	r19, Y+19	; 0x13
	  uip_connr->len = 0;
    2f7c:	28 17       	cp	r18, r24
    2f7e:	39 07       	cpc	r19, r25
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    2f80:	20 f4       	brcc	.+8      	; 0x2f8a <uip_process+0xd04>
    2f82:	30 93 ac 0d 	sts	0x0DAC, r19
    2f86:	20 93 ab 0d 	sts	0x0DAB, r18

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    2f8a:	80 91 ab 0d 	lds	r24, 0x0DAB
    2f8e:	90 91 ac 0d 	lds	r25, 0x0DAC
    2f92:	99 8b       	std	Y+17, r25	; 0x11
	    uip_slen = uip_connr->mss;
    2f94:	88 8b       	std	Y+16, r24	; 0x10
    2f96:	04 c0       	rjmp	.+8      	; 0x2fa0 <uip_process+0xd1a>
    2f98:	30 93 ac 0d 	sts	0x0DAC, r19
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    2f9c:	20 93 ab 0d 	sts	0x0DAB, r18
    2fa0:	1b 8e       	std	Y+27, r1	; 0x1b
    2fa2:	80 91 49 06 	lds	r24, 0x0649
    2fa6:	90 91 4a 06 	lds	r25, 0x064A
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    2faa:	90 93 53 06 	sts	0x0653, r25
    2fae:	80 93 52 06 	sts	0x0652, r24
	}
      }
      uip_connr->nrtx = 0;
    2fb2:	80 91 ab 0d 	lds	r24, 0x0DAB
    apprexmit:
      uip_appdata = uip_sappdata;
    2fb6:	90 91 ac 0d 	lds	r25, 0x0DAC
    2fba:	00 97       	sbiw	r24, 0x00	; 0
    2fbc:	59 f0       	breq	.+22     	; 0x2fd4 <uip_process+0xd4e>
    2fbe:	88 89       	ldd	r24, Y+16	; 0x10
    2fc0:	99 89       	ldd	r25, Y+17	; 0x11
    2fc2:	00 97       	sbiw	r24, 0x00	; 0

      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    2fc4:	39 f0       	breq	.+14     	; 0x2fd4 <uip_process+0xd4e>
    2fc6:	88 96       	adiw	r24, 0x28	; 40
    2fc8:	90 93 48 06 	sts	0x0648, r25
    2fcc:	80 93 47 06 	sts	0x0647, r24
    2fd0:	88 e1       	ldi	r24, 0x18	; 24
    2fd2:	0b c0       	rjmp	.+22     	; 0x2fea <uip_process+0xd64>
    2fd4:	80 91 4f 06 	lds	r24, 0x064F
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    2fd8:	81 ff       	sbrs	r24, 1
    2fda:	f3 c0       	rjmp	.+486    	; 0x31c2 <uip_process+0xf3c>
    2fdc:	88 e2       	ldi	r24, 0x28	; 40
    2fde:	90 e0       	ldi	r25, 0x00	; 0
    2fe0:	90 93 48 06 	sts	0x0648, r25
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    2fe4:	80 93 47 06 	sts	0x0647, r24
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    2fe8:	80 e1       	ldi	r24, 0x10	; 16
    2fea:	80 93 ee 07 	sts	0x07EE, r24
	uip_len = UIP_TCPIP_HLEN;
    2fee:	59 c0       	rjmp	.+178    	; 0x30a2 <uip_process+0xe1c>
    2ff0:	80 91 4f 06 	lds	r24, 0x064F
    2ff4:	80 ff       	sbrs	r24, 0
    2ff6:	e5 c0       	rjmp	.+458    	; 0x31c2 <uip_process+0xf3c>
    2ff8:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_ACK;
    2ffa:	80 e1       	ldi	r24, 0x10	; 16
    2ffc:	80 93 4f 06 	sts	0x064F, r24
	goto tcp_send_noopts;
    3000:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    3004:	de c0       	rjmp	.+444    	; 0x31c2 <uip_process+0xf3c>
    3006:	80 91 47 06 	lds	r24, 0x0647
      uip_connr->tcpstateflags = UIP_CLOSED;
    300a:	90 91 48 06 	lds	r25, 0x0648
      uip_flags = UIP_CLOSE;
    300e:	00 97       	sbiw	r24, 0x00	; 0
    3010:	09 f0       	breq	.+2      	; 0x3014 <uip_process+0xd8e>
      UIP_APPCALL();
    3012:	3f d8       	rcall	.-3970   	; 0x2092 <uip_add_rcv_nxt>
    3014:	90 91 ee 07 	lds	r25, 0x07EE

  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    3018:	80 91 4f 06 	lds	r24, 0x064F
    301c:	90 ff       	sbrs	r25, 0
    301e:	0b c0       	rjmp	.+22     	; 0x3036 <uip_process+0xdb0>
    3020:	80 ff       	sbrs	r24, 0
    3022:	06 c0       	rjmp	.+12     	; 0x3030 <uip_process+0xdaa>
      uip_add_rcv_nxt(uip_len);
    3024:	87 e0       	ldi	r24, 0x07	; 7
    3026:	89 8f       	std	Y+25, r24	; 0x19
    }
    if(BUF->flags & TCP_FIN) {
    3028:	1a 8e       	std	Y+26, r1	; 0x1a
    302a:	19 8a       	std	Y+17, r1	; 0x11
    302c:	18 8a       	std	Y+16, r1	; 0x10
    302e:	18 c0       	rjmp	.+48     	; 0x3060 <uip_process+0xdda>
    3030:	86 e0       	ldi	r24, 0x06	; 6
    3032:	89 8f       	std	Y+25, r24	; 0x19
      if(uip_flags & UIP_ACKDATA) {
    3034:	15 c0       	rjmp	.+42     	; 0x3060 <uip_process+0xdda>
    3036:	80 ff       	sbrs	r24, 0
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3038:	1c c0       	rjmp	.+56     	; 0x3072 <uip_process+0xdec>
    303a:	85 e0       	ldi	r24, 0x05	; 5
	uip_connr->timer = 0;
    303c:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->len = 0;
    303e:	19 8a       	std	Y+17, r1	; 0x11
    3040:	18 8a       	std	Y+16, r1	; 0x10
    3042:	bf c0       	rjmp	.+382    	; 0x31c2 <uip_process+0xf3c>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    3044:	80 91 47 06 	lds	r24, 0x0647
    3048:	90 91 48 06 	lds	r25, 0x0648
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    304c:	00 97       	sbiw	r24, 0x00	; 0
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    304e:	09 f0       	breq	.+2      	; 0x3052 <uip_process+0xdcc>
    3050:	20 d8       	rcall	.-4032   	; 0x2092 <uip_add_rcv_nxt>
      uip_connr->len = 0;
    3052:	80 91 ee 07 	lds	r24, 0x07EE
      goto drop;
    3056:	80 ff       	sbrs	r24, 0
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    3058:	0c c0       	rjmp	.+24     	; 0x3072 <uip_process+0xdec>
    305a:	87 e0       	ldi	r24, 0x07	; 7
    305c:	89 8f       	std	Y+25, r24	; 0x19
    305e:	1a 8e       	std	Y+26, r1	; 0x1a
    3060:	81 e0       	ldi	r24, 0x01	; 1
    3062:	90 e0       	ldi	r25, 0x00	; 0
      uip_add_rcv_nxt(uip_len);
    3064:	16 d8       	rcall	.-4052   	; 0x2092 <uip_add_rcv_nxt>
    3066:	80 e1       	ldi	r24, 0x10	; 16
    }
    if(BUF->flags & TCP_FIN) {
    3068:	80 93 4f 06 	sts	0x064F, r24
    306c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uIPManagement_TCPCallback>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3070:	0f c0       	rjmp	.+30     	; 0x3090 <uip_process+0xe0a>
    3072:	80 91 47 06 	lds	r24, 0x0647
      uip_connr->timer = 0;
      uip_add_rcv_nxt(1);
    3076:	90 91 48 06 	lds	r25, 0x0648
    307a:	00 97       	sbiw	r24, 0x00	; 0
    307c:	49 f4       	brne	.+18     	; 0x3090 <uip_process+0xe0a>
      uip_flags = UIP_CLOSE;
    307e:	a1 c0       	rjmp	.+322    	; 0x31c2 <uip_process+0xf3c>
    3080:	80 91 4f 06 	lds	r24, 0x064F
      UIP_APPCALL();
    3084:	80 ff       	sbrs	r24, 0
    3086:	9d c0       	rjmp	.+314    	; 0x31c2 <uip_process+0xf3c>
      goto tcp_send_ack;
    3088:	87 e0       	ldi	r24, 0x07	; 7
    }
    if(uip_len > 0) {
    308a:	89 8f       	std	Y+25, r24	; 0x19
    308c:	1a 8e       	std	Y+26, r1	; 0x1a
    308e:	99 c0       	rjmp	.+306    	; 0x31c2 <uip_process+0xf3c>
    3090:	80 e1       	ldi	r24, 0x10	; 16
    3092:	80 93 ee 07 	sts	0x07EE, r24
    3096:	88 e2       	ldi	r24, 0x28	; 40

  case UIP_TIME_WAIT:
    goto tcp_send_ack;

  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    3098:	90 e0       	ldi	r25, 0x00	; 0
    309a:	90 93 48 06 	sts	0x0648, r25
    309e:	80 93 47 06 	sts	0x0647, r24
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    30a2:	80 e5       	ldi	r24, 0x50	; 80
      uip_connr->timer = 0;
    30a4:	80 93 ed 07 	sts	0x07ED, r24
  goto drop;

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    30a8:	88 85       	ldd	r24, Y+8	; 0x08
    30aa:	80 93 e9 07 	sts	0x07E9, r24

 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    30ae:	89 85       	ldd	r24, Y+9	; 0x09
    30b0:	80 93 ea 07 	sts	0x07EA, r24
    30b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    30b6:	80 93 eb 07 	sts	0x07EB, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    30ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    30bc:	80 93 ec 07 	sts	0x07EC, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    30c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    30c2:	80 93 e5 07 	sts	0x07E5, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    30c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    30c8:	80 93 e6 07 	sts	0x07E6, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    30cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    30ce:	80 93 e7 07 	sts	0x07E7, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    30d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    30d4:	80 93 e8 07 	sts	0x07E8, r24

  BUF->seqno[0] = uip_connr->snd_nxt[0];
    30d8:	86 e0       	ldi	r24, 0x06	; 6
    30da:	80 93 d6 07 	sts	0x07D6, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    30de:	8c 81       	ldd	r24, Y+4	; 0x04
    30e0:	9d 81       	ldd	r25, Y+5	; 0x05
    30e2:	90 93 e2 07 	sts	0x07E2, r25
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    30e6:	80 93 e1 07 	sts	0x07E1, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    30ea:	8e 81       	ldd	r24, Y+6	; 0x06
    30ec:	9f 81       	ldd	r25, Y+7	; 0x07
    30ee:	90 93 e4 07 	sts	0x07E4, r25

  BUF->proto = UIP_PROTO_TCP;
    30f2:	80 93 e3 07 	sts	0x07E3, r24

  BUF->srcport  = uip_connr->lport;
    30f6:	80 91 bb 07 	lds	r24, 0x07BB
    30fa:	90 91 bc 07 	lds	r25, 0x07BC
    30fe:	a0 91 bd 07 	lds	r26, 0x07BD
  BUF->destport = uip_connr->rport;
    3102:	b0 91 be 07 	lds	r27, 0x07BE
    3106:	80 93 d9 07 	sts	0x07D9, r24
    310a:	90 93 da 07 	sts	0x07DA, r25

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    310e:	a0 93 db 07 	sts	0x07DB, r26
    3112:	b0 93 dc 07 	sts	0x07DC, r27
    3116:	88 81       	ld	r24, Y
    3118:	99 81       	ldd	r25, Y+1	; 0x01
    311a:	aa 81       	ldd	r26, Y+2	; 0x02
    311c:	bb 81       	ldd	r27, Y+3	; 0x03
    311e:	80 93 dd 07 	sts	0x07DD, r24
    3122:	90 93 de 07 	sts	0x07DE, r25
    3126:	a0 93 df 07 	sts	0x07DF, r26
    312a:	b0 93 e0 07 	sts	0x07E0, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    312e:	89 8d       	ldd	r24, Y+25	; 0x19
    3130:	84 ff       	sbrs	r24, 4
    3132:	05 c0       	rjmp	.+10     	; 0x313e <uip_process+0xeb8>
    3134:	10 92 f0 07 	sts	0x07F0, r1
    3138:	10 92 ef 07 	sts	0x07EF, r1
    313c:	06 c0       	rjmp	.+12     	; 0x314a <uip_process+0xec4>
    313e:	85 e0       	ldi	r24, 0x05	; 5
    3140:	80 93 ef 07 	sts	0x07EF, r24
    3144:	84 eb       	ldi	r24, 0xB4	; 180

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    3146:	80 93 f0 07 	sts	0x07F0, r24
    314a:	80 e4       	ldi	r24, 0x40	; 64
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    314c:	80 93 d5 07 	sts	0x07D5, r24
    3150:	80 91 47 06 	lds	r24, 0x0647
    3154:	90 91 48 06 	lds	r25, 0x0648
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    3158:	90 93 cf 07 	sts	0x07CF, r25
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    315c:	80 93 d0 07 	sts	0x07D0, r24
    3160:	10 92 f4 07 	sts	0x07F4, r1
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    3164:	10 92 f3 07 	sts	0x07F3, r1
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    3168:	10 92 f2 07 	sts	0x07F2, r1
    316c:	10 92 f1 07 	sts	0x07F1, r1
    3170:	69 d8       	rcall	.-3886   	; 0x2244 <uip_tcpchksum>
    3172:	80 95       	com	r24
  BUF->len[1] = (uip_len & 0xff);
    3174:	90 95       	com	r25
    3176:	90 93 f2 07 	sts	0x07F2, r25
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    317a:	80 93 f1 07 	sts	0x07F1, r24
    317e:	85 e4       	ldi	r24, 0x45	; 69

  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    3180:	80 93 cd 07 	sts	0x07CD, r24
    3184:	10 92 ce 07 	sts	0x07CE, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    3188:	10 92 d4 07 	sts	0x07D4, r1
    318c:	10 92 d3 07 	sts	0x07D3, r1
    3190:	80 91 86 03 	lds	r24, 0x0386
    3194:	90 91 87 03 	lds	r25, 0x0387
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    3198:	01 96       	adiw	r24, 0x01	; 1
    319a:	90 93 87 03 	sts	0x0387, r25
  BUF->tos = 0;
    319e:	80 93 86 03 	sts	0x0386, r24
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    31a2:	90 93 d1 07 	sts	0x07D1, r25
    31a6:	80 93 d2 07 	sts	0x07D2, r24
  ++ipid;
    31aa:	10 92 d8 07 	sts	0x07D8, r1
    31ae:	10 92 d7 07 	sts	0x07D7, r1
    31b2:	34 d8       	rcall	.-3992   	; 0x221c <uip_ipchksum>
    31b4:	80 95       	com	r24
    31b6:	90 95       	com	r25
    31b8:	90 93 d8 07 	sts	0x07D8, r25
  BUF->ipid[0] = ipid >> 8;
    31bc:	80 93 d7 07 	sts	0x07D7, r24
  BUF->ipid[1] = ipid & 0xff;
    31c0:	04 c0       	rjmp	.+8      	; 0x31ca <uip_process+0xf44>
    31c2:	10 92 48 06 	sts	0x0648, r1
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    31c6:	10 92 47 06 	sts	0x0647, r1
    31ca:	10 92 4f 06 	sts	0x064F, r1
  BUF->ipchksum = ~(uip_ipchksum());
    31ce:	df 91       	pop	r29
    31d0:	cf 91       	pop	r28
    31d2:	1f 91       	pop	r17
    31d4:	0f 91       	pop	r16
    31d6:	ff 90       	pop	r15
    31d8:	ef 90       	pop	r14
    31da:	df 90       	pop	r13
    31dc:	cf 90       	pop	r12
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    31de:	bf 90       	pop	r11
    31e0:	af 90       	pop	r10
    31e2:	08 95       	ret

000031e4 <uip_send>:
    31e4:	fc 01       	movw	r30, r24
  uip_flags = 0;
    31e6:	20 91 49 06 	lds	r18, 0x0649
  return;
}
    31ea:	30 91 4a 06 	lds	r19, 0x064A
    31ee:	89 ea       	ldi	r24, 0xA9	; 169
    31f0:	9d e0       	ldi	r25, 0x0D	; 13
    31f2:	82 1b       	sub	r24, r18
    31f4:	93 0b       	sbc	r25, r19
    31f6:	ab 01       	movw	r20, r22
    31f8:	86 17       	cp	r24, r22
    31fa:	97 07       	cpc	r25, r23
    31fc:	0c f4       	brge	.+2      	; 0x3200 <uip_send+0x1c>
    31fe:	ac 01       	movw	r20, r24
{
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    3200:	14 16       	cp	r1, r20
    3202:	15 06       	cpc	r1, r21
    3204:	5c f4       	brge	.+22     	; 0x321c <uip_send+0x38>
    uip_slen = copylen;
    3206:	40 93 ab 0d 	sts	0x0DAB, r20
    320a:	50 93 ac 0d 	sts	0x0DAC, r21
    if(data != uip_sappdata) {
    320e:	e2 17       	cp	r30, r18
    3210:	f3 07       	cpc	r31, r19
    3212:	21 f0       	breq	.+8      	; 0x321c <uip_send+0x38>
      memcpy(uip_sappdata, (data), uip_slen);
    3214:	c9 01       	movw	r24, r18
    3216:	bf 01       	movw	r22, r30
    3218:	0c 94 79 3c 	jmp	0x78f2	; 0x78f2 <memcpy>
    321c:	08 95       	ret

0000321e <uip_arp_update.constprop.0>:
  }

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
    321e:	ef 92       	push	r14
    3220:	ff 92       	push	r15
    3222:	0f 93       	push	r16
    3224:	1f 93       	push	r17
    3226:	cf 93       	push	r28
    3228:	df 93       	push	r29
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    322a:	10 92 92 03 	sts	0x0392, r1

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    322e:	60 91 20 03 	lds	r22, 0x0320
    3232:	70 91 21 03 	lds	r23, 0x0321
    3236:	a0 91 22 03 	lds	r26, 0x0322
    323a:	b0 91 23 03 	lds	r27, 0x0323

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    323e:	c0 91 db 07 	lds	r28, 0x07DB
    3242:	d0 91 dc 07 	lds	r29, 0x07DC
    3246:	00 91 dd 07 	lds	r16, 0x07DD
    324a:	10 91 de 07 	lds	r17, 0x07DE
    324e:	40 e0       	ldi	r20, 0x00	; 0
}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
{
  register struct arp_entry *tabptr = NULL;
    3250:	e0 e0       	ldi	r30, 0x00	; 0
    3252:	f0 e0       	ldi	r31, 0x00	; 0
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    3254:	8b e0       	ldi	r24, 0x0B	; 11
    3256:	e8 2e       	mov	r14, r24
    3258:	f1 2c       	mov	r15, r1
    325a:	2a c0       	rjmp	.+84     	; 0x32b0 <uip_arp_update.constprop.0+0x92>
    325c:	84 2f       	mov	r24, r20
    325e:	90 e0       	ldi	r25, 0x00	; 0
    3260:	8e 9d       	mul	r24, r14
    3262:	f0 01       	movw	r30, r0
    3264:	8f 9d       	mul	r24, r15
    3266:	f0 0d       	add	r31, r0
    3268:	9e 9d       	mul	r25, r14
    326a:	f0 0d       	add	r31, r0
    326c:	11 24       	eor	r1, r1
    326e:	ed 56       	subi	r30, 0x6D	; 109
    3270:	fc 4f       	sbci	r31, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3272:	80 81       	ld	r24, Z
    3274:	91 81       	ldd	r25, Z+1	; 0x01
    3276:	86 17       	cp	r24, r22
    3278:	97 07       	cpc	r25, r23
    327a:	29 f4       	brne	.+10     	; 0x3286 <uip_arp_update.constprop.0+0x68>
    327c:	22 81       	ldd	r18, Z+2	; 0x02
    327e:	33 81       	ldd	r19, Z+3	; 0x03
    3280:	2a 17       	cp	r18, r26
    3282:	3b 07       	cpc	r19, r27
    3284:	a1 f0       	breq	.+40     	; 0x32ae <uip_arp_update.constprop.0+0x90>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    3286:	c8 17       	cp	r28, r24
    3288:	d9 07       	cpc	r29, r25
    328a:	89 f4       	brne	.+34     	; 0x32ae <uip_arp_update.constprop.0+0x90>
    328c:	82 81       	ldd	r24, Z+2	; 0x02
    328e:	93 81       	ldd	r25, Z+3	; 0x03
    3290:	08 17       	cp	r16, r24
    3292:	19 07       	cpc	r17, r25
    3294:	61 f4       	brne	.+24     	; 0x32ae <uip_arp_update.constprop.0+0x90>
    3296:	40 93 92 03 	sts	0x0392, r20

	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    329a:	ef 01       	movw	r28, r30
    329c:	24 96       	adiw	r28, 0x04	; 4
    329e:	a5 ed       	ldi	r26, 0xD5	; 213
    32a0:	b7 e0       	ldi	r27, 0x07	; 7
    32a2:	86 e0       	ldi	r24, 0x06	; 6
    32a4:	0d 90       	ld	r0, X+
    32a6:	09 92       	st	Y+, r0
    32a8:	81 50       	subi	r24, 0x01	; 1
    32aa:	e1 f7       	brne	.-8      	; 0x32a4 <uip_arp_update.constprop.0+0x86>
    32ac:	78 c0       	rjmp	.+240    	; 0x339e <uip_arp_update.constprop.0+0x180>
	tabptr->time = arptime;
    32ae:	4f 5f       	subi	r20, 0xFF	; 255
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32b0:	48 30       	cpi	r20, 0x08	; 8
    32b2:	a0 f2       	brcs	.-88     	; 0x325c <uip_arp_update.constprop.0+0x3e>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32b4:	10 92 92 03 	sts	0x0392, r1
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    32b8:	20 91 20 03 	lds	r18, 0x0320
    32bc:	30 91 21 03 	lds	r19, 0x0321
    32c0:	40 91 22 03 	lds	r20, 0x0322
    32c4:	50 91 23 03 	lds	r21, 0x0323
    32c8:	a0 e0       	ldi	r26, 0x00	; 0
  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    32ca:	6b e0       	ldi	r22, 0x0B	; 11
    32cc:	70 e0       	ldi	r23, 0x00	; 0
    32ce:	16 c0       	rjmp	.+44     	; 0x32fc <uip_arp_update.constprop.0+0xde>
    32d0:	8a 2f       	mov	r24, r26
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	86 9f       	mul	r24, r22
    32d6:	f0 01       	movw	r30, r0
    32d8:	87 9f       	mul	r24, r23
    32da:	f0 0d       	add	r31, r0
    32dc:	96 9f       	mul	r25, r22
    32de:	f0 0d       	add	r31, r0
    32e0:	11 24       	eor	r1, r1
    32e2:	ed 56       	subi	r30, 0x6D	; 109
    32e4:	fc 4f       	sbci	r31, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    32e6:	80 81       	ld	r24, Z
    32e8:	91 81       	ldd	r25, Z+1	; 0x01
    32ea:	82 17       	cp	r24, r18
    32ec:	93 07       	cpc	r25, r19
    32ee:	29 f4       	brne	.+10     	; 0x32fa <uip_arp_update.constprop.0+0xdc>
    32f0:	82 81       	ldd	r24, Z+2	; 0x02
    32f2:	93 81       	ldd	r25, Z+3	; 0x03
    32f4:	84 17       	cp	r24, r20
    32f6:	95 07       	cpc	r25, r21
    32f8:	19 f0       	breq	.+6      	; 0x3300 <uip_arp_update.constprop.0+0xe2>
    32fa:	af 5f       	subi	r26, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32fc:	a8 30       	cpi	r26, 0x08	; 8
    32fe:	40 f3       	brcs	.-48     	; 0x32d0 <uip_arp_update.constprop.0+0xb2>
    3300:	a0 93 92 03 	sts	0x0392, r26
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    3304:	a8 30       	cpi	r26, 0x08	; 8
    3306:	b9 f5       	brne	.+110    	; 0x3376 <uip_arp_update.constprop.0+0x158>
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    3308:	00 91 eb 03 	lds	r16, 0x03EB
    330c:	40 2f       	mov	r20, r16
    330e:	50 e0       	ldi	r21, 0x00	; 0
    3310:	c0 e0       	ldi	r28, 0x00	; 0
    3312:	b0 e0       	ldi	r27, 0x00	; 0
    3314:	a0 e0       	ldi	r26, 0x00	; 0
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    3316:	6b e0       	ldi	r22, 0x0B	; 11
    3318:	70 e0       	ldi	r23, 0x00	; 0
    331a:	18 c0       	rjmp	.+48     	; 0x334c <uip_arp_update.constprop.0+0x12e>
    331c:	8a 2f       	mov	r24, r26
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	86 9f       	mul	r24, r22
    3322:	f0 01       	movw	r30, r0
    3324:	87 9f       	mul	r24, r23
    3326:	f0 0d       	add	r31, r0
    3328:	96 9f       	mul	r25, r22
    332a:	f0 0d       	add	r31, r0
    332c:	11 24       	eor	r1, r1
      if(arptime - tabptr->time > tmpage) {
    332e:	ed 56       	subi	r30, 0x6D	; 109
    3330:	fc 4f       	sbci	r31, 0xFC	; 252
    3332:	e2 85       	ldd	r30, Z+10	; 0x0a
    3334:	9a 01       	movw	r18, r20
    3336:	2e 1b       	sub	r18, r30
    3338:	31 09       	sbc	r19, r1
    333a:	8c 2f       	mov	r24, r28
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	82 17       	cp	r24, r18
    3340:	93 07       	cpc	r25, r19
    3342:	1c f4       	brge	.+6      	; 0x334a <uip_arp_update.constprop.0+0x12c>
	tmpage = arptime - tabptr->time;
    3344:	c0 2f       	mov	r28, r16
    3346:	ce 1b       	sub	r28, r30
	c = i;
    3348:	ba 2f       	mov	r27, r26
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
    334a:	af 5f       	subi	r26, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    334c:	a8 30       	cpi	r26, 0x08	; 8
    334e:	30 f3       	brcs	.-52     	; 0x331c <uip_arp_update.constprop.0+0xfe>
    3350:	c0 93 ec 03 	sts	0x03EC, r28
    3354:	b0 93 ed 03 	sts	0x03ED, r27
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    3358:	b0 93 92 03 	sts	0x0392, r27
    tabptr = &arp_table[i];
    335c:	2b 2f       	mov	r18, r27
    335e:	30 e0       	ldi	r19, 0x00	; 0
    3360:	8b e0       	ldi	r24, 0x0B	; 11
    3362:	90 e0       	ldi	r25, 0x00	; 0
    3364:	28 9f       	mul	r18, r24
    3366:	f0 01       	movw	r30, r0
    3368:	29 9f       	mul	r18, r25
    336a:	f0 0d       	add	r31, r0
    336c:	38 9f       	mul	r19, r24
    336e:	f0 0d       	add	r31, r0
    3370:	11 24       	eor	r1, r1
    3372:	ed 56       	subi	r30, 0x6D	; 109
    3374:	fc 4f       	sbci	r31, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  uip_ipaddr_copy(&tabptr->ipaddr, ipaddr);
    3376:	40 91 db 07 	lds	r20, 0x07DB
    337a:	50 91 dc 07 	lds	r21, 0x07DC
    337e:	60 91 dd 07 	lds	r22, 0x07DD
    3382:	70 91 de 07 	lds	r23, 0x07DE
    3386:	df 01       	movw	r26, r30
    3388:	4d 93       	st	X+, r20
    338a:	5d 93       	st	X+, r21
    338c:	6d 93       	st	X+, r22
    338e:	7d 93       	st	X+, r23
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3390:	c5 ed       	ldi	r28, 0xD5	; 213
    3392:	d7 e0       	ldi	r29, 0x07	; 7
    3394:	86 e0       	ldi	r24, 0x06	; 6
    3396:	09 90       	ld	r0, Y+
    3398:	0d 92       	st	X+, r0
    339a:	81 50       	subi	r24, 0x01	; 1
    339c:	e1 f7       	brne	.-8      	; 0x3396 <uip_arp_update.constprop.0+0x178>
  tabptr->time = arptime;
    339e:	80 91 eb 03 	lds	r24, 0x03EB
    33a2:	82 87       	std	Z+10, r24	; 0x0a
}
    33a4:	df 91       	pop	r29
    33a6:	cf 91       	pop	r28
    33a8:	1f 91       	pop	r17
    33aa:	0f 91       	pop	r16
    33ac:	ff 90       	pop	r15
    33ae:	ef 90       	pop	r14
    33b0:	08 95       	ret

000033b2 <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33b2:	10 92 92 03 	sts	0x0392, r1
    memset(&arp_table[i].ipaddr, 0, 4);
    33b6:	8b e0       	ldi	r24, 0x0B	; 11
    33b8:	90 e0       	ldi	r25, 0x00	; 0
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33ba:	12 c0       	rjmp	.+36     	; 0x33e0 <uip_arp_init+0x2e>
    memset(&arp_table[i].ipaddr, 0, 4);
    33bc:	24 2f       	mov	r18, r20
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	28 9f       	mul	r18, r24
    33c2:	f0 01       	movw	r30, r0
    33c4:	29 9f       	mul	r18, r25
    33c6:	f0 0d       	add	r31, r0
    33c8:	38 9f       	mul	r19, r24
    33ca:	f0 0d       	add	r31, r0
    33cc:	11 24       	eor	r1, r1
    33ce:	ed 56       	subi	r30, 0x6D	; 109
    33d0:	fc 4f       	sbci	r31, 0xFC	; 252
    33d2:	10 82       	st	Z, r1
    33d4:	11 82       	std	Z+1, r1	; 0x01
    33d6:	12 82       	std	Z+2, r1	; 0x02
    33d8:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33da:	4f 5f       	subi	r20, 0xFF	; 255
    33dc:	40 93 92 03 	sts	0x0392, r20
    33e0:	40 91 92 03 	lds	r20, 0x0392
    33e4:	48 30       	cpi	r20, 0x08	; 8
    33e6:	50 f3       	brcs	.-44     	; 0x33bc <uip_arp_init+0xa>
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
    33e8:	08 95       	ret

000033ea <uip_arp_timer>:
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
    33ea:	80 91 eb 03 	lds	r24, 0x03EB
    33ee:	8f 5f       	subi	r24, 0xFF	; 255
    33f0:	80 93 eb 03 	sts	0x03EB, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33f4:	10 92 92 03 	sts	0x0392, r1
    tabptr = &arp_table[i];
    33f8:	2b e0       	ldi	r18, 0x0B	; 11
    33fa:	30 e0       	ldi	r19, 0x00	; 0
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    33fc:	60 91 20 03 	lds	r22, 0x0320
    3400:	70 91 21 03 	lds	r23, 0x0321
    3404:	a0 91 22 03 	lds	r26, 0x0322
    3408:	b0 91 23 03 	lds	r27, 0x0323
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    340c:	25 c0       	rjmp	.+74     	; 0x3458 <uip_arp_timer+0x6e>
    tabptr = &arp_table[i];
    340e:	84 2f       	mov	r24, r20
    3410:	90 e0       	ldi	r25, 0x00	; 0
    3412:	82 9f       	mul	r24, r18
    3414:	f0 01       	movw	r30, r0
    3416:	83 9f       	mul	r24, r19
    3418:	f0 0d       	add	r31, r0
    341a:	92 9f       	mul	r25, r18
    341c:	f0 0d       	add	r31, r0
    341e:	11 24       	eor	r1, r1
    3420:	ed 56       	subi	r30, 0x6D	; 109
    3422:	fc 4f       	sbci	r31, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3424:	80 81       	ld	r24, Z
    3426:	91 81       	ldd	r25, Z+1	; 0x01
    3428:	86 17       	cp	r24, r22
    342a:	97 07       	cpc	r25, r23
    342c:	91 f4       	brne	.+36     	; 0x3452 <uip_arp_timer+0x68>
    342e:	82 81       	ldd	r24, Z+2	; 0x02
    3430:	93 81       	ldd	r25, Z+3	; 0x03
    3432:	8a 17       	cp	r24, r26
    3434:	9b 07       	cpc	r25, r27
    3436:	69 f4       	brne	.+26     	; 0x3452 <uip_arp_timer+0x68>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
    3438:	80 91 eb 03 	lds	r24, 0x03EB
    343c:	90 e0       	ldi	r25, 0x00	; 0
    343e:	52 85       	ldd	r21, Z+10	; 0x0a
    3440:	85 1b       	sub	r24, r21
    3442:	91 09       	sbc	r25, r1
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3444:	88 37       	cpi	r24, 0x78	; 120
    3446:	91 05       	cpc	r25, r1
    3448:	24 f0       	brlt	.+8      	; 0x3452 <uip_arp_timer+0x68>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    344a:	10 82       	st	Z, r1
    344c:	11 82       	std	Z+1, r1	; 0x01
    344e:	12 82       	std	Z+2, r1	; 0x02
    3450:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3452:	4f 5f       	subi	r20, 0xFF	; 255
    3454:	40 93 92 03 	sts	0x0392, r20
    3458:	40 91 92 03 	lds	r20, 0x0392
    345c:	48 30       	cpi	r20, 0x08	; 8
    345e:	b8 f2       	brcs	.-82     	; 0x340e <uip_arp_timer+0x24>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }

}
    3460:	08 95       	ret

00003462 <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    3462:	cf 93       	push	r28
    3464:	df 93       	push	r29
  if(uip_len < sizeof(struct arp_hdr)) {
    3466:	80 91 47 06 	lds	r24, 0x0647
    346a:	90 91 48 06 	lds	r25, 0x0648
    uip_len = 0;
    346e:	10 92 48 06 	sts	0x0648, r1
    3472:	10 92 47 06 	sts	0x0647, r1
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
  if(uip_len < sizeof(struct arp_hdr)) {
    3476:	8a 32       	cpi	r24, 0x2A	; 42
    3478:	91 05       	cpc	r25, r1
    347a:	08 f4       	brcc	.+2      	; 0x347e <uip_arp_arpin+0x1c>
    347c:	90 c0       	rjmp	.+288    	; 0x359e <uip_arp_arpin+0x13c>
    uip_len = 0;
    return;
  }
  uip_len = 0;

  switch(BUF->opcode) {
    347e:	80 91 d3 07 	lds	r24, 0x07D3
    3482:	90 91 d4 07 	lds	r25, 0x07D4
    3486:	21 e0       	ldi	r18, 0x01	; 1
    3488:	80 30       	cpi	r24, 0x00	; 0
    348a:	92 07       	cpc	r25, r18
    348c:	31 f0       	breq	.+12     	; 0x349a <uip_arp_arpin+0x38>
    348e:	22 e0       	ldi	r18, 0x02	; 2
    3490:	80 30       	cpi	r24, 0x00	; 0
    3492:	92 07       	cpc	r25, r18
    3494:	09 f0       	breq	.+2      	; 0x3498 <uip_arp_arpin+0x36>
    3496:	83 c0       	rjmp	.+262    	; 0x359e <uip_arp_arpin+0x13c>
    3498:	6b c0       	rjmp	.+214    	; 0x3570 <uip_arp_arpin+0x10e>
    PRINTF("uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n",
	   BUF->dipaddr.u8[0], BUF->dipaddr.u8[1],
	   BUF->dipaddr.u8[2], BUF->dipaddr.u8[3],
	   uip_hostaddr.u8[0], uip_hostaddr.u8[1],
	   uip_hostaddr.u8[2], uip_hostaddr.u8[3]);
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    349a:	20 91 e5 07 	lds	r18, 0x07E5
    349e:	30 91 e6 07 	lds	r19, 0x07E6
    34a2:	80 91 bb 07 	lds	r24, 0x07BB
    34a6:	90 91 bc 07 	lds	r25, 0x07BC
    34aa:	28 17       	cp	r18, r24
    34ac:	39 07       	cpc	r19, r25
    34ae:	09 f0       	breq	.+2      	; 0x34b2 <uip_arp_arpin+0x50>
    34b0:	76 c0       	rjmp	.+236    	; 0x359e <uip_arp_arpin+0x13c>
    34b2:	20 91 e7 07 	lds	r18, 0x07E7
    34b6:	30 91 e8 07 	lds	r19, 0x07E8
    34ba:	80 91 bd 07 	lds	r24, 0x07BD
    34be:	90 91 be 07 	lds	r25, 0x07BE
    34c2:	28 17       	cp	r18, r24
    34c4:	39 07       	cpc	r19, r25
    34c6:	09 f0       	breq	.+2      	; 0x34ca <uip_arp_arpin+0x68>
    34c8:	6a c0       	rjmp	.+212    	; 0x359e <uip_arp_arpin+0x13c>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    34ca:	a9 de       	rcall	.-686    	; 0x321e <uip_arp_update.constprop.0>
    34cc:	80 e0       	ldi	r24, 0x00	; 0

      BUF->opcode = HTONS(ARP_REPLY);
    34ce:	92 e0       	ldi	r25, 0x02	; 2
    34d0:	90 93 d4 07 	sts	0x07D4, r25
    34d4:	80 93 d3 07 	sts	0x07D3, r24
    34d8:	ef ed       	ldi	r30, 0xDF	; 223

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    34da:	f7 e0       	ldi	r31, 0x07	; 7
    34dc:	df 01       	movw	r26, r30
    34de:	1a 97       	sbiw	r26, 0x0a	; 10
    34e0:	86 e0       	ldi	r24, 0x06	; 6
    34e2:	0d 90       	ld	r0, X+
    34e4:	01 92       	st	Z+, r0
    34e6:	81 50       	subi	r24, 0x01	; 1
    34e8:	e1 f7       	brne	.-8      	; 0x34e2 <uip_arp_arpin+0x80>
    34ea:	a5 ed       	ldi	r26, 0xD5	; 213
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    34ec:	b7 e0       	ldi	r27, 0x07	; 7
    34ee:	e0 e8       	ldi	r30, 0x80	; 128
    34f0:	f3 e0       	ldi	r31, 0x03	; 3
    34f2:	86 e0       	ldi	r24, 0x06	; 6
    34f4:	01 90       	ld	r0, Z+
    34f6:	0d 92       	st	X+, r0
    34f8:	81 50       	subi	r24, 0x01	; 1
    34fa:	e1 f7       	brne	.-8      	; 0x34f4 <uip_arp_arpin+0x92>
    34fc:	a5 ec       	ldi	r26, 0xC5	; 197
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    34fe:	b7 e0       	ldi	r27, 0x07	; 7
    3500:	e0 e8       	ldi	r30, 0x80	; 128
    3502:	f3 e0       	ldi	r31, 0x03	; 3
    3504:	86 e0       	ldi	r24, 0x06	; 6
    3506:	01 90       	ld	r0, Z+
    3508:	0d 92       	st	X+, r0
    350a:	81 50       	subi	r24, 0x01	; 1
    350c:	e1 f7       	brne	.-8      	; 0x3506 <uip_arp_arpin+0xa4>
    350e:	af eb       	ldi	r26, 0xBF	; 191
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    3510:	b7 e0       	ldi	r27, 0x07	; 7
    3512:	ed 01       	movw	r28, r26
    3514:	a0 96       	adiw	r28, 0x20	; 32
    3516:	86 e0       	ldi	r24, 0x06	; 6
    3518:	fd 01       	movw	r30, r26
    351a:	09 90       	ld	r0, Y+
    351c:	0d 92       	st	X+, r0
    351e:	81 50       	subi	r24, 0x01	; 1
    3520:	e1 f7       	brne	.-8      	; 0x351a <uip_arp_arpin+0xb8>
    3522:	80 91 db 07 	lds	r24, 0x07DB

      uip_ipaddr_copy(&BUF->dipaddr, &BUF->sipaddr);
    3526:	90 91 dc 07 	lds	r25, 0x07DC
    352a:	a0 91 dd 07 	lds	r26, 0x07DD
    352e:	b0 91 de 07 	lds	r27, 0x07DE
    3532:	80 93 e5 07 	sts	0x07E5, r24
    3536:	90 93 e6 07 	sts	0x07E6, r25
    353a:	a0 93 e7 07 	sts	0x07E7, r26
    353e:	b0 93 e8 07 	sts	0x07E8, r27
    3542:	80 91 bb 07 	lds	r24, 0x07BB
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    3546:	90 91 bc 07 	lds	r25, 0x07BC
    354a:	a0 91 bd 07 	lds	r26, 0x07BD
    354e:	b0 91 be 07 	lds	r27, 0x07BE
    3552:	84 8f       	std	Z+28, r24	; 0x1c
    3554:	95 8f       	std	Z+29, r25	; 0x1d
    3556:	a6 8f       	std	Z+30, r26	; 0x1e
    3558:	b7 8f       	std	Z+31, r27	; 0x1f
    355a:	88 e0       	ldi	r24, 0x08	; 8

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    355c:	96 e0       	ldi	r25, 0x06	; 6
    355e:	95 87       	std	Z+13, r25	; 0x0d
    3560:	84 87       	std	Z+12, r24	; 0x0c
    3562:	8a e2       	ldi	r24, 0x2A	; 42
      uip_len = sizeof(struct arp_hdr);
    3564:	90 e0       	ldi	r25, 0x00	; 0
    3566:	90 93 48 06 	sts	0x0648, r25
    356a:	80 93 47 06 	sts	0x0647, r24
    356e:	17 c0       	rjmp	.+46     	; 0x359e <uip_arp_arpin+0x13c>
    3570:	20 91 e5 07 	lds	r18, 0x07E5
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    3574:	30 91 e6 07 	lds	r19, 0x07E6
    3578:	80 91 bb 07 	lds	r24, 0x07BB
    357c:	90 91 bc 07 	lds	r25, 0x07BC
    3580:	28 17       	cp	r18, r24
    3582:	39 07       	cpc	r19, r25
    3584:	61 f4       	brne	.+24     	; 0x359e <uip_arp_arpin+0x13c>
    3586:	20 91 e7 07 	lds	r18, 0x07E7
    358a:	30 91 e8 07 	lds	r19, 0x07E8
    358e:	80 91 bd 07 	lds	r24, 0x07BD
    3592:	90 91 be 07 	lds	r25, 0x07BE
    3596:	28 17       	cp	r18, r24
    3598:	39 07       	cpc	r19, r25
    359a:	09 f4       	brne	.+2      	; 0x359e <uip_arp_arpin+0x13c>
    359c:	40 de       	rcall	.-896    	; 0x321e <uip_arp_update.constprop.0>
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    359e:	df 91       	pop	r29
    35a0:	cf 91       	pop	r28
    }
    break;
  }

  return;
}
    35a2:	08 95       	ret

000035a4 <uip_arp_out>:
    35a4:	80 91 dd 07 	lds	r24, 0x07DD

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr)) {
    35a8:	90 91 de 07 	lds	r25, 0x07DE
    35ac:	20 91 24 03 	lds	r18, 0x0324
    35b0:	30 91 25 03 	lds	r19, 0x0325
    35b4:	82 17       	cp	r24, r18
    35b6:	93 07       	cpc	r25, r19
    35b8:	a9 f4       	brne	.+42     	; 0x35e4 <uip_arp_out+0x40>
    35ba:	40 91 df 07 	lds	r20, 0x07DF
    35be:	50 91 e0 07 	lds	r21, 0x07E0
    35c2:	20 91 26 03 	lds	r18, 0x0326
    35c6:	30 91 27 03 	lds	r19, 0x0327
    35ca:	42 17       	cp	r20, r18
    35cc:	53 07       	cpc	r21, r19
    35ce:	51 f4       	brne	.+20     	; 0x35e4 <uip_arp_out+0x40>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    35d0:	af eb       	ldi	r26, 0xBF	; 191
    35d2:	b7 e0       	ldi	r27, 0x07	; 7
    35d4:	e8 e2       	ldi	r30, 0x28	; 40
    35d6:	f3 e0       	ldi	r31, 0x03	; 3
    35d8:	86 e0       	ldi	r24, 0x06	; 6
    35da:	01 90       	ld	r0, Z+
    35dc:	0d 92       	st	X+, r0
    35de:	81 50       	subi	r24, 0x01	; 1
    35e0:	e1 f7       	brne	.-8      	; 0x35da <uip_arp_out+0x36>
    35e2:	d4 c0       	rjmp	.+424    	; 0x378c <uip_arp_out+0x1e8>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask)) {
    35e4:	20 91 bb 07 	lds	r18, 0x07BB
    35e8:	30 91 bc 07 	lds	r19, 0x07BC
    35ec:	28 27       	eor	r18, r24
    35ee:	39 27       	eor	r19, r25
    35f0:	80 91 b7 07 	lds	r24, 0x07B7
    35f4:	90 91 b8 07 	lds	r25, 0x07B8
    35f8:	28 23       	and	r18, r24
    35fa:	39 23       	and	r19, r25
    35fc:	21 15       	cp	r18, r1
    35fe:	31 05       	cpc	r19, r1
    3600:	91 f4       	brne	.+36     	; 0x3626 <uip_arp_out+0x82>
    3602:	80 91 bd 07 	lds	r24, 0x07BD
    3606:	90 91 be 07 	lds	r25, 0x07BE
    360a:	20 91 df 07 	lds	r18, 0x07DF
    360e:	30 91 e0 07 	lds	r19, 0x07E0
    3612:	82 27       	eor	r24, r18
    3614:	93 27       	eor	r25, r19
    3616:	20 91 b9 07 	lds	r18, 0x07B9
    361a:	30 91 ba 07 	lds	r19, 0x07BA
    361e:	82 23       	and	r24, r18
    3620:	93 23       	and	r25, r19
    3622:	00 97       	sbiw	r24, 0x00	; 0
    3624:	49 f0       	breq	.+18     	; 0x3638 <uip_arp_out+0x94>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(&ipaddr, &uip_draddr);
    3626:	80 91 b3 07 	lds	r24, 0x07B3
    362a:	90 91 b4 07 	lds	r25, 0x07B4
    362e:	a0 91 b5 07 	lds	r26, 0x07B5
    3632:	b0 91 b6 07 	lds	r27, 0x07B6
    3636:	08 c0       	rjmp	.+16     	; 0x3648 <uip_arp_out+0xa4>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    3638:	80 91 dd 07 	lds	r24, 0x07DD
    363c:	90 91 de 07 	lds	r25, 0x07DE
    3640:	a0 91 df 07 	lds	r26, 0x07DF
    3644:	b0 91 e0 07 	lds	r27, 0x07E0
    3648:	80 93 ee 03 	sts	0x03EE, r24
    364c:	90 93 ef 03 	sts	0x03EF, r25
    3650:	a0 93 f0 03 	sts	0x03F0, r26
    3654:	b0 93 f1 03 	sts	0x03F1, r27
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3658:	10 92 92 03 	sts	0x0392, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    365c:	20 91 ee 03 	lds	r18, 0x03EE
    3660:	30 91 ef 03 	lds	r19, 0x03EF
    3664:	40 91 f0 03 	lds	r20, 0x03F0
    3668:	50 91 f1 03 	lds	r21, 0x03F1
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    366c:	a0 e0       	ldi	r26, 0x00	; 0
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
  struct arp_entry *tabptr = NULL;
    366e:	e0 e0       	ldi	r30, 0x00	; 0
    3670:	f0 e0       	ldi	r31, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    3672:	6b e0       	ldi	r22, 0x0B	; 11
    3674:	70 e0       	ldi	r23, 0x00	; 0
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3676:	16 c0       	rjmp	.+44     	; 0x36a4 <uip_arp_out+0x100>
      tabptr = &arp_table[i];
    3678:	8a 2f       	mov	r24, r26
    367a:	90 e0       	ldi	r25, 0x00	; 0
    367c:	86 9f       	mul	r24, r22
    367e:	f0 01       	movw	r30, r0
    3680:	87 9f       	mul	r24, r23
    3682:	f0 0d       	add	r31, r0
    3684:	96 9f       	mul	r25, r22
    3686:	f0 0d       	add	r31, r0
    3688:	11 24       	eor	r1, r1
    368a:	ed 56       	subi	r30, 0x6D	; 109
    368c:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    368e:	80 81       	ld	r24, Z
    3690:	91 81       	ldd	r25, Z+1	; 0x01
    3692:	28 17       	cp	r18, r24
    3694:	39 07       	cpc	r19, r25
    3696:	29 f4       	brne	.+10     	; 0x36a2 <uip_arp_out+0xfe>
    3698:	82 81       	ldd	r24, Z+2	; 0x02
    369a:	93 81       	ldd	r25, Z+3	; 0x03
    369c:	48 17       	cp	r20, r24
    369e:	59 07       	cpc	r21, r25
    36a0:	19 f0       	breq	.+6      	; 0x36a8 <uip_arp_out+0x104>
    36a2:	af 5f       	subi	r26, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    36a4:	a8 30       	cpi	r26, 0x08	; 8
    36a6:	40 f3       	brcs	.-48     	; 0x3678 <uip_arp_out+0xd4>
    36a8:	a0 93 92 03 	sts	0x0392, r26
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    36ac:	a8 30       	cpi	r26, 0x08	; 8
    36ae:	09 f0       	breq	.+2      	; 0x36b2 <uip_arp_out+0x10e>
    36b0:	65 c0       	rjmp	.+202    	; 0x377c <uip_arp_out+0x1d8>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    36b2:	8f eb       	ldi	r24, 0xBF	; 191
    36b4:	97 e0       	ldi	r25, 0x07	; 7
    36b6:	6f ef       	ldi	r22, 0xFF	; 255
    36b8:	70 e0       	ldi	r23, 0x00	; 0
    36ba:	46 e0       	ldi	r20, 0x06	; 6
    36bc:	50 e0       	ldi	r21, 0x00	; 0
    36be:	0e 94 82 3c 	call	0x7904	; 0x7904 <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    36c2:	af ed       	ldi	r26, 0xDF	; 223
    36c4:	b7 e0       	ldi	r27, 0x07	; 7
    36c6:	86 e0       	ldi	r24, 0x06	; 6
    36c8:	fd 01       	movw	r30, r26
    36ca:	11 92       	st	Z+, r1
    36cc:	8a 95       	dec	r24
    36ce:	e9 f7       	brne	.-6      	; 0x36ca <uip_arp_out+0x126>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    36d0:	5a 97       	sbiw	r26, 0x1a	; 26
    36d2:	e0 e8       	ldi	r30, 0x80	; 128
    36d4:	f3 e0       	ldi	r31, 0x03	; 3
    36d6:	86 e0       	ldi	r24, 0x06	; 6
    36d8:	01 90       	ld	r0, Z+
    36da:	0d 92       	st	X+, r0
    36dc:	81 50       	subi	r24, 0x01	; 1
    36de:	e1 f7       	brne	.-8      	; 0x36d8 <uip_arp_out+0x134>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    36e0:	a5 ed       	ldi	r26, 0xD5	; 213
    36e2:	b7 e0       	ldi	r27, 0x07	; 7
    36e4:	e0 e8       	ldi	r30, 0x80	; 128
    36e6:	f3 e0       	ldi	r31, 0x03	; 3
    36e8:	86 e0       	ldi	r24, 0x06	; 6
    36ea:	01 90       	ld	r0, Z+
    36ec:	0d 92       	st	X+, r0
    36ee:	81 50       	subi	r24, 0x01	; 1
    36f0:	e1 f7       	brne	.-8      	; 0x36ea <uip_arp_out+0x146>

      uip_ipaddr_copy(&BUF->dipaddr, &ipaddr);
    36f2:	80 91 ee 03 	lds	r24, 0x03EE
    36f6:	90 91 ef 03 	lds	r25, 0x03EF
    36fa:	a0 91 f0 03 	lds	r26, 0x03F0
    36fe:	b0 91 f1 03 	lds	r27, 0x03F1
    3702:	80 93 e5 07 	sts	0x07E5, r24
    3706:	90 93 e6 07 	sts	0x07E6, r25
    370a:	a0 93 e7 07 	sts	0x07E7, r26
    370e:	b0 93 e8 07 	sts	0x07E8, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    3712:	80 91 bb 07 	lds	r24, 0x07BB
    3716:	90 91 bc 07 	lds	r25, 0x07BC
    371a:	a0 91 bd 07 	lds	r26, 0x07BD
    371e:	b0 91 be 07 	lds	r27, 0x07BE
    3722:	80 93 db 07 	sts	0x07DB, r24
    3726:	90 93 dc 07 	sts	0x07DC, r25
    372a:	a0 93 dd 07 	sts	0x07DD, r26
    372e:	b0 93 de 07 	sts	0x07DE, r27
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    3732:	80 e0       	ldi	r24, 0x00	; 0
    3734:	91 e0       	ldi	r25, 0x01	; 1
    3736:	90 93 d4 07 	sts	0x07D4, r25
    373a:	80 93 d3 07 	sts	0x07D3, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    373e:	90 93 ce 07 	sts	0x07CE, r25
    3742:	80 93 cd 07 	sts	0x07CD, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    3746:	88 e0       	ldi	r24, 0x08	; 8
    3748:	90 e0       	ldi	r25, 0x00	; 0
    374a:	90 93 d0 07 	sts	0x07D0, r25
    374e:	80 93 cf 07 	sts	0x07CF, r24
      BUF->hwlen = 6;
    3752:	86 e0       	ldi	r24, 0x06	; 6
    3754:	80 93 d1 07 	sts	0x07D1, r24
      BUF->protolen = 4;
    3758:	84 e0       	ldi	r24, 0x04	; 4
    375a:	80 93 d2 07 	sts	0x07D2, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    375e:	88 e0       	ldi	r24, 0x08	; 8
    3760:	96 e0       	ldi	r25, 0x06	; 6
    3762:	90 93 cc 07 	sts	0x07CC, r25
    3766:	80 93 cb 07 	sts	0x07CB, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    376a:	85 ef       	ldi	r24, 0xF5	; 245
    376c:	97 e0       	ldi	r25, 0x07	; 7
    376e:	90 93 53 06 	sts	0x0653, r25
    3772:	80 93 52 06 	sts	0x0652, r24

      uip_len = sizeof(struct arp_hdr);
    3776:	8a e2       	ldi	r24, 0x2A	; 42
    3778:	90 e0       	ldi	r25, 0x00	; 0
    377a:	1c c0       	rjmp	.+56     	; 0x37b4 <uip_arp_out+0x210>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    377c:	af eb       	ldi	r26, 0xBF	; 191
    377e:	b7 e0       	ldi	r27, 0x07	; 7
    3780:	34 96       	adiw	r30, 0x04	; 4
    3782:	86 e0       	ldi	r24, 0x06	; 6
    3784:	01 90       	ld	r0, Z+
    3786:	0d 92       	st	X+, r0
    3788:	81 50       	subi	r24, 0x01	; 1
    378a:	e1 f7       	brne	.-8      	; 0x3784 <uip_arp_out+0x1e0>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    378c:	a5 ec       	ldi	r26, 0xC5	; 197
    378e:	b7 e0       	ldi	r27, 0x07	; 7
    3790:	e0 e8       	ldi	r30, 0x80	; 128
    3792:	f3 e0       	ldi	r31, 0x03	; 3
    3794:	86 e0       	ldi	r24, 0x06	; 6
    3796:	01 90       	ld	r0, Z+
    3798:	0d 92       	st	X+, r0
    379a:	81 50       	subi	r24, 0x01	; 1
    379c:	e1 f7       	brne	.-8      	; 0x3796 <uip_arp_out+0x1f2>

  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    379e:	88 e0       	ldi	r24, 0x08	; 8
    37a0:	90 e0       	ldi	r25, 0x00	; 0
    37a2:	90 93 cc 07 	sts	0x07CC, r25
    37a6:	80 93 cb 07 	sts	0x07CB, r24

  uip_len += sizeof(struct uip_eth_hdr);
    37aa:	80 91 47 06 	lds	r24, 0x0647
    37ae:	90 91 48 06 	lds	r25, 0x0648
    37b2:	0e 96       	adiw	r24, 0x0e	; 14
    37b4:	90 93 48 06 	sts	0x0648, r25
    37b8:	80 93 47 06 	sts	0x0647, r24
    37bc:	08 95       	ret

000037be <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    37be:	cf 93       	push	r28
    37c0:	df 93       	push	r29
    37c2:	ec 01       	movw	r28, r24
  t->interval = interval;
    37c4:	7b 83       	std	Y+3, r23	; 0x03
    37c6:	6a 83       	std	Y+2, r22	; 0x02
  t->start = clock_time();
    37c8:	49 d0       	rcall	.+146    	; 0x385c <clock_time>
    37ca:	99 83       	std	Y+1, r25	; 0x01
    37cc:	88 83       	st	Y, r24
    37ce:	df 91       	pop	r29
}
    37d0:	cf 91       	pop	r28
    37d2:	08 95       	ret

000037d4 <timer_reset>:
    37d4:	fc 01       	movw	r30, r24
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
  t->start += t->interval;
    37d6:	80 81       	ld	r24, Z
    37d8:	91 81       	ldd	r25, Z+1	; 0x01
    37da:	22 81       	ldd	r18, Z+2	; 0x02
    37dc:	33 81       	ldd	r19, Z+3	; 0x03
    37de:	82 0f       	add	r24, r18
    37e0:	93 1f       	adc	r25, r19
    37e2:	91 83       	std	Z+1, r25	; 0x01
    37e4:	80 83       	st	Z, r24
}
    37e6:	08 95       	ret

000037e8 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    37e8:	cf 93       	push	r28
    37ea:	df 93       	push	r29
    37ec:	ec 01       	movw	r28, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    37ee:	36 d0       	rcall	.+108    	; 0x385c <clock_time>
    37f0:	28 81       	ld	r18, Y
    37f2:	39 81       	ldd	r19, Y+1	; 0x01
    37f4:	ac 01       	movw	r20, r24
    37f6:	42 1b       	sub	r20, r18
    37f8:	53 0b       	sbc	r21, r19
    37fa:	9a 01       	movw	r18, r20
    37fc:	81 e0       	ldi	r24, 0x01	; 1
    37fe:	90 e0       	ldi	r25, 0x00	; 0
    3800:	4a 81       	ldd	r20, Y+2	; 0x02
    3802:	5b 81       	ldd	r21, Y+3	; 0x03
    3804:	24 17       	cp	r18, r20
    3806:	35 07       	cpc	r19, r21
    3808:	10 f4       	brcc	.+4      	; 0x380e <timer_expired+0x26>
    380a:	80 e0       	ldi	r24, 0x00	; 0
    380c:	90 e0       	ldi	r25, 0x00	; 0
    380e:	df 91       	pop	r29
}
    3810:	cf 91       	pop	r28
    3812:	08 95       	ret

00003814 <__vector_17>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    3814:	1f 92       	push	r1
    3816:	0f 92       	push	r0
    3818:	0f b6       	in	r0, 0x3f	; 63
    381a:	0f 92       	push	r0
    381c:	11 24       	eor	r1, r1
    381e:	8f 93       	push	r24
    3820:	9f 93       	push	r25
	clock_datetime += 1;
    3822:	80 91 f2 03 	lds	r24, 0x03F2
    3826:	90 91 f3 03 	lds	r25, 0x03F3
    382a:	01 96       	adiw	r24, 0x01	; 1
    382c:	90 93 f3 03 	sts	0x03F3, r25
    3830:	80 93 f2 03 	sts	0x03F2, r24
}
    3834:	9f 91       	pop	r25
    3836:	8f 91       	pop	r24
    3838:	0f 90       	pop	r0
    383a:	0f be       	out	0x3f, r0	; 63
    383c:	0f 90       	pop	r0
    383e:	1f 90       	pop	r1
    3840:	18 95       	reti

00003842 <clock_init>:

//Initialise the clock
void clock_init()
{
	OCR1A  = (((F_CPU / 1024) / 100) - 1);
    3842:	8d e4       	ldi	r24, 0x4D	; 77
    3844:	90 e0       	ldi	r25, 0x00	; 0
    3846:	90 93 89 00 	sts	0x0089, r25
    384a:	80 93 88 00 	sts	0x0088, r24
	TCCR1B = ((1 << WGM12) | (1 << CS12) | (1 << CS10));
    384e:	8d e0       	ldi	r24, 0x0D	; 13
    3850:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1 << OCIE1A);
    3854:	82 e0       	ldi	r24, 0x02	; 2
    3856:	80 93 6f 00 	sts	0x006F, r24
}
    385a:	08 95       	ret

0000385c <clock_time>:
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    385c:	f8 94       	cli
clock_time_t clock_time()
{
	clock_time_t time;

	GlobalInterruptDisable();
	time = clock_datetime;
    385e:	80 91 f2 03 	lds	r24, 0x03F2
    3862:	90 91 f3 03 	lds	r25, 0x03F3
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    3866:	78 94       	sei
	GlobalInterruptEnable();

	return time;
}
    3868:	08 95       	ret

0000386a <uip_split_output>:
{
#if UIP_TCP
  u16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP  && uip_len == UIP_BUFSIZE) {
    386a:	80 91 d6 07 	lds	r24, 0x07D6
    386e:	40 91 47 06 	lds	r20, 0x0647
    3872:	50 91 48 06 	lds	r21, 0x0648
    3876:	86 30       	cpi	r24, 0x06	; 6
    3878:	09 f0       	breq	.+2      	; 0x387c <uip_split_output+0x12>
    387a:	8e c0       	rjmp	.+284    	; 0x3998 <uip_split_output+0x12e>
    387c:	85 e0       	ldi	r24, 0x05	; 5
    387e:	4a 3e       	cpi	r20, 0xEA	; 234
    3880:	58 07       	cpc	r21, r24
    3882:	09 f0       	breq	.+2      	; 0x3886 <uip_split_output+0x1c>
    3884:	89 c0       	rjmp	.+274    	; 0x3998 <uip_split_output+0x12e>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    3886:	80 e1       	ldi	r24, 0x10	; 16
    3888:	93 e0       	ldi	r25, 0x03	; 3
    388a:	90 93 48 06 	sts	0x0648, r25
    388e:	80 93 47 06 	sts	0x0647, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len - UIP_LLH_LEN) >> 8;
    3892:	83 e0       	ldi	r24, 0x03	; 3
    3894:	80 93 cf 07 	sts	0x07CF, r24
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    3898:	82 e0       	ldi	r24, 0x02	; 2
    389a:	80 93 d0 07 	sts	0x07D0, r24
#endif /* UIP_CONF_IPV6 */

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    389e:	10 92 f2 07 	sts	0x07F2, r1
    38a2:	10 92 f1 07 	sts	0x07F1, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    38a6:	0e 94 22 11 	call	0x2244	; 0x2244 <uip_tcpchksum>
    38aa:	80 95       	com	r24
    38ac:	90 95       	com	r25
    38ae:	90 93 f2 07 	sts	0x07F2, r25
    38b2:	80 93 f1 07 	sts	0x07F1, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    38b6:	10 92 d8 07 	sts	0x07D8, r1
    38ba:	10 92 d7 07 	sts	0x07D7, r1
    BUF->ipchksum = ~(uip_ipchksum());
    38be:	0e 94 0e 11 	call	0x221c	; 0x221c <uip_ipchksum>
    38c2:	80 95       	com	r24
    38c4:	90 95       	com	r25
    38c6:	90 93 d8 07 	sts	0x07D8, r25
    38ca:	80 93 d7 07 	sts	0x07D7, r24

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    38ce:	80 91 fb 03 	lds	r24, 0x03FB
    38d2:	40 91 47 06 	lds	r20, 0x0647
    38d6:	50 91 48 06 	lds	r21, 0x0648
    38da:	81 30       	cpi	r24, 0x01	; 1
    38dc:	39 f4       	brne	.+14     	; 0x38ec <uip_split_output+0x82>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    38de:	8c e4       	ldi	r24, 0x4C	; 76
    38e0:	91 e0       	ldi	r25, 0x01	; 1
    38e2:	6f eb       	ldi	r22, 0xBF	; 191
    38e4:	77 e0       	ldi	r23, 0x07	; 7
    38e6:	0e 94 91 37 	call	0x6f22	; 0x6f22 <RNDIS_Device_SendPacket>
    38ea:	06 c0       	rjmp	.+12     	; 0x38f8 <uip_split_output+0x8e>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    38ec:	8a ee       	ldi	r24, 0xEA	; 234
    38ee:	91 e0       	ldi	r25, 0x01	; 1
    38f0:	6f eb       	ldi	r22, 0xBF	; 191
    38f2:	77 e0       	ldi	r23, 0x07	; 7
    38f4:	0e 94 84 3b 	call	0x7708	; 0x7708 <RNDIS_Host_SendPacket>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is determined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    38f8:	80 e1       	ldi	r24, 0x10	; 16
    38fa:	93 e0       	ldi	r25, 0x03	; 3
    38fc:	90 93 48 06 	sts	0x0648, r25
    3900:	80 93 47 06 	sts	0x0647, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len  - UIP_LLH_LEN) >> 8;
    3904:	83 e0       	ldi	r24, 0x03	; 3
    3906:	80 93 cf 07 	sts	0x07CF, r24
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    390a:	82 e0       	ldi	r24, 0x02	; 2
    390c:	80 93 d0 07 	sts	0x07D0, r24
#endif /* UIP_CONF_IPV6 */

    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
    3910:	90 91 52 06 	lds	r25, 0x0652
    3914:	80 91 53 06 	lds	r24, 0x0653
    3918:	e9 2f       	mov	r30, r25
    391a:	f8 2f       	mov	r31, r24
    391c:	df 01       	movw	r26, r30
    391e:	a6 52       	subi	r26, 0x26	; 38
    3920:	bd 4f       	sbci	r27, 0xFD	; 253
    3922:	8a ed       	ldi	r24, 0xDA	; 218
    3924:	92 e0       	ldi	r25, 0x02	; 2
    3926:	0d 90       	ld	r0, X+
    3928:	01 92       	st	Z+, r0
    392a:	01 97       	sbiw	r24, 0x01	; 1
    392c:	e1 f7       	brne	.-8      	; 0x3926 <uip_split_output+0xbc>

    uip_add32(BUF->seqno, len1);
    392e:	85 ee       	ldi	r24, 0xE5	; 229
    3930:	97 e0       	ldi	r25, 0x07	; 7
    3932:	6a ed       	ldi	r22, 0xDA	; 218
    3934:	72 e0       	ldi	r23, 0x02	; 2
    3936:	0e 94 11 10 	call	0x2022	; 0x2022 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    393a:	80 91 4b 06 	lds	r24, 0x064B
    393e:	80 93 e5 07 	sts	0x07E5, r24
    BUF->seqno[1] = uip_acc32[1];
    3942:	80 91 4c 06 	lds	r24, 0x064C
    3946:	80 93 e6 07 	sts	0x07E6, r24
    BUF->seqno[2] = uip_acc32[2];
    394a:	80 91 4d 06 	lds	r24, 0x064D
    394e:	80 93 e7 07 	sts	0x07E7, r24
    BUF->seqno[3] = uip_acc32[3];
    3952:	80 91 4e 06 	lds	r24, 0x064E
    3956:	80 93 e8 07 	sts	0x07E8, r24

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    395a:	10 92 f2 07 	sts	0x07F2, r1
    395e:	10 92 f1 07 	sts	0x07F1, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    3962:	0e 94 22 11 	call	0x2244	; 0x2244 <uip_tcpchksum>
    3966:	80 95       	com	r24
    3968:	90 95       	com	r25
    396a:	90 93 f2 07 	sts	0x07F2, r25
    396e:	80 93 f1 07 	sts	0x07F1, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    3972:	10 92 d8 07 	sts	0x07D8, r1
    3976:	10 92 d7 07 	sts	0x07D7, r1
    BUF->ipchksum = ~(uip_ipchksum());
    397a:	0e 94 0e 11 	call	0x221c	; 0x221c <uip_ipchksum>
    397e:	80 95       	com	r24
    3980:	90 95       	com	r25
    3982:	90 93 d8 07 	sts	0x07D8, r25
    3986:	80 93 d7 07 	sts	0x07D7, r24

    /* Transmit the second packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    398a:	80 91 fb 03 	lds	r24, 0x03FB
    398e:	40 91 47 06 	lds	r20, 0x0647
    3992:	50 91 48 06 	lds	r21, 0x0648
    3996:	02 c0       	rjmp	.+4      	; 0x399c <uip_split_output+0x132>

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3998:	80 91 fb 03 	lds	r24, 0x03FB
    399c:	81 30       	cpi	r24, 0x01	; 1
    399e:	31 f4       	brne	.+12     	; 0x39ac <uip_split_output+0x142>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    39a0:	8c e4       	ldi	r24, 0x4C	; 76
    39a2:	91 e0       	ldi	r25, 0x01	; 1
    39a4:	6f eb       	ldi	r22, 0xBF	; 191
    39a6:	77 e0       	ldi	r23, 0x07	; 7
    39a8:	0c 94 91 37 	jmp	0x6f22	; 0x6f22 <RNDIS_Device_SendPacket>
    39ac:	8a ee       	ldi	r24, 0xEA	; 234
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    39ae:	91 e0       	ldi	r25, 0x01	; 1
    39b0:	6f eb       	ldi	r22, 0xBF	; 191
    39b2:	77 e0       	ldi	r23, 0x07	; 7
    39b4:	0c 94 84 3b 	jmp	0x7708	; 0x7708 <RNDIS_Host_SendPacket>

000039b8 <disk_initialize>:
DSTATUS disk_initialize (
	BYTE drv				/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    39b8:	80 e0       	ldi	r24, 0x00	; 0
    39ba:	08 95       	ret

000039bc <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    39bc:	80 e0       	ldi	r24, 0x00	; 0
    39be:	08 95       	ret

000039c0 <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..128) */
)
{
    39c0:	0f 93       	push	r16
    39c2:	fb 01       	movw	r30, r22
    39c4:	ca 01       	movw	r24, r20
    39c6:	b9 01       	movw	r22, r18
    39c8:	40 2f       	mov	r20, r16
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
    39ca:	50 e0       	ldi	r21, 0x00	; 0
    39cc:	9f 01       	movw	r18, r30
    39ce:	0e 94 6c 07 	call	0xed8	; 0xed8 <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
    39d2:	80 e0       	ldi	r24, 0x00	; 0
    39d4:	0f 91       	pop	r16
    39d6:	08 95       	ret

000039d8 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    39d8:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    39da:	ed 91       	ld	r30, X+
    39dc:	fc 91       	ld	r31, X
    39de:	11 97       	sbiw	r26, 0x01	; 1
    39e0:	30 97       	sbiw	r30, 0x00	; 0
    39e2:	91 f0       	breq	.+36     	; 0x3a08 <validate+0x30>
    39e4:	80 81       	ld	r24, Z
    39e6:	88 23       	and	r24, r24
    39e8:	79 f0       	breq	.+30     	; 0x3a08 <validate+0x30>
    39ea:	26 81       	ldd	r18, Z+6	; 0x06
    39ec:	37 81       	ldd	r19, Z+7	; 0x07
    39ee:	12 96       	adiw	r26, 0x02	; 2
    39f0:	8d 91       	ld	r24, X+
    39f2:	9c 91       	ld	r25, X
    39f4:	13 97       	sbiw	r26, 0x03	; 3
    39f6:	28 17       	cp	r18, r24
    39f8:	39 07       	cpc	r19, r25
    39fa:	31 f4       	brne	.+12     	; 0x3a08 <validate+0x30>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    39fc:	81 81       	ldd	r24, Z+1	; 0x01
    39fe:	de df       	rcall	.-68     	; 0x39bc <disk_status>
    3a00:	80 ff       	sbrs	r24, 0
    3a02:	04 c0       	rjmp	.+8      	; 0x3a0c <validate+0x34>
    3a04:	83 e0       	ldi	r24, 0x03	; 3
		return FR_NOT_READY;
    3a06:	08 95       	ret
    3a08:	89 e0       	ldi	r24, 0x09	; 9
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    3a0a:	08 95       	ret
    3a0c:	80 e0       	ldi	r24, 0x00	; 0
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    3a0e:	08 95       	ret

00003a10 <move_window>:
}
    3a10:	cf 92       	push	r12
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    3a12:	df 92       	push	r13
    3a14:	ef 92       	push	r14
    3a16:	ff 92       	push	r15
    3a18:	0f 93       	push	r16
    3a1a:	cf 93       	push	r28
    3a1c:	df 93       	push	r29
    3a1e:	ec 01       	movw	r28, r24
    3a20:	6a 01       	movw	r12, r20
    3a22:	7b 01       	movw	r14, r22
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
    3a24:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3a26:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3a28:	a8 a1       	lds	r26, 0x48
    3a2a:	b9 a1       	lds	r27, 0x49
    3a2c:	84 17       	cp	r24, r20
    3a2e:	95 07       	cpc	r25, r21
    3a30:	a6 07       	cpc	r26, r22
    3a32:	b7 07       	cpc	r27, r23
    3a34:	a1 f0       	breq	.+40     	; 0x3a5e <move_window+0x4e>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    3a36:	41 15       	cp	r20, r1
    3a38:	51 05       	cpc	r21, r1
    3a3a:	61 05       	cpc	r22, r1
    3a3c:	71 05       	cpc	r23, r1
    3a3e:	79 f0       	breq	.+30     	; 0x3a5e <move_window+0x4e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    3a40:	be 01       	movw	r22, r28
    3a42:	6e 5d       	subi	r22, 0xDE	; 222
    3a44:	7f 4f       	sbci	r23, 0xFF	; 255
    3a46:	89 81       	ldd	r24, Y+1	; 0x01
    3a48:	a7 01       	movw	r20, r14
    3a4a:	96 01       	movw	r18, r12
    3a4c:	01 e0       	ldi	r16, 0x01	; 1
    3a4e:	b8 df       	rcall	.-144    	; 0x39c0 <disk_read>
    3a50:	88 23       	and	r24, r24
    3a52:	39 f4       	brne	.+14     	; 0x3a62 <move_window+0x52>
    3a54:	ce 8e       	std	Y+30, r12	; 0x1e
				return FR_DISK_ERR;
			fs->winsect = sector;
    3a56:	df 8e       	std	Y+31, r13	; 0x1f
    3a58:	e8 a2       	lds	r30, 0x98
    3a5a:	f9 a2       	lds	r31, 0x99
    3a5c:	03 c0       	rjmp	.+6      	; 0x3a64 <move_window+0x54>
    3a5e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return FR_OK;
    3a60:	01 c0       	rjmp	.+2      	; 0x3a64 <move_window+0x54>
    3a62:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    3a64:	df 91       	pop	r29
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    3a66:	cf 91       	pop	r28
    3a68:	0f 91       	pop	r16
    3a6a:	ff 90       	pop	r15
    3a6c:	ef 90       	pop	r14
    3a6e:	df 90       	pop	r13
    3a70:	cf 90       	pop	r12
    3a72:	08 95       	ret

00003a74 <check_fs>:
    3a74:	0f 93       	push	r16
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    3a76:	cf 93       	push	r28
    3a78:	df 93       	push	r29
    3a7a:	ec 01       	movw	r28, r24
    3a7c:	9a 01       	movw	r18, r20
    3a7e:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    3a80:	bc 01       	movw	r22, r24
    3a82:	6e 5d       	subi	r22, 0xDE	; 222
    3a84:	7f 4f       	sbci	r23, 0xFF	; 255
    3a86:	89 81       	ldd	r24, Y+1	; 0x01
    3a88:	01 e0       	ldi	r16, 0x01	; 1
    3a8a:	9a df       	rcall	.-204    	; 0x39c0 <disk_read>
    3a8c:	88 23       	and	r24, r24
    3a8e:	51 f5       	brne	.+84     	; 0x3ae4 <check_fs+0x70>
    3a90:	fe 01       	movw	r30, r28
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    3a92:	e0 5e       	subi	r30, 0xE0	; 224
    3a94:	fd 4f       	sbci	r31, 0xFD	; 253
    3a96:	80 81       	ld	r24, Z
    3a98:	91 81       	ldd	r25, Z+1	; 0x01
    3a9a:	2a ea       	ldi	r18, 0xAA	; 170
    3a9c:	85 35       	cpi	r24, 0x55	; 85
    3a9e:	92 07       	cpc	r25, r18
    3aa0:	19 f5       	brne	.+70     	; 0x3ae8 <check_fs+0x74>
    3aa2:	fe 01       	movw	r30, r28
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    3aa4:	e8 5a       	subi	r30, 0xA8	; 168
    3aa6:	ff 4f       	sbci	r31, 0xFF	; 255
    3aa8:	80 81       	ld	r24, Z
    3aaa:	91 81       	ldd	r25, Z+1	; 0x01
    3aac:	a2 81       	ldd	r26, Z+2	; 0x02
    3aae:	b3 81       	ldd	r27, Z+3	; 0x03
    3ab0:	b0 70       	andi	r27, 0x00	; 0
    3ab2:	86 34       	cpi	r24, 0x46	; 70
    3ab4:	21 e4       	ldi	r18, 0x41	; 65
    3ab6:	92 07       	cpc	r25, r18
    3ab8:	24 e5       	ldi	r18, 0x54	; 84
    3aba:	a2 07       	cpc	r26, r18
    3abc:	20 e0       	ldi	r18, 0x00	; 0
    3abe:	b2 07       	cpc	r27, r18
    3ac0:	a9 f0       	breq	.+42     	; 0x3aec <check_fs+0x78>
    3ac2:	cc 58       	subi	r28, 0x8C	; 140
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    3ac4:	df 4f       	sbci	r29, 0xFF	; 255
    3ac6:	48 81       	ld	r20, Y
    3ac8:	59 81       	ldd	r21, Y+1	; 0x01
    3aca:	6a 81       	ldd	r22, Y+2	; 0x02
    3acc:	7b 81       	ldd	r23, Y+3	; 0x03
    3ace:	70 70       	andi	r23, 0x00	; 0
    3ad0:	81 e0       	ldi	r24, 0x01	; 1
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    3ad2:	46 34       	cpi	r20, 0x46	; 70
    3ad4:	91 e4       	ldi	r25, 0x41	; 65
    3ad6:	59 07       	cpc	r21, r25
    3ad8:	94 e5       	ldi	r25, 0x54	; 84
    3ada:	69 07       	cpc	r22, r25
    3adc:	90 e0       	ldi	r25, 0x00	; 0
    3ade:	79 07       	cpc	r23, r25
    3ae0:	31 f4       	brne	.+12     	; 0x3aee <check_fs+0x7a>
    3ae2:	04 c0       	rjmp	.+8      	; 0x3aec <check_fs+0x78>
    3ae4:	83 e0       	ldi	r24, 0x03	; 3
    3ae6:	03 c0       	rjmp	.+6      	; 0x3aee <check_fs+0x7a>
    3ae8:	82 e0       	ldi	r24, 0x02	; 2
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    3aea:	01 c0       	rjmp	.+2      	; 0x3aee <check_fs+0x7a>
    3aec:	80 e0       	ldi	r24, 0x00	; 0

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    3aee:	df 91       	pop	r29
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    3af0:	cf 91       	pop	r28
    3af2:	0f 91       	pop	r16
    3af4:	08 95       	ret

00003af6 <ld_clust.isra.0>:
    3af6:	0f 93       	push	r16
/*-----------------------------------------------------------------------*/
/* Directory handling - Load/Store start cluster number                  */
/*-----------------------------------------------------------------------*/

static
DWORD ld_clust (
    3af8:	1f 93       	push	r17
    3afa:	fb 01       	movw	r30, r22
	BYTE *dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    3afc:	02 8d       	ldd	r16, Z+26	; 0x1a
    3afe:	13 8d       	ldd	r17, Z+27	; 0x1b
    3b00:	20 e0       	ldi	r18, 0x00	; 0
    3b02:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    3b04:	83 30       	cpi	r24, 0x03	; 3
    3b06:	59 f4       	brne	.+22     	; 0x3b1e <ld_clust.isra.0+0x28>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    3b08:	84 89       	ldd	r24, Z+20	; 0x14
    3b0a:	95 89       	ldd	r25, Z+21	; 0x15
    3b0c:	a0 e0       	ldi	r26, 0x00	; 0
    3b0e:	b0 e0       	ldi	r27, 0x00	; 0
    3b10:	dc 01       	movw	r26, r24
    3b12:	99 27       	eor	r25, r25
    3b14:	88 27       	eor	r24, r24
    3b16:	08 2b       	or	r16, r24
    3b18:	19 2b       	or	r17, r25
    3b1a:	2a 2b       	or	r18, r26
    3b1c:	3b 2b       	or	r19, r27

	return cl;
}
    3b1e:	b8 01       	movw	r22, r16
    3b20:	c9 01       	movw	r24, r18
    3b22:	1f 91       	pop	r17
    3b24:	0f 91       	pop	r16
    3b26:	08 95       	ret

00003b28 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    3b28:	0f 93       	push	r16
    3b2a:	1f 93       	push	r17
    3b2c:	cf 93       	push	r28
    3b2e:	df 93       	push	r29
    3b30:	ec 01       	movw	r28, r24
    3b32:	db 01       	movw	r26, r22
    3b34:	ca 01       	movw	r24, r20
	clst -= 2;
    3b36:	02 97       	sbiw	r24, 0x02	; 2
    3b38:	a1 09       	sbc	r26, r1
    3b3a:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3b3c:	4a 85       	ldd	r20, Y+10	; 0x0a
    3b3e:	5b 85       	ldd	r21, Y+11	; 0x0b
    3b40:	6c 85       	ldd	r22, Y+12	; 0x0c
    3b42:	7d 85       	ldd	r23, Y+13	; 0x0d
    3b44:	42 50       	subi	r20, 0x02	; 2
    3b46:	50 40       	sbci	r21, 0x00	; 0
    3b48:	60 40       	sbci	r22, 0x00	; 0
    3b4a:	70 40       	sbci	r23, 0x00	; 0
    3b4c:	84 17       	cp	r24, r20
    3b4e:	95 07       	cpc	r25, r21
    3b50:	a6 07       	cpc	r26, r22
    3b52:	b7 07       	cpc	r27, r23
    3b54:	98 f4       	brcc	.+38     	; 0x3b7c <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    3b56:	2a 81       	ldd	r18, Y+2	; 0x02
    3b58:	30 e0       	ldi	r19, 0x00	; 0
    3b5a:	40 e0       	ldi	r20, 0x00	; 0
    3b5c:	50 e0       	ldi	r21, 0x00	; 0
    3b5e:	bc 01       	movw	r22, r24
    3b60:	cd 01       	movw	r24, r26
    3b62:	0e 94 fd 3b 	call	0x77fa	; 0x77fa <__mulsi3>
    3b66:	8b 01       	movw	r16, r22
    3b68:	9c 01       	movw	r18, r24
    3b6a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3b6c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b6e:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3b70:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3b72:	08 0f       	add	r16, r24
    3b74:	19 1f       	adc	r17, r25
    3b76:	2a 1f       	adc	r18, r26
    3b78:	3b 1f       	adc	r19, r27
    3b7a:	03 c0       	rjmp	.+6      	; 0x3b82 <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3b7c:	00 e0       	ldi	r16, 0x00	; 0
    3b7e:	10 e0       	ldi	r17, 0x00	; 0
    3b80:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    3b82:	b8 01       	movw	r22, r16
    3b84:	c9 01       	movw	r24, r18
    3b86:	df 91       	pop	r29
    3b88:	cf 91       	pop	r28
    3b8a:	1f 91       	pop	r17
    3b8c:	0f 91       	pop	r16
    3b8e:	08 95       	ret

00003b90 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    3b90:	bf 92       	push	r11
    3b92:	cf 92       	push	r12
    3b94:	df 92       	push	r13
    3b96:	ef 92       	push	r14
    3b98:	ff 92       	push	r15
    3b9a:	0f 93       	push	r16
    3b9c:	1f 93       	push	r17
    3b9e:	cf 93       	push	r28
    3ba0:	df 93       	push	r29
    3ba2:	ec 01       	movw	r28, r24
    3ba4:	6a 01       	movw	r12, r20
    3ba6:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    3ba8:	42 30       	cpi	r20, 0x02	; 2
    3baa:	51 05       	cpc	r21, r1
    3bac:	61 05       	cpc	r22, r1
    3bae:	71 05       	cpc	r23, r1
    3bb0:	08 f4       	brcc	.+2      	; 0x3bb4 <get_fat+0x24>
    3bb2:	a0 c0       	rjmp	.+320    	; 0x3cf4 <get_fat+0x164>
    3bb4:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bb6:	9b 85       	ldd	r25, Y+11	; 0x0b
    3bb8:	ac 85       	ldd	r26, Y+12	; 0x0c
    3bba:	bd 85       	ldd	r27, Y+13	; 0x0d
    3bbc:	48 17       	cp	r20, r24
    3bbe:	59 07       	cpc	r21, r25
    3bc0:	6a 07       	cpc	r22, r26
    3bc2:	7b 07       	cpc	r23, r27
    3bc4:	08 f0       	brcs	.+2      	; 0x3bc8 <get_fat+0x38>
    3bc6:	96 c0       	rjmp	.+300    	; 0x3cf4 <get_fat+0x164>
		return 1;

	switch (fs->fs_type) {
    3bc8:	88 81       	ld	r24, Y
    3bca:	82 30       	cpi	r24, 0x02	; 2
    3bcc:	09 f4       	brne	.+2      	; 0x3bd0 <get_fat+0x40>
    3bce:	56 c0       	rjmp	.+172    	; 0x3c7c <get_fat+0xec>
    3bd0:	83 30       	cpi	r24, 0x03	; 3
    3bd2:	09 f4       	brne	.+2      	; 0x3bd6 <get_fat+0x46>
    3bd4:	6e c0       	rjmp	.+220    	; 0x3cb2 <get_fat+0x122>
    3bd6:	81 30       	cpi	r24, 0x01	; 1
    3bd8:	09 f0       	breq	.+2      	; 0x3bdc <get_fat+0x4c>
    3bda:	91 c0       	rjmp	.+290    	; 0x3cfe <get_fat+0x16e>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    3bdc:	8a 01       	movw	r16, r20
    3bde:	16 95       	lsr	r17
    3be0:	07 95       	ror	r16
    3be2:	04 0f       	add	r16, r20
    3be4:	15 1f       	adc	r17, r21
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3be6:	a8 01       	movw	r20, r16
    3be8:	45 2f       	mov	r20, r21
    3bea:	55 27       	eor	r21, r21
    3bec:	46 95       	lsr	r20
    3bee:	60 e0       	ldi	r22, 0x00	; 0
    3bf0:	70 e0       	ldi	r23, 0x00	; 0
    3bf2:	8a 89       	ldd	r24, Y+18	; 0x12
    3bf4:	9b 89       	ldd	r25, Y+19	; 0x13
    3bf6:	ac 89       	ldd	r26, Y+20	; 0x14
    3bf8:	bd 89       	ldd	r27, Y+21	; 0x15
    3bfa:	48 0f       	add	r20, r24
    3bfc:	59 1f       	adc	r21, r25
    3bfe:	6a 1f       	adc	r22, r26
    3c00:	7b 1f       	adc	r23, r27
    3c02:	ce 01       	movw	r24, r28
    3c04:	05 df       	rcall	.-502    	; 0x3a10 <move_window>
    3c06:	88 23       	and	r24, r24
    3c08:	09 f0       	breq	.+2      	; 0x3c0c <get_fat+0x7c>
    3c0a:	79 c0       	rjmp	.+242    	; 0x3cfe <get_fat+0x16e>
    3c0c:	f8 01       	movw	r30, r16
		wc = fs->win[bc % SS(fs)]; bc++;
    3c0e:	f1 70       	andi	r31, 0x01	; 1
    3c10:	ec 0f       	add	r30, r28
    3c12:	fd 1f       	adc	r31, r29
    3c14:	b2 a0       	lds	r27, 0x82
    3c16:	0f 5f       	subi	r16, 0xFF	; 255
    3c18:	1f 4f       	sbci	r17, 0xFF	; 255
    3c1a:	a8 01       	movw	r20, r16
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3c1c:	45 2f       	mov	r20, r21
    3c1e:	55 27       	eor	r21, r21
    3c20:	46 95       	lsr	r20
    3c22:	60 e0       	ldi	r22, 0x00	; 0
    3c24:	70 e0       	ldi	r23, 0x00	; 0
    3c26:	8a 89       	ldd	r24, Y+18	; 0x12
    3c28:	9b 89       	ldd	r25, Y+19	; 0x13
    3c2a:	ac 89       	ldd	r26, Y+20	; 0x14
    3c2c:	bd 89       	ldd	r27, Y+21	; 0x15
    3c2e:	48 0f       	add	r20, r24
    3c30:	59 1f       	adc	r21, r25
    3c32:	6a 1f       	adc	r22, r26
    3c34:	7b 1f       	adc	r23, r27
    3c36:	ce 01       	movw	r24, r28
    3c38:	eb de       	rcall	.-554    	; 0x3a10 <move_window>
    3c3a:	88 23       	and	r24, r24
    3c3c:	09 f0       	breq	.+2      	; 0x3c40 <get_fat+0xb0>
    3c3e:	5f c0       	rjmp	.+190    	; 0x3cfe <get_fat+0x16e>
    3c40:	6b 2d       	mov	r22, r11
    3c42:	70 e0       	ldi	r23, 0x00	; 0

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    3c44:	f8 01       	movw	r30, r16
    3c46:	f1 70       	andi	r31, 0x01	; 1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    3c48:	ec 0f       	add	r30, r28
    3c4a:	fd 1f       	adc	r31, r29
    3c4c:	92 a1       	lds	r25, 0x42
    3c4e:	80 e0       	ldi	r24, 0x00	; 0
    3c50:	68 2b       	or	r22, r24
    3c52:	79 2b       	or	r23, r25
    3c54:	81 e0       	ldi	r24, 0x01	; 1
    3c56:	c8 22       	and	r12, r24
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    3c58:	dd 24       	eor	r13, r13
    3c5a:	c1 14       	cp	r12, r1
    3c5c:	d1 04       	cpc	r13, r1
    3c5e:	39 f0       	breq	.+14     	; 0x3c6e <get_fat+0xde>
    3c60:	c4 e0       	ldi	r28, 0x04	; 4
    3c62:	76 95       	lsr	r23
    3c64:	67 95       	ror	r22
    3c66:	ca 95       	dec	r28
    3c68:	e1 f7       	brne	.-8      	; 0x3c62 <get_fat+0xd2>
    3c6a:	8b 01       	movw	r16, r22
    3c6c:	1f c0       	rjmp	.+62     	; 0x3cac <get_fat+0x11c>
    3c6e:	8b 01       	movw	r16, r22
    3c70:	20 e0       	ldi	r18, 0x00	; 0
    3c72:	30 e0       	ldi	r19, 0x00	; 0
    3c74:	1f 70       	andi	r17, 0x0F	; 15
    3c76:	20 70       	andi	r18, 0x00	; 0
    3c78:	30 70       	andi	r19, 0x00	; 0
    3c7a:	44 c0       	rjmp	.+136    	; 0x3d04 <get_fat+0x174>
    3c7c:	45 2f       	mov	r20, r21
    3c7e:	56 2f       	mov	r21, r22

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    3c80:	67 2f       	mov	r22, r23
    3c82:	77 27       	eor	r23, r23
    3c84:	8a 89       	ldd	r24, Y+18	; 0x12
    3c86:	9b 89       	ldd	r25, Y+19	; 0x13
    3c88:	ac 89       	ldd	r26, Y+20	; 0x14
    3c8a:	bd 89       	ldd	r27, Y+21	; 0x15
    3c8c:	48 0f       	add	r20, r24
    3c8e:	59 1f       	adc	r21, r25
    3c90:	6a 1f       	adc	r22, r26
    3c92:	7b 1f       	adc	r23, r27
    3c94:	ce 01       	movw	r24, r28
    3c96:	bc de       	rcall	.-648    	; 0x3a10 <move_window>
    3c98:	88 23       	and	r24, r24
    3c9a:	89 f5       	brne	.+98     	; 0x3cfe <get_fat+0x16e>
    3c9c:	f6 01       	movw	r30, r12
    3c9e:	ee 0f       	add	r30, r30
    3ca0:	ff 1f       	adc	r31, r31
		p = &fs->win[clst * 2 % SS(fs)];
    3ca2:	f1 70       	andi	r31, 0x01	; 1
    3ca4:	ec 0f       	add	r30, r28
    3ca6:	fd 1f       	adc	r31, r29
    3ca8:	02 a1       	lds	r16, 0x42
		return LD_WORD(p);
    3caa:	13 a1       	lds	r17, 0x43
    3cac:	20 e0       	ldi	r18, 0x00	; 0
    3cae:	30 e0       	ldi	r19, 0x00	; 0
    3cb0:	29 c0       	rjmp	.+82     	; 0x3d04 <get_fat+0x174>
    3cb2:	e7 e0       	ldi	r30, 0x07	; 7
    3cb4:	76 95       	lsr	r23
    3cb6:	67 95       	ror	r22

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    3cb8:	57 95       	ror	r21
    3cba:	47 95       	ror	r20
    3cbc:	ea 95       	dec	r30
    3cbe:	d1 f7       	brne	.-12     	; 0x3cb4 <get_fat+0x124>
    3cc0:	8a 89       	ldd	r24, Y+18	; 0x12
    3cc2:	9b 89       	ldd	r25, Y+19	; 0x13
    3cc4:	ac 89       	ldd	r26, Y+20	; 0x14
    3cc6:	bd 89       	ldd	r27, Y+21	; 0x15
    3cc8:	48 0f       	add	r20, r24
    3cca:	59 1f       	adc	r21, r25
    3ccc:	6a 1f       	adc	r22, r26
    3cce:	7b 1f       	adc	r23, r27
    3cd0:	ce 01       	movw	r24, r28
    3cd2:	9e de       	rcall	.-708    	; 0x3a10 <move_window>
    3cd4:	88 23       	and	r24, r24
    3cd6:	99 f4       	brne	.+38     	; 0x3cfe <get_fat+0x16e>
    3cd8:	f6 01       	movw	r30, r12
    3cda:	ee 0f       	add	r30, r30
    3cdc:	ff 1f       	adc	r31, r31
    3cde:	ee 0f       	add	r30, r30
		p = &fs->win[clst * 4 % SS(fs)];
    3ce0:	ff 1f       	adc	r31, r31
    3ce2:	f1 70       	andi	r31, 0x01	; 1
    3ce4:	ec 0f       	add	r30, r28
    3ce6:	fd 1f       	adc	r31, r29
    3ce8:	02 a1       	lds	r16, 0x42
    3cea:	13 a1       	lds	r17, 0x43
		return LD_DWORD(p) & 0x0FFFFFFF;
    3cec:	24 a1       	lds	r18, 0x44
    3cee:	35 a1       	lds	r19, 0x45
    3cf0:	3f 70       	andi	r19, 0x0F	; 15
    3cf2:	08 c0       	rjmp	.+16     	; 0x3d04 <get_fat+0x174>
    3cf4:	01 e0       	ldi	r16, 0x01	; 1
    3cf6:	10 e0       	ldi	r17, 0x00	; 0
    3cf8:	20 e0       	ldi	r18, 0x00	; 0
    3cfa:	30 e0       	ldi	r19, 0x00	; 0
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    3cfc:	03 c0       	rjmp	.+6      	; 0x3d04 <get_fat+0x174>
    3cfe:	0f ef       	ldi	r16, 0xFF	; 255
    3d00:	1f ef       	ldi	r17, 0xFF	; 255
    3d02:	98 01       	movw	r18, r16
    3d04:	b8 01       	movw	r22, r16
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    3d06:	c9 01       	movw	r24, r18
    3d08:	df 91       	pop	r29
    3d0a:	cf 91       	pop	r28
}
    3d0c:	1f 91       	pop	r17
    3d0e:	0f 91       	pop	r16
    3d10:	ff 90       	pop	r15
    3d12:	ef 90       	pop	r14
    3d14:	df 90       	pop	r13
    3d16:	cf 90       	pop	r12
    3d18:	bf 90       	pop	r11
    3d1a:	08 95       	ret

00003d1c <dir_sdi.constprop.4>:
    3d1c:	0f 93       	push	r16
    3d1e:	1f 93       	push	r17
    3d20:	cf 93       	push	r28
    3d22:	df 93       	push	r29
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (
    3d24:	8c 01       	movw	r16, r24
{
	DWORD clst;
	WORD ic;


	dj->index = idx;
    3d26:	dc 01       	movw	r26, r24
    3d28:	15 96       	adiw	r26, 0x05	; 5
    3d2a:	1c 92       	st	X, r1
    3d2c:	1e 92       	st	-X, r1
    3d2e:	14 97       	sbiw	r26, 0x04	; 4
	clst = dj->sclust;
    3d30:	16 96       	adiw	r26, 0x06	; 6
    3d32:	4d 91       	ld	r20, X+
    3d34:	5d 91       	ld	r21, X+
    3d36:	6d 91       	ld	r22, X+
    3d38:	7c 91       	ld	r23, X
    3d3a:	19 97       	sbiw	r26, 0x09	; 9
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3d3c:	41 30       	cpi	r20, 0x01	; 1
    3d3e:	51 05       	cpc	r21, r1
    3d40:	61 05       	cpc	r22, r1
    3d42:	71 05       	cpc	r23, r1
    3d44:	09 f4       	brne	.+2      	; 0x3d48 <dir_sdi.constprop.4+0x2c>
    3d46:	67 c0       	rjmp	.+206    	; 0x3e16 <dir_sdi.constprop.4+0xfa>
    3d48:	cd 91       	ld	r28, X+
    3d4a:	dc 91       	ld	r29, X
    3d4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d50:	ac 85       	ldd	r26, Y+12	; 0x0c
    3d52:	bd 85       	ldd	r27, Y+13	; 0x0d
    3d54:	48 17       	cp	r20, r24
    3d56:	59 07       	cpc	r21, r25
    3d58:	6a 07       	cpc	r22, r26
    3d5a:	7b 07       	cpc	r23, r27
    3d5c:	08 f0       	brcs	.+2      	; 0x3d60 <dir_sdi.constprop.4+0x44>
    3d5e:	5b c0       	rjmp	.+182    	; 0x3e16 <dir_sdi.constprop.4+0xfa>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    3d60:	41 15       	cp	r20, r1
    3d62:	51 05       	cpc	r21, r1
    3d64:	61 05       	cpc	r22, r1
    3d66:	71 05       	cpc	r23, r1
    3d68:	d9 f4       	brne	.+54     	; 0x3da0 <dir_sdi.constprop.4+0x84>
    3d6a:	88 81       	ld	r24, Y
    3d6c:	83 30       	cpi	r24, 0x03	; 3
    3d6e:	49 f4       	brne	.+18     	; 0x3d82 <dir_sdi.constprop.4+0x66>
		clst = dj->fs->dirbase;
    3d70:	4e 89       	ldd	r20, Y+22	; 0x16
    3d72:	5f 89       	ldd	r21, Y+23	; 0x17
    3d74:	68 8d       	ldd	r22, Y+24	; 0x18
    3d76:	79 8d       	ldd	r23, Y+25	; 0x19

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    3d78:	41 15       	cp	r20, r1
    3d7a:	51 05       	cpc	r21, r1
    3d7c:	61 05       	cpc	r22, r1
    3d7e:	71 05       	cpc	r23, r1
    3d80:	79 f4       	brne	.+30     	; 0x3da0 <dir_sdi.constprop.4+0x84>
		dj->clust = clst;
    3d82:	f8 01       	movw	r30, r16
    3d84:	12 86       	std	Z+10, r1	; 0x0a
    3d86:	13 86       	std	Z+11, r1	; 0x0b
    3d88:	14 86       	std	Z+12, r1	; 0x0c
    3d8a:	15 86       	std	Z+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    3d8c:	88 85       	ldd	r24, Y+8	; 0x08
    3d8e:	99 85       	ldd	r25, Y+9	; 0x09
    3d90:	00 97       	sbiw	r24, 0x00	; 0
    3d92:	09 f4       	brne	.+2      	; 0x3d96 <dir_sdi.constprop.4+0x7a>
    3d94:	40 c0       	rjmp	.+128    	; 0x3e16 <dir_sdi.constprop.4+0xfa>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3d96:	8e 89       	ldd	r24, Y+22	; 0x16
    3d98:	9f 89       	ldd	r25, Y+23	; 0x17
    3d9a:	a8 8d       	ldd	r26, Y+24	; 0x18
    3d9c:	b9 8d       	ldd	r27, Y+25	; 0x19
    3d9e:	2d c0       	rjmp	.+90     	; 0x3dfa <dir_sdi.constprop.4+0xde>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    3da0:	8a 81       	ldd	r24, Y+2	; 0x02
		while (idx >= ic) {	/* Follow cluster chain */
    3da2:	88 23       	and	r24, r24
    3da4:	01 f5       	brne	.+64     	; 0x3de6 <dir_sdi.constprop.4+0xca>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    3da6:	d8 01       	movw	r26, r16
    3da8:	8d 91       	ld	r24, X+
    3daa:	9c 91       	ld	r25, X
    3dac:	f1 de       	rcall	.-542    	; 0x3b90 <get_fat>
    3dae:	ab 01       	movw	r20, r22
    3db0:	bc 01       	movw	r22, r24
    3db2:	4f 3f       	cpi	r20, 0xFF	; 255
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3db4:	bf ef       	ldi	r27, 0xFF	; 255
    3db6:	5b 07       	cpc	r21, r27
    3db8:	bf ef       	ldi	r27, 0xFF	; 255
    3dba:	6b 07       	cpc	r22, r27
    3dbc:	bf ef       	ldi	r27, 0xFF	; 255
    3dbe:	7b 07       	cpc	r23, r27
    3dc0:	41 f1       	breq	.+80     	; 0x3e12 <dir_sdi.constprop.4+0xf6>
    3dc2:	42 30       	cpi	r20, 0x02	; 2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    3dc4:	51 05       	cpc	r21, r1
    3dc6:	61 05       	cpc	r22, r1
    3dc8:	71 05       	cpc	r23, r1
    3dca:	28 f1       	brcs	.+74     	; 0x3e16 <dir_sdi.constprop.4+0xfa>
    3dcc:	d8 01       	movw	r26, r16
    3dce:	ed 91       	ld	r30, X+
    3dd0:	fc 91       	ld	r31, X
    3dd2:	82 85       	ldd	r24, Z+10	; 0x0a
    3dd4:	93 85       	ldd	r25, Z+11	; 0x0b
    3dd6:	a4 85       	ldd	r26, Z+12	; 0x0c
    3dd8:	b5 85       	ldd	r27, Z+13	; 0x0d
    3dda:	48 17       	cp	r20, r24
    3ddc:	59 07       	cpc	r21, r25
    3dde:	6a 07       	cpc	r22, r26
    3de0:	7b 07       	cpc	r23, r27
    3de2:	08 f3       	brcs	.-62     	; 0x3da6 <dir_sdi.constprop.4+0x8a>
    3de4:	18 c0       	rjmp	.+48     	; 0x3e16 <dir_sdi.constprop.4+0xfa>
    3de6:	f8 01       	movw	r30, r16
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    3de8:	42 87       	std	Z+10, r20	; 0x0a
    3dea:	53 87       	std	Z+11, r21	; 0x0b
    3dec:	64 87       	std	Z+12, r22	; 0x0c
    3dee:	75 87       	std	Z+13, r23	; 0x0d
    3df0:	ce 01       	movw	r24, r28
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3df2:	9a de       	rcall	.-716    	; 0x3b28 <clust2sect>
    3df4:	dc 01       	movw	r26, r24
    3df6:	cb 01       	movw	r24, r22
    3df8:	f8 01       	movw	r30, r16
    3dfa:	86 87       	std	Z+14, r24	; 0x0e
    3dfc:	97 87       	std	Z+15, r25	; 0x0f
    3dfe:	a0 8b       	std	Z+16, r26	; 0x10
    3e00:	b1 8b       	std	Z+17, r27	; 0x11
    3e02:	a2 96       	adiw	r28, 0x22	; 34
    3e04:	d8 01       	movw	r26, r16
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    3e06:	53 96       	adiw	r26, 0x13	; 19
    3e08:	dc 93       	st	X, r29
    3e0a:	ce 93       	st	-X, r28
    3e0c:	52 97       	sbiw	r26, 0x12	; 18
    3e0e:	80 e0       	ldi	r24, 0x00	; 0
    3e10:	03 c0       	rjmp	.+6      	; 0x3e18 <dir_sdi.constprop.4+0xfc>

	return FR_OK;	/* Seek succeeded */
    3e12:	81 e0       	ldi	r24, 0x01	; 1
    3e14:	01 c0       	rjmp	.+2      	; 0x3e18 <dir_sdi.constprop.4+0xfc>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3e16:	82 e0       	ldi	r24, 0x02	; 2
    3e18:	df 91       	pop	r29
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    3e1a:	cf 91       	pop	r28
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    3e1c:	1f 91       	pop	r17
    3e1e:	0f 91       	pop	r16
    3e20:	08 95       	ret

00003e22 <f_mount>:
    3e22:	88 23       	and	r24, r24
    3e24:	91 f4       	brne	.+36     	; 0x3e4a <f_mount+0x28>
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    3e26:	e0 91 f4 03 	lds	r30, 0x03F4
    3e2a:	f0 91 f5 03 	lds	r31, 0x03F5

	if (rfs) {
    3e2e:	30 97       	sbiw	r30, 0x00	; 0
    3e30:	09 f0       	breq	.+2      	; 0x3e34 <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    3e32:	10 82       	st	Z, r1
	}

	if (fs) {
    3e34:	61 15       	cp	r22, r1
    3e36:	71 05       	cpc	r23, r1
    3e38:	11 f0       	breq	.+4      	; 0x3e3e <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    3e3a:	fb 01       	movw	r30, r22
    3e3c:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    3e3e:	70 93 f5 03 	sts	0x03F5, r23
    3e42:	60 93 f4 03 	sts	0x03F4, r22

	return FR_OK;
    3e46:	80 e0       	ldi	r24, 0x00	; 0
    3e48:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3e4a:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    3e4c:	08 95       	ret

00003e4e <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3e4e:	2f 92       	push	r2
    3e50:	3f 92       	push	r3
    3e52:	4f 92       	push	r4
    3e54:	5f 92       	push	r5
    3e56:	6f 92       	push	r6
    3e58:	7f 92       	push	r7
    3e5a:	8f 92       	push	r8
    3e5c:	9f 92       	push	r9
    3e5e:	af 92       	push	r10
    3e60:	bf 92       	push	r11
    3e62:	cf 92       	push	r12
    3e64:	df 92       	push	r13
    3e66:	ef 92       	push	r14
    3e68:	ff 92       	push	r15
    3e6a:	0f 93       	push	r16
    3e6c:	1f 93       	push	r17
    3e6e:	cf 93       	push	r28
    3e70:	df 93       	push	r29
    3e72:	cd b7       	in	r28, 0x3d	; 61
    3e74:	de b7       	in	r29, 0x3e	; 62
    3e76:	e5 97       	sbiw	r28, 0x35	; 53
    3e78:	0f b6       	in	r0, 0x3f	; 63
    3e7a:	f8 94       	cli
    3e7c:	de bf       	out	0x3e, r29	; 62
    3e7e:	0f be       	out	0x3f, r0	; 63
    3e80:	cd bf       	out	0x3d, r28	; 61
    3e82:	9c a3       	lds	r25, 0x5c
    3e84:	8b a3       	lds	r24, 0x5b
    3e86:	4b 01       	movw	r8, r22
    3e88:	4d ab       	sts	0x5d, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3e8a:	00 97       	sbiw	r24, 0x00	; 0
    3e8c:	09 f4       	brne	.+2      	; 0x3e90 <f_open+0x42>
    3e8e:	6c c3       	rjmp	.+1752   	; 0x4568 <f_open+0x71a>
	fp->fs = 0;			/* Clear file object */
    3e90:	dc 01       	movw	r26, r24
    3e92:	11 96       	adiw	r26, 0x01	; 1
    3e94:	1c 92       	st	X, r1
    3e96:	1e 92       	st	-X, r1
	const TCHAR *p = *path;
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    3e98:	fb 01       	movw	r30, r22
    3e9a:	80 81       	ld	r24, Z
    3e9c:	90 e0       	ldi	r25, 0x00	; 0
    3e9e:	c0 97       	sbiw	r24, 0x30	; 48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    3ea0:	8a 30       	cpi	r24, 0x0A	; 10
    3ea2:	91 05       	cpc	r25, r1
    3ea4:	40 f4       	brcc	.+16     	; 0x3eb6 <f_open+0x68>
    3ea6:	21 81       	ldd	r18, Z+1	; 0x01
    3ea8:	2a 33       	cpi	r18, 0x3A	; 58
    3eaa:	29 f4       	brne	.+10     	; 0x3eb6 <f_open+0x68>
		p += 2; *path = p;				/* Return pointer to the path name */
    3eac:	22 e0       	ldi	r18, 0x02	; 2
    3eae:	30 e0       	ldi	r19, 0x00	; 0
    3eb0:	82 0e       	add	r8, r18
    3eb2:	93 1e       	adc	r9, r19
    3eb4:	02 c0       	rjmp	.+4      	; 0x3eba <f_open+0x6c>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
#else
		vol = 0;						/* Use drive 0 */
    3eb6:	80 e0       	ldi	r24, 0x00	; 0
    3eb8:	90 e0       	ldi	r25, 0x00	; 0
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    3eba:	00 97       	sbiw	r24, 0x00	; 0
    3ebc:	09 f0       	breq	.+2      	; 0x3ec0 <f_open+0x72>
    3ebe:	ad c1       	rjmp	.+858    	; 0x421a <f_open+0x3cc>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    3ec0:	a0 90 f4 03 	lds	r10, 0x03F4
    3ec4:	b0 90 f5 03 	lds	r11, 0x03F5
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    3ec8:	a1 14       	cp	r10, r1
    3eca:	b1 04       	cpc	r11, r1
    3ecc:	09 f4       	brne	.+2      	; 0x3ed0 <f_open+0x82>
    3ece:	a7 c1       	rjmp	.+846    	; 0x421e <f_open+0x3d0>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    3ed0:	be 86       	std	Y+14, r11	; 0x0e
    3ed2:	ad 86       	std	Y+13, r10	; 0x0d
	if (fs->fs_type) {					/* If the volume has been mounted */
    3ed4:	d5 01       	movw	r26, r10
    3ed6:	8c 91       	ld	r24, X
    3ed8:	88 23       	and	r24, r24
    3eda:	29 f0       	breq	.+10     	; 0x3ee6 <f_open+0x98>
		stat = disk_status(fs->drv);
    3edc:	11 96       	adiw	r26, 0x01	; 1
    3ede:	8c 91       	ld	r24, X
    3ee0:	6d dd       	rcall	.-1318   	; 0x39bc <disk_status>
    3ee2:	80 ff       	sbrs	r24, 0
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    3ee4:	5c c3       	rjmp	.+1720   	; 0x459e <f_open+0x750>
    3ee6:	f5 01       	movw	r30, r10
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    3ee8:	10 82       	st	Z, r1
    3eea:	11 82       	std	Z+1, r1	; 0x01
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    3eec:	80 e0       	ldi	r24, 0x00	; 0
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    3eee:	64 dd       	rcall	.-1336   	; 0x39b8 <disk_initialize>
    3ef0:	80 fd       	sbrc	r24, 0
    3ef2:	97 c1       	rjmp	.+814    	; 0x4222 <f_open+0x3d4>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    3ef4:	c5 01       	movw	r24, r10
    3ef6:	40 e0       	ldi	r20, 0x00	; 0
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    3ef8:	50 e0       	ldi	r21, 0x00	; 0
    3efa:	ba 01       	movw	r22, r20
    3efc:	bb dd       	rcall	.-1162   	; 0x3a74 <check_fs>
    3efe:	81 30       	cpi	r24, 0x01	; 1
    3f00:	b9 f4       	brne	.+46     	; 0x3f30 <f_open+0xe2>
    3f02:	f5 01       	movw	r30, r10
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    3f04:	ec 51       	subi	r30, 0x1C	; 28
    3f06:	fe 4f       	sbci	r31, 0xFE	; 254
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    3f08:	80 81       	ld	r24, Z
    3f0a:	88 23       	and	r24, r24
    3f0c:	09 f4       	brne	.+2      	; 0x3f10 <f_open+0xc2>
    3f0e:	8d c1       	rjmp	.+794    	; 0x422a <f_open+0x3dc>
    3f10:	f5 01       	movw	r30, r10
    3f12:	e8 51       	subi	r30, 0x18	; 24
    3f14:	fe 4f       	sbci	r31, 0xFE	; 254
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    3f16:	20 81       	ld	r18, Z
    3f18:	31 81       	ldd	r19, Z+1	; 0x01
    3f1a:	42 81       	ldd	r20, Z+2	; 0x02
    3f1c:	53 81       	ldd	r21, Z+3	; 0x03
    3f1e:	29 a7       	lds	r18, 0x79
    3f20:	3a a7       	lds	r19, 0x7a
    3f22:	4b a7       	lds	r20, 0x7b
    3f24:	5c a7       	lds	r21, 0x7c
    3f26:	c5 01       	movw	r24, r10
    3f28:	ba 01       	movw	r22, r20
    3f2a:	a9 01       	movw	r20, r18
			fmt = check_fs(fs, bsect);		/* Check the partition */
    3f2c:	a3 dd       	rcall	.-1210   	; 0x3a74 <check_fs>
    3f2e:	04 c0       	rjmp	.+8      	; 0x3f38 <f_open+0xea>
    3f30:	19 a6       	lds	r17, 0xb9
    3f32:	1a a6       	lds	r17, 0xba
    3f34:	1b a6       	lds	r17, 0xbb
    3f36:	1c a6       	lds	r17, 0xbc
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    3f38:	83 30       	cpi	r24, 0x03	; 3
    3f3a:	09 f4       	brne	.+2      	; 0x3f3e <f_open+0xf0>
    3f3c:	74 c1       	rjmp	.+744    	; 0x4226 <f_open+0x3d8>
    3f3e:	88 23       	and	r24, r24
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    3f40:	09 f0       	breq	.+2      	; 0x3f44 <f_open+0xf6>
    3f42:	73 c1       	rjmp	.+742    	; 0x422a <f_open+0x3dc>
    3f44:	d5 01       	movw	r26, r10
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    3f46:	9d 96       	adiw	r26, 0x2d	; 45
    3f48:	8d 91       	ld	r24, X+
    3f4a:	9c 91       	ld	r25, X

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    3f4c:	9e 97       	sbiw	r26, 0x2e	; 46
    3f4e:	b2 e0       	ldi	r27, 0x02	; 2
    3f50:	80 30       	cpi	r24, 0x00	; 0
    3f52:	9b 07       	cpc	r25, r27
    3f54:	09 f0       	breq	.+2      	; 0x3f58 <f_open+0x10a>
    3f56:	69 c1       	rjmp	.+722    	; 0x422a <f_open+0x3dc>
    3f58:	f5 01       	movw	r30, r10
    3f5a:	80 ad       	sts	0x60, r24
    3f5c:	91 ad       	sts	0x61, r25
    3f5e:	9c 01       	movw	r18, r24
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    3f60:	40 e0       	ldi	r20, 0x00	; 0
    3f62:	50 e0       	ldi	r21, 0x00	; 0
    3f64:	2d a3       	lds	r18, 0x5d
    3f66:	3e a3       	lds	r19, 0x5e
    3f68:	4f a3       	lds	r20, 0x5f
    3f6a:	58 a7       	lds	r21, 0x78
    3f6c:	21 15       	cp	r18, r1
    3f6e:	31 05       	cpc	r19, r1
    3f70:	41 05       	cpc	r20, r1
    3f72:	51 05       	cpc	r21, r1
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    3f74:	51 f4       	brne	.+20     	; 0x3f8a <f_open+0x13c>
    3f76:	ea 5b       	subi	r30, 0xBA	; 186
    3f78:	ff 4f       	sbci	r31, 0xFF	; 255
    3f7a:	80 81       	ld	r24, Z
    3f7c:	91 81       	ldd	r25, Z+1	; 0x01
    3f7e:	a2 81       	ldd	r26, Z+2	; 0x02
    3f80:	b3 81       	ldd	r27, Z+3	; 0x03
    3f82:	8d a3       	lds	r24, 0x5d
    3f84:	9e a3       	lds	r25, 0x5e
    3f86:	af a3       	lds	r26, 0x5f
    3f88:	b8 a7       	lds	r27, 0x78
    3f8a:	2d a1       	lds	r18, 0x4d
    3f8c:	3e a1       	lds	r19, 0x4e
    3f8e:	4f a1       	lds	r20, 0x4f
    3f90:	58 a5       	lds	r21, 0x68
	fs->fsize = fasize;
    3f92:	d5 01       	movw	r26, r10
    3f94:	1e 96       	adiw	r26, 0x0e	; 14
    3f96:	2d 93       	st	X+, r18
    3f98:	3d 93       	st	X+, r19
    3f9a:	4d 93       	st	X+, r20
    3f9c:	5c 93       	st	X, r21
    3f9e:	51 97       	sbiw	r26, 0x11	; 17
    3fa0:	d2 96       	adiw	r26, 0x32	; 50
    3fa2:	4c 91       	ld	r20, X
    3fa4:	d2 97       	sbiw	r26, 0x32	; 50
    3fa6:	13 96       	adiw	r26, 0x03	; 3

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    3fa8:	4c 93       	st	X, r20
    3faa:	13 97       	sbiw	r26, 0x03	; 3
    3fac:	84 2f       	mov	r24, r20
    3fae:	81 50       	subi	r24, 0x01	; 1
    3fb0:	82 30       	cpi	r24, 0x02	; 2
    3fb2:	08 f0       	brcs	.+2      	; 0x3fb6 <f_open+0x168>
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    3fb4:	3a c1       	rjmp	.+628    	; 0x422a <f_open+0x3dc>
    3fb6:	9f 96       	adiw	r26, 0x2f	; 47
    3fb8:	0c 91       	ld	r16, X
    3fba:	9f 97       	sbiw	r26, 0x2f	; 47
    3fbc:	12 96       	adiw	r26, 0x02	; 2
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    3fbe:	0c 93       	st	X, r16
    3fc0:	12 97       	sbiw	r26, 0x02	; 2
    3fc2:	00 23       	and	r16, r16
    3fc4:	09 f4       	brne	.+2      	; 0x3fc8 <f_open+0x17a>
    3fc6:	31 c1       	rjmp	.+610    	; 0x422a <f_open+0x3dc>
    3fc8:	20 2f       	mov	r18, r16
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    3fca:	30 e0       	ldi	r19, 0x00	; 0
    3fcc:	c9 01       	movw	r24, r18
    3fce:	01 97       	sbiw	r24, 0x01	; 1
    3fd0:	82 23       	and	r24, r18
    3fd2:	93 23       	and	r25, r19
    3fd4:	00 97       	sbiw	r24, 0x00	; 0
    3fd6:	09 f0       	breq	.+2      	; 0x3fda <f_open+0x18c>
    3fd8:	28 c1       	rjmp	.+592    	; 0x422a <f_open+0x3dc>
    3fda:	d3 96       	adiw	r26, 0x33	; 51
    3fdc:	2d 90       	ld	r2, X+
    3fde:	3c 90       	ld	r3, X
    3fe0:	d4 97       	sbiw	r26, 0x34	; 52

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    3fe2:	19 96       	adiw	r26, 0x09	; 9
    3fe4:	3c 92       	st	X, r3
    3fe6:	2e 92       	st	-X, r2
    3fe8:	18 97       	sbiw	r26, 0x08	; 8
    3fea:	c1 01       	movw	r24, r2
    3fec:	8f 70       	andi	r24, 0x0F	; 15
    3fee:	90 70       	andi	r25, 0x00	; 0
    3ff0:	00 97       	sbiw	r24, 0x00	; 0
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    3ff2:	09 f0       	breq	.+2      	; 0x3ff6 <f_open+0x1a8>
    3ff4:	1a c1       	rjmp	.+564    	; 0x422a <f_open+0x3dc>
    3ff6:	d5 96       	adiw	r26, 0x35	; 53
    3ff8:	8d 91       	ld	r24, X+
    3ffa:	9c 91       	ld	r25, X
    3ffc:	d6 97       	sbiw	r26, 0x36	; 54

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    3ffe:	2c 01       	movw	r4, r24
    4000:	66 24       	eor	r6, r6
    4002:	77 24       	eor	r7, r7
    4004:	41 14       	cp	r4, r1
    4006:	51 04       	cpc	r5, r1
    4008:	61 04       	cpc	r6, r1
    400a:	71 04       	cpc	r7, r1
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    400c:	39 f4       	brne	.+14     	; 0x401c <f_open+0x1ce>
    400e:	f5 01       	movw	r30, r10
    4010:	ee 5b       	subi	r30, 0xBE	; 190
    4012:	ff 4f       	sbci	r31, 0xFF	; 255
    4014:	40 80       	ld	r4, Z
    4016:	51 80       	ldd	r5, Z+1	; 0x01
    4018:	62 80       	ldd	r6, Z+2	; 0x02
    401a:	73 80       	ldd	r7, Z+3	; 0x03
    401c:	f5 01       	movw	r30, r10
    401e:	c0 a8       	sts	0x00, r28
    4020:	d1 a8       	sts	0x81, r29
    4022:	c1 14       	cp	r12, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    4024:	d1 04       	cpc	r13, r1
    4026:	09 f4       	brne	.+2      	; 0x402a <f_open+0x1dc>
    4028:	00 c1       	rjmp	.+512    	; 0x422a <f_open+0x3dc>
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    402a:	24 2f       	mov	r18, r20
    402c:	30 e0       	ldi	r19, 0x00	; 0
    402e:	40 e0       	ldi	r20, 0x00	; 0
    4030:	50 e0       	ldi	r21, 0x00	; 0
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    4032:	6d a1       	lds	r22, 0x4d
    4034:	7e a1       	lds	r23, 0x4e
    4036:	8f a1       	lds	r24, 0x4f
    4038:	98 a5       	lds	r25, 0x68
    403a:	0e 94 fd 3b 	call	0x77fa	; 0x77fa <__mulsi3>
    403e:	6d a7       	lds	r22, 0x7d
    4040:	7e a7       	lds	r23, 0x7e
    4042:	8f a7       	lds	r24, 0x7f
    4044:	98 ab       	sts	0x58, r25
    4046:	96 01       	movw	r18, r12
    4048:	40 e0       	ldi	r20, 0x00	; 0
    404a:	50 e0       	ldi	r21, 0x00	; 0
    404c:	29 ab       	sts	0x59, r18

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    404e:	3a ab       	sts	0x5a, r19
    4050:	4b ab       	sts	0x5b, r20
    4052:	5c ab       	sts	0x5c, r21
    4054:	61 01       	movw	r12, r2
    4056:	e4 e0       	ldi	r30, 0x04	; 4
    4058:	d6 94       	lsr	r13
    405a:	c7 94       	ror	r12
    405c:	ea 95       	dec	r30
    405e:	e1 f7       	brne	.-8      	; 0x4058 <f_open+0x20a>
    4060:	ee 24       	eor	r14, r14
    4062:	ff 24       	eor	r15, r15
    4064:	c2 0e       	add	r12, r18
    4066:	d3 1e       	adc	r13, r19
    4068:	e4 1e       	adc	r14, r20
    406a:	f5 1e       	adc	r15, r21
    406c:	c6 0e       	add	r12, r22
    406e:	d7 1e       	adc	r13, r23
    4070:	e8 1e       	adc	r14, r24
    4072:	f9 1e       	adc	r15, r25
    4074:	4c 14       	cp	r4, r12
    4076:	5d 04       	cpc	r5, r13
    4078:	6e 04       	cpc	r6, r14
    407a:	7f 04       	cpc	r7, r15
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    407c:	08 f4       	brcc	.+2      	; 0x4080 <f_open+0x232>
    407e:	d5 c0       	rjmp	.+426    	; 0x422a <f_open+0x3dc>
    4080:	c3 01       	movw	r24, r6
    4082:	b2 01       	movw	r22, r4
    4084:	6c 19       	sub	r22, r12
    4086:	7d 09       	sbc	r23, r13
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    4088:	8e 09       	sbc	r24, r14
    408a:	9f 09       	sbc	r25, r15
    408c:	20 2f       	mov	r18, r16
    408e:	30 e0       	ldi	r19, 0x00	; 0
    4090:	40 e0       	ldi	r20, 0x00	; 0
    4092:	50 e0       	ldi	r21, 0x00	; 0
    4094:	0e 94 1c 3c 	call	0x7838	; 0x7838 <__udivmodsi4>
    4098:	89 01       	movw	r16, r18
    409a:	9a 01       	movw	r18, r20
    409c:	01 15       	cp	r16, r1
    409e:	11 05       	cpc	r17, r1
    40a0:	21 05       	cpc	r18, r1
    40a2:	31 05       	cpc	r19, r1
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    40a4:	09 f4       	brne	.+2      	; 0x40a8 <f_open+0x25a>
    40a6:	c1 c0       	rjmp	.+386    	; 0x422a <f_open+0x3dc>
    40a8:	06 3f       	cpi	r16, 0xF6	; 246
    40aa:	4f e0       	ldi	r20, 0x0F	; 15
    40ac:	14 07       	cpc	r17, r20
    40ae:	40 e0       	ldi	r20, 0x00	; 0
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    40b0:	24 07       	cpc	r18, r20
    40b2:	40 e0       	ldi	r20, 0x00	; 0
    40b4:	34 07       	cpc	r19, r20
    40b6:	58 f0       	brcs	.+22     	; 0x40ce <f_open+0x280>
    40b8:	06 3f       	cpi	r16, 0xF6	; 246
    40ba:	5f ef       	ldi	r21, 0xFF	; 255
    40bc:	15 07       	cpc	r17, r21
    40be:	50 e0       	ldi	r21, 0x00	; 0
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    40c0:	25 07       	cpc	r18, r21
    40c2:	50 e0       	ldi	r21, 0x00	; 0
    40c4:	35 07       	cpc	r19, r21
    40c6:	30 f4       	brcc	.+12     	; 0x40d4 <f_open+0x286>
    40c8:	92 e0       	ldi	r25, 0x02	; 2
    40ca:	49 2e       	mov	r4, r25
    40cc:	05 c0       	rjmp	.+10     	; 0x40d8 <f_open+0x28a>
    40ce:	44 24       	eor	r4, r4
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    40d0:	43 94       	inc	r4
    40d2:	02 c0       	rjmp	.+4      	; 0x40d8 <f_open+0x28a>
    40d4:	83 e0       	ldi	r24, 0x03	; 3
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    40d6:	48 2e       	mov	r4, r24
    40d8:	0e 5f       	subi	r16, 0xFE	; 254
    40da:	1f 4f       	sbci	r17, 0xFF	; 255
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    40dc:	2f 4f       	sbci	r18, 0xFF	; 255
    40de:	3f 4f       	sbci	r19, 0xFF	; 255

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    40e0:	d5 01       	movw	r26, r10
    40e2:	1a 96       	adiw	r26, 0x0a	; 10
    40e4:	0d 93       	st	X+, r16
    40e6:	1d 93       	st	X+, r17
    40e8:	2d 93       	st	X+, r18
    40ea:	3c 93       	st	X, r19
    40ec:	1d 97       	sbiw	r26, 0x0d	; 13
    40ee:	89 a5       	lds	r24, 0x69
    40f0:	9a a5       	lds	r25, 0x6a
    40f2:	ab a5       	lds	r26, 0x6b
    40f4:	bc a5       	lds	r27, 0x6c
	fs->database = bsect + sysect;						/* Data start sector */
    40f6:	c8 0e       	add	r12, r24
    40f8:	d9 1e       	adc	r13, r25
    40fa:	ea 1e       	adc	r14, r26
    40fc:	fb 1e       	adc	r15, r27
    40fe:	d5 01       	movw	r26, r10
    4100:	5a 96       	adiw	r26, 0x1a	; 26
    4102:	cd 92       	st	X+, r12
    4104:	dd 92       	st	X+, r13
    4106:	ed 92       	st	X+, r14
    4108:	fc 92       	st	X, r15
    410a:	5d 97       	sbiw	r26, 0x1d	; 29
    410c:	49 a5       	lds	r20, 0x69
    410e:	5a a5       	lds	r21, 0x6a
    4110:	6b a5       	lds	r22, 0x6b
    4112:	7c a5       	lds	r23, 0x6c
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    4114:	89 a9       	sts	0x49, r24
    4116:	9a a9       	sts	0x4a, r25
    4118:	ab a9       	sts	0x4b, r26
    411a:	bc a9       	sts	0x4c, r27
    411c:	48 0f       	add	r20, r24
    411e:	59 1f       	adc	r21, r25
    4120:	6a 1f       	adc	r22, r26
    4122:	7b 1f       	adc	r23, r27
    4124:	d5 01       	movw	r26, r10
    4126:	52 96       	adiw	r26, 0x12	; 18
    4128:	4d 93       	st	X+, r20
    412a:	5d 93       	st	X+, r21
    412c:	6d 93       	st	X+, r22
    412e:	7c 93       	st	X, r23
    4130:	55 97       	sbiw	r26, 0x15	; 21
    4132:	b3 e0       	ldi	r27, 0x03	; 3
    4134:	4b 16       	cp	r4, r27
    4136:	d9 f4       	brne	.+54     	; 0x416e <f_open+0x320>
    4138:	21 14       	cp	r2, r1
	if (fmt == FS_FAT32) {
    413a:	31 04       	cpc	r3, r1
    413c:	09 f0       	breq	.+2      	; 0x4140 <f_open+0x2f2>
    413e:	75 c0       	rjmp	.+234    	; 0x422a <f_open+0x3dc>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    4140:	f5 01       	movw	r30, r10
    4142:	e2 5b       	subi	r30, 0xB2	; 178
    4144:	ff 4f       	sbci	r31, 0xFF	; 255
    4146:	80 81       	ld	r24, Z
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    4148:	91 81       	ldd	r25, Z+1	; 0x01
    414a:	a2 81       	ldd	r26, Z+2	; 0x02
    414c:	b3 81       	ldd	r27, Z+3	; 0x03
    414e:	f5 01       	movw	r30, r10
    4150:	86 8b       	std	Z+22, r24	; 0x16
    4152:	97 8b       	std	Z+23, r25	; 0x17
    4154:	a0 8f       	std	Z+24, r26	; 0x18
    4156:	b1 8f       	std	Z+25, r27	; 0x19
    4158:	b9 01       	movw	r22, r18
    415a:	a8 01       	movw	r20, r16
    415c:	44 0f       	add	r20, r20
    415e:	55 1f       	adc	r21, r21
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    4160:	66 1f       	adc	r22, r22
    4162:	77 1f       	adc	r23, r23
    4164:	44 0f       	add	r20, r20
    4166:	55 1f       	adc	r21, r21
    4168:	66 1f       	adc	r22, r22
    416a:	77 1f       	adc	r23, r23
    416c:	2c c0       	rjmp	.+88     	; 0x41c6 <f_open+0x378>
    416e:	21 14       	cp	r2, r1
    4170:	31 04       	cpc	r3, r1
    4172:	09 f4       	brne	.+2      	; 0x4176 <f_open+0x328>
    4174:	5a c0       	rjmp	.+180    	; 0x422a <f_open+0x3dc>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    4176:	8d a5       	lds	r24, 0x6d
    4178:	9e a5       	lds	r25, 0x6e
    417a:	af a5       	lds	r26, 0x6f
    417c:	b8 a9       	sts	0x48, r27
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    417e:	84 0f       	add	r24, r20
    4180:	95 1f       	adc	r25, r21
    4182:	a6 1f       	adc	r26, r22
    4184:	b7 1f       	adc	r27, r23
    4186:	f5 01       	movw	r30, r10
    4188:	86 8b       	std	Z+22, r24	; 0x16
    418a:	97 8b       	std	Z+23, r25	; 0x17
    418c:	a0 8f       	std	Z+24, r26	; 0x18
    418e:	b1 8f       	std	Z+25, r27	; 0x19
    4190:	b9 01       	movw	r22, r18
    4192:	a8 01       	movw	r20, r16
    4194:	44 0f       	add	r20, r20
    4196:	55 1f       	adc	r21, r21
    4198:	66 1f       	adc	r22, r22
    419a:	77 1f       	adc	r23, r23
    419c:	f2 e0       	ldi	r31, 0x02	; 2
    419e:	4f 16       	cp	r4, r31
    41a0:	91 f0       	breq	.+36     	; 0x41c6 <f_open+0x378>
    41a2:	40 0f       	add	r20, r16
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    41a4:	51 1f       	adc	r21, r17
    41a6:	62 1f       	adc	r22, r18
    41a8:	73 1f       	adc	r23, r19
    41aa:	76 95       	lsr	r23
    41ac:	67 95       	ror	r22
    41ae:	57 95       	ror	r21
    41b0:	47 95       	ror	r20
    41b2:	d9 01       	movw	r26, r18
    41b4:	c8 01       	movw	r24, r16
    41b6:	81 70       	andi	r24, 0x01	; 1
    41b8:	90 70       	andi	r25, 0x00	; 0
    41ba:	a0 70       	andi	r26, 0x00	; 0
    41bc:	b0 70       	andi	r27, 0x00	; 0
    41be:	48 0f       	add	r20, r24
    41c0:	59 1f       	adc	r21, r25
    41c2:	6a 1f       	adc	r22, r26
    41c4:	7b 1f       	adc	r23, r27
    41c6:	41 50       	subi	r20, 0x01	; 1
    41c8:	5e 4f       	sbci	r21, 0xFE	; 254
    41ca:	6f 4f       	sbci	r22, 0xFF	; 255
    41cc:	7f 4f       	sbci	r23, 0xFF	; 255
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    41ce:	39 e0       	ldi	r19, 0x09	; 9
    41d0:	76 95       	lsr	r23
    41d2:	67 95       	ror	r22
    41d4:	57 95       	ror	r21
    41d6:	47 95       	ror	r20
    41d8:	3a 95       	dec	r19
    41da:	d1 f7       	brne	.-12     	; 0x41d0 <f_open+0x382>
    41dc:	8d a1       	lds	r24, 0x4d
    41de:	9e a1       	lds	r25, 0x4e
    41e0:	af a1       	lds	r26, 0x4f
    41e2:	b8 a5       	lds	r27, 0x68
    41e4:	84 17       	cp	r24, r20
    41e6:	95 07       	cpc	r25, r21
    41e8:	a6 07       	cpc	r26, r22
    41ea:	b7 07       	cpc	r27, r23
    41ec:	f0 f0       	brcs	.+60     	; 0x422a <f_open+0x3dc>
    41ee:	d5 01       	movw	r26, r10
    41f0:	4c 92       	st	X, r4
    41f2:	80 91 f6 03 	lds	r24, 0x03F6
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    41f6:	90 91 f7 03 	lds	r25, 0x03F7
	fs->id = ++Fsid;		/* File system mount ID */
    41fa:	01 96       	adiw	r24, 0x01	; 1
    41fc:	90 93 f7 03 	sts	0x03F7, r25
    4200:	80 93 f6 03 	sts	0x03F6, r24
    4204:	17 96       	adiw	r26, 0x07	; 7
    4206:	9c 93       	st	X, r25
    4208:	8e 93       	st	-X, r24
    420a:	16 97       	sbiw	r26, 0x06	; 6
    420c:	f5 01       	movw	r30, r10
    420e:	16 8e       	std	Z+30, r1	; 0x1e
    4210:	17 8e       	std	Z+31, r1	; 0x1f
    4212:	10 a2       	lds	r17, 0x90
	fs->winsect = 0;		/* Invalidate sector cache */
    4214:	11 a2       	lds	r17, 0x91
    4216:	14 82       	std	Z+4, r1	; 0x04
    4218:	c2 c1       	rjmp	.+900    	; 0x459e <f_open+0x750>
    421a:	0b e0       	ldi	r16, 0x0B	; 11
    421c:	a6 c1       	rjmp	.+844    	; 0x456a <f_open+0x71c>
	fs->wflag = 0;
    421e:	0c e0       	ldi	r16, 0x0C	; 12
    4220:	a4 c1       	rjmp	.+840    	; 0x456a <f_open+0x71c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    4222:	03 e0       	ldi	r16, 0x03	; 3
    4224:	a2 c1       	rjmp	.+836    	; 0x456a <f_open+0x71c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    4226:	01 e0       	ldi	r16, 0x01	; 1
    4228:	a0 c1       	rjmp	.+832    	; 0x456a <f_open+0x71c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    422a:	0d e0       	ldi	r16, 0x0D	; 13
    422c:	9e c1       	rjmp	.+828    	; 0x456a <f_open+0x71c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    422e:	8c 35       	cpi	r24, 0x5C	; 92
    4230:	19 f4       	brne	.+6      	; 0x4238 <f_open+0x3ea>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    4232:	08 94       	sec
    4234:	81 1c       	adc	r8, r1
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    4236:	91 1c       	adc	r9, r1
    4238:	1b 8a       	std	Y+19, r1	; 0x13
		path++;
    423a:	1c 8a       	std	Y+20, r1	; 0x14
    423c:	1d 8a       	std	Y+21, r1	; 0x15
    423e:	1e 8a       	std	Y+22, r1	; 0x16
	dj->sclust = 0;						/* Start from the root dir */
    4240:	d4 01       	movw	r26, r8
    4242:	8c 91       	ld	r24, X
    4244:	80 32       	cpi	r24, 0x20	; 32
    4246:	38 f4       	brcc	.+14     	; 0x4256 <f_open+0x408>
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    4248:	ce 01       	movw	r24, r28
    424a:	0d 96       	adiw	r24, 0x0d	; 13
    424c:	67 dd       	rcall	.-1330   	; 0x3d1c <dir_sdi.constprop.4>
    424e:	08 2f       	mov	r16, r24
		res = dir_sdi(dj, 0);
    4250:	18 a2       	lds	r17, 0x98
    4252:	1f 8e       	std	Y+31, r1	; 0x1f
    4254:	78 c1       	rjmp	.+752    	; 0x4546 <f_open+0x6f8>
    4256:	90 e2       	ldi	r25, 0x20	; 32
    4258:	29 2e       	mov	r2, r25
		dj->dir = 0;
    425a:	25 e0       	ldi	r18, 0x05	; 5
    425c:	f2 2e       	mov	r15, r18
    425e:	24 01       	movw	r4, r8
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    4260:	f4 01       	movw	r30, r8
    4262:	80 81       	ld	r24, Z
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    4264:	08 94       	sec
    4266:	81 1c       	adc	r8, r1
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    4268:	91 1c       	adc	r9, r1
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    426a:	8f 32       	cpi	r24, 0x2F	; 47
    426c:	c1 f3       	breq	.-16     	; 0x425e <f_open+0x410>
    426e:	8c 35       	cpi	r24, 0x5C	; 92
    4270:	b1 f3       	breq	.-20     	; 0x425e <f_open+0x410>
    4272:	c9 a0       	lds	r28, 0x89
    4274:	da a0       	lds	r29, 0x8a
    4276:	f6 01       	movw	r30, r12
    4278:	8c e0       	ldi	r24, 0x0C	; 12
    427a:	90 e0       	ldi	r25, 0x00	; 0
	sfn = dj->fn;
    427c:	01 c0       	rjmp	.+2      	; 0x4280 <f_open+0x432>
    427e:	21 92       	st	Z+, r2
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    4280:	01 97       	sbiw	r24, 0x01	; 1
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
    4282:	e9 f7       	brne	.-6      	; 0x427e <f_open+0x430>
    4284:	60 e0       	ldi	r22, 0x00	; 0
    4286:	70 e0       	ldi	r23, 0x00	; 0
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    4288:	a0 e0       	ldi	r26, 0x00	; 0
    428a:	b0 e0       	ldi	r27, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    428c:	08 e0       	ldi	r16, 0x08	; 8
    428e:	10 e0       	ldi	r17, 0x00	; 0
    4290:	30 e0       	ldi	r19, 0x00	; 0
    4292:	01 c0       	rjmp	.+2      	; 0x4296 <f_open+0x448>
    4294:	d4 01       	movw	r26, r8
    4296:	f2 01       	movw	r30, r4
    4298:	ea 0f       	add	r30, r26
    429a:	fb 1f       	adc	r31, r27
    429c:	20 81       	ld	r18, Z
    429e:	4d 01       	movw	r8, r26
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    42a0:	08 94       	sec
    42a2:	81 1c       	adc	r8, r1
    42a4:	91 1c       	adc	r9, r1
    42a6:	21 32       	cpi	r18, 0x21	; 33
    42a8:	08 f4       	brcc	.+2      	; 0x42ac <f_open+0x45e>
    42aa:	60 c0       	rjmp	.+192    	; 0x436c <f_open+0x51e>
    42ac:	2f 32       	cpi	r18, 0x2F	; 47
    42ae:	09 f4       	brne	.+2      	; 0x42b2 <f_open+0x464>
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    42b0:	5f c0       	rjmp	.+190    	; 0x4370 <f_open+0x522>
    42b2:	2c 35       	cpi	r18, 0x5C	; 92
    42b4:	09 f4       	brne	.+2      	; 0x42b8 <f_open+0x46a>
    42b6:	5c c0       	rjmp	.+184    	; 0x4370 <f_open+0x522>
    42b8:	2e 32       	cpi	r18, 0x2E	; 46
    42ba:	19 f0       	breq	.+6      	; 0x42c2 <f_open+0x474>
    42bc:	60 17       	cp	r22, r16
    42be:	71 07       	cpc	r23, r17
    42c0:	70 f0       	brcs	.+28     	; 0x42de <f_open+0x490>
		if (c == '.' || i >= ni) {
    42c2:	08 30       	cpi	r16, 0x08	; 8
    42c4:	11 05       	cpc	r17, r1
    42c6:	09 f0       	breq	.+2      	; 0x42ca <f_open+0x47c>
    42c8:	39 c1       	rjmp	.+626    	; 0x453c <f_open+0x6ee>
    42ca:	2e 32       	cpi	r18, 0x2E	; 46
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    42cc:	09 f0       	breq	.+2      	; 0x42d0 <f_open+0x482>
    42ce:	36 c1       	rjmp	.+620    	; 0x453c <f_open+0x6ee>
    42d0:	33 0f       	add	r19, r19
    42d2:	33 0f       	add	r19, r19
    42d4:	68 e0       	ldi	r22, 0x08	; 8
    42d6:	70 e0       	ldi	r23, 0x00	; 0
    42d8:	0b e0       	ldi	r16, 0x0B	; 11
			i = 8; ni = 11;
			b <<= 2; continue;
    42da:	10 e0       	ldi	r17, 0x00	; 0
    42dc:	db cf       	rjmp	.-74     	; 0x4294 <f_open+0x446>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    42de:	27 fd       	sbrc	r18, 7
    42e0:	33 60       	ori	r19, 0x03	; 3
    42e2:	82 2f       	mov	r24, r18
    42e4:	81 58       	subi	r24, 0x81	; 129
    42e6:	8f 31       	cpi	r24, 0x1F	; 31
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    42e8:	18 f0       	brcs	.+6      	; 0x42f0 <f_open+0x4a2>
			b |= 3;						/* Eliminate NT flag */
    42ea:	8f 55       	subi	r24, 0x5F	; 95
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    42ec:	8d 31       	cpi	r24, 0x1D	; 29
    42ee:	f8 f4       	brcc	.+62     	; 0x432e <f_open+0x4e0>
    42f0:	f2 01       	movw	r30, r4
    42f2:	e8 0d       	add	r30, r8
    42f4:	f9 1d       	adc	r31, r9
    42f6:	40 81       	ld	r20, Z
    42f8:	84 2f       	mov	r24, r20
			d = (BYTE)p[si++];			/* Get 2nd byte */
    42fa:	80 54       	subi	r24, 0x40	; 64
    42fc:	8f 33       	cpi	r24, 0x3F	; 63
    42fe:	20 f0       	brcs	.+8      	; 0x4308 <f_open+0x4ba>
    4300:	80 54       	subi	r24, 0x40	; 64
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    4302:	8d 37       	cpi	r24, 0x7D	; 125
    4304:	08 f0       	brcs	.+2      	; 0x4308 <f_open+0x4ba>
    4306:	1a c1       	rjmp	.+564    	; 0x453c <f_open+0x6ee>
    4308:	c8 01       	movw	r24, r16
    430a:	01 97       	sbiw	r24, 0x01	; 1
    430c:	68 17       	cp	r22, r24
    430e:	79 07       	cpc	r23, r25
    4310:	08 f0       	brcs	.+2      	; 0x4314 <f_open+0x4c6>
    4312:	14 c1       	rjmp	.+552    	; 0x453c <f_open+0x6ee>
    4314:	82 e0       	ldi	r24, 0x02	; 2
    4316:	88 2e       	mov	r8, r24
    4318:	91 2c       	mov	r9, r1
    431a:	8a 0e       	add	r8, r26
    431c:	9b 1e       	adc	r9, r27
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    431e:	f6 01       	movw	r30, r12
    4320:	e6 0f       	add	r30, r22
    4322:	f7 1f       	adc	r31, r23
    4324:	20 83       	st	Z, r18
    4326:	41 83       	std	Z+1, r20	; 0x01
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    4328:	6e 5f       	subi	r22, 0xFE	; 254
    432a:	7f 4f       	sbci	r23, 0xFF	; 255
    432c:	b3 cf       	rjmp	.-154    	; 0x4294 <f_open+0x446>
    432e:	42 2f       	mov	r20, r18
			sfn[i++] = d;
    4330:	50 e0       	ldi	r21, 0x00	; 0
    4332:	ee e2       	ldi	r30, 0x2E	; 46
    4334:	f3 e0       	ldi	r31, 0x03	; 3
    4336:	81 91       	ld	r24, Z+
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    4338:	88 23       	and	r24, r24
    433a:	29 f0       	breq	.+10     	; 0x4346 <f_open+0x4f8>
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	84 17       	cp	r24, r20
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    4340:	95 07       	cpc	r25, r21
    4342:	c9 f7       	brne	.-14     	; 0x4336 <f_open+0x4e8>
    4344:	fb c0       	rjmp	.+502    	; 0x453c <f_open+0x6ee>
    4346:	82 2f       	mov	r24, r18
    4348:	81 54       	subi	r24, 0x41	; 65
    434a:	8a 31       	cpi	r24, 0x1A	; 26
    434c:	10 f4       	brcc	.+4      	; 0x4352 <f_open+0x504>
    434e:	32 60       	ori	r19, 0x02	; 2
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    4350:	06 c0       	rjmp	.+12     	; 0x435e <f_open+0x510>
    4352:	82 2f       	mov	r24, r18
    4354:	81 56       	subi	r24, 0x61	; 97
    4356:	8a 31       	cpi	r24, 0x1A	; 26
				b |= 2;
    4358:	10 f4       	brcc	.+4      	; 0x435e <f_open+0x510>
    435a:	31 60       	ori	r19, 0x01	; 1
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    435c:	20 52       	subi	r18, 0x20	; 32
    435e:	f6 01       	movw	r30, r12
    4360:	e6 0f       	add	r30, r22
    4362:	f7 1f       	adc	r31, r23
					b |= 1; c -= 0x20;
    4364:	20 83       	st	Z, r18
    4366:	6f 5f       	subi	r22, 0xFF	; 255
				}
			}
			sfn[i++] = c;
    4368:	7f 4f       	sbci	r23, 0xFF	; 255
    436a:	94 cf       	rjmp	.-216    	; 0x4294 <f_open+0x446>
    436c:	44 e0       	ldi	r20, 0x04	; 4
    436e:	01 c0       	rjmp	.+2      	; 0x4372 <f_open+0x524>
    4370:	40 e0       	ldi	r20, 0x00	; 0
    4372:	61 15       	cp	r22, r1
    4374:	71 05       	cpc	r23, r1
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    4376:	09 f4       	brne	.+2      	; 0x437a <f_open+0x52c>
    4378:	e1 c0       	rjmp	.+450    	; 0x453c <f_open+0x6ee>
    437a:	d6 01       	movw	r26, r12

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    437c:	8c 91       	ld	r24, X
    437e:	85 3e       	cpi	r24, 0xE5	; 229
    4380:	09 f4       	brne	.+2      	; 0x4384 <f_open+0x536>
    4382:	fc 92       	st	X, r15
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    4384:	08 30       	cpi	r16, 0x08	; 8
    4386:	11 05       	cpc	r17, r1
    4388:	11 f4       	brne	.+4      	; 0x438e <f_open+0x540>
    438a:	33 0f       	add	r19, r19
    438c:	33 0f       	add	r19, r19

	if (ni == 8) b <<= 2;
    438e:	83 2f       	mov	r24, r19
    4390:	90 e0       	ldi	r25, 0x00	; 0
    4392:	9c 01       	movw	r18, r24
    4394:	23 70       	andi	r18, 0x03	; 3
    4396:	30 70       	andi	r19, 0x00	; 0
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    4398:	21 30       	cpi	r18, 0x01	; 1
    439a:	31 05       	cpc	r19, r1
    439c:	09 f4       	brne	.+2      	; 0x43a0 <f_open+0x552>
    439e:	40 61       	ori	r20, 0x10	; 16
    43a0:	8c 70       	andi	r24, 0x0C	; 12
    43a2:	90 70       	andi	r25, 0x00	; 0
    43a4:	84 30       	cpi	r24, 0x04	; 4
    43a6:	91 05       	cpc	r25, r1
    43a8:	09 f4       	brne	.+2      	; 0x43ac <f_open+0x55e>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    43aa:	48 60       	ori	r20, 0x08	; 8
    43ac:	f6 01       	movw	r30, r12
    43ae:	43 87       	std	Z+11, r20	; 0x0b
    43b0:	ce 01       	movw	r24, r28
    43b2:	0d 96       	adiw	r24, 0x0d	; 13
    43b4:	b3 dc       	rcall	.-1690   	; 0x3d1c <dir_sdi.constprop.4>

	sfn[NS] = c;		/* Store NT flag, File name is created */
    43b6:	88 23       	and	r24, r24
    43b8:	09 f0       	breq	.+2      	; 0x43bc <f_open+0x56e>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    43ba:	a0 c0       	rjmp	.+320    	; 0x44fc <f_open+0x6ae>
    43bc:	4b 8d       	ldd	r20, Y+27	; 0x1b
    43be:	5c 8d       	ldd	r21, Y+28	; 0x1c
    43c0:	6d 8d       	ldd	r22, Y+29	; 0x1d
	if (res != FR_OK) return res;
    43c2:	7e 8d       	ldd	r23, Y+30	; 0x1e
    43c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    43c6:	9e 85       	ldd	r25, Y+14	; 0x0e

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    43c8:	23 db       	rcall	.-2490   	; 0x3a10 <move_window>
    43ca:	88 23       	and	r24, r24
    43cc:	09 f0       	breq	.+2      	; 0x43d0 <f_open+0x582>
    43ce:	96 c0       	rjmp	.+300    	; 0x44fc <f_open+0x6ae>
    43d0:	ef 8d       	ldd	r30, Y+31	; 0x1f
    43d2:	f8 a1       	lds	r31, 0x48
    43d4:	90 81       	ld	r25, Z
    43d6:	99 23       	and	r25, r25
		if (res != FR_OK) break;
    43d8:	09 f4       	brne	.+2      	; 0x43dc <f_open+0x58e>
    43da:	8f c0       	rjmp	.+286    	; 0x44fa <f_open+0x6ac>
    43dc:	93 85       	ldd	r25, Z+11	; 0x0b
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    43de:	93 fd       	sbrc	r25, 3
    43e0:	0c c0       	rjmp	.+24     	; 0x43fa <f_open+0x5ac>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    43e2:	a9 a1       	lds	r26, 0x49
    43e4:	ba a1       	lds	r27, 0x4a
    43e6:	2c e0       	ldi	r18, 0x0C	; 12
    43e8:	30 e0       	ldi	r19, 0x00	; 0
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    43ea:	21 50       	subi	r18, 0x01	; 1
    43ec:	30 40       	sbci	r19, 0x00	; 0
    43ee:	09 f4       	brne	.+2      	; 0x43f2 <f_open+0x5a4>
    43f0:	85 c0       	rjmp	.+266    	; 0x44fc <f_open+0x6ae>
    43f2:	41 91       	ld	r20, Z+
    43f4:	9d 91       	ld	r25, X+
    43f6:	49 17       	cp	r20, r25
    43f8:	c1 f3       	breq	.-16     	; 0x43ea <f_open+0x59c>
    43fa:	c9 88       	ldd	r12, Y+17	; 0x11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    43fc:	da 88       	ldd	r13, Y+18	; 0x12
    43fe:	08 94       	sec
    4400:	c1 1c       	adc	r12, r1
    4402:	d1 1c       	adc	r13, r1
    4404:	c1 14       	cp	r12, r1
    4406:	d1 04       	cpc	r13, r1
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    4408:	09 f4       	brne	.+2      	; 0x440c <f_open+0x5be>
    440a:	77 c0       	rjmp	.+238    	; 0x44fa <f_open+0x6ac>
    440c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    440e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4410:	ad 8d       	ldd	r26, Y+29	; 0x1d
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    4412:	be 8d       	ldd	r27, Y+30	; 0x1e
    4414:	00 97       	sbiw	r24, 0x00	; 0
    4416:	a1 05       	cpc	r26, r1
    4418:	b1 05       	cpc	r27, r1
    441a:	09 f4       	brne	.+2      	; 0x441e <f_open+0x5d0>
    441c:	6e c0       	rjmp	.+220    	; 0x44fa <f_open+0x6ac>
    441e:	1f e0       	ldi	r17, 0x0F	; 15
    4420:	a1 2e       	mov	r10, r17
    4422:	b1 2c       	mov	r11, r1
    4424:	ac 20       	and	r10, r12
    4426:	bd 20       	and	r11, r13
    4428:	a1 14       	cp	r10, r1
    442a:	b1 04       	cpc	r11, r1
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    442c:	09 f0       	breq	.+2      	; 0x4430 <f_open+0x5e2>
    442e:	50 c0       	rjmp	.+160    	; 0x44d0 <f_open+0x682>
    4430:	01 96       	adiw	r24, 0x01	; 1
    4432:	a1 1d       	adc	r26, r1
    4434:	b1 1d       	adc	r27, r1
    4436:	8b 8f       	std	Y+27, r24	; 0x1b
    4438:	9c 8f       	std	Y+28, r25	; 0x1c
    443a:	ad 8f       	std	Y+29, r26	; 0x1d
    443c:	be 8f       	std	Y+30, r27	; 0x1e
		dj->sect++;					/* Next sector */
    443e:	4f 89       	ldd	r20, Y+23	; 0x17
    4440:	58 8d       	ldd	r21, Y+24	; 0x18
    4442:	69 8d       	ldd	r22, Y+25	; 0x19
    4444:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4446:	ed 85       	ldd	r30, Y+13	; 0x0d
    4448:	fe 85       	ldd	r31, Y+14	; 0x0e
    444a:	41 15       	cp	r20, r1

		if (dj->clust == 0) {	/* Static table */
    444c:	51 05       	cpc	r21, r1
    444e:	61 05       	cpc	r22, r1
    4450:	71 05       	cpc	r23, r1
    4452:	39 f4       	brne	.+14     	; 0x4462 <f_open+0x614>
    4454:	80 85       	ldd	r24, Z+8	; 0x08
    4456:	91 85       	ldd	r25, Z+9	; 0x09
    4458:	c8 16       	cp	r12, r24
    445a:	d9 06       	cpc	r13, r25
    445c:	08 f0       	brcs	.+2      	; 0x4460 <f_open+0x612>
    445e:	4d c0       	rjmp	.+154    	; 0x44fa <f_open+0x6ac>
    4460:	37 c0       	rjmp	.+110    	; 0x44d0 <f_open+0x682>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    4462:	82 81       	ldd	r24, Z+2	; 0x02
    4464:	90 e0       	ldi	r25, 0x00	; 0
    4466:	01 97       	sbiw	r24, 0x01	; 1
    4468:	96 01       	movw	r18, r12
    446a:	a4 e0       	ldi	r26, 0x04	; 4
    446c:	36 95       	lsr	r19
    446e:	27 95       	ror	r18
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    4470:	aa 95       	dec	r26
    4472:	e1 f7       	brne	.-8      	; 0x446c <f_open+0x61e>
    4474:	82 23       	and	r24, r18
    4476:	93 23       	and	r25, r19
    4478:	00 97       	sbiw	r24, 0x00	; 0
    447a:	51 f5       	brne	.+84     	; 0x44d0 <f_open+0x682>
    447c:	cf 01       	movw	r24, r30
    447e:	88 db       	rcall	.-2288   	; 0x3b90 <get_fat>
    4480:	ab 01       	movw	r20, r22
    4482:	bc 01       	movw	r22, r24
    4484:	42 30       	cpi	r20, 0x02	; 2
    4486:	51 05       	cpc	r21, r1
    4488:	61 05       	cpc	r22, r1
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    448a:	71 05       	cpc	r23, r1
    448c:	90 f1       	brcs	.+100    	; 0x44f2 <f_open+0x6a4>
    448e:	4f 3f       	cpi	r20, 0xFF	; 255
    4490:	ff ef       	ldi	r31, 0xFF	; 255
    4492:	5f 07       	cpc	r21, r31
				if (clst <= 1) return FR_INT_ERR;
    4494:	ff ef       	ldi	r31, 0xFF	; 255
    4496:	6f 07       	cpc	r22, r31
    4498:	ff ef       	ldi	r31, 0xFF	; 255
    449a:	7f 07       	cpc	r23, r31
    449c:	61 f1       	breq	.+88     	; 0x44f6 <f_open+0x6a8>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    449e:	8d 85       	ldd	r24, Y+13	; 0x0d
    44a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    44a2:	dc 01       	movw	r26, r24
    44a4:	1a 96       	adiw	r26, 0x0a	; 10
    44a6:	0d 91       	ld	r16, X+
    44a8:	1d 91       	ld	r17, X+
    44aa:	2d 91       	ld	r18, X+
    44ac:	3c 91       	ld	r19, X
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    44ae:	1d 97       	sbiw	r26, 0x0d	; 13
    44b0:	40 17       	cp	r20, r16
    44b2:	51 07       	cpc	r21, r17
    44b4:	62 07       	cpc	r22, r18
    44b6:	73 07       	cpc	r23, r19
    44b8:	00 f5       	brcc	.+64     	; 0x44fa <f_open+0x6ac>
    44ba:	4f 8b       	std	Y+23, r20	; 0x17
    44bc:	58 8f       	std	Y+24, r21	; 0x18
    44be:	69 8f       	std	Y+25, r22	; 0x19
    44c0:	7a 8f       	std	Y+26, r23	; 0x1a
    44c2:	32 db       	rcall	.-2460   	; 0x3b28 <clust2sect>
    44c4:	dc 01       	movw	r26, r24
    44c6:	cb 01       	movw	r24, r22
    44c8:	8b 8f       	std	Y+27, r24	; 0x1b
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    44ca:	9c 8f       	std	Y+28, r25	; 0x1c
    44cc:	ad 8f       	std	Y+29, r26	; 0x1d
    44ce:	be 8f       	std	Y+30, r27	; 0x1e
    44d0:	da 8a       	std	Y+18, r13	; 0x12
				dj->sect = clust2sect(dj->fs, clst);
    44d2:	c9 8a       	std	Y+17, r12	; 0x11
    44d4:	2d 85       	ldd	r18, Y+13	; 0x0d
    44d6:	3e 85       	ldd	r19, Y+14	; 0x0e
    44d8:	2e 5d       	subi	r18, 0xDE	; 222
    44da:	3f 4f       	sbci	r19, 0xFF	; 255
    44dc:	c5 01       	movw	r24, r10
    44de:	45 e0       	ldi	r20, 0x05	; 5
    44e0:	88 0f       	add	r24, r24
			}
		}
	}

	dj->index = i;
    44e2:	99 1f       	adc	r25, r25
    44e4:	4a 95       	dec	r20
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    44e6:	e1 f7       	brne	.-8      	; 0x44e0 <f_open+0x692>
    44e8:	28 0f       	add	r18, r24
    44ea:	39 1f       	adc	r19, r25
    44ec:	38 a3       	lds	r19, 0x58
    44ee:	2f 8f       	std	Y+31, r18	; 0x1f
    44f0:	65 cf       	rjmp	.-310    	; 0x43bc <f_open+0x56e>
    44f2:	82 e0       	ldi	r24, 0x02	; 2
    44f4:	03 c0       	rjmp	.+6      	; 0x44fc <f_open+0x6ae>
    44f6:	81 e0       	ldi	r24, 0x01	; 1
    44f8:	01 c0       	rjmp	.+2      	; 0x44fc <f_open+0x6ae>
    44fa:	84 e0       	ldi	r24, 0x04	; 4
    44fc:	e9 a1       	lds	r30, 0x49
    44fe:	fa a1       	lds	r31, 0x4a
    4500:	93 85       	ldd	r25, Z+11	; 0x0b
    4502:	88 23       	and	r24, r24
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    4504:	31 f0       	breq	.+12     	; 0x4512 <f_open+0x6c4>
    4506:	08 2f       	mov	r16, r24
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    4508:	04 30       	cpi	r16, 0x04	; 4
    450a:	e9 f4       	brne	.+58     	; 0x4546 <f_open+0x6f8>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    450c:	92 ff       	sbrs	r25, 2
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    450e:	18 c0       	rjmp	.+48     	; 0x4540 <f_open+0x6f2>
    4510:	1a c0       	rjmp	.+52     	; 0x4546 <f_open+0x6f8>
    4512:	92 fd       	sbrc	r25, 2
			if (res != FR_OK) {				/* Failed to find the object */
    4514:	17 c0       	rjmp	.+46     	; 0x4544 <f_open+0x6f6>
    4516:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4518:	78 a1       	lds	r23, 0x48
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    451a:	fb 01       	movw	r30, r22
    451c:	83 85       	ldd	r24, Z+11	; 0x0b
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    451e:	84 ff       	sbrs	r24, 4
    4520:	0f c0       	rjmp	.+30     	; 0x4540 <f_open+0x6f2>
    4522:	84 0c       	add	r8, r4
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    4524:	95 1c       	adc	r9, r5
    4526:	ed 85       	ldd	r30, Y+13	; 0x0d
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    4528:	fe 85       	ldd	r31, Y+14	; 0x0e
    452a:	80 81       	ld	r24, Z
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    452c:	e4 da       	rcall	.-2616   	; 0x3af6 <ld_clust.isra.0>
    452e:	dc 01       	movw	r26, r24
    4530:	cb 01       	movw	r24, r22
    4532:	8b 8b       	std	Y+19, r24	; 0x13
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    4534:	9c 8b       	std	Y+20, r25	; 0x14
    4536:	ad 8b       	std	Y+21, r26	; 0x15
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    4538:	be 8b       	std	Y+22, r27	; 0x16
    453a:	91 ce       	rjmp	.-734    	; 0x425e <f_open+0x410>
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    453c:	06 e0       	ldi	r16, 0x06	; 6
    453e:	03 c0       	rjmp	.+6      	; 0x4546 <f_open+0x6f8>
    4540:	05 e0       	ldi	r16, 0x05	; 5
    4542:	01 c0       	rjmp	.+2      	; 0x4546 <f_open+0x6f8>
    4544:	08 2f       	mov	r16, r24
    4546:	cf 8c       	ldd	r12, Y+31	; 0x1f
    4548:	d8 a0       	lds	r29, 0x88
    454a:	00 23       	and	r16, r16
    454c:	71 f4       	brne	.+28     	; 0x456a <f_open+0x71c>
    454e:	c1 14       	cp	r12, r1
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    4550:	d1 04       	cpc	r13, r1
    4552:	41 f0       	breq	.+16     	; 0x4564 <f_open+0x716>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    4554:	d6 01       	movw	r26, r12
    4556:	1b 96       	adiw	r26, 0x0b	; 11
    4558:	8c 91       	ld	r24, X
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
    455a:	1b 97       	sbiw	r26, 0x0b	; 11
    455c:	84 ff       	sbrs	r24, 4
			if (!fp->lockid) res = FR_INT_ERR;
#endif
		}

#else				/* R/O configuration */
		if (res == FR_OK) {					/* Follow succeeded */
    455e:	29 c0       	rjmp	.+82     	; 0x45b2 <f_open+0x764>
    4560:	04 e0       	ldi	r16, 0x04	; 4
			dir = dj.dir;
			if (!dir) {						/* Current dir itself */
    4562:	03 c0       	rjmp	.+6      	; 0x456a <f_open+0x71c>
    4564:	06 e0       	ldi	r16, 0x06	; 6
    4566:	01 c0       	rjmp	.+2      	; 0x456a <f_open+0x71c>
				res = FR_INVALID_NAME;
			} else {
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
    4568:	09 e0       	ldi	r16, 0x09	; 9
    456a:	80 2f       	mov	r24, r16
    456c:	e5 96       	adiw	r28, 0x35	; 53
    456e:	0f b6       	in	r0, 0x3f	; 63
    4570:	f8 94       	cli
    4572:	de bf       	out	0x3e, r29	; 62
					res = FR_NO_FILE;
    4574:	0f be       	out	0x3f, r0	; 63
    4576:	cd bf       	out	0x3d, r28	; 61

#else				/* R/O configuration */
		if (res == FR_OK) {					/* Follow succeeded */
			dir = dj.dir;
			if (!dir) {						/* Current dir itself */
				res = FR_INVALID_NAME;
    4578:	df 91       	pop	r29
    457a:	cf 91       	pop	r28
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    457c:	1f 91       	pop	r17
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    457e:	0f 91       	pop	r16
    4580:	ff 90       	pop	r15
    4582:	ef 90       	pop	r14
    4584:	df 90       	pop	r13
    4586:	cf 90       	pop	r12
    4588:	bf 90       	pop	r11
    458a:	af 90       	pop	r10
    458c:	9f 90       	pop	r9
    458e:	8f 90       	pop	r8
    4590:	7f 90       	pop	r7
    4592:	6f 90       	pop	r6
    4594:	5f 90       	pop	r5
    4596:	4f 90       	pop	r4
    4598:	3f 90       	pop	r3
    459a:	2f 90       	pop	r2
    459c:	08 95       	ret
    459e:	ce 01       	movw	r24, r28
    45a0:	01 96       	adiw	r24, 0x01	; 1
    45a2:	9a a3       	lds	r25, 0x5a
    45a4:	89 a3       	lds	r24, 0x59
    45a6:	f4 01       	movw	r30, r8
    45a8:	80 81       	ld	r24, Z
    45aa:	8f 32       	cpi	r24, 0x2F	; 47
    45ac:	09 f0       	breq	.+2      	; 0x45b0 <f_open+0x762>
    45ae:	3f ce       	rjmp	.-898    	; 0x422e <f_open+0x3e0>
    45b0:	40 ce       	rjmp	.-896    	; 0x4232 <f_open+0x3e4>
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
    45b2:	8d a9       	sts	0x4d, r24
    45b4:	81 70       	andi	r24, 0x01	; 1
    45b6:	ab a1       	lds	r26, 0x4b
    45b8:	bc a1       	lds	r27, 0x4c
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    45ba:	14 96       	adiw	r26, 0x04	; 4
    45bc:	8c 93       	st	X, r24
    45be:	ad 84       	ldd	r10, Y+13	; 0x0d
    45c0:	be 84       	ldd	r11, Y+14	; 0x0e
    45c2:	f5 01       	movw	r30, r10
    45c4:	80 81       	ld	r24, Z

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
    45c6:	b6 01       	movw	r22, r12
    45c8:	96 da       	rcall	.-2772   	; 0x3af6 <ld_clust.isra.0>
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    45ca:	dc 01       	movw	r26, r24
    45cc:	cb 01       	movw	r24, r22
    45ce:	eb a1       	lds	r30, 0x4b
    45d0:	fc a1       	lds	r31, 0x4c
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    45d2:	86 87       	std	Z+14, r24	; 0x0e
    45d4:	97 87       	std	Z+15, r25	; 0x0f
    45d6:	a0 8b       	std	Z+16, r26	; 0x10
    45d8:	b1 8b       	std	Z+17, r27	; 0x11
    45da:	f6 01       	movw	r30, r12
    45dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    45de:	95 8d       	ldd	r25, Z+29	; 0x1d
    45e0:	a6 8d       	ldd	r26, Z+30	; 0x1e
    45e2:	b7 8d       	ldd	r27, Z+31	; 0x1f
    45e4:	eb a1       	lds	r30, 0x4b
    45e6:	fc a1       	lds	r31, 0x4c
    45e8:	82 87       	std	Z+10, r24	; 0x0a
    45ea:	93 87       	std	Z+11, r25	; 0x0b
    45ec:	a4 87       	std	Z+12, r26	; 0x0c
    45ee:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    45f0:	16 82       	std	Z+6, r1	; 0x06
    45f2:	17 82       	std	Z+7, r1	; 0x07
    45f4:	10 86       	std	Z+8, r1	; 0x08
    45f6:	11 86       	std	Z+9, r1	; 0x09
    45f8:	16 8a       	std	Z+22, r1	; 0x16
    45fa:	17 8a       	std	Z+23, r1	; 0x17
    45fc:	10 8e       	std	Z+24, r1	; 0x18
    45fe:	11 8e       	std	Z+25, r1	; 0x19
    4600:	b1 82       	std	Z+1, r11	; 0x01
    4602:	a0 82       	st	Z, r10
    4604:	d5 01       	movw	r26, r10
			fp->fptr = 0;						/* File pointer */
    4606:	16 96       	adiw	r26, 0x06	; 6
    4608:	8d 91       	ld	r24, X+
    460a:	9c 91       	ld	r25, X
    460c:	17 97       	sbiw	r26, 0x07	; 7
			fp->dsect = 0;
    460e:	93 83       	std	Z+3, r25	; 0x03
    4610:	82 83       	std	Z+2, r24	; 0x02
    4612:	ab cf       	rjmp	.-170    	; 0x456a <f_open+0x71c>

00004614 <f_read>:
    4614:	2f 92       	push	r2
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    4616:	3f 92       	push	r3
    4618:	4f 92       	push	r4
    461a:	5f 92       	push	r5
    461c:	6f 92       	push	r6
    461e:	7f 92       	push	r7
    4620:	8f 92       	push	r8
    4622:	9f 92       	push	r9
    4624:	bf 92       	push	r11
    4626:	cf 92       	push	r12
    4628:	df 92       	push	r13
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    462a:	ef 92       	push	r14
    462c:	ff 92       	push	r15
    462e:	0f 93       	push	r16
    4630:	1f 93       	push	r17
    4632:	cf 93       	push	r28
    4634:	df 93       	push	r29
    4636:	ec 01       	movw	r28, r24
    4638:	e6 2e       	mov	r14, r22
    463a:	07 2f       	mov	r16, r23
    463c:	4a 01       	movw	r8, r20
    463e:	29 01       	movw	r4, r18
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    4640:	d9 01       	movw	r26, r18
    4642:	1d 92       	st	X+, r1
    4644:	1c 92       	st	X, r1

	res = validate(fp);							/* Check validity */
    4646:	c8 d9       	rcall	.-3184   	; 0x39d8 <validate>
    4648:	b8 2e       	mov	r11, r24
    464a:	88 23       	and	r24, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    464c:	09 f0       	breq	.+2      	; 0x4650 <f_read+0x3c>
    464e:	01 c1       	rjmp	.+514    	; 0x4852 <f_read+0x23e>
    4650:	8c 81       	ldd	r24, Y+4	; 0x04
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    4652:	87 fd       	sbrc	r24, 7
    4654:	f9 c0       	rjmp	.+498    	; 0x4848 <f_read+0x234>
    4656:	80 ff       	sbrs	r24, 0
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    4658:	fa c0       	rjmp	.+500    	; 0x484e <f_read+0x23a>
    465a:	4a 85       	ldd	r20, Y+10	; 0x0a
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    465c:	5b 85       	ldd	r21, Y+11	; 0x0b
    465e:	6c 85       	ldd	r22, Y+12	; 0x0c
    4660:	7d 85       	ldd	r23, Y+13	; 0x0d
    4662:	8e 81       	ldd	r24, Y+6	; 0x06
    4664:	9f 81       	ldd	r25, Y+7	; 0x07
    4666:	a8 85       	ldd	r26, Y+8	; 0x08
    4668:	b9 85       	ldd	r27, Y+9	; 0x09
    466a:	48 1b       	sub	r20, r24
    466c:	59 0b       	sbc	r21, r25
    466e:	6a 0b       	sbc	r22, r26
    4670:	7b 0b       	sbc	r23, r27
    4672:	c4 01       	movw	r24, r8
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    4674:	a0 e0       	ldi	r26, 0x00	; 0
    4676:	b0 e0       	ldi	r27, 0x00	; 0
    4678:	48 17       	cp	r20, r24
    467a:	59 07       	cpc	r21, r25
    467c:	6a 07       	cpc	r22, r26
    467e:	7b 07       	cpc	r23, r27
    4680:	08 f4       	brcc	.+2      	; 0x4684 <f_read+0x70>
    4682:	4a 01       	movw	r8, r20
    4684:	6e 2c       	mov	r6, r14
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    4686:	70 2e       	mov	r7, r16
    4688:	21 2c       	mov	r2, r1
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    468a:	f2 e0       	ldi	r31, 0x02	; 2
    468c:	3f 2e       	mov	r3, r31
    468e:	d7 c0       	rjmp	.+430    	; 0x483e <f_read+0x22a>
    4690:	0e 81       	ldd	r16, Y+6	; 0x06
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    4692:	1f 81       	ldd	r17, Y+7	; 0x07
    4694:	28 85       	ldd	r18, Y+8	; 0x08
    4696:	39 85       	ldd	r19, Y+9	; 0x09
    4698:	d9 01       	movw	r26, r18
    469a:	c8 01       	movw	r24, r16
    469c:	91 70       	andi	r25, 0x01	; 1
    469e:	a0 70       	andi	r26, 0x00	; 0
    46a0:	b0 70       	andi	r27, 0x00	; 0
    46a2:	00 97       	sbiw	r24, 0x00	; 0
    46a4:	a1 05       	cpc	r26, r1
    46a6:	b1 05       	cpc	r27, r1
    46a8:	09 f0       	breq	.+2      	; 0x46ac <f_read+0x98>
    46aa:	71 c0       	rjmp	.+226    	; 0x478e <f_read+0x17a>
    46ac:	88 81       	ld	r24, Y
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    46ae:	99 81       	ldd	r25, Y+1	; 0x01
    46b0:	b9 01       	movw	r22, r18
    46b2:	a8 01       	movw	r20, r16
    46b4:	e9 e0       	ldi	r30, 0x09	; 9
    46b6:	76 95       	lsr	r23
    46b8:	67 95       	ror	r22
    46ba:	57 95       	ror	r21
    46bc:	47 95       	ror	r20
    46be:	ea 95       	dec	r30
    46c0:	d1 f7       	brne	.-12     	; 0x46b6 <f_read+0xa2>
    46c2:	fc 01       	movw	r30, r24
    46c4:	c2 80       	ldd	r12, Z+2	; 0x02
    46c6:	ca 94       	dec	r12
    46c8:	c4 22       	and	r12, r20
    46ca:	19 f5       	brne	.+70     	; 0x4712 <f_read+0xfe>
			if (!csect) {						/* On the cluster boundary? */
    46cc:	01 15       	cp	r16, r1
				if (fp->fptr == 0) {			/* On the top of the file? */
    46ce:	11 05       	cpc	r17, r1
    46d0:	21 05       	cpc	r18, r1
    46d2:	31 05       	cpc	r19, r1
    46d4:	29 f4       	brne	.+10     	; 0x46e0 <f_read+0xcc>
    46d6:	8e 85       	ldd	r24, Y+14	; 0x0e
					clst = fp->sclust;			/* Follow from the origin */
    46d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    46da:	a8 89       	ldd	r26, Y+16	; 0x10
    46dc:	b9 89       	ldd	r27, Y+17	; 0x11
    46de:	07 c0       	rjmp	.+14     	; 0x46ee <f_read+0xda>
    46e0:	4a 89       	ldd	r20, Y+18	; 0x12
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    46e2:	5b 89       	ldd	r21, Y+19	; 0x13
    46e4:	6c 89       	ldd	r22, Y+20	; 0x14
    46e6:	7d 89       	ldd	r23, Y+21	; 0x15
    46e8:	53 da       	rcall	.-2906   	; 0x3b90 <get_fat>
    46ea:	dc 01       	movw	r26, r24
    46ec:	cb 01       	movw	r24, r22
    46ee:	82 30       	cpi	r24, 0x02	; 2
    46f0:	91 05       	cpc	r25, r1
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    46f2:	a1 05       	cpc	r26, r1
    46f4:	b1 05       	cpc	r27, r1
    46f6:	d8 f0       	brcs	.+54     	; 0x472e <f_read+0x11a>
    46f8:	8f 3f       	cpi	r24, 0xFF	; 255
    46fa:	ff ef       	ldi	r31, 0xFF	; 255
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    46fc:	9f 07       	cpc	r25, r31
    46fe:	ff ef       	ldi	r31, 0xFF	; 255
    4700:	af 07       	cpc	r26, r31
    4702:	ff ef       	ldi	r31, 0xFF	; 255
    4704:	bf 07       	cpc	r27, r31
    4706:	09 f4       	brne	.+2      	; 0x470a <f_read+0xf6>
    4708:	4f c0       	rjmp	.+158    	; 0x47a8 <f_read+0x194>
    470a:	8a 8b       	std	Y+18, r24	; 0x12
    470c:	9b 8b       	std	Y+19, r25	; 0x13
				fp->clust = clst;				/* Update current cluster */
    470e:	ac 8b       	std	Y+20, r26	; 0x14
    4710:	bd 8b       	std	Y+21, r27	; 0x15
    4712:	08 81       	ld	r16, Y
    4714:	19 81       	ldd	r17, Y+1	; 0x01
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    4716:	4a 89       	ldd	r20, Y+18	; 0x12
    4718:	5b 89       	ldd	r21, Y+19	; 0x13
    471a:	6c 89       	ldd	r22, Y+20	; 0x14
    471c:	7d 89       	ldd	r23, Y+21	; 0x15
    471e:	c8 01       	movw	r24, r16
    4720:	03 da       	rcall	.-3066   	; 0x3b28 <clust2sect>
    4722:	dc 01       	movw	r26, r24
    4724:	cb 01       	movw	r24, r22
    4726:	00 97       	sbiw	r24, 0x00	; 0
    4728:	a1 05       	cpc	r26, r1
    472a:	b1 05       	cpc	r27, r1
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    472c:	21 f4       	brne	.+8      	; 0x4736 <f_read+0x122>
    472e:	8c 81       	ldd	r24, Y+4	; 0x04
    4730:	80 68       	ori	r24, 0x80	; 128
    4732:	8c 83       	std	Y+4, r24	; 0x04
    4734:	89 c0       	rjmp	.+274    	; 0x4848 <f_read+0x234>
    4736:	9c 01       	movw	r18, r24
    4738:	ad 01       	movw	r20, r26
    473a:	2c 0d       	add	r18, r12
			sect += csect;
    473c:	31 1d       	adc	r19, r1
    473e:	41 1d       	adc	r20, r1
    4740:	51 1d       	adc	r21, r1
    4742:	74 01       	movw	r14, r8
    4744:	ef 2c       	mov	r14, r15
    4746:	ff 24       	eor	r15, r15
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    4748:	e6 94       	lsr	r14
    474a:	e1 14       	cp	r14, r1
    474c:	f1 04       	cpc	r15, r1
    474e:	d9 f0       	breq	.+54     	; 0x4786 <f_read+0x172>
			if (cc) {							/* Read maximum contiguous sectors directly */
    4750:	d8 01       	movw	r26, r16
    4752:	12 96       	adiw	r26, 0x02	; 2
    4754:	8c 91       	ld	r24, X
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    4756:	12 97       	sbiw	r26, 0x02	; 2
    4758:	dd 24       	eor	r13, r13
    475a:	b7 01       	movw	r22, r14
    475c:	6c 0d       	add	r22, r12
    475e:	7d 1d       	adc	r23, r13
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	86 17       	cp	r24, r22
    4764:	97 07       	cpc	r25, r23
    4766:	18 f4       	brcc	.+6      	; 0x476e <f_read+0x15a>
    4768:	7c 01       	movw	r14, r24
    476a:	ec 18       	sub	r14, r12
    476c:	fd 08       	sbc	r15, r13
					cc = fp->fs->csize - csect;
    476e:	f8 01       	movw	r30, r16
    4770:	81 81       	ldd	r24, Z+1	; 0x01
    4772:	b3 01       	movw	r22, r6
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    4774:	0e 2d       	mov	r16, r14
    4776:	24 d9       	rcall	.-3512   	; 0x39c0 <disk_read>
    4778:	88 23       	and	r24, r24
    477a:	b1 f4       	brne	.+44     	; 0x47a8 <f_read+0x194>
    477c:	97 01       	movw	r18, r14
    477e:	32 2f       	mov	r19, r18
    4780:	22 27       	eor	r18, r18
    4782:	33 0f       	add	r19, r19
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    4784:	42 c0       	rjmp	.+132    	; 0x480a <f_read+0x1f6>
    4786:	2e 8b       	std	Y+22, r18	; 0x16
    4788:	3f 8b       	std	Y+23, r19	; 0x17
    478a:	48 8f       	std	Y+24, r20	; 0x18
				continue;
    478c:	59 8f       	std	Y+25, r21	; 0x19
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    478e:	ce 80       	ldd	r12, Y+6	; 0x06
    4790:	df 80       	ldd	r13, Y+7	; 0x07
    4792:	e8 84       	ldd	r14, Y+8	; 0x08
    4794:	f9 84       	ldd	r15, Y+9	; 0x09
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    4796:	4e 89       	ldd	r20, Y+22	; 0x16
    4798:	5f 89       	ldd	r21, Y+23	; 0x17
    479a:	68 8d       	ldd	r22, Y+24	; 0x18
    479c:	79 8d       	ldd	r23, Y+25	; 0x19
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    479e:	88 81       	ld	r24, Y
    47a0:	99 81       	ldd	r25, Y+1	; 0x01
    47a2:	36 d9       	rcall	.-3476   	; 0x3a10 <move_window>
    47a4:	88 23       	and	r24, r24
    47a6:	31 f0       	breq	.+12     	; 0x47b4 <f_read+0x1a0>
    47a8:	8c 81       	ldd	r24, Y+4	; 0x04
    47aa:	80 68       	ori	r24, 0x80	; 128
    47ac:	8c 83       	std	Y+4, r24	; 0x04
    47ae:	bb 24       	eor	r11, r11
    47b0:	b3 94       	inc	r11
			ABORT(fp->fs, FR_DISK_ERR);
    47b2:	4f c0       	rjmp	.+158    	; 0x4852 <f_read+0x23e>
    47b4:	c6 01       	movw	r24, r12
    47b6:	91 70       	andi	r25, 0x01	; 1
    47b8:	91 01       	movw	r18, r2
    47ba:	28 1b       	sub	r18, r24
    47bc:	39 0b       	sbc	r19, r25
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    47be:	c9 01       	movw	r24, r18
    47c0:	94 01       	movw	r18, r8
    47c2:	88 15       	cp	r24, r8
    47c4:	99 05       	cpc	r25, r9
    47c6:	08 f4       	brcc	.+2      	; 0x47ca <f_read+0x1b6>
    47c8:	9c 01       	movw	r18, r24
    47ca:	8e 81       	ldd	r24, Y+6	; 0x06
    47cc:	9f 81       	ldd	r25, Y+7	; 0x07
    47ce:	91 70       	andi	r25, 0x01	; 1
    47d0:	82 96       	adiw	r24, 0x22	; 34
    47d2:	48 81       	ld	r20, Y
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    47d4:	59 81       	ldd	r21, Y+1	; 0x01
    47d6:	48 0f       	add	r20, r24
    47d8:	59 1f       	adc	r21, r25
    47da:	fa 01       	movw	r30, r20
    47dc:	d3 01       	movw	r26, r6
    47de:	c9 01       	movw	r24, r18
    47e0:	05 c0       	rjmp	.+10     	; 0x47ec <f_read+0x1d8>
    47e2:	61 91       	ld	r22, Z+

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
    47e4:	71 91       	ld	r23, Z+
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    47e6:	6d 93       	st	X+, r22
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    47e8:	7d 93       	st	X+, r23
    47ea:	02 97       	sbiw	r24, 0x02	; 2
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
		*(int*)d = *(int*)s;
    47ec:	82 30       	cpi	r24, 0x02	; 2
    47ee:	91 05       	cpc	r25, r1
    47f0:	c0 f7       	brcc	.-16     	; 0x47e2 <f_read+0x1ce>
    47f2:	c9 01       	movw	r24, r18
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
    47f4:	8e 7f       	andi	r24, 0xFE	; 254
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
    47f6:	f3 01       	movw	r30, r6
    47f8:	e8 0f       	add	r30, r24
    47fa:	f9 1f       	adc	r31, r25

/*-----------------------------------------------------------------------*/
/* Read File                                                             */
/*-----------------------------------------------------------------------*/

FRESULT f_read (
    47fc:	84 0f       	add	r24, r20
    47fe:	95 1f       	adc	r25, r21
    4800:	20 ff       	sbrs	r18, 0
    4802:	03 c0       	rjmp	.+6      	; 0x480a <f_read+0x1f6>
    4804:	dc 01       	movw	r26, r24
    4806:	8c 91       	ld	r24, X
    4808:	80 83       	st	Z, r24
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    480a:	62 0e       	add	r6, r18
    480c:	73 1e       	adc	r7, r19
		*d++ = *s++;
    480e:	a9 01       	movw	r20, r18
    4810:	60 e0       	ldi	r22, 0x00	; 0
    4812:	70 e0       	ldi	r23, 0x00	; 0
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    4814:	8e 81       	ldd	r24, Y+6	; 0x06
    4816:	9f 81       	ldd	r25, Y+7	; 0x07
    4818:	a8 85       	ldd	r26, Y+8	; 0x08
    481a:	b9 85       	ldd	r27, Y+9	; 0x09
    481c:	84 0f       	add	r24, r20
    481e:	95 1f       	adc	r25, r21
    4820:	a6 1f       	adc	r26, r22
    4822:	b7 1f       	adc	r27, r23
    4824:	8e 83       	std	Y+6, r24	; 0x06
    4826:	9f 83       	std	Y+7, r25	; 0x07
    4828:	a8 87       	std	Y+8, r26	; 0x08
    482a:	b9 87       	std	Y+9, r27	; 0x09
    482c:	f2 01       	movw	r30, r4
    482e:	80 81       	ld	r24, Z
    4830:	91 81       	ldd	r25, Z+1	; 0x01
    4832:	82 0f       	add	r24, r18
    4834:	93 1f       	adc	r25, r19
    4836:	91 83       	std	Z+1, r25	; 0x01
    4838:	80 83       	st	Z, r24
    483a:	82 1a       	sub	r8, r18
    483c:	93 0a       	sbc	r9, r19
    483e:	81 14       	cp	r8, r1
    4840:	91 04       	cpc	r9, r1
    4842:	09 f0       	breq	.+2      	; 0x4846 <f_read+0x232>
    4844:	25 cf       	rjmp	.-438    	; 0x4690 <f_read+0x7c>
    4846:	05 c0       	rjmp	.+10     	; 0x4852 <f_read+0x23e>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    4848:	a2 e0       	ldi	r26, 0x02	; 2
    484a:	ba 2e       	mov	r11, r26
    484c:	02 c0       	rjmp	.+4      	; 0x4852 <f_read+0x23e>
    484e:	f7 e0       	ldi	r31, 0x07	; 7
    4850:	bf 2e       	mov	r11, r31
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4852:	8b 2d       	mov	r24, r11
    4854:	df 91       	pop	r29
    4856:	cf 91       	pop	r28
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    4858:	1f 91       	pop	r17
    485a:	0f 91       	pop	r16
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    485c:	ff 90       	pop	r15
    485e:	ef 90       	pop	r14
    4860:	df 90       	pop	r13
    4862:	cf 90       	pop	r12
    4864:	bf 90       	pop	r11
    4866:	9f 90       	pop	r9
    4868:	8f 90       	pop	r8
    486a:	7f 90       	pop	r7
    486c:	6f 90       	pop	r6
    486e:	5f 90       	pop	r5
    4870:	4f 90       	pop	r4
    4872:	3f 90       	pop	r3
    4874:	2f 90       	pop	r2
    4876:	08 95       	ret

00004878 <f_close>:
    4878:	cf 93       	push	r28
    487a:	df 93       	push	r29
    487c:	ec 01       	movw	r28, r24
    487e:	ac d8       	rcall	.-3752   	; 0x39d8 <validate>
    4880:	88 23       	and	r24, r24
	res = validate(fp);
	{
#if _FS_REENTRANT
		FATFS *fs = fp->fs;
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    4882:	11 f4       	brne	.+4      	; 0x4888 <f_close+0x10>
    4884:	19 82       	std	Y+1, r1	; 0x01
    4886:	18 82       	st	Y, r1
    4888:	df 91       	pop	r29
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
    488a:	cf 91       	pop	r28
    488c:	08 95       	ret

0000488e <f_lseek>:
    488e:	2f 92       	push	r2

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    4890:	3f 92       	push	r3
    4892:	4f 92       	push	r4
    4894:	5f 92       	push	r5
    4896:	6f 92       	push	r6
    4898:	7f 92       	push	r7
    489a:	8f 92       	push	r8
    489c:	9f 92       	push	r9
    489e:	af 92       	push	r10
    48a0:	bf 92       	push	r11
    48a2:	cf 92       	push	r12
    48a4:	df 92       	push	r13
    48a6:	ef 92       	push	r14
    48a8:	ff 92       	push	r15
    48aa:	1f 93       	push	r17
    48ac:	cf 93       	push	r28
    48ae:	df 93       	push	r29
    48b0:	cd b7       	in	r28, 0x3d	; 61
    48b2:	de b7       	in	r29, 0x3e	; 62
    48b4:	28 97       	sbiw	r28, 0x08	; 8
    48b6:	0f b6       	in	r0, 0x3f	; 63
    48b8:	f8 94       	cli
    48ba:	de bf       	out	0x3e, r29	; 62
    48bc:	0f be       	out	0x3f, r0	; 63
    48be:	cd bf       	out	0x3d, r28	; 61
    48c0:	1c 01       	movw	r2, r24
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    48c2:	4d 83       	std	Y+5, r20	; 0x05
    48c4:	5e 83       	std	Y+6, r21	; 0x06
    48c6:	6f 83       	std	Y+7, r22	; 0x07
    48c8:	78 87       	std	Y+8, r23	; 0x08
    48ca:	86 d8       	rcall	.-3828   	; 0x39d8 <validate>
    48cc:	18 2f       	mov	r17, r24
    48ce:	4d 81       	ldd	r20, Y+5	; 0x05
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    48d0:	5e 81       	ldd	r21, Y+6	; 0x06
    48d2:	6f 81       	ldd	r22, Y+7	; 0x07
    48d4:	78 85       	ldd	r23, Y+8	; 0x08
    48d6:	88 23       	and	r24, r24
    48d8:	09 f0       	breq	.+2      	; 0x48dc <f_lseek+0x4e>
    48da:	22 c1       	rjmp	.+580    	; 0x4b20 <f_lseek+0x292>
    48dc:	d1 01       	movw	r26, r2
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    48de:	14 96       	adiw	r26, 0x04	; 4
    48e0:	8c 91       	ld	r24, X
    48e2:	14 97       	sbiw	r26, 0x04	; 4
    48e4:	87 fd       	sbrc	r24, 7
    48e6:	1b c1       	rjmp	.+566    	; 0x4b1e <f_lseek+0x290>
    48e8:	1a 96       	adiw	r26, 0x0a	; 10
    48ea:	8d 91       	ld	r24, X+
    48ec:	9d 91       	ld	r25, X+
    48ee:	0d 90       	ld	r0, X+
    48f0:	bc 91       	ld	r27, X
    48f2:	a0 2d       	mov	r26, r0
    48f4:	6a 01       	movw	r12, r20
    48f6:	7b 01       	movw	r14, r22
    48f8:	8c 15       	cp	r24, r12
    48fa:	9d 05       	cpc	r25, r13
    48fc:	ae 05       	cpc	r26, r14
    48fe:	bf 05       	cpc	r27, r15
    4900:	10 f4       	brcc	.+4      	; 0x4906 <f_lseek+0x78>
    4902:	6c 01       	movw	r12, r24
    4904:	7d 01       	movw	r14, r26
    4906:	f1 01       	movw	r30, r2
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    4908:	86 81       	ldd	r24, Z+6	; 0x06
    490a:	97 81       	ldd	r25, Z+7	; 0x07
    490c:	a0 85       	ldd	r26, Z+8	; 0x08
    490e:	b1 85       	ldd	r27, Z+9	; 0x09
    4910:	16 82       	std	Z+6, r1	; 0x06
		fp->fptr = nsect = 0;
    4912:	17 82       	std	Z+7, r1	; 0x07
    4914:	10 86       	std	Z+8, r1	; 0x08
    4916:	11 86       	std	Z+9, r1	; 0x09
    4918:	c1 14       	cp	r12, r1
		if (ofs) {
    491a:	d1 04       	cpc	r13, r1
    491c:	e1 04       	cpc	r14, r1
    491e:	f1 04       	cpc	r15, r1
    4920:	09 f4       	brne	.+2      	; 0x4924 <f_lseek+0x96>
    4922:	e0 c0       	rjmp	.+448    	; 0x4ae4 <f_lseek+0x256>
    4924:	20 81       	ld	r18, Z
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    4926:	31 81       	ldd	r19, Z+1	; 0x01
    4928:	f9 01       	movw	r30, r18
    492a:	82 80       	ldd	r8, Z+2	; 0x02
    492c:	99 24       	eor	r9, r9
    492e:	aa 24       	eor	r10, r10
    4930:	bb 24       	eor	r11, r11
    4932:	49 e0       	ldi	r20, 0x09	; 9
    4934:	88 0c       	add	r8, r8
    4936:	99 1c       	adc	r9, r9
    4938:	aa 1c       	adc	r10, r10
    493a:	bb 1c       	adc	r11, r11
    493c:	4a 95       	dec	r20
    493e:	d1 f7       	brne	.-12     	; 0x4934 <f_lseek+0xa6>
    4940:	00 97       	sbiw	r24, 0x00	; 0
			if (ifptr > 0 &&
    4942:	a1 05       	cpc	r26, r1
    4944:	b1 05       	cpc	r27, r1
    4946:	e9 f1       	breq	.+122    	; 0x49c2 <f_lseek+0x134>
    4948:	2c 01       	movw	r4, r24
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    494a:	3d 01       	movw	r6, r26
    494c:	08 94       	sec
    494e:	41 08       	sbc	r4, r1
    4950:	51 08       	sbc	r5, r1
    4952:	61 08       	sbc	r6, r1
    4954:	71 08       	sbc	r7, r1
    4956:	c7 01       	movw	r24, r14
    4958:	b6 01       	movw	r22, r12
    495a:	61 50       	subi	r22, 0x01	; 1
    495c:	70 40       	sbci	r23, 0x00	; 0
    495e:	80 40       	sbci	r24, 0x00	; 0
    4960:	90 40       	sbci	r25, 0x00	; 0
    4962:	a5 01       	movw	r20, r10
    4964:	94 01       	movw	r18, r8
    4966:	0e 94 1c 3c 	call	0x7838	; 0x7838 <__udivmodsi4>
    496a:	29 83       	std	Y+1, r18	; 0x01
    496c:	3a 83       	std	Y+2, r19	; 0x02
    496e:	4b 83       	std	Y+3, r20	; 0x03
    4970:	5c 83       	std	Y+4, r21	; 0x04
    4972:	c3 01       	movw	r24, r6
    4974:	b2 01       	movw	r22, r4
    4976:	a5 01       	movw	r20, r10
    4978:	94 01       	movw	r18, r8
    497a:	0e 94 1c 3c 	call	0x7838	; 0x7838 <__udivmodsi4>
    497e:	89 81       	ldd	r24, Y+1	; 0x01

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    4980:	9a 81       	ldd	r25, Y+2	; 0x02
    4982:	ab 81       	ldd	r26, Y+3	; 0x03
    4984:	bc 81       	ldd	r27, Y+4	; 0x04
    4986:	82 17       	cp	r24, r18
    4988:	93 07       	cpc	r25, r19
    498a:	a4 07       	cpc	r26, r20
    498c:	b5 07       	cpc	r27, r21
    498e:	c8 f0       	brcs	.+50     	; 0x49c2 <f_lseek+0x134>
    4990:	88 27       	eor	r24, r24
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    4992:	99 27       	eor	r25, r25
    4994:	dc 01       	movw	r26, r24
    4996:	88 19       	sub	r24, r8
    4998:	99 09       	sbc	r25, r9
    499a:	aa 09       	sbc	r26, r10
    499c:	bb 09       	sbc	r27, r11
    499e:	84 21       	and	r24, r4
    49a0:	95 21       	and	r25, r5
    49a2:	a6 21       	and	r26, r6
    49a4:	b7 21       	and	r27, r7
    49a6:	f1 01       	movw	r30, r2
    49a8:	86 83       	std	Z+6, r24	; 0x06
    49aa:	97 83       	std	Z+7, r25	; 0x07
    49ac:	a0 87       	std	Z+8, r26	; 0x08
    49ae:	b1 87       	std	Z+9, r27	; 0x09
    49b0:	c8 1a       	sub	r12, r24
				ofs -= fp->fptr;
    49b2:	d9 0a       	sbc	r13, r25
    49b4:	ea 0a       	sbc	r14, r26
    49b6:	fb 0a       	sbc	r15, r27
    49b8:	42 89       	ldd	r20, Z+18	; 0x12
				clst = fp->clust;
    49ba:	53 89       	ldd	r21, Z+19	; 0x13
    49bc:	64 89       	ldd	r22, Z+20	; 0x14
    49be:	75 89       	ldd	r23, Z+21	; 0x15
    49c0:	0c c0       	rjmp	.+24     	; 0x49da <f_lseek+0x14c>
    49c2:	d1 01       	movw	r26, r2
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    49c4:	1e 96       	adiw	r26, 0x0e	; 14
    49c6:	4d 91       	ld	r20, X+
    49c8:	5d 91       	ld	r21, X+
    49ca:	6d 91       	ld	r22, X+
    49cc:	7c 91       	ld	r23, X
    49ce:	51 97       	sbiw	r26, 0x11	; 17
    49d0:	f1 01       	movw	r30, r2
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
    49d2:	42 8b       	std	Z+18, r20	; 0x12
    49d4:	53 8b       	std	Z+19, r21	; 0x13
    49d6:	64 8b       	std	Z+20, r22	; 0x14
    49d8:	75 8b       	std	Z+21, r23	; 0x15
    49da:	41 15       	cp	r20, r1
			}
			if (clst != 0) {
    49dc:	51 05       	cpc	r21, r1
    49de:	61 05       	cpc	r22, r1
    49e0:	71 05       	cpc	r23, r1
    49e2:	09 f4       	brne	.+2      	; 0x49e6 <f_lseek+0x158>
    49e4:	7f c0       	rjmp	.+254    	; 0x4ae4 <f_lseek+0x256>
    49e6:	44 c0       	rjmp	.+136    	; 0x4a70 <f_lseek+0x1e2>
    49e8:	d1 01       	movw	r26, r2
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    49ea:	8d 91       	ld	r24, X+
    49ec:	9c 91       	ld	r25, X
    49ee:	d0 d8       	rcall	.-3680   	; 0x3b90 <get_fat>
    49f0:	ab 01       	movw	r20, r22
    49f2:	bc 01       	movw	r22, r24
    49f4:	4f 3f       	cpi	r20, 0xFF	; 255
    49f6:	bf ef       	ldi	r27, 0xFF	; 255
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    49f8:	5b 07       	cpc	r21, r27
    49fa:	bf ef       	ldi	r27, 0xFF	; 255
    49fc:	6b 07       	cpc	r22, r27
    49fe:	bf ef       	ldi	r27, 0xFF	; 255
    4a00:	7b 07       	cpc	r23, r27
    4a02:	31 f4       	brne	.+12     	; 0x4a10 <f_lseek+0x182>
    4a04:	f1 01       	movw	r30, r2
    4a06:	84 81       	ldd	r24, Z+4	; 0x04
    4a08:	80 68       	ori	r24, 0x80	; 128
    4a0a:	84 83       	std	Z+4, r24	; 0x04
    4a0c:	11 e0       	ldi	r17, 0x01	; 1
    4a0e:	88 c0       	rjmp	.+272    	; 0x4b20 <f_lseek+0x292>
    4a10:	42 30       	cpi	r20, 0x02	; 2
    4a12:	51 05       	cpc	r21, r1
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    4a14:	61 05       	cpc	r22, r1
    4a16:	71 05       	cpc	r23, r1
    4a18:	60 f0       	brcs	.+24     	; 0x4a32 <f_lseek+0x1a4>
    4a1a:	d1 01       	movw	r26, r2
    4a1c:	ed 91       	ld	r30, X+
    4a1e:	fc 91       	ld	r31, X
    4a20:	82 85       	ldd	r24, Z+10	; 0x0a
    4a22:	93 85       	ldd	r25, Z+11	; 0x0b
    4a24:	a4 85       	ldd	r26, Z+12	; 0x0c
    4a26:	b5 85       	ldd	r27, Z+13	; 0x0d
    4a28:	48 17       	cp	r20, r24
    4a2a:	59 07       	cpc	r21, r25
    4a2c:	6a 07       	cpc	r22, r26
    4a2e:	7b 07       	cpc	r23, r27
    4a30:	28 f0       	brcs	.+10     	; 0x4a3c <f_lseek+0x1ae>
    4a32:	f1 01       	movw	r30, r2
    4a34:	84 81       	ldd	r24, Z+4	; 0x04
    4a36:	80 68       	ori	r24, 0x80	; 128
    4a38:	84 83       	std	Z+4, r24	; 0x04
    4a3a:	71 c0       	rjmp	.+226    	; 0x4b1e <f_lseek+0x290>
    4a3c:	d1 01       	movw	r26, r2
    4a3e:	52 96       	adiw	r26, 0x12	; 18
					fp->clust = clst;
    4a40:	4d 93       	st	X+, r20
    4a42:	5d 93       	st	X+, r21
    4a44:	6d 93       	st	X+, r22
    4a46:	7c 93       	st	X, r23
    4a48:	55 97       	sbiw	r26, 0x15	; 21
    4a4a:	16 96       	adiw	r26, 0x06	; 6
    4a4c:	8d 91       	ld	r24, X+
					fp->fptr += bcs;
    4a4e:	9d 91       	ld	r25, X+
    4a50:	0d 90       	ld	r0, X+
    4a52:	bc 91       	ld	r27, X
    4a54:	a0 2d       	mov	r26, r0
    4a56:	88 0d       	add	r24, r8
    4a58:	99 1d       	adc	r25, r9
    4a5a:	aa 1d       	adc	r26, r10
    4a5c:	bb 1d       	adc	r27, r11
    4a5e:	f1 01       	movw	r30, r2
    4a60:	86 83       	std	Z+6, r24	; 0x06
    4a62:	97 83       	std	Z+7, r25	; 0x07
    4a64:	a0 87       	std	Z+8, r26	; 0x08
    4a66:	b1 87       	std	Z+9, r27	; 0x09
    4a68:	c8 18       	sub	r12, r8
    4a6a:	d9 08       	sbc	r13, r9
					ofs -= bcs;
    4a6c:	ea 08       	sbc	r14, r10
    4a6e:	fb 08       	sbc	r15, r11
    4a70:	8c 14       	cp	r8, r12
    4a72:	9d 04       	cpc	r9, r13
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    4a74:	ae 04       	cpc	r10, r14
    4a76:	bf 04       	cpc	r11, r15
    4a78:	08 f4       	brcc	.+2      	; 0x4a7c <f_lseek+0x1ee>
    4a7a:	b6 cf       	rjmp	.-148    	; 0x49e8 <f_lseek+0x15a>
    4a7c:	f1 01       	movw	r30, r2
    4a7e:	86 81       	ldd	r24, Z+6	; 0x06
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    4a80:	97 81       	ldd	r25, Z+7	; 0x07
    4a82:	a0 85       	ldd	r26, Z+8	; 0x08
    4a84:	b1 85       	ldd	r27, Z+9	; 0x09
    4a86:	8c 0d       	add	r24, r12
    4a88:	9d 1d       	adc	r25, r13
    4a8a:	ae 1d       	adc	r26, r14
    4a8c:	bf 1d       	adc	r27, r15
    4a8e:	86 83       	std	Z+6, r24	; 0x06
    4a90:	97 83       	std	Z+7, r25	; 0x07
    4a92:	a0 87       	std	Z+8, r26	; 0x08
    4a94:	b1 87       	std	Z+9, r27	; 0x09
    4a96:	d7 01       	movw	r26, r14
    4a98:	c6 01       	movw	r24, r12
				if (ofs % SS(fp->fs)) {
    4a9a:	91 70       	andi	r25, 0x01	; 1
    4a9c:	a0 70       	andi	r26, 0x00	; 0
    4a9e:	b0 70       	andi	r27, 0x00	; 0
    4aa0:	00 97       	sbiw	r24, 0x00	; 0
    4aa2:	a1 05       	cpc	r26, r1
    4aa4:	b1 05       	cpc	r27, r1
    4aa6:	f1 f0       	breq	.+60     	; 0x4ae4 <f_lseek+0x256>
    4aa8:	80 81       	ld	r24, Z
    4aaa:	91 81       	ldd	r25, Z+1	; 0x01
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    4aac:	3d d8       	rcall	.-3974   	; 0x3b28 <clust2sect>
    4aae:	dc 01       	movw	r26, r24
    4ab0:	cb 01       	movw	r24, r22
    4ab2:	00 97       	sbiw	r24, 0x00	; 0
    4ab4:	a1 05       	cpc	r26, r1
    4ab6:	b1 05       	cpc	r27, r1
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    4ab8:	49 f4       	brne	.+18     	; 0x4acc <f_lseek+0x23e>
    4aba:	d1 01       	movw	r26, r2
    4abc:	14 96       	adiw	r26, 0x04	; 4
    4abe:	8c 91       	ld	r24, X
    4ac0:	14 97       	sbiw	r26, 0x04	; 4
    4ac2:	80 68       	ori	r24, 0x80	; 128
    4ac4:	14 96       	adiw	r26, 0x04	; 4
    4ac6:	8c 93       	st	X, r24
    4ac8:	14 97       	sbiw	r26, 0x04	; 4
    4aca:	29 c0       	rjmp	.+82     	; 0x4b1e <f_lseek+0x290>
    4acc:	29 e0       	ldi	r18, 0x09	; 9
    4ace:	f6 94       	lsr	r15
    4ad0:	e7 94       	ror	r14
					nsect += ofs / SS(fp->fs);
    4ad2:	d7 94       	ror	r13
    4ad4:	c7 94       	ror	r12
    4ad6:	2a 95       	dec	r18
    4ad8:	d1 f7       	brne	.-12     	; 0x4ace <f_lseek+0x240>
    4ada:	c8 0e       	add	r12, r24
    4adc:	d9 1e       	adc	r13, r25
    4ade:	ea 1e       	adc	r14, r26
    4ae0:	fb 1e       	adc	r15, r27
    4ae2:	03 c0       	rjmp	.+6      	; 0x4aea <f_lseek+0x25c>
    4ae4:	cc 24       	eor	r12, r12
    4ae6:	dd 24       	eor	r13, r13
    4ae8:	76 01       	movw	r14, r12
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    4aea:	f1 01       	movw	r30, r2
    4aec:	86 81       	ldd	r24, Z+6	; 0x06
    4aee:	97 81       	ldd	r25, Z+7	; 0x07
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    4af0:	a0 85       	ldd	r26, Z+8	; 0x08
    4af2:	b1 85       	ldd	r27, Z+9	; 0x09
    4af4:	91 70       	andi	r25, 0x01	; 1
    4af6:	a0 70       	andi	r26, 0x00	; 0
    4af8:	b0 70       	andi	r27, 0x00	; 0
    4afa:	00 97       	sbiw	r24, 0x00	; 0
    4afc:	a1 05       	cpc	r26, r1
    4afe:	b1 05       	cpc	r27, r1
    4b00:	79 f0       	breq	.+30     	; 0x4b20 <f_lseek+0x292>
    4b02:	86 89       	ldd	r24, Z+22	; 0x16
    4b04:	97 89       	ldd	r25, Z+23	; 0x17
    4b06:	a0 8d       	ldd	r26, Z+24	; 0x18
    4b08:	b1 8d       	ldd	r27, Z+25	; 0x19
    4b0a:	c8 16       	cp	r12, r24
    4b0c:	d9 06       	cpc	r13, r25
    4b0e:	ea 06       	cpc	r14, r26
    4b10:	fb 06       	cpc	r15, r27
    4b12:	31 f0       	breq	.+12     	; 0x4b20 <f_lseek+0x292>
    4b14:	c6 8a       	std	Z+22, r12	; 0x16
    4b16:	d7 8a       	std	Z+23, r13	; 0x17
    4b18:	e0 8e       	std	Z+24, r14	; 0x18
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    4b1a:	f1 8e       	std	Z+25, r15	; 0x19
    4b1c:	01 c0       	rjmp	.+2      	; 0x4b20 <f_lseek+0x292>
    4b1e:	12 e0       	ldi	r17, 0x02	; 2
    4b20:	81 2f       	mov	r24, r17
    4b22:	28 96       	adiw	r28, 0x08	; 8


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4b24:	0f b6       	in	r0, 0x3f	; 63
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    4b26:	f8 94       	cli
    4b28:	de bf       	out	0x3e, r29	; 62
    4b2a:	0f be       	out	0x3f, r0	; 63
    4b2c:	cd bf       	out	0x3d, r28	; 61
    4b2e:	df 91       	pop	r29
    4b30:	cf 91       	pop	r28
    4b32:	1f 91       	pop	r17
    4b34:	ff 90       	pop	r15
    4b36:	ef 90       	pop	r14
    4b38:	df 90       	pop	r13
    4b3a:	cf 90       	pop	r12
    4b3c:	bf 90       	pop	r11
    4b3e:	af 90       	pop	r10
    4b40:	9f 90       	pop	r9
    4b42:	8f 90       	pop	r8
    4b44:	7f 90       	pop	r7
    4b46:	6f 90       	pop	r6
    4b48:	5f 90       	pop	r5
    4b4a:	4f 90       	pop	r4
    4b4c:	3f 90       	pop	r3
    4b4e:	2f 90       	pop	r2
    4b50:	08 95       	ret

00004b52 <Endpoint_Null_Stream>:
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    4b52:	df 92       	push	r13
    4b54:	ef 92       	push	r14
    4b56:	ff 92       	push	r15
    4b58:	0f 93       	push	r16
    4b5a:	1f 93       	push	r17
    4b5c:	cf 93       	push	r28
    4b5e:	df 93       	push	r29
    4b60:	ec 01       	movw	r28, r24
    4b62:	8b 01       	movw	r16, r22
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;
	
	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4b64:	ba d2       	rcall	.+1396   	; 0x50da <Endpoint_WaitUntilReady>
    4b66:	d8 2e       	mov	r13, r24
    4b68:	88 23       	and	r24, r24
    4b6a:	79 f5       	brne	.+94     	; 0x4bca <Endpoint_Null_Stream+0x78>
    4b6c:	01 15       	cp	r16, r1
	  return ErrorCode;
	  
	if (BytesProcessed != NULL)
    4b6e:	11 05       	cpc	r17, r1
    4b70:	29 f0       	breq	.+10     	; 0x4b7c <Endpoint_Null_Stream+0x2a>
    4b72:	f8 01       	movw	r30, r16
	  Length -= *BytesProcessed;
    4b74:	20 81       	ld	r18, Z
    4b76:	31 81       	ldd	r19, Z+1	; 0x01
    4b78:	c2 1b       	sub	r28, r18
    4b7a:	d3 0b       	sbc	r29, r19
    4b7c:	ee 24       	eor	r14, r14
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    4b7e:	ff 24       	eor	r15, r15
    4b80:	20 c0       	rjmp	.+64     	; 0x4bc2 <Endpoint_Null_Stream+0x70>
    4b82:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b86:	85 fd       	sbrc	r24, 5
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4b88:	16 c0       	rjmp	.+44     	; 0x4bb6 <Endpoint_Null_Stream+0x64>
    4b8a:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4b8e:	8e 77       	andi	r24, 0x7E	; 126
    4b90:	80 93 e8 00 	sts	0x00E8, r24
    4b94:	01 15       	cp	r16, r1
		{
			Endpoint_ClearIN();

			if (BytesProcessed != NULL)
    4b96:	11 05       	cpc	r17, r1
    4b98:	51 f0       	breq	.+20     	; 0x4bae <Endpoint_Null_Stream+0x5c>
    4b9a:	f8 01       	movw	r30, r16
			{
				*BytesProcessed += BytesInTransfer;
    4b9c:	80 81       	ld	r24, Z
    4b9e:	91 81       	ldd	r25, Z+1	; 0x01
    4ba0:	8e 0d       	add	r24, r14
    4ba2:	9f 1d       	adc	r25, r15
    4ba4:	91 83       	std	Z+1, r25	; 0x01
    4ba6:	80 83       	st	Z, r24
    4ba8:	35 e0       	ldi	r19, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4baa:	d3 2e       	mov	r13, r19
    4bac:	0e c0       	rjmp	.+28     	; 0x4bca <Endpoint_Null_Stream+0x78>
    4bae:	95 d2       	rcall	.+1322   	; 0x50da <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4bb0:	88 23       	and	r24, r24
    4bb2:	39 f0       	breq	.+14     	; 0x4bc2 <Endpoint_Null_Stream+0x70>
    4bb4:	09 c0       	rjmp	.+18     	; 0x4bc8 <Endpoint_Null_Stream+0x76>
    4bb6:	10 92 f1 00 	sts	0x00F1, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4bba:	21 97       	sbiw	r28, 0x01	; 1
    4bbc:	08 94       	sec
		}
		else
		{
			Endpoint_Write_8(0);

			Length--;
    4bbe:	e1 1c       	adc	r14, r1
			BytesInTransfer++;
    4bc0:	f1 1c       	adc	r15, r1
    4bc2:	20 97       	sbiw	r28, 0x00	; 0
    4bc4:	f1 f6       	brne	.-68     	; 0x4b82 <Endpoint_Null_Stream+0x30>
	  return ErrorCode;
	  
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    4bc6:	01 c0       	rjmp	.+2      	; 0x4bca <Endpoint_Null_Stream+0x78>
    4bc8:	d8 2e       	mov	r13, r24
    4bca:	8d 2d       	mov	r24, r13
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4bcc:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
}
    4bce:	cf 91       	pop	r28
    4bd0:	1f 91       	pop	r17
    4bd2:	0f 91       	pop	r16
    4bd4:	ff 90       	pop	r15
    4bd6:	ef 90       	pop	r14
    4bd8:	df 90       	pop	r13
    4bda:	08 95       	ret

00004bdc <Endpoint_Write_Stream_LE>:
    4bdc:	af 92       	push	r10
    4bde:	bf 92       	push	r11
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4be0:	cf 92       	push	r12
    4be2:	df 92       	push	r13
    4be4:	ef 92       	push	r14
    4be6:	ff 92       	push	r15
    4be8:	1f 93       	push	r17
    4bea:	cf 93       	push	r28
    4bec:	df 93       	push	r29
    4bee:	ec 01       	movw	r28, r24
    4bf0:	7b 01       	movw	r14, r22
    4bf2:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4bf4:	72 d2       	rcall	.+1252   	; 0x50da <Endpoint_WaitUntilReady>
    4bf6:	18 2f       	mov	r17, r24
    4bf8:	88 23       	and	r24, r24
    4bfa:	a1 f5       	brne	.+104    	; 0x4c64 <Endpoint_Write_Stream_LE+0x88>
    4bfc:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4bfe:	d1 04       	cpc	r13, r1
    4c00:	39 f0       	breq	.+14     	; 0x4c10 <Endpoint_Write_Stream_LE+0x34>
    4c02:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    4c04:	20 81       	ld	r18, Z
    4c06:	31 81       	ldd	r19, Z+1	; 0x01
    4c08:	e2 1a       	sub	r14, r18
    4c0a:	f3 0a       	sbc	r15, r19
    4c0c:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4c0e:	d3 1f       	adc	r29, r19
    4c10:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4c12:	bb 24       	eor	r11, r11
    4c14:	22 c0       	rjmp	.+68     	; 0x4c5a <Endpoint_Write_Stream_LE+0x7e>
    4c16:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4c1a:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4c1c:	15 c0       	rjmp	.+42     	; 0x4c48 <Endpoint_Write_Stream_LE+0x6c>
    4c1e:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4c22:	8e 77       	andi	r24, 0x7E	; 126
    4c24:	80 93 e8 00 	sts	0x00E8, r24
    4c28:	c1 14       	cp	r12, r1

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4c2a:	d1 04       	cpc	r13, r1
    4c2c:	49 f0       	breq	.+18     	; 0x4c40 <Endpoint_Write_Stream_LE+0x64>
    4c2e:	f6 01       	movw	r30, r12
			{
				*BytesProcessed += BytesInTransfer;
    4c30:	80 81       	ld	r24, Z
    4c32:	91 81       	ldd	r25, Z+1	; 0x01
    4c34:	8a 0d       	add	r24, r10
    4c36:	9b 1d       	adc	r25, r11
    4c38:	91 83       	std	Z+1, r25	; 0x01
    4c3a:	80 83       	st	Z, r24
    4c3c:	15 e0       	ldi	r17, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4c3e:	12 c0       	rjmp	.+36     	; 0x4c64 <Endpoint_Write_Stream_LE+0x88>
    4c40:	4c d2       	rcall	.+1176   	; 0x50da <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4c42:	88 23       	and	r24, r24
    4c44:	51 f0       	breq	.+20     	; 0x4c5a <Endpoint_Write_Stream_LE+0x7e>
    4c46:	0d c0       	rjmp	.+26     	; 0x4c62 <Endpoint_Write_Stream_LE+0x86>
    4c48:	89 91       	ld	r24, Y+
    4c4a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4c4e:	08 94       	sec
    4c50:	e1 08       	sbc	r14, r1
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    4c52:	f1 08       	sbc	r15, r1
    4c54:	08 94       	sec
    4c56:	a1 1c       	adc	r10, r1
			BytesInTransfer++;
    4c58:	b1 1c       	adc	r11, r1
    4c5a:	e1 14       	cp	r14, r1
    4c5c:	f1 04       	cpc	r15, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4c5e:	d9 f6       	brne	.-74     	; 0x4c16 <Endpoint_Write_Stream_LE+0x3a>
    4c60:	01 c0       	rjmp	.+2      	; 0x4c64 <Endpoint_Write_Stream_LE+0x88>
    4c62:	18 2f       	mov	r17, r24
    4c64:	81 2f       	mov	r24, r17
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4c66:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    4c68:	cf 91       	pop	r28
    4c6a:	1f 91       	pop	r17
    4c6c:	ff 90       	pop	r15
    4c6e:	ef 90       	pop	r14
    4c70:	df 90       	pop	r13
    4c72:	cf 90       	pop	r12
    4c74:	bf 90       	pop	r11
    4c76:	af 90       	pop	r10
    4c78:	08 95       	ret

00004c7a <Endpoint_Write_Stream_BE>:
    4c7a:	af 92       	push	r10
    4c7c:	bf 92       	push	r11
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4c7e:	cf 92       	push	r12
    4c80:	df 92       	push	r13
    4c82:	ff 92       	push	r15
    4c84:	0f 93       	push	r16
    4c86:	1f 93       	push	r17
    4c88:	cf 93       	push	r28
    4c8a:	df 93       	push	r29
    4c8c:	ec 01       	movw	r28, r24
    4c8e:	6b 01       	movw	r12, r22
    4c90:	5a 01       	movw	r10, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4c92:	23 d2       	rcall	.+1094   	; 0x50da <Endpoint_WaitUntilReady>
    4c94:	f8 2e       	mov	r15, r24
    4c96:	88 23       	and	r24, r24
    4c98:	d9 f5       	brne	.+118    	; 0x4d10 <Endpoint_Write_Stream_BE+0x96>
    4c9a:	86 01       	movw	r16, r12

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4c9c:	01 50       	subi	r16, 0x01	; 1
    4c9e:	10 40       	sbci	r17, 0x00	; 0
    4ca0:	0c 0f       	add	r16, r28
    4ca2:	1d 1f       	adc	r17, r29
    4ca4:	a1 14       	cp	r10, r1
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4ca6:	b1 04       	cpc	r11, r1
    4ca8:	39 f0       	breq	.+14     	; 0x4cb8 <Endpoint_Write_Stream_BE+0x3e>
    4caa:	f5 01       	movw	r30, r10
	{
		Length -= *BytesProcessed;
    4cac:	20 81       	ld	r18, Z
    4cae:	31 81       	ldd	r19, Z+1	; 0x01
    4cb0:	c2 1a       	sub	r12, r18
    4cb2:	d3 0a       	sbc	r13, r19
    4cb4:	02 1b       	sub	r16, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4cb6:	13 0b       	sbc	r17, r19
    4cb8:	c0 e0       	ldi	r28, 0x00	; 0
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4cba:	d0 e0       	ldi	r29, 0x00	; 0
    4cbc:	24 c0       	rjmp	.+72     	; 0x4d06 <Endpoint_Write_Stream_BE+0x8c>
    4cbe:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4cc2:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4cc4:	16 c0       	rjmp	.+44     	; 0x4cf2 <Endpoint_Write_Stream_BE+0x78>
    4cc6:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4cca:	8e 77       	andi	r24, 0x7E	; 126
    4ccc:	80 93 e8 00 	sts	0x00E8, r24
    4cd0:	a1 14       	cp	r10, r1

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4cd2:	b1 04       	cpc	r11, r1
    4cd4:	51 f0       	breq	.+20     	; 0x4cea <Endpoint_Write_Stream_BE+0x70>
    4cd6:	f5 01       	movw	r30, r10
			{
				*BytesProcessed += BytesInTransfer;
    4cd8:	80 81       	ld	r24, Z
    4cda:	91 81       	ldd	r25, Z+1	; 0x01
    4cdc:	8c 0f       	add	r24, r28
    4cde:	9d 1f       	adc	r25, r29
    4ce0:	91 83       	std	Z+1, r25	; 0x01
    4ce2:	80 83       	st	Z, r24
    4ce4:	45 e0       	ldi	r20, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4ce6:	f4 2e       	mov	r15, r20
    4ce8:	13 c0       	rjmp	.+38     	; 0x4d10 <Endpoint_Write_Stream_BE+0x96>
    4cea:	f7 d1       	rcall	.+1006   	; 0x50da <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4cec:	88 23       	and	r24, r24
    4cee:	59 f0       	breq	.+22     	; 0x4d06 <Endpoint_Write_Stream_BE+0x8c>
    4cf0:	0e c0       	rjmp	.+28     	; 0x4d0e <Endpoint_Write_Stream_BE+0x94>
    4cf2:	f8 01       	movw	r30, r16
    4cf4:	80 81       	ld	r24, Z
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4cf6:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4cfa:	01 50       	subi	r16, 0x01	; 1
    4cfc:	10 40       	sbci	r17, 0x00	; 0
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4cfe:	08 94       	sec
    4d00:	c1 08       	sbc	r12, r1
			Length--;
    4d02:	d1 08       	sbc	r13, r1
    4d04:	21 96       	adiw	r28, 0x01	; 1
    4d06:	c1 14       	cp	r12, r1
			BytesInTransfer++;
    4d08:	d1 04       	cpc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4d0a:	c9 f6       	brne	.-78     	; 0x4cbe <Endpoint_Write_Stream_BE+0x44>
    4d0c:	01 c0       	rjmp	.+2      	; 0x4d10 <Endpoint_Write_Stream_BE+0x96>
    4d0e:	f8 2e       	mov	r15, r24
    4d10:	8f 2d       	mov	r24, r15
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4d12:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    4d14:	cf 91       	pop	r28
    4d16:	1f 91       	pop	r17
    4d18:	0f 91       	pop	r16
    4d1a:	ff 90       	pop	r15
    4d1c:	df 90       	pop	r13
    4d1e:	cf 90       	pop	r12
    4d20:	bf 90       	pop	r11
    4d22:	af 90       	pop	r10
    4d24:	08 95       	ret

00004d26 <Endpoint_Read_Stream_LE>:
    4d26:	af 92       	push	r10
    4d28:	bf 92       	push	r11
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4d2a:	cf 92       	push	r12
    4d2c:	df 92       	push	r13
    4d2e:	ef 92       	push	r14
    4d30:	ff 92       	push	r15
    4d32:	1f 93       	push	r17
    4d34:	cf 93       	push	r28
    4d36:	df 93       	push	r29
    4d38:	ec 01       	movw	r28, r24
    4d3a:	7b 01       	movw	r14, r22
    4d3c:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4d3e:	cd d1       	rcall	.+922    	; 0x50da <Endpoint_WaitUntilReady>
    4d40:	18 2f       	mov	r17, r24
    4d42:	88 23       	and	r24, r24
    4d44:	a1 f5       	brne	.+104    	; 0x4dae <Endpoint_Read_Stream_LE+0x88>
    4d46:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4d48:	d1 04       	cpc	r13, r1
    4d4a:	39 f0       	breq	.+14     	; 0x4d5a <Endpoint_Read_Stream_LE+0x34>
    4d4c:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    4d4e:	20 81       	ld	r18, Z
    4d50:	31 81       	ldd	r19, Z+1	; 0x01
    4d52:	e2 1a       	sub	r14, r18
    4d54:	f3 0a       	sbc	r15, r19
    4d56:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4d58:	d3 1f       	adc	r29, r19
    4d5a:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4d5c:	bb 24       	eor	r11, r11
    4d5e:	22 c0       	rjmp	.+68     	; 0x4da4 <Endpoint_Read_Stream_LE+0x7e>
    4d60:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4d64:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4d66:	15 c0       	rjmp	.+42     	; 0x4d92 <Endpoint_Read_Stream_LE+0x6c>
    4d68:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4d6c:	8b 77       	andi	r24, 0x7B	; 123
    4d6e:	80 93 e8 00 	sts	0x00E8, r24
    4d72:	c1 14       	cp	r12, r1

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4d74:	d1 04       	cpc	r13, r1
    4d76:	49 f0       	breq	.+18     	; 0x4d8a <Endpoint_Read_Stream_LE+0x64>
    4d78:	f6 01       	movw	r30, r12
			{
				*BytesProcessed += BytesInTransfer;
    4d7a:	80 81       	ld	r24, Z
    4d7c:	91 81       	ldd	r25, Z+1	; 0x01
    4d7e:	8a 0d       	add	r24, r10
    4d80:	9b 1d       	adc	r25, r11
    4d82:	91 83       	std	Z+1, r25	; 0x01
    4d84:	80 83       	st	Z, r24
    4d86:	15 e0       	ldi	r17, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4d88:	12 c0       	rjmp	.+36     	; 0x4dae <Endpoint_Read_Stream_LE+0x88>
    4d8a:	a7 d1       	rcall	.+846    	; 0x50da <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4d8c:	88 23       	and	r24, r24
    4d8e:	51 f0       	breq	.+20     	; 0x4da4 <Endpoint_Read_Stream_LE+0x7e>
    4d90:	0d c0       	rjmp	.+26     	; 0x4dac <Endpoint_Read_Stream_LE+0x86>
    4d92:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4d96:	89 93       	st	Y+, r24
    4d98:	08 94       	sec
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4d9a:	e1 08       	sbc	r14, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    4d9c:	f1 08       	sbc	r15, r1
    4d9e:	08 94       	sec
    4da0:	a1 1c       	adc	r10, r1
			BytesInTransfer++;
    4da2:	b1 1c       	adc	r11, r1
    4da4:	e1 14       	cp	r14, r1
    4da6:	f1 04       	cpc	r15, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4da8:	d9 f6       	brne	.-74     	; 0x4d60 <Endpoint_Read_Stream_LE+0x3a>
    4daa:	01 c0       	rjmp	.+2      	; 0x4dae <Endpoint_Read_Stream_LE+0x88>
    4dac:	18 2f       	mov	r17, r24
    4dae:	81 2f       	mov	r24, r17
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4db0:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    4db2:	cf 91       	pop	r28
    4db4:	1f 91       	pop	r17
    4db6:	ff 90       	pop	r15
    4db8:	ef 90       	pop	r14
    4dba:	df 90       	pop	r13
    4dbc:	cf 90       	pop	r12
    4dbe:	bf 90       	pop	r11
    4dc0:	af 90       	pop	r10
    4dc2:	08 95       	ret

00004dc4 <Endpoint_Write_Control_Stream_LE>:
    4dc4:	20 91 d6 0d 	lds	r18, 0x0DD6
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    4dc8:	30 91 d7 0d 	lds	r19, 0x0DD7
    4dcc:	26 17       	cp	r18, r22
    4dce:	37 07       	cpc	r19, r23
    4dd0:	20 f4       	brcc	.+8      	; 0x4dda <Endpoint_Write_Control_Stream_LE+0x16>
    4dd2:	b9 01       	movw	r22, r18
    4dd4:	fc 01       	movw	r30, r24
    4dd6:	20 e0       	ldi	r18, 0x00	; 0
    4dd8:	35 c0       	rjmp	.+106    	; 0x4e44 <Endpoint_Write_Control_Stream_LE+0x80>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    4dda:	61 15       	cp	r22, r1
    4ddc:	71 05       	cpc	r23, r1
    4dde:	d1 f7       	brne	.-12     	; 0x4dd4 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4de0:	20 91 e8 00 	lds	r18, 0x00E8
    4de4:	2e 77       	andi	r18, 0x7E	; 126
    4de6:	20 93 e8 00 	sts	0x00E8, r18
    4dea:	f4 cf       	rjmp	.-24     	; 0x4dd4 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4dec:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4dee:	88 23       	and	r24, r24
    4df0:	f1 f1       	breq	.+124    	; 0x4e6e <Endpoint_Write_Control_Stream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4df2:	85 30       	cpi	r24, 0x05	; 5
    4df4:	c1 f1       	breq	.+112    	; 0x4e66 <Endpoint_Write_Control_Stream_LE+0xa2>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4df6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4dfa:	83 fd       	sbrc	r24, 3
    4dfc:	36 c0       	rjmp	.+108    	; 0x4e6a <Endpoint_Write_Control_Stream_LE+0xa6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4dfe:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    4e02:	82 fd       	sbrc	r24, 2
    4e04:	2a c0       	rjmp	.+84     	; 0x4e5a <Endpoint_Write_Control_Stream_LE+0x96>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4e06:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    4e0a:	80 ff       	sbrs	r24, 0
    4e0c:	1b c0       	rjmp	.+54     	; 0x4e44 <Endpoint_Write_Control_Stream_LE+0x80>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4e0e:	80 91 f2 00 	lds	r24, 0x00F2
    4e12:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4e16:	06 c0       	rjmp	.+12     	; 0x4e24 <Endpoint_Write_Control_Stream_LE+0x60>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4e18:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4e1a:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    4e1e:	61 50       	subi	r22, 0x01	; 1
    4e20:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    4e22:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4e24:	61 15       	cp	r22, r1
    4e26:	71 05       	cpc	r23, r1
    4e28:	19 f0       	breq	.+6      	; 0x4e30 <Endpoint_Write_Control_Stream_LE+0x6c>
    4e2a:	88 30       	cpi	r24, 0x08	; 8
    4e2c:	91 05       	cpc	r25, r1
    4e2e:	a0 f3       	brcs	.-24     	; 0x4e18 <Endpoint_Write_Control_Stream_LE+0x54>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    4e30:	21 e0       	ldi	r18, 0x01	; 1
    4e32:	88 30       	cpi	r24, 0x08	; 8
    4e34:	91 05       	cpc	r25, r1
    4e36:	09 f0       	breq	.+2      	; 0x4e3a <Endpoint_Write_Control_Stream_LE+0x76>
    4e38:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4e3a:	80 91 e8 00 	lds	r24, 0x00E8
    4e3e:	8e 77       	andi	r24, 0x7E	; 126
    4e40:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4e44:	61 15       	cp	r22, r1
    4e46:	71 05       	cpc	r23, r1
    4e48:	89 f6       	brne	.-94     	; 0x4dec <Endpoint_Write_Control_Stream_LE+0x28>
    4e4a:	22 23       	and	r18, r18
    4e4c:	79 f6       	brne	.-98     	; 0x4dec <Endpoint_Write_Control_Stream_LE+0x28>
    4e4e:	05 c0       	rjmp	.+10     	; 0x4e5a <Endpoint_Write_Control_Stream_LE+0x96>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4e50:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4e52:	88 23       	and	r24, r24
    4e54:	61 f0       	breq	.+24     	; 0x4e6e <Endpoint_Write_Control_Stream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4e56:	85 30       	cpi	r24, 0x05	; 5
    4e58:	61 f0       	breq	.+24     	; 0x4e72 <Endpoint_Write_Control_Stream_LE+0xae>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4e5a:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    4e5e:	82 ff       	sbrs	r24, 2
    4e60:	f7 cf       	rjmp	.-18     	; 0x4e50 <Endpoint_Write_Control_Stream_LE+0x8c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4e62:	80 e0       	ldi	r24, 0x00	; 0
    4e64:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4e66:	83 e0       	ldi	r24, 0x03	; 3
    4e68:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4e6a:	81 e0       	ldi	r24, 0x01	; 1
    4e6c:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4e6e:	82 e0       	ldi	r24, 0x02	; 2
    4e70:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4e72:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4e74:	08 95       	ret

00004e76 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    4e76:	61 15       	cp	r22, r1
    4e78:	71 05       	cpc	r23, r1
    4e7a:	29 f4       	brne	.+10     	; 0x4e86 <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4e7c:	20 91 e8 00 	lds	r18, 0x00E8
    4e80:	2b 77       	andi	r18, 0x7B	; 123
    4e82:	20 93 e8 00 	sts	0x00E8, r18

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    4e86:	38 2f       	mov	r19, r24
    4e88:	29 2f       	mov	r18, r25
    4e8a:	25 c0       	rjmp	.+74     	; 0x4ed6 <Endpoint_Read_Control_Stream_LE+0x60>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4e8c:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4e8e:	88 23       	and	r24, r24
    4e90:	a9 f1       	breq	.+106    	; 0x4efc <Endpoint_Read_Control_Stream_LE+0x86>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4e92:	85 30       	cpi	r24, 0x05	; 5
    4e94:	79 f1       	breq	.+94     	; 0x4ef4 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4e96:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4e9a:	83 fd       	sbrc	r24, 3
    4e9c:	2d c0       	rjmp	.+90     	; 0x4ef8 <Endpoint_Read_Control_Stream_LE+0x82>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4e9e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    4ea2:	82 ff       	sbrs	r24, 2
    4ea4:	f3 cf       	rjmp	.-26     	; 0x4e8c <Endpoint_Read_Control_Stream_LE+0x16>
    4ea6:	e3 2f       	mov	r30, r19
    4ea8:	f2 2f       	mov	r31, r18
    4eaa:	08 c0       	rjmp	.+16     	; 0x4ebc <Endpoint_Read_Control_Stream_LE+0x46>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4eac:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4eb0:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4eb2:	3e 2f       	mov	r19, r30
    4eb4:	2f 2f       	mov	r18, r31
				Length--;
    4eb6:	61 50       	subi	r22, 0x01	; 1
    4eb8:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    4eba:	41 f0       	breq	.+16     	; 0x4ecc <Endpoint_Read_Control_Stream_LE+0x56>
    4ebc:	3e 2f       	mov	r19, r30
    4ebe:	2f 2f       	mov	r18, r31
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4ec0:	80 91 f2 00 	lds	r24, 0x00F2
    4ec4:	90 91 f3 00 	lds	r25, 0x00F3
    4ec8:	00 97       	sbiw	r24, 0x00	; 0
    4eca:	81 f7       	brne	.-32     	; 0x4eac <Endpoint_Read_Control_Stream_LE+0x36>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4ecc:	80 91 e8 00 	lds	r24, 0x00E8
    4ed0:	8b 77       	andi	r24, 0x7B	; 123
    4ed2:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    4ed6:	61 15       	cp	r22, r1
    4ed8:	71 05       	cpc	r23, r1
    4eda:	c1 f6       	brne	.-80     	; 0x4e8c <Endpoint_Read_Control_Stream_LE+0x16>
    4edc:	05 c0       	rjmp	.+10     	; 0x4ee8 <Endpoint_Read_Control_Stream_LE+0x72>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4ede:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4ee0:	88 23       	and	r24, r24
    4ee2:	61 f0       	breq	.+24     	; 0x4efc <Endpoint_Read_Control_Stream_LE+0x86>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4ee4:	85 30       	cpi	r24, 0x05	; 5
    4ee6:	61 f0       	breq	.+24     	; 0x4f00 <Endpoint_Read_Control_Stream_LE+0x8a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4ee8:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    4eec:	80 ff       	sbrs	r24, 0
    4eee:	f7 cf       	rjmp	.-18     	; 0x4ede <Endpoint_Read_Control_Stream_LE+0x68>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4ef0:	80 e0       	ldi	r24, 0x00	; 0
    4ef2:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4ef4:	83 e0       	ldi	r24, 0x03	; 3
    4ef6:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4ef8:	81 e0       	ldi	r24, 0x01	; 1
    4efa:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4efc:	82 e0       	ldi	r24, 0x02	; 2
    4efe:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4f00:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4f02:	08 95       	ret

00004f04 <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    4f04:	20 91 d6 0d 	lds	r18, 0x0DD6
    4f08:	30 91 d7 0d 	lds	r19, 0x0DD7
    4f0c:	26 17       	cp	r18, r22
    4f0e:	37 07       	cpc	r19, r23
    4f10:	20 f4       	brcc	.+8      	; 0x4f1a <Endpoint_Write_Control_PStream_LE+0x16>
    4f12:	b9 01       	movw	r22, r18
    4f14:	fc 01       	movw	r30, r24
    4f16:	20 e0       	ldi	r18, 0x00	; 0
    4f18:	37 c0       	rjmp	.+110    	; 0x4f88 <Endpoint_Write_Control_PStream_LE+0x84>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    4f1a:	61 15       	cp	r22, r1
    4f1c:	71 05       	cpc	r23, r1
    4f1e:	d1 f7       	brne	.-12     	; 0x4f14 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4f20:	20 91 e8 00 	lds	r18, 0x00E8
    4f24:	2e 77       	andi	r18, 0x7E	; 126
    4f26:	20 93 e8 00 	sts	0x00E8, r18
    4f2a:	f4 cf       	rjmp	.-24     	; 0x4f14 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4f2c:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4f2e:	88 23       	and	r24, r24
    4f30:	09 f4       	brne	.+2      	; 0x4f34 <Endpoint_Write_Control_PStream_LE+0x30>
    4f32:	3f c0       	rjmp	.+126    	; 0x4fb2 <Endpoint_Write_Control_PStream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4f34:	85 30       	cpi	r24, 0x05	; 5
    4f36:	c9 f1       	breq	.+114    	; 0x4faa <Endpoint_Write_Control_PStream_LE+0xa6>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4f38:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4f3c:	83 fd       	sbrc	r24, 3
    4f3e:	37 c0       	rjmp	.+110    	; 0x4fae <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4f40:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    4f44:	82 fd       	sbrc	r24, 2
    4f46:	2b c0       	rjmp	.+86     	; 0x4f9e <Endpoint_Write_Control_PStream_LE+0x9a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4f48:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    4f4c:	80 ff       	sbrs	r24, 0
    4f4e:	1c c0       	rjmp	.+56     	; 0x4f88 <Endpoint_Write_Control_PStream_LE+0x84>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4f50:	80 91 f2 00 	lds	r24, 0x00F2
    4f54:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4f58:	07 c0       	rjmp	.+14     	; 0x4f68 <Endpoint_Write_Control_PStream_LE+0x64>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4f5a:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4f5c:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4f60:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    4f62:	61 50       	subi	r22, 0x01	; 1
    4f64:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    4f66:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4f68:	61 15       	cp	r22, r1
    4f6a:	71 05       	cpc	r23, r1
    4f6c:	19 f0       	breq	.+6      	; 0x4f74 <Endpoint_Write_Control_PStream_LE+0x70>
    4f6e:	88 30       	cpi	r24, 0x08	; 8
    4f70:	91 05       	cpc	r25, r1
    4f72:	98 f3       	brcs	.-26     	; 0x4f5a <Endpoint_Write_Control_PStream_LE+0x56>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    4f74:	21 e0       	ldi	r18, 0x01	; 1
    4f76:	88 30       	cpi	r24, 0x08	; 8
    4f78:	91 05       	cpc	r25, r1
    4f7a:	09 f0       	breq	.+2      	; 0x4f7e <Endpoint_Write_Control_PStream_LE+0x7a>
    4f7c:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4f7e:	80 91 e8 00 	lds	r24, 0x00E8
    4f82:	8e 77       	andi	r24, 0x7E	; 126
    4f84:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4f88:	61 15       	cp	r22, r1
    4f8a:	71 05       	cpc	r23, r1
    4f8c:	79 f6       	brne	.-98     	; 0x4f2c <Endpoint_Write_Control_PStream_LE+0x28>
    4f8e:	22 23       	and	r18, r18
    4f90:	69 f6       	brne	.-102    	; 0x4f2c <Endpoint_Write_Control_PStream_LE+0x28>
    4f92:	05 c0       	rjmp	.+10     	; 0x4f9e <Endpoint_Write_Control_PStream_LE+0x9a>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4f94:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4f96:	88 23       	and	r24, r24
    4f98:	61 f0       	breq	.+24     	; 0x4fb2 <Endpoint_Write_Control_PStream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4f9a:	85 30       	cpi	r24, 0x05	; 5
    4f9c:	61 f0       	breq	.+24     	; 0x4fb6 <Endpoint_Write_Control_PStream_LE+0xb2>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4f9e:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    4fa2:	82 ff       	sbrs	r24, 2
    4fa4:	f7 cf       	rjmp	.-18     	; 0x4f94 <Endpoint_Write_Control_PStream_LE+0x90>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4fa6:	80 e0       	ldi	r24, 0x00	; 0
    4fa8:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4faa:	83 e0       	ldi	r24, 0x03	; 3
    4fac:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4fae:	81 e0       	ldi	r24, 0x01	; 1
    4fb0:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4fb2:	82 e0       	ldi	r24, 0x02	; 2
    4fb4:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4fb6:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4fb8:	08 95       	ret

00004fba <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    4fba:	98 2f       	mov	r25, r24
    4fbc:	2a c0       	rjmp	.+84     	; 0x5012 <Endpoint_ConfigureEndpoint_Prv+0x58>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    4fbe:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    4fc2:	98 17       	cp	r25, r24
    4fc4:	39 f0       	breq	.+14     	; 0x4fd4 <Endpoint_ConfigureEndpoint_Prv+0x1a>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    4fc6:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    4fca:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    4fce:	50 91 f0 00 	lds	r21, 0x00F0
    4fd2:	03 c0       	rjmp	.+6      	; 0x4fda <Endpoint_ConfigureEndpoint_Prv+0x20>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    4fd4:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    4fd6:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    4fd8:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    4fda:	21 ff       	sbrs	r18, 1
    4fdc:	19 c0       	rjmp	.+50     	; 0x5010 <Endpoint_ConfigureEndpoint_Prv+0x56>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    4fde:	30 91 eb 00 	lds	r19, 0x00EB
    4fe2:	3e 7f       	andi	r19, 0xFE	; 254
    4fe4:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    4fe8:	30 91 ed 00 	lds	r19, 0x00ED
    4fec:	3d 7f       	andi	r19, 0xFD	; 253
    4fee:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    4ff2:	30 91 eb 00 	lds	r19, 0x00EB
    4ff6:	31 60       	ori	r19, 0x01	; 1
    4ff8:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    4ffc:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    5000:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    5004:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    5008:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    500c:	27 ff       	sbrs	r18, 7
    500e:	08 c0       	rjmp	.+16     	; 0x5020 <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    5010:	9f 5f       	subi	r25, 0xFF	; 255
    5012:	97 30       	cpi	r25, 0x07	; 7
    5014:	a0 f2       	brcs	.-88     	; 0x4fbe <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5016:	8f 70       	andi	r24, 0x0F	; 15
    5018:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    501c:	81 e0       	ldi	r24, 0x01	; 1
    501e:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    5020:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    5022:	08 95       	ret

00005024 <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    5024:	0f 93       	push	r16
    5026:	1f 93       	push	r17
    5028:	cf 93       	push	r28
    502a:	df 93       	push	r29
    502c:	16 2f       	mov	r17, r22
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    502e:	ec 01       	movw	r28, r24
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    5030:	00 e0       	ldi	r16, 0x00	; 0
    5032:	2a c0       	rjmp	.+84     	; 0x5088 <Endpoint_ConfigureEndpointTable+0x64>
	{
		if (!(Table[i].Address))
    5034:	98 81       	ld	r25, Y
    5036:	99 23       	and	r25, r25
    5038:	29 f1       	breq	.+74     	; 0x5084 <Endpoint_ConfigureEndpointTable+0x60>
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    503a:	6b 81       	ldd	r22, Y+3	; 0x03
    503c:	e9 81       	ldd	r30, Y+1	; 0x01
    503e:	fa 81       	ldd	r31, Y+2	; 0x02
    5040:	2c 81       	ldd	r18, Y+4	; 0x04
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    5042:	89 2f       	mov	r24, r25
    5044:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    5046:	87 30       	cpi	r24, 0x07	; 7
    5048:	18 f5       	brcc	.+70     	; 0x5090 <Endpoint_ConfigureEndpointTable+0x6c>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    504a:	62 95       	swap	r22
    504c:	66 0f       	add	r22, r22
    504e:	66 0f       	add	r22, r22
    5050:	60 7c       	andi	r22, 0xC0	; 192
    5052:	99 1f       	adc	r25, r25
    5054:	99 27       	eor	r25, r25
    5056:	99 1f       	adc	r25, r25
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    5058:	69 2b       	or	r22, r25
    505a:	22 30       	cpi	r18, 0x02	; 2
    505c:	10 f0       	brcs	.+4      	; 0x5062 <Endpoint_ConfigureEndpointTable+0x3e>
    505e:	96 e0       	ldi	r25, 0x06	; 6
    5060:	01 c0       	rjmp	.+2      	; 0x5064 <Endpoint_ConfigureEndpointTable+0x40>
    5062:	92 e0       	ldi	r25, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    5064:	28 e0       	ldi	r18, 0x08	; 8
    5066:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    5068:	40 e0       	ldi	r20, 0x00	; 0
    506a:	03 c0       	rjmp	.+6      	; 0x5072 <Endpoint_ConfigureEndpointTable+0x4e>
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    506c:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    506e:	22 0f       	add	r18, r18
    5070:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    5072:	2e 17       	cp	r18, r30
    5074:	3f 07       	cpc	r19, r31
    5076:	d0 f3       	brcs	.-12     	; 0x506c <Endpoint_ConfigureEndpointTable+0x48>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    5078:	42 95       	swap	r20
    507a:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    507c:	49 2b       	or	r20, r25
    507e:	9d df       	rcall	.-198    	; 0x4fba <Endpoint_ConfigureEndpoint_Prv>
    5080:	88 23       	and	r24, r24
    5082:	31 f0       	breq	.+12     	; 0x5090 <Endpoint_ConfigureEndpointTable+0x6c>
    5084:	0f 5f       	subi	r16, 0xFF	; 255
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    5086:	25 96       	adiw	r28, 0x05	; 5
    5088:	01 17       	cp	r16, r17
    508a:	a1 f6       	brne	.-88     	; 0x5034 <Endpoint_ConfigureEndpointTable+0x10>
    508c:	81 e0       	ldi	r24, 0x01	; 1
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}
	
	return true;
    508e:	01 c0       	rjmp	.+2      	; 0x5092 <Endpoint_ConfigureEndpointTable+0x6e>
    5090:	80 e0       	ldi	r24, 0x00	; 0
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    5092:	df 91       	pop	r29
	}
	
	return true;
}
    5094:	cf 91       	pop	r28
    5096:	1f 91       	pop	r17
    5098:	0f 91       	pop	r16
    509a:	08 95       	ret

0000509c <Endpoint_ClearStatusStage>:
    509c:	80 91 d0 0d 	lds	r24, 0x0DD0
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    50a0:	87 ff       	sbrs	r24, 7
    50a2:	11 c0       	rjmp	.+34     	; 0x50c6 <Endpoint_ClearStatusStage+0x2a>
    50a4:	03 c0       	rjmp	.+6      	; 0x50ac <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    50a6:	8e b3       	in	r24, 0x1e	; 30
    50a8:	88 23       	and	r24, r24
    50aa:	b1 f0       	breq	.+44     	; 0x50d8 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    50ac:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    50b0:	82 ff       	sbrs	r24, 2
    50b2:	f9 cf       	rjmp	.-14     	; 0x50a6 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    50b4:	80 91 e8 00 	lds	r24, 0x00E8
    50b8:	8b 77       	andi	r24, 0x7B	; 123
    50ba:	80 93 e8 00 	sts	0x00E8, r24
    50be:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    50c0:	8e b3       	in	r24, 0x1e	; 30
    50c2:	88 23       	and	r24, r24
    50c4:	49 f0       	breq	.+18     	; 0x50d8 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    50c6:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    50ca:	80 ff       	sbrs	r24, 0
    50cc:	f9 cf       	rjmp	.-14     	; 0x50c0 <Endpoint_ClearStatusStage+0x24>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    50ce:	80 91 e8 00 	lds	r24, 0x00E8
    50d2:	8e 77       	andi	r24, 0x7E	; 126
    50d4:	80 93 e8 00 	sts	0x00E8, r24
    50d8:	08 95       	ret

000050da <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    50da:	80 91 e4 00 	lds	r24, 0x00E4
    50de:	90 91 e5 00 	lds	r25, 0x00E5
    50e2:	45 e6       	ldi	r20, 0x65	; 101
    50e4:	01 c0       	rjmp	.+2      	; 0x50e8 <Endpoint_WaitUntilReady+0xe>
    50e6:	c9 01       	movw	r24, r18
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    50e8:	20 91 ec 00 	lds	r18, 0x00EC
    50ec:	20 ff       	sbrs	r18, 0
    50ee:	22 c0       	rjmp	.+68     	; 0x5134 <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    50f0:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    50f4:	20 fd       	sbrc	r18, 0
    50f6:	14 c0       	rjmp	.+40     	; 0x5120 <Endpoint_WaitUntilReady+0x46>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    50f8:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    50fa:	22 23       	and	r18, r18
    50fc:	99 f0       	breq	.+38     	; 0x5124 <Endpoint_WaitUntilReady+0x4a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    50fe:	25 30       	cpi	r18, 0x05	; 5
    5100:	99 f0       	breq	.+38     	; 0x5128 <Endpoint_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5102:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    5106:	25 fd       	sbrc	r18, 5
    5108:	11 c0       	rjmp	.+34     	; 0x512c <Endpoint_WaitUntilReady+0x52>
    510a:	20 91 e4 00 	lds	r18, 0x00E4
    510e:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    5112:	28 17       	cp	r18, r24
    5114:	39 07       	cpc	r19, r25
    5116:	41 f3       	breq	.-48     	; 0x50e8 <Endpoint_WaitUntilReady+0xe>
    5118:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    511a:	29 f7       	brne	.-54     	; 0x50e6 <Endpoint_WaitUntilReady+0xc>
			  return ENDPOINT_READYWAIT_Timeout;
    511c:	84 e0       	ldi	r24, 0x04	; 4
    511e:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    5120:	80 e0       	ldi	r24, 0x00	; 0
    5122:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    5124:	82 e0       	ldi	r24, 0x02	; 2
    5126:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    5128:	83 e0       	ldi	r24, 0x03	; 3
    512a:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    512c:	81 e0       	ldi	r24, 0x01	; 1
    512e:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    5130:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    5132:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5134:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    5138:	22 ff       	sbrs	r18, 2
    513a:	de cf       	rjmp	.-68     	; 0x50f8 <Endpoint_WaitUntilReady+0x1e>
    513c:	f9 cf       	rjmp	.-14     	; 0x5130 <Endpoint_WaitUntilReady+0x56>

0000513e <USB_Host_ResetDevice>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    513e:	80 91 9e 00 	lds	r24, 0x009E
    5142:	90 e0       	ldi	r25, 0x00	; 0
    5144:	81 70       	andi	r24, 0x01	; 1
    5146:	90 70       	andi	r25, 0x00	; 0
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    5148:	20 91 a0 00 	lds	r18, 0x00A0
    514c:	2d 7f       	andi	r18, 0xFD	; 253
    514e:	20 93 a0 00 	sts	0x00A0, r18
			 *  woken up automatically and the bus resumed after the reset has been correctly issued.
			 */
			static inline void USB_Host_ResetBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResetBus(void)
			{
				UHCON |=  (1 << RESET);
    5152:	20 91 9e 00 	lds	r18, 0x009E
    5156:	22 60       	ori	r18, 0x02	; 2
    5158:	20 93 9e 00 	sts	0x009E, r18
			 *  \return Boolean \c true if no bus reset is currently being sent, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusResetComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusResetComplete(void)
			{
				return ((UHCON & (1 << RESET)) ? false : true);
    515c:	20 91 9e 00 	lds	r18, 0x009E
	bool BusSuspended = USB_Host_IsBusSuspended();

	USB_INT_Disable(USB_INT_DDISCI);

	USB_Host_ResetBus();
	while (!(USB_Host_IsBusResetComplete()));
    5160:	21 fd       	sbrc	r18, 1
    5162:	fc cf       	rjmp	.-8      	; 0x515c <USB_Host_ResetDevice+0x1e>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5164:	20 91 9e 00 	lds	r18, 0x009E
    5168:	21 60       	ori	r18, 0x01	; 1
    516a:	20 93 9e 00 	sts	0x009E, r18
	USB_Host_ResumeBus();

	USB_Host_ConfigurationNumber = 0;
    516e:	10 92 ce 0d 	sts	0x0DCE, r1
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    5172:	20 91 a0 00 	lds	r18, 0x00A0
    5176:	30 e0       	ldi	r19, 0x00	; 0
    5178:	20 72       	andi	r18, 0x20	; 32
    517a:	30 70       	andi	r19, 0x00	; 0
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    517c:	40 91 a0 00 	lds	r20, 0x00A0
    5180:	4f 7d       	andi	r20, 0xDF	; 223
    5182:	40 93 a0 00 	sts	0x00A0, r20
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5186:	40 91 9f 00 	lds	r20, 0x009F
    518a:	4f 7d       	andi	r20, 0xDF	; 223
    518c:	40 93 9f 00 	sts	0x009F, r20
    5190:	4a e0       	ldi	r20, 0x0A	; 10
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    5192:	50 91 9f 00 	lds	r21, 0x009F
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    5196:	55 ff       	sbrs	r21, 5
    5198:	0b c0       	rjmp	.+22     	; 0x51b0 <USB_Host_ResetDevice+0x72>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    519a:	40 91 9f 00 	lds	r20, 0x009F
    519e:	4f 7d       	andi	r20, 0xDF	; 223
    51a0:	40 93 9f 00 	sts	0x009F, r20
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    51a4:	40 91 9f 00 	lds	r20, 0x009F
    51a8:	4d 7f       	andi	r20, 0xFD	; 253
    51aa:	40 93 9f 00 	sts	0x009F, r20
    51ae:	08 c0       	rjmp	.+16     	; 0x51c0 <USB_Host_ResetDevice+0x82>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    51b0:	ef ec       	ldi	r30, 0xCF	; 207
    51b2:	f7 e0       	ldi	r31, 0x07	; 7
    51b4:	31 97       	sbiw	r30, 0x01	; 1
    51b6:	f1 f7       	brne	.-4      	; 0x51b4 <USB_Host_ResetDevice+0x76>
    51b8:	00 c0       	rjmp	.+0      	; 0x51ba <USB_Host_ResetDevice+0x7c>
    51ba:	00 00       	nop
    51bc:	41 50       	subi	r20, 0x01	; 1
	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);

	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    51be:	49 f7       	brne	.-46     	; 0x5192 <USB_Host_ResetDevice+0x54>
		}

		Delay_MS(1);
	}

	if (HSOFIEnabled)
    51c0:	21 15       	cp	r18, r1
    51c2:	31 05       	cpc	r19, r1
    51c4:	29 f0       	breq	.+10     	; 0x51d0 <USB_Host_ResetDevice+0x92>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    51c6:	20 91 a0 00 	lds	r18, 0x00A0
    51ca:	20 62       	ori	r18, 0x20	; 32
    51cc:	20 93 a0 00 	sts	0x00A0, r18
	  USB_INT_Enable(USB_INT_HSOFI);

	if (BusSuspended)
    51d0:	00 97       	sbiw	r24, 0x00	; 0
    51d2:	29 f4       	brne	.+10     	; 0x51de <USB_Host_ResetDevice+0xa0>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    51d4:	80 91 9e 00 	lds	r24, 0x009E
    51d8:	8e 7f       	andi	r24, 0xFE	; 254
    51da:	80 93 9e 00 	sts	0x009E, r24
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    51de:	80 91 a0 00 	lds	r24, 0x00A0
    51e2:	82 60       	ori	r24, 0x02	; 2
    51e4:	80 93 a0 00 	sts	0x00A0, r24
	  USB_Host_SuspendBus();

	USB_INT_Enable(USB_INT_DDISCI);
}
    51e8:	08 95       	ret

000051ea <USB_Host_WaitMS>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    51ea:	40 91 9e 00 	lds	r20, 0x009E
    51ee:	50 e0       	ldi	r21, 0x00	; 0
    51f0:	41 70       	andi	r20, 0x01	; 1
    51f2:	50 70       	andi	r21, 0x00	; 0
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    51f4:	20 91 a0 00 	lds	r18, 0x00A0
    51f8:	30 e0       	ldi	r19, 0x00	; 0
    51fa:	20 72       	andi	r18, 0x20	; 32
    51fc:	30 70       	andi	r19, 0x00	; 0
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    51fe:	90 91 a0 00 	lds	r25, 0x00A0
    5202:	9f 7d       	andi	r25, 0xDF	; 223
    5204:	90 93 a0 00 	sts	0x00A0, r25
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5208:	90 91 9f 00 	lds	r25, 0x009F
    520c:	9f 7d       	andi	r25, 0xDF	; 223
    520e:	90 93 9f 00 	sts	0x009F, r25
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5212:	90 91 9e 00 	lds	r25, 0x009E
    5216:	91 60       	ori	r25, 0x01	; 1
    5218:	90 93 9e 00 	sts	0x009E, r25
    521c:	29 c0       	rjmp	.+82     	; 0x5270 <USB_Host_WaitMS+0x86>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    521e:	90 91 9f 00 	lds	r25, 0x009F

	USB_Host_ResumeBus();

	while (MS)
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    5222:	95 ff       	sbrs	r25, 5
    5224:	06 c0       	rjmp	.+12     	; 0x5232 <USB_Host_WaitMS+0x48>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5226:	90 91 9f 00 	lds	r25, 0x009F
    522a:	9f 7d       	andi	r25, 0xDF	; 223
    522c:	90 93 9f 00 	sts	0x009F, r25
		{
			USB_INT_Clear(USB_INT_HSOFI);
			MS--;
    5230:	81 50       	subi	r24, 0x01	; 1
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
    5232:	9e b3       	in	r25, 0x1e	; 30
    5234:	91 30       	cpi	r25, 0x01	; 1
    5236:	f9 f0       	breq	.+62     	; 0x5276 <USB_Host_WaitMS+0x8c>
    5238:	90 91 fb 03 	lds	r25, 0x03FB
    523c:	92 30       	cpi	r25, 0x02	; 2
    523e:	d9 f4       	brne	.+54     	; 0x5276 <USB_Host_WaitMS+0x8c>
			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
			 */
			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsError(void)
			{
				return ((UPINTX & (1 << PERRI)) ? true : false);
    5240:	90 91 a6 00 	lds	r25, 0x00A6
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;

			break;
		}

		if (Pipe_IsError())
    5244:	94 ff       	sbrs	r25, 4
    5246:	09 c0       	rjmp	.+18     	; 0x525a <USB_Host_WaitMS+0x70>

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    5248:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    524c:	80 91 a6 00 	lds	r24, 0x00A6
    5250:	8f 7e       	andi	r24, 0xEF	; 239
    5252:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearError();
			ErrorCode = HOST_WAITERROR_PipeError;
    5256:	82 e0       	ldi	r24, 0x02	; 2

			break;
    5258:	0f c0       	rjmp	.+30     	; 0x5278 <USB_Host_WaitMS+0x8e>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    525a:	90 91 a6 00 	lds	r25, 0x00A6
		}

		if (Pipe_IsStalled())
    525e:	91 ff       	sbrs	r25, 1
    5260:	07 c0       	rjmp	.+14     	; 0x5270 <USB_Host_WaitMS+0x86>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearStall(void)
			{
				UPINTX &= ~(1 << RXSTALLI);
    5262:	80 91 a6 00 	lds	r24, 0x00A6
    5266:	8d 7f       	andi	r24, 0xFD	; 253
    5268:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearStall();
			ErrorCode = HOST_WAITERROR_SetupStalled;
    526c:	83 e0       	ldi	r24, 0x03	; 3

			break;
    526e:	04 c0       	rjmp	.+8      	; 0x5278 <USB_Host_WaitMS+0x8e>
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    5270:	88 23       	and	r24, r24
    5272:	a9 f6       	brne	.-86     	; 0x521e <USB_Host_WaitMS+0x34>
    5274:	01 c0       	rjmp	.+2      	; 0x5278 <USB_Host_WaitMS+0x8e>
			MS--;
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
		{
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;
    5276:	81 e0       	ldi	r24, 0x01	; 1

			break;
		}
	}

	if (BusSuspended)
    5278:	41 15       	cp	r20, r1
    527a:	51 05       	cpc	r21, r1
    527c:	29 f4       	brne	.+10     	; 0x5288 <USB_Host_WaitMS+0x9e>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    527e:	90 91 9e 00 	lds	r25, 0x009E
    5282:	9e 7f       	andi	r25, 0xFE	; 254
    5284:	90 93 9e 00 	sts	0x009E, r25
	  USB_Host_SuspendBus();

	if (HSOFIEnabled)
    5288:	21 15       	cp	r18, r1
    528a:	31 05       	cpc	r19, r1
    528c:	29 f0       	breq	.+10     	; 0x5298 <USB_Host_WaitMS+0xae>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    528e:	90 91 a0 00 	lds	r25, 0x00A0
    5292:	90 62       	ori	r25, 0x20	; 32
    5294:	90 93 a0 00 	sts	0x00A0, r25
	  USB_INT_Enable(USB_INT_HSOFI);

	return ErrorCode;
}
    5298:	08 95       	ret

0000529a <USB_Host_ProcessNextHostState>:

#define  __INCLUDE_FROM_HOST_C
#include "../Host.h"

void USB_Host_ProcessNextHostState(void)
{
    529a:	0f 93       	push	r16
    529c:	1f 93       	push	r17
    529e:	cf 93       	push	r28
    52a0:	df 93       	push	r29
    52a2:	cd b7       	in	r28, 0x3d	; 61
    52a4:	de b7       	in	r29, 0x3e	; 62
    52a6:	28 97       	sbiw	r28, 0x08	; 8
    52a8:	0f b6       	in	r0, 0x3f	; 63
    52aa:	f8 94       	cli
    52ac:	de bf       	out	0x3e, r29	; 62
    52ae:	0f be       	out	0x3f, r0	; 63
    52b0:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    52b2:	8e b3       	in	r24, 0x1e	; 30
    52b4:	85 30       	cpi	r24, 0x05	; 5
    52b6:	09 f4       	brne	.+2      	; 0x52ba <USB_Host_ProcessNextHostState+0x20>
    52b8:	96 c0       	rjmp	.+300    	; 0x53e6 <USB_Host_ProcessNextHostState+0x14c>
    52ba:	86 30       	cpi	r24, 0x06	; 6
    52bc:	68 f4       	brcc	.+26     	; 0x52d8 <USB_Host_ProcessNextHostState+0x3e>
    52be:	82 30       	cpi	r24, 0x02	; 2
    52c0:	b9 f1       	breq	.+110    	; 0x5330 <USB_Host_ProcessNextHostState+0x96>
    52c2:	83 30       	cpi	r24, 0x03	; 3
    52c4:	18 f4       	brcc	.+6      	; 0x52cc <USB_Host_ProcessNextHostState+0x32>
    52c6:	88 23       	and	r24, r24
    52c8:	a1 f0       	breq	.+40     	; 0x52f2 <USB_Host_ProcessNextHostState+0x58>
    52ca:	ff c0       	rjmp	.+510    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    52cc:	83 30       	cpi	r24, 0x03	; 3
    52ce:	c9 f1       	breq	.+114    	; 0x5342 <USB_Host_ProcessNextHostState+0xa8>
    52d0:	84 30       	cpi	r24, 0x04	; 4
    52d2:	09 f0       	breq	.+2      	; 0x52d6 <USB_Host_ProcessNextHostState+0x3c>
    52d4:	fa c0       	rjmp	.+500    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    52d6:	60 c0       	rjmp	.+192    	; 0x5398 <USB_Host_ProcessNextHostState+0xfe>
    52d8:	87 30       	cpi	r24, 0x07	; 7
    52da:	09 f4       	brne	.+2      	; 0x52de <USB_Host_ProcessNextHostState+0x44>
    52dc:	9a c0       	rjmp	.+308    	; 0x5412 <USB_Host_ProcessNextHostState+0x178>
    52de:	87 30       	cpi	r24, 0x07	; 7
    52e0:	08 f4       	brcc	.+2      	; 0x52e4 <USB_Host_ProcessNextHostState+0x4a>
    52e2:	8b c0       	rjmp	.+278    	; 0x53fa <USB_Host_ProcessNextHostState+0x160>
    52e4:	88 30       	cpi	r24, 0x08	; 8
    52e6:	09 f4       	brne	.+2      	; 0x52ea <USB_Host_ProcessNextHostState+0x50>
    52e8:	b3 c0       	rjmp	.+358    	; 0x5450 <USB_Host_ProcessNextHostState+0x1b6>
    52ea:	89 30       	cpi	r24, 0x09	; 9
    52ec:	09 f0       	breq	.+2      	; 0x52f0 <USB_Host_ProcessNextHostState+0x56>
    52ee:	ed c0       	rjmp	.+474    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    52f0:	d3 c0       	rjmp	.+422    	; 0x5498 <USB_Host_ProcessNextHostState+0x1fe>
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    52f2:	00 91 f8 03 	lds	r16, 0x03F8
    52f6:	10 91 f9 03 	lds	r17, 0x03F9
    52fa:	01 15       	cp	r16, r1
    52fc:	11 05       	cpc	r17, r1
    52fe:	09 f4       	brne	.+2      	; 0x5302 <USB_Host_ProcessNextHostState+0x68>
    5300:	e4 c0       	rjmp	.+456    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5302:	81 e0       	ldi	r24, 0x01	; 1
    5304:	72 df       	rcall	.-284    	; 0x51ea <USB_Host_WaitMS>
    5306:	68 2f       	mov	r22, r24
    5308:	88 23       	and	r24, r24
    530a:	29 f0       	breq	.+10     	; 0x5316 <USB_Host_ProcessNextHostState+0x7c>
    530c:	80 91 fa 03 	lds	r24, 0x03FA
				{
					USB_HostState = PostWaitState;
    5310:	8e bb       	out	0x1e, r24	; 30
    5312:	81 e0       	ldi	r24, 0x01	; 1
					ErrorCode     = HOST_ENUMERROR_WaitStage;
    5314:	cd c0       	rjmp	.+410    	; 0x54b0 <USB_Host_ProcessNextHostState+0x216>
					break;
    5316:	01 50       	subi	r16, 0x01	; 1
				}

				if (!(--WaitMSRemaining))
    5318:	10 40       	sbci	r17, 0x00	; 0
    531a:	10 93 f9 03 	sts	0x03F9, r17
    531e:	00 93 f8 03 	sts	0x03F8, r16
    5322:	01 15       	cp	r16, r1
    5324:	11 05       	cpc	r17, r1
    5326:	09 f0       	breq	.+2      	; 0x532a <USB_Host_ProcessNextHostState+0x90>
    5328:	d0 c0       	rjmp	.+416    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    532a:	80 91 fa 03 	lds	r24, 0x03FA
				  USB_HostState = PostWaitState;
    532e:	07 c0       	rjmp	.+14     	; 0x533e <USB_Host_ProcessNextHostState+0xa4>
    5330:	88 ee       	ldi	r24, 0xE8	; 232
			}

			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    5332:	93 e0       	ldi	r25, 0x03	; 3
    5334:	90 93 f9 03 	sts	0x03F9, r25
    5338:	80 93 f8 03 	sts	0x03F8, r24
    533c:	83 e0       	ldi	r24, 0x03	; 3

			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    533e:	8e bb       	out	0x1e, r24	; 30
    5340:	c4 c0       	rjmp	.+392    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
			break;
    5342:	80 91 f8 03 	lds	r24, 0x03F8
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    5346:	90 91 f9 03 	lds	r25, 0x03F9
    534a:	9c 01       	movw	r18, r24
    534c:	21 50       	subi	r18, 0x01	; 1
    534e:	30 40       	sbci	r19, 0x00	; 0
    5350:	30 93 f9 03 	sts	0x03F9, r19
    5354:	20 93 f8 03 	sts	0x03F8, r18
    5358:	00 97       	sbiw	r24, 0x00	; 0
    535a:	39 f0       	breq	.+14     	; 0x536a <USB_Host_ProcessNextHostState+0xd0>
    535c:	8f ec       	ldi	r24, 0xCF	; 207
    535e:	97 e0       	ldi	r25, 0x07	; 7
    5360:	01 97       	sbiw	r24, 0x01	; 1
    5362:	f1 f7       	brne	.-4      	; 0x5360 <USB_Host_ProcessNextHostState+0xc6>
    5364:	00 c0       	rjmp	.+0      	; 0x5366 <USB_Host_ProcessNextHostState+0xcc>
    5366:	00 00       	nop
    5368:	b0 c0       	rjmp	.+352    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    536a:	77 98       	cbi	0x0e, 7	; 14
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  |=  (1 << 7);
				#else
				PORTE  &= ~(1 << 7);
    536c:	80 91 d8 00 	lds	r24, 0x00D8

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    5370:	80 61       	ori	r24, 0x10	; 16
    5372:	80 93 d8 00 	sts	0x00D8, r24
    5376:	80 91 dd 00 	lds	r24, 0x00DD
			}

			static inline void USB_Host_VBUS_Auto_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Enable(void)
			{
				OTGCON &= ~(1 << VBUSHWC);
    537a:	8b 7f       	andi	r24, 0xFB	; 251
    537c:	80 93 dd 00 	sts	0x00DD, r24
    5380:	80 91 d7 00 	lds	r24, 0x00D7
				UHWCON |=  (1 << UVCONE);
    5384:	80 61       	ori	r24, 0x10	; 16
    5386:	80 93 d7 00 	sts	0x00D7, r24
    538a:	80 91 dd 00 	lds	r24, 0x00DD
			}

			static inline void USB_Host_VBUS_Auto_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_On(void)
			{
				OTGCON |=  (1 << VBUSREQ);
    538e:	82 60       	ori	r24, 0x02	; 2
    5390:	80 93 dd 00 	sts	0x00DD, r24
    5394:	84 e0       	ldi	r24, 0x04	; 4
				#if defined(NO_AUTO_VBUS_MANAGEMENT)
				USB_Host_VBUS_Manual_Enable();
				USB_Host_VBUS_Manual_On();
				#endif

				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    5396:	d3 cf       	rjmp	.-90     	; 0x533e <USB_Host_ProcessNextHostState+0xa4>
    5398:	80 91 9f 00 	lds	r24, 0x009F
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
    539c:	80 ff       	sbrs	r24, 0
			}

			break;
		case HOST_STATE_Powered_WaitForConnect:
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    539e:	95 c0       	rjmp	.+298    	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    53a0:	80 91 9f 00 	lds	r24, 0x009F
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    53a4:	8e 7f       	andi	r24, 0xFE	; 254
    53a6:	80 93 9f 00 	sts	0x009F, r24
    53aa:	80 91 9f 00 	lds	r24, 0x009F
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    53ae:	8d 7f       	andi	r24, 0xFD	; 253
    53b0:	80 93 9f 00 	sts	0x009F, r24
    53b4:	80 91 df 00 	lds	r24, 0x00DF
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    53b8:	8d 7f       	andi	r24, 0xFD	; 253
    53ba:	80 93 df 00 	sts	0x00DF, r24
    53be:	80 91 de 00 	lds	r24, 0x00DE
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
    53c2:	82 60       	ori	r24, 0x02	; 2
    53c4:	80 93 de 00 	sts	0x00DE, r24
    53c8:	80 91 9e 00 	lds	r24, 0x009E
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    53cc:	81 60       	ori	r24, 0x01	; 1
    53ce:	80 93 9e 00 	sts	0x009E, r24
    53d2:	05 d2       	rcall	.+1034   	; 0x57de <Pipe_ClearPipes>

				USB_INT_Clear(USB_INT_VBERRI);
				USB_INT_Enable(USB_INT_VBERRI);

				USB_Host_ResumeBus();
				Pipe_ClearPipes();
    53d4:	1e ba       	out	0x1e, r1	; 30
    53d6:	84 e6       	ldi	r24, 0x64	; 100

				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    53d8:	90 e0       	ldi	r25, 0x00	; 0
    53da:	90 93 f9 03 	sts	0x03F9, r25
    53de:	80 93 f8 03 	sts	0x03F8, r24
    53e2:	85 e0       	ldi	r24, 0x05	; 5
    53e4:	56 c0       	rjmp	.+172    	; 0x5492 <USB_Host_ProcessNextHostState+0x1f8>
    53e6:	ab de       	rcall	.-682    	; 0x513e <USB_Host_ResetDevice>
    53e8:	1e ba       	out	0x1e, r1	; 30
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    53ea:	88 ec       	ldi	r24, 0xC8	; 200
    53ec:	90 e0       	ldi	r25, 0x00	; 0

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    53ee:	90 93 f9 03 	sts	0x03F9, r25
    53f2:	80 93 f8 03 	sts	0x03F8, r24
    53f6:	86 e0       	ldi	r24, 0x06	; 6
    53f8:	4c c0       	rjmp	.+152    	; 0x5492 <USB_Host_ProcessNextHostState+0x1f8>
    53fa:	80 e0       	ldi	r24, 0x00	; 0
    53fc:	60 e0       	ldi	r22, 0x00	; 0
    53fe:	40 e0       	ldi	r20, 0x00	; 0
			break;
		case HOST_STATE_Powered_ConfigPipe:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, PIPE_CONTROLPIPE_DEFAULT_SIZE, 1)))
    5400:	20 e4       	ldi	r18, 0x40	; 64
    5402:	30 e0       	ldi	r19, 0x00	; 0
    5404:	01 e0       	ldi	r16, 0x01	; 1
    5406:	65 d1       	rcall	.+714    	; 0x56d2 <Pipe_ConfigurePipe>
    5408:	88 23       	and	r24, r24
    540a:	09 f4       	brne	.+2      	; 0x540e <USB_Host_ProcessNextHostState+0x174>
    540c:	4d c0       	rjmp	.+154    	; 0x54a8 <USB_Host_ProcessNextHostState+0x20e>
    540e:	87 e0       	ldi	r24, 0x07	; 7
    5410:	96 cf       	rjmp	.-212    	; 0x533e <USB_Host_ProcessNextHostState+0xa4>
    5412:	a0 ed       	ldi	r26, 0xD0	; 208
    5414:	bd e0       	ldi	r27, 0x0D	; 13
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    5416:	ed e3       	ldi	r30, 0x3D	; 61
    5418:	f3 e0       	ldi	r31, 0x03	; 3
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    541a:	88 e0       	ldi	r24, 0x08	; 8
    541c:	01 90       	ld	r0, Z+
    541e:	0d 92       	st	X+, r0
    5420:	81 50       	subi	r24, 0x01	; 1
    5422:	e1 f7       	brne	.-8      	; 0x541c <USB_Host_ProcessNextHostState+0x182>
    5424:	10 92 a7 00 	sts	0x00A7, r1
    5428:	ce 01       	movw	r24, r28
    542a:	01 96       	adiw	r24, 0x01	; 1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    542c:	ee d6       	rcall	.+3548   	; 0x620a <USB_Host_SendControlRequest>
    542e:	68 2f       	mov	r22, r24
				};

			uint8_t DataBuffer[8];

			Pipe_SelectPipe(PIPE_CONTROLPIPE);
			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    5430:	88 23       	and	r24, r24
    5432:	09 f0       	breq	.+2      	; 0x5436 <USB_Host_ProcessNextHostState+0x19c>
    5434:	3c c0       	rjmp	.+120    	; 0x54ae <USB_Host_ProcessNextHostState+0x214>
    5436:	88 85       	ldd	r24, Y+8	; 0x08
    5438:	80 93 4d 03 	sts	0x034D, r24
    543c:	80 de       	rcall	.-768    	; 0x513e <USB_Host_ResetDevice>
    543e:	1e ba       	out	0x1e, r1	; 30
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_Host_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    5440:	88 ec       	ldi	r24, 0xC8	; 200
    5442:	90 e0       	ldi	r25, 0x00	; 0
    5444:	90 93 f9 03 	sts	0x03F9, r25

			USB_Host_ResetDevice();
    5448:	80 93 f8 03 	sts	0x03F8, r24

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    544c:	88 e0       	ldi	r24, 0x08	; 8
    544e:	21 c0       	rjmp	.+66     	; 0x5492 <USB_Host_ProcessNextHostState+0x1f8>
    5450:	20 91 4d 03 	lds	r18, 0x034D
    5454:	80 e0       	ldi	r24, 0x00	; 0
    5456:	60 e0       	ldi	r22, 0x00	; 0
    5458:	40 e0       	ldi	r20, 0x00	; 0
    545a:	30 e0       	ldi	r19, 0x00	; 0
			break;
		case HOST_STATE_Default_PostReset:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, USB_Host_ControlPipeSize, 1)))
    545c:	01 e0       	ldi	r16, 0x01	; 1
    545e:	39 d1       	rcall	.+626    	; 0x56d2 <Pipe_ConfigurePipe>
    5460:	88 23       	and	r24, r24
    5462:	11 f1       	breq	.+68     	; 0x54a8 <USB_Host_ProcessNextHostState+0x20e>
    5464:	a0 ed       	ldi	r26, 0xD0	; 208
    5466:	bd e0       	ldi	r27, 0x0D	; 13
    5468:	e5 e4       	ldi	r30, 0x45	; 69
    546a:	f3 e0       	ldi	r31, 0x03	; 3
    546c:	88 e0       	ldi	r24, 0x08	; 8
    546e:	01 90       	ld	r0, Z+
    5470:	0d 92       	st	X+, r0
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    5472:	81 50       	subi	r24, 0x01	; 1
    5474:	e1 f7       	brne	.-8      	; 0x546e <USB_Host_ProcessNextHostState+0x1d4>
    5476:	80 e0       	ldi	r24, 0x00	; 0
    5478:	90 e0       	ldi	r25, 0x00	; 0
    547a:	c7 d6       	rcall	.+3470   	; 0x620a <USB_Host_SendControlRequest>
    547c:	68 2f       	mov	r22, r24
    547e:	88 23       	and	r24, r24
    5480:	b1 f4       	brne	.+44     	; 0x54ae <USB_Host_ProcessNextHostState+0x214>
    5482:	1e ba       	out	0x1e, r1	; 30
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    5484:	84 e6       	ldi	r24, 0x64	; 100
    5486:	90 e0       	ldi	r25, 0x00	; 0
    5488:	90 93 f9 03 	sts	0x03F9, r25
    548c:	80 93 f8 03 	sts	0x03F8, r24
    5490:	89 e0       	ldi	r24, 0x09	; 9
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    5492:	80 93 fa 03 	sts	0x03FA, r24
    5496:	19 c0       	rjmp	.+50     	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
    5498:	81 e0       	ldi	r24, 0x01	; 1
    549a:	80 93 a1 00 	sts	0x00A1, r24
    549e:	8a e0       	ldi	r24, 0x0A	; 10
    54a0:	8e bb       	out	0x1e, r24	; 30
    54a2:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <EVENT_USB_Host_DeviceEnumerationComplete>
			break;
    54a6:	11 c0       	rjmp	.+34     	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
			}

			static inline void USB_Host_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SetDeviceAddress(const uint8_t Address)
			{
				UHADDR  =  (Address & 0x7F);
    54a8:	60 e0       	ldi	r22, 0x00	; 0
    54aa:	84 e0       	ldi	r24, 0x04	; 4
    54ac:	01 c0       	rjmp	.+2      	; 0x54b0 <USB_Host_ProcessNextHostState+0x216>
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);

			USB_HostState = HOST_STATE_Addressed;
    54ae:	83 e0       	ldi	r24, 0x03	; 3
    54b0:	9e b3       	in	r25, 0x1e	; 30

			EVENT_USB_Host_DeviceEnumerationComplete();
    54b2:	91 30       	cpi	r25, 0x01	; 1
    54b4:	51 f0       	breq	.+20     	; 0x54ca <USB_Host_ProcessNextHostState+0x230>
			break;
    54b6:	0e 94 5d 03 	call	0x6ba	; 0x6ba <EVENT_USB_Host_DeviceEnumerationFailed>
			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
			break;
		case HOST_STATE_Default_PostReset:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, USB_Host_ControlPipeSize, 1)))
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
    54ba:	80 91 dd 00 	lds	r24, 0x00DD
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
    54be:	81 60       	ori	r24, 0x01	; 1

		default:
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    54c0:	80 93 dd 00 	sts	0x00DD, r24
    54c4:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    54c8:	07 d2       	rcall	.+1038   	; 0x58d8 <USB_ResetInterface>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    54ca:	28 96       	adiw	r28, 0x08	; 8
    54cc:	0f b6       	in	r0, 0x3f	; 63
    54ce:	f8 94       	cli
    54d0:	de bf       	out	0x3e, r29	; 62
    54d2:	0f be       	out	0x3f, r0	; 63

		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_DeviceUnattached();
    54d4:	cd bf       	out	0x3d, r28	; 61
    54d6:	df 91       	pop	r29

		USB_ResetInterface();
    54d8:	cf 91       	pop	r28
    54da:	1f 91       	pop	r17
	}
}
    54dc:	0f 91       	pop	r16
    54de:	08 95       	ret

000054e0 <Pipe_Discard_Stream>:

#include "PipeStream_AVR8.h"

uint8_t Pipe_Discard_Stream(uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    54e0:	df 92       	push	r13
    54e2:	ef 92       	push	r14
    54e4:	ff 92       	push	r15
    54e6:	0f 93       	push	r16
    54e8:	1f 93       	push	r17
    54ea:	cf 93       	push	r28
    54ec:	df 93       	push	r29
    54ee:	ec 01       	movw	r28, r24
    54f0:	8b 01       	movw	r16, r22
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    54f2:	80 91 aa 00 	lds	r24, 0x00AA
    54f6:	8f 7c       	andi	r24, 0xCF	; 207
    54f8:	80 61       	ori	r24, 0x10	; 16
    54fa:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;
	
	Pipe_SetPipeToken(PIPE_TOKEN_IN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    54fe:	a5 d1       	rcall	.+842    	; 0x584a <Pipe_WaitUntilReady>
    5500:	d8 2e       	mov	r13, r24
    5502:	88 23       	and	r24, r24
    5504:	79 f5       	brne	.+94     	; 0x5564 <Pipe_Discard_Stream+0x84>
    5506:	01 15       	cp	r16, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5508:	11 05       	cpc	r17, r1
    550a:	29 f0       	breq	.+10     	; 0x5516 <Pipe_Discard_Stream+0x36>
    550c:	f8 01       	movw	r30, r16
	  Length -= *BytesProcessed;
    550e:	20 81       	ld	r18, Z
    5510:	31 81       	ldd	r19, Z+1	; 0x01
    5512:	c2 1b       	sub	r28, r18
    5514:	d3 0b       	sbc	r29, r19
    5516:	ee 24       	eor	r14, r14

#include "PipeStream_AVR8.h"

uint8_t Pipe_Discard_Stream(uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5518:	ff 24       	eor	r15, r15
    551a:	20 c0       	rjmp	.+64     	; 0x555c <Pipe_Discard_Stream+0x7c>
    551c:	80 91 a6 00 	lds	r24, 0x00A6
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5520:	85 fd       	sbrc	r24, 5
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5522:	16 c0       	rjmp	.+44     	; 0x5550 <Pipe_Discard_Stream+0x70>
    5524:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5528:	8e 77       	andi	r24, 0x7E	; 126
    552a:	80 93 a6 00 	sts	0x00A6, r24
    552e:	01 15       	cp	r16, r1
		{
			Pipe_ClearIN();
				
			if (BytesProcessed != NULL)
    5530:	11 05       	cpc	r17, r1
    5532:	51 f0       	breq	.+20     	; 0x5548 <Pipe_Discard_Stream+0x68>
    5534:	f8 01       	movw	r30, r16
			{
				*BytesProcessed += BytesInTransfer;
    5536:	80 81       	ld	r24, Z
    5538:	91 81       	ldd	r25, Z+1	; 0x01
    553a:	8e 0d       	add	r24, r14
    553c:	9f 1d       	adc	r25, r15
    553e:	91 83       	std	Z+1, r25	; 0x01
    5540:	80 83       	st	Z, r24
    5542:	24 e0       	ldi	r18, 0x04	; 4
				return PIPE_RWSTREAM_IncompleteTransfer;
    5544:	d2 2e       	mov	r13, r18
    5546:	0e c0       	rjmp	.+28     	; 0x5564 <Pipe_Discard_Stream+0x84>
    5548:	80 d1       	rcall	.+768    	; 0x584a <Pipe_WaitUntilReady>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    554a:	88 23       	and	r24, r24
    554c:	39 f0       	breq	.+14     	; 0x555c <Pipe_Discard_Stream+0x7c>
    554e:	09 c0       	rjmp	.+18     	; 0x5562 <Pipe_Discard_Stream+0x82>
    5550:	80 91 af 00 	lds	r24, 0x00AF
			static inline void Pipe_Discard_8(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Discard_8(void)
			{
				uint8_t Dummy;

				Dummy = UPDATX;
    5554:	21 97       	sbiw	r28, 0x01	; 1
    5556:	08 94       	sec
		}
		else
		{
			Pipe_Discard_8();
			
			Length--;
    5558:	e1 1c       	adc	r14, r1
			BytesInTransfer++;
    555a:	f1 1c       	adc	r15, r1
    555c:	20 97       	sbiw	r28, 0x00	; 0
    555e:	f1 f6       	brne	.-68     	; 0x551c <Pipe_Discard_Stream+0x3c>
	  return ErrorCode;

	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    5560:	01 c0       	rjmp	.+2      	; 0x5564 <Pipe_Discard_Stream+0x84>
    5562:	d8 2e       	mov	r13, r24
    5564:	8d 2d       	mov	r24, r13
			{
				*BytesProcessed += BytesInTransfer;
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5566:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    5568:	cf 91       	pop	r28
    556a:	1f 91       	pop	r17
    556c:	0f 91       	pop	r16
    556e:	ff 90       	pop	r15
    5570:	ef 90       	pop	r14
    5572:	df 90       	pop	r13
    5574:	08 95       	ret

00005576 <Pipe_Write_Stream_LE>:
    5576:	af 92       	push	r10
    5578:	bf 92       	push	r11
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    557a:	cf 92       	push	r12
    557c:	df 92       	push	r13
    557e:	ff 92       	push	r15
    5580:	0f 93       	push	r16
    5582:	1f 93       	push	r17
    5584:	cf 93       	push	r28
    5586:	df 93       	push	r29
    5588:	5c 01       	movw	r10, r24
    558a:	eb 01       	movw	r28, r22
    558c:	6a 01       	movw	r12, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    558e:	80 91 aa 00 	lds	r24, 0x00AA
    5592:	8f 7c       	andi	r24, 0xCF	; 207
    5594:	80 62       	ori	r24, 0x20	; 32
    5596:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    559a:	57 d1       	rcall	.+686    	; 0x584a <Pipe_WaitUntilReady>
    559c:	f8 2e       	mov	r15, r24
    559e:	88 23       	and	r24, r24
    55a0:	b1 f5       	brne	.+108    	; 0x560e <Pipe_Write_Stream_LE+0x98>
    55a2:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    55a4:	d1 04       	cpc	r13, r1
    55a6:	41 f0       	breq	.+16     	; 0x55b8 <Pipe_Write_Stream_LE+0x42>
    55a8:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    55aa:	00 81       	ld	r16, Z
    55ac:	11 81       	ldd	r17, Z+1	; 0x01
    55ae:	c0 1b       	sub	r28, r16
    55b0:	d1 0b       	sbc	r29, r17
    55b2:	0a 0d       	add	r16, r10
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    55b4:	1b 1d       	adc	r17, r11
    55b6:	01 c0       	rjmp	.+2      	; 0x55ba <Pipe_Write_Stream_LE+0x44>
    55b8:	85 01       	movw	r16, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    55ba:	aa 24       	eor	r10, r10
    55bc:	bb 24       	eor	r11, r11
    55be:	23 c0       	rjmp	.+70     	; 0x5606 <Pipe_Write_Stream_LE+0x90>
    55c0:	80 91 a6 00 	lds	r24, 0x00A6
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    55c4:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    55c6:	16 c0       	rjmp	.+44     	; 0x55f4 <Pipe_Write_Stream_LE+0x7e>
    55c8:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    55cc:	8b 77       	andi	r24, 0x7B	; 123
    55ce:	80 93 a6 00 	sts	0x00A6, r24
    55d2:	c1 14       	cp	r12, r1
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    55d4:	d1 04       	cpc	r13, r1
    55d6:	51 f0       	breq	.+20     	; 0x55ec <Pipe_Write_Stream_LE+0x76>
    55d8:	f6 01       	movw	r30, r12
			{
				*BytesProcessed += BytesInTransfer;
    55da:	80 81       	ld	r24, Z
    55dc:	91 81       	ldd	r25, Z+1	; 0x01
    55de:	8a 0d       	add	r24, r10
    55e0:	9b 1d       	adc	r25, r11
    55e2:	91 83       	std	Z+1, r25	; 0x01
    55e4:	80 83       	st	Z, r24
    55e6:	44 e0       	ldi	r20, 0x04	; 4
				return PIPE_RWSTREAM_IncompleteTransfer;
    55e8:	f4 2e       	mov	r15, r20
    55ea:	11 c0       	rjmp	.+34     	; 0x560e <Pipe_Write_Stream_LE+0x98>
    55ec:	2e d1       	rcall	.+604    	; 0x584a <Pipe_WaitUntilReady>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    55ee:	88 23       	and	r24, r24
    55f0:	51 f0       	breq	.+20     	; 0x5606 <Pipe_Write_Stream_LE+0x90>
    55f2:	0c c0       	rjmp	.+24     	; 0x560c <Pipe_Write_Stream_LE+0x96>
    55f4:	f8 01       	movw	r30, r16
    55f6:	81 91       	ld	r24, Z+
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    55f8:	8f 01       	movw	r16, r30
    55fa:	80 93 af 00 	sts	0x00AF, r24
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    55fe:	21 97       	sbiw	r28, 0x01	; 1
    5600:	08 94       	sec
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5602:	a1 1c       	adc	r10, r1
			BytesInTransfer++;
    5604:	b1 1c       	adc	r11, r1
    5606:	20 97       	sbiw	r28, 0x00	; 0
    5608:	d9 f6       	brne	.-74     	; 0x55c0 <Pipe_Write_Stream_LE+0x4a>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    560a:	01 c0       	rjmp	.+2      	; 0x560e <Pipe_Write_Stream_LE+0x98>
    560c:	f8 2e       	mov	r15, r24
    560e:	8f 2d       	mov	r24, r15
			{
				*BytesProcessed += BytesInTransfer;
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5610:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    5612:	cf 91       	pop	r28
    5614:	1f 91       	pop	r17
    5616:	0f 91       	pop	r16
    5618:	ff 90       	pop	r15
    561a:	df 90       	pop	r13
    561c:	cf 90       	pop	r12
    561e:	bf 90       	pop	r11
    5620:	af 90       	pop	r10
    5622:	08 95       	ret

00005624 <Pipe_Read_Stream_LE>:
    5624:	af 92       	push	r10
    5626:	bf 92       	push	r11
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5628:	cf 92       	push	r12
    562a:	df 92       	push	r13
    562c:	ff 92       	push	r15
    562e:	0f 93       	push	r16
    5630:	1f 93       	push	r17
    5632:	cf 93       	push	r28
    5634:	df 93       	push	r29
    5636:	5c 01       	movw	r10, r24
    5638:	eb 01       	movw	r28, r22
    563a:	6a 01       	movw	r12, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    563c:	80 91 aa 00 	lds	r24, 0x00AA
    5640:	8f 7c       	andi	r24, 0xCF	; 207
    5642:	80 61       	ori	r24, 0x10	; 16
    5644:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5648:	00 d1       	rcall	.+512    	; 0x584a <Pipe_WaitUntilReady>
    564a:	f8 2e       	mov	r15, r24
    564c:	88 23       	and	r24, r24
    564e:	b1 f5       	brne	.+108    	; 0x56bc <Pipe_Read_Stream_LE+0x98>
    5650:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5652:	d1 04       	cpc	r13, r1
    5654:	41 f0       	breq	.+16     	; 0x5666 <Pipe_Read_Stream_LE+0x42>
    5656:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    5658:	00 81       	ld	r16, Z
    565a:	11 81       	ldd	r17, Z+1	; 0x01
    565c:	c0 1b       	sub	r28, r16
    565e:	d1 0b       	sbc	r29, r17
    5660:	0a 0d       	add	r16, r10
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5662:	1b 1d       	adc	r17, r11
    5664:	01 c0       	rjmp	.+2      	; 0x5668 <Pipe_Read_Stream_LE+0x44>
    5666:	85 01       	movw	r16, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5668:	aa 24       	eor	r10, r10
    566a:	bb 24       	eor	r11, r11
    566c:	23 c0       	rjmp	.+70     	; 0x56b4 <Pipe_Read_Stream_LE+0x90>
    566e:	80 91 a6 00 	lds	r24, 0x00A6
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5672:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5674:	16 c0       	rjmp	.+44     	; 0x56a2 <Pipe_Read_Stream_LE+0x7e>
    5676:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    567a:	8e 77       	andi	r24, 0x7E	; 126
    567c:	80 93 a6 00 	sts	0x00A6, r24
    5680:	c1 14       	cp	r12, r1
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    5682:	d1 04       	cpc	r13, r1
    5684:	51 f0       	breq	.+20     	; 0x569a <Pipe_Read_Stream_LE+0x76>
    5686:	f6 01       	movw	r30, r12
			{
				*BytesProcessed += BytesInTransfer;
    5688:	80 81       	ld	r24, Z
    568a:	91 81       	ldd	r25, Z+1	; 0x01
    568c:	8a 0d       	add	r24, r10
    568e:	9b 1d       	adc	r25, r11
    5690:	91 83       	std	Z+1, r25	; 0x01
    5692:	80 83       	st	Z, r24
    5694:	64 e0       	ldi	r22, 0x04	; 4
				return PIPE_RWSTREAM_IncompleteTransfer;
    5696:	f6 2e       	mov	r15, r22
    5698:	11 c0       	rjmp	.+34     	; 0x56bc <Pipe_Read_Stream_LE+0x98>
    569a:	d7 d0       	rcall	.+430    	; 0x584a <Pipe_WaitUntilReady>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    569c:	88 23       	and	r24, r24
    569e:	51 f0       	breq	.+20     	; 0x56b4 <Pipe_Read_Stream_LE+0x90>
    56a0:	0c c0       	rjmp	.+24     	; 0x56ba <Pipe_Read_Stream_LE+0x96>
    56a2:	80 91 af 00 	lds	r24, 0x00AF
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    56a6:	f8 01       	movw	r30, r16
    56a8:	81 93       	st	Z+, r24
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    56aa:	8f 01       	movw	r16, r30
    56ac:	21 97       	sbiw	r28, 0x01	; 1
    56ae:	08 94       	sec
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    56b0:	a1 1c       	adc	r10, r1
			BytesInTransfer++;
    56b2:	b1 1c       	adc	r11, r1
    56b4:	20 97       	sbiw	r28, 0x00	; 0
    56b6:	d9 f6       	brne	.-74     	; 0x566e <Pipe_Read_Stream_LE+0x4a>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    56b8:	01 c0       	rjmp	.+2      	; 0x56bc <Pipe_Read_Stream_LE+0x98>
    56ba:	f8 2e       	mov	r15, r24
    56bc:	8f 2d       	mov	r24, r15
			{
				*BytesProcessed += BytesInTransfer;
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    56be:	df 91       	pop	r29
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    56c0:	cf 91       	pop	r28
    56c2:	1f 91       	pop	r17
    56c4:	0f 91       	pop	r16
    56c6:	ff 90       	pop	r15
    56c8:	df 90       	pop	r13
    56ca:	cf 90       	pop	r12
    56cc:	bf 90       	pop	r11
    56ce:	af 90       	pop	r10
    56d0:	08 95       	ret

000056d2 <Pipe_ConfigurePipe>:
bool Pipe_ConfigurePipe(const uint8_t Address,
                        const uint8_t Type,
                        const uint8_t EndpointAddress,
                        const uint16_t Size,
                        const uint8_t Banks)
{
    56d2:	0f 93       	push	r16
	uint8_t Number = (Address & PIPE_EPNUM_MASK);
    56d4:	58 2f       	mov	r21, r24
    56d6:	5f 70       	andi	r21, 0x0F	; 15
	uint8_t Token  = (Address & PIPE_DIR_IN) ? PIPE_TOKEN_IN : PIPE_TOKEN_OUT;
    56d8:	87 ff       	sbrs	r24, 7
    56da:	02 c0       	rjmp	.+4      	; 0x56e0 <Pipe_ConfigurePipe+0xe>
    56dc:	80 e1       	ldi	r24, 0x10	; 16
    56de:	01 c0       	rjmp	.+2      	; 0x56e2 <Pipe_ConfigurePipe+0x10>
    56e0:	80 e2       	ldi	r24, 0x20	; 32
	
	if (Number >= PIPE_TOTAL_PIPES)
    56e2:	57 30       	cpi	r21, 0x07	; 7
    56e4:	08 f0       	brcs	.+2      	; 0x56e8 <Pipe_ConfigurePipe+0x16>
    56e6:	57 c0       	rjmp	.+174    	; 0x5796 <Pipe_ConfigurePipe+0xc4>
	  return false;

	if (Type == EP_TYPE_CONTROL)
    56e8:	66 23       	and	r22, r22
    56ea:	09 f4       	brne	.+2      	; 0x56ee <Pipe_ConfigurePipe+0x1c>
	  Token = PIPE_TOKEN_SETUP;
    56ec:	80 e0       	ldi	r24, 0x00	; 0

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
    56ee:	4f 70       	andi	r20, 0x0F	; 15
    56f0:	62 95       	swap	r22
    56f2:	66 0f       	add	r22, r22
    56f4:	66 0f       	add	r22, r22
    56f6:	60 7c       	andi	r22, 0xC0	; 192
    56f8:	64 2b       	or	r22, r20
    56fa:	68 2b       	or	r22, r24
    56fc:	45 2f       	mov	r20, r21
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    56fe:	02 60       	ori	r16, 0x02	; 2
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    5700:	40 93 a7 00 	sts	0x00A7, r20
		uint8_t UPCFG2XTemp;
		uint8_t UPIENXTemp;

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
    5704:	45 17       	cp	r20, r21
    5706:	a9 f4       	brne	.+42     	; 0x5732 <Pipe_ConfigurePipe+0x60>
    5708:	04 c0       	rjmp	.+8      	; 0x5712 <Pipe_ConfigurePipe+0x40>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
				{
					MaskVal++;
    570a:	7f 5f       	subi	r23, 0xFF	; 255
					CheckBytes <<= 1;
    570c:	88 0f       	add	r24, r24
    570e:	99 1f       	adc	r25, r25
    5710:	03 c0       	rjmp	.+6      	; 0x5718 <Pipe_ConfigurePipe+0x46>
    5712:	88 e0       	ldi	r24, 0x08	; 8
    5714:	90 e0       	ldi	r25, 0x00	; 0
    5716:	70 e0       	ldi	r23, 0x00	; 0
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    5718:	82 17       	cp	r24, r18
    571a:	93 07       	cpc	r25, r19
    571c:	10 f4       	brcc	.+4      	; 0x5722 <Pipe_ConfigurePipe+0x50>
    571e:	75 30       	cpi	r23, 0x05	; 5
    5720:	a1 f7       	brne	.-24     	; 0x570a <Pipe_ConfigurePipe+0x38>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    5722:	87 2f       	mov	r24, r23
    5724:	82 95       	swap	r24
    5726:	80 7f       	andi	r24, 0xF0	; 240
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    5728:	80 2b       	or	r24, r16

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
    572a:	f6 2f       	mov	r31, r22
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
			UPIENXTemp  = 0;
    572c:	70 e0       	ldi	r23, 0x00	; 0

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
    572e:	e0 e0       	ldi	r30, 0x00	; 0
    5730:	08 c0       	rjmp	.+16     	; 0x5742 <Pipe_ConfigurePipe+0x70>
			UPIENXTemp  = 0;
		}
		else
		{
			UPCFG0XTemp = UPCFG0X;
    5732:	f0 91 aa 00 	lds	r31, 0x00AA
			UPCFG1XTemp = UPCFG1X;
    5736:	80 91 ab 00 	lds	r24, 0x00AB
			UPCFG2XTemp = UPCFG2X;
    573a:	e0 91 ad 00 	lds	r30, 0x00AD
			UPIENXTemp  = UPIENX;
    573e:	70 91 ae 00 	lds	r23, 0x00AE
		}

		if (!(UPCFG1XTemp & (1 << ALLOC)))
    5742:	81 ff       	sbrs	r24, 1
    5744:	20 c0       	rjmp	.+64     	; 0x5786 <Pipe_ConfigurePipe+0xb4>
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    5746:	90 91 a9 00 	lds	r25, 0x00A9
    574a:	9e 7f       	andi	r25, 0xFE	; 254
    574c:	90 93 a9 00 	sts	0x00A9, r25
		  continue;

		Pipe_DisablePipe();
		UPCFG1X &= ~(1 << ALLOC);
    5750:	90 91 ab 00 	lds	r25, 0x00AB
    5754:	9d 7f       	andi	r25, 0xFD	; 253
    5756:	90 93 ab 00 	sts	0x00AB, r25
			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePipe().
			 */
			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_EnablePipe(void)
			{
				UPCONX |= (1 << PEN);
    575a:	90 91 a9 00 	lds	r25, 0x00A9
    575e:	91 60       	ori	r25, 0x01	; 1
    5760:	90 93 a9 00 	sts	0x00A9, r25

		Pipe_EnablePipe();
		UPCFG0X = UPCFG0XTemp;
    5764:	f0 93 aa 00 	sts	0x00AA, r31
		UPCFG1X = UPCFG1XTemp;
    5768:	80 93 ab 00 	sts	0x00AB, r24
		UPCFG2X = UPCFG2XTemp;
    576c:	e0 93 ad 00 	sts	0x00AD, r30
		UPIENX  = UPIENXTemp;
    5770:	70 93 ae 00 	sts	0x00AE, r23

			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInfiniteINRequests(void)
			{
				UPCONX |= (1 << INMODE);
    5774:	80 91 a9 00 	lds	r24, 0x00A9
    5778:	80 62       	ori	r24, 0x20	; 32
    577a:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    577e:	80 91 ac 00 	lds	r24, 0x00AC

		Pipe_SetInfiniteINRequests();

		if (!(Pipe_IsConfigured()))
    5782:	87 ff       	sbrs	r24, 7
    5784:	08 c0       	rjmp	.+16     	; 0x5796 <Pipe_ConfigurePipe+0xc4>

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    5786:	4f 5f       	subi	r20, 0xFF	; 255
    5788:	47 30       	cpi	r20, 0x07	; 7
    578a:	09 f0       	breq	.+2      	; 0x578e <Pipe_ConfigurePipe+0xbc>
    578c:	b9 cf       	rjmp	.-142    	; 0x5700 <Pipe_ConfigurePipe+0x2e>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    578e:	50 93 a7 00 	sts	0x00A7, r21
		if (!(Pipe_IsConfigured()))
		  return false;
	}

	Pipe_SelectPipe(Number);
	return true;
    5792:	81 e0       	ldi	r24, 0x01	; 1
    5794:	01 c0       	rjmp	.+2      	; 0x5798 <Pipe_ConfigurePipe+0xc6>
		UPIENX  = UPIENXTemp;

		Pipe_SetInfiniteINRequests();

		if (!(Pipe_IsConfigured()))
		  return false;
    5796:	80 e0       	ldi	r24, 0x00	; 0
	}

	Pipe_SelectPipe(Number);
	return true;
#endif
}
    5798:	0f 91       	pop	r16
    579a:	08 95       	ret

0000579c <Pipe_ConfigurePipeTable>:

uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
    579c:	ff 92       	push	r15
    579e:	0f 93       	push	r16
    57a0:	1f 93       	push	r17
    57a2:	cf 93       	push	r28
    57a4:	df 93       	push	r29
    57a6:	16 2f       	mov	r17, r22
		{
			return false;
		}
	}
	
	return true;
    57a8:	ec 01       	movw	r28, r24
uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    57aa:	ff 24       	eor	r15, r15
    57ac:	0d c0       	rjmp	.+26     	; 0x57c8 <Pipe_ConfigurePipeTable+0x2c>
	{
		if (!(Table[i].Address))
    57ae:	88 81       	ld	r24, Y
    57b0:	88 23       	and	r24, r24
    57b2:	41 f0       	breq	.+16     	; 0x57c4 <Pipe_ConfigurePipeTable+0x28>
		  continue;
	
		if (!(Pipe_ConfigurePipe(Table[i].Address, Table[i].Type, Table[i].EndpointAddress, Table[i].Size, Table[i].Banks)))
    57b4:	29 81       	ldd	r18, Y+1	; 0x01
    57b6:	3a 81       	ldd	r19, Y+2	; 0x02
    57b8:	6c 81       	ldd	r22, Y+4	; 0x04
    57ba:	4b 81       	ldd	r20, Y+3	; 0x03
    57bc:	0d 81       	ldd	r16, Y+5	; 0x05
    57be:	89 df       	rcall	.-238    	; 0x56d2 <Pipe_ConfigurePipe>
    57c0:	88 23       	and	r24, r24
    57c2:	31 f0       	breq	.+12     	; 0x57d0 <Pipe_ConfigurePipeTable+0x34>
    57c4:	f3 94       	inc	r15
uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    57c6:	26 96       	adiw	r28, 0x06	; 6
    57c8:	f1 16       	cp	r15, r17
    57ca:	89 f7       	brne	.-30     	; 0x57ae <Pipe_ConfigurePipeTable+0x12>
    57cc:	81 e0       	ldi	r24, 0x01	; 1
		{
			return false;
		}
	}
	
	return true;
    57ce:	01 c0       	rjmp	.+2      	; 0x57d2 <Pipe_ConfigurePipeTable+0x36>
    57d0:	80 e0       	ldi	r24, 0x00	; 0
		if (!(Table[i].Address))
		  continue;
	
		if (!(Pipe_ConfigurePipe(Table[i].Address, Table[i].Type, Table[i].EndpointAddress, Table[i].Size, Table[i].Banks)))
		{
			return false;
    57d2:	df 91       	pop	r29
		}
	}
	
	return true;
}
    57d4:	cf 91       	pop	r28
    57d6:	1f 91       	pop	r17
    57d8:	0f 91       	pop	r16
    57da:	ff 90       	pop	r15
    57dc:	08 95       	ret

000057de <Pipe_ClearPipes>:
    57de:	10 92 f8 00 	sts	0x00F8, r1

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    57e2:	80 e0       	ldi	r24, 0x00	; 0
    57e4:	80 93 a7 00 	sts	0x00A7, r24
	{
		Pipe_SelectPipe(PNum);
		UPIENX  = 0;
    57e8:	10 92 ae 00 	sts	0x00AE, r1
		UPINTX  = 0;
    57ec:	10 92 a6 00 	sts	0x00A6, r1
		UPCFG1X = 0;
    57f0:	10 92 ab 00 	sts	0x00AB, r1
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    57f4:	90 91 a9 00 	lds	r25, 0x00A9
    57f8:	9e 7f       	andi	r25, 0xFE	; 254
    57fa:	90 93 a9 00 	sts	0x00A9, r25

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    57fe:	8f 5f       	subi	r24, 0xFF	; 255
    5800:	87 30       	cpi	r24, 0x07	; 7
    5802:	81 f7       	brne	.-32     	; 0x57e4 <Pipe_ClearPipes+0x6>
		UPIENX  = 0;
		UPINTX  = 0;
		UPCFG1X = 0;
		Pipe_DisablePipe();
	}
}
    5804:	08 95       	ret

00005806 <Pipe_IsEndpointBound>:
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    5806:	40 91 a7 00 	lds	r20, 0x00A7
			 *  \return The currently selected pipe's direction, as a \c PIPE_DIR_* mask.
			 */
			static inline uint8_t Pipe_GetPipeDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeDirection(void)
			{
				return (UPCFG0X & (1 << EPDIR)) ? PIPE_DIR_IN : PIPE_DIR_OUT;
    580a:	90 91 aa 00 	lds	r25, 0x00AA

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    580e:	90 e0       	ldi	r25, 0x00	; 0
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    5810:	90 93 a7 00 	sts	0x00A7, r25
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    5814:	20 91 ac 00 	lds	r18, 0x00AC
	{
		Pipe_SelectPipe(PNum);

		if (!(Pipe_IsConfigured()))
    5818:	27 ff       	sbrs	r18, 7
    581a:	0c c0       	rjmp	.+24     	; 0x5834 <Pipe_IsEndpointBound+0x2e>
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				uint8_t UPCFG0X_Temp = UPCFG0X;
    581c:	30 91 aa 00 	lds	r19, 0x00AA
				
				return (((UPCFG0X_Temp >> PEPNUM0) & PIPE_EPNUM_MASK) | ((UPCFG0X_Temp & PEPNUM1) ? ENDPOINT_DIR_OUT : ENDPOINT_DIR_IN));
    5820:	53 2f       	mov	r21, r19
    5822:	5f 70       	andi	r21, 0x0F	; 15
    5824:	30 ff       	sbrs	r19, 0
    5826:	02 c0       	rjmp	.+4      	; 0x582c <Pipe_IsEndpointBound+0x26>
    5828:	20 e0       	ldi	r18, 0x00	; 0
    582a:	01 c0       	rjmp	.+2      	; 0x582e <Pipe_IsEndpointBound+0x28>
    582c:	20 e8       	ldi	r18, 0x80	; 128
    582e:	25 2b       	or	r18, r21
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
    5830:	28 17       	cp	r18, r24
    5832:	49 f0       	breq	.+18     	; 0x5846 <Pipe_IsEndpointBound+0x40>

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    5834:	9f 5f       	subi	r25, 0xFF	; 255
    5836:	97 30       	cpi	r25, 0x07	; 7
    5838:	59 f7       	brne	.-42     	; 0x5810 <Pipe_IsEndpointBound+0xa>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    583a:	84 2f       	mov	r24, r20
    583c:	8f 70       	andi	r24, 0x0F	; 15
    583e:	80 93 a7 00 	sts	0x00A7, r24
		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
    5842:	80 e0       	ldi	r24, 0x00	; 0
    5844:	08 95       	ret

		if (!(Pipe_IsConfigured()))
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
    5846:	81 e0       	ldi	r24, 0x01	; 1
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
}
    5848:	08 95       	ret

0000584a <Pipe_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Host_GetFrameNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t USB_Host_GetFrameNumber(void)
			{
				return UHFNUM;
    584a:	80 91 a2 00 	lds	r24, 0x00A2
    584e:	90 91 a3 00 	lds	r25, 0x00A3
    5852:	45 e6       	ldi	r20, 0x65	; 101
    5854:	01 c0       	rjmp	.+2      	; 0x5858 <Pipe_WaitUntilReady+0xe>
    5856:	c9 01       	movw	r24, r18
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    5858:	20 91 aa 00 	lds	r18, 0x00AA
    585c:	20 73       	andi	r18, 0x30	; 48

	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();

	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    585e:	20 31       	cpi	r18, 0x10	; 16
    5860:	29 f4       	brne	.+10     	; 0x586c <Pipe_WaitUntilReady+0x22>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    5862:	20 91 a6 00 	lds	r18, 0x00A6
		{
			if (Pipe_IsINReceived())
    5866:	20 ff       	sbrs	r18, 0
    5868:	05 c0       	rjmp	.+10     	; 0x5874 <Pipe_WaitUntilReady+0x2a>
    586a:	16 c0       	rjmp	.+44     	; 0x5898 <Pipe_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    586c:	20 91 a6 00 	lds	r18, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    5870:	22 fd       	sbrc	r18, 2
    5872:	12 c0       	rjmp	.+36     	; 0x5898 <Pipe_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    5874:	20 91 a6 00 	lds	r18, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
    5878:	21 fd       	sbrc	r18, 1
    587a:	10 c0       	rjmp	.+32     	; 0x589c <Pipe_WaitUntilReady+0x52>
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    587c:	2e b3       	in	r18, 0x1e	; 30
    587e:	21 30       	cpi	r18, 0x01	; 1
    5880:	79 f0       	breq	.+30     	; 0x58a0 <Pipe_WaitUntilReady+0x56>
    5882:	20 91 a2 00 	lds	r18, 0x00A2
    5886:	30 91 a3 00 	lds	r19, 0x00A3
		  return PIPE_READYWAIT_DeviceDisconnected;

		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    588a:	28 17       	cp	r18, r24
    588c:	39 07       	cpc	r19, r25
    588e:	21 f3       	breq	.-56     	; 0x5858 <Pipe_WaitUntilReady+0xe>
    5890:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    5892:	09 f7       	brne	.-62     	; 0x5856 <Pipe_WaitUntilReady+0xc>
			  return PIPE_READYWAIT_Timeout;
    5894:	83 e0       	ldi	r24, 0x03	; 3
    5896:	08 95       	ret
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
			  return PIPE_READYWAIT_NoError;
    5898:	80 e0       	ldi	r24, 0x00	; 0
    589a:	08 95       	ret
		}

		if (Pipe_IsStalled())
		  return PIPE_READYWAIT_PipeStalled;
    589c:	81 e0       	ldi	r24, 0x01	; 1
    589e:	08 95       	ret
		else if (USB_HostState == HOST_STATE_Unattached)
		  return PIPE_READYWAIT_DeviceDisconnected;
    58a0:	82 e0       	ldi	r24, 0x02	; 2

			if (!(TimeoutMSRem--))
			  return PIPE_READYWAIT_Timeout;
		}
	}
}
    58a2:	08 95       	ret

000058a4 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    58a4:	cf d0       	rcall	.+414    	; 0x5a44 <USB_INT_DisableAllInterrupts>
    58a6:	da d0       	rcall	.+436    	; 0x5a5c <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    58a8:	e0 ee       	ldi	r30, 0xE0	; 224
    58aa:	f0 e0       	ldi	r31, 0x00	; 0
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    58ac:	80 81       	ld	r24, Z
    58ae:	81 60       	ori	r24, 0x01	; 1
    58b0:	80 83       	st	Z, r24
    58b2:	e8 ed       	ldi	r30, 0xD8	; 216
    58b4:	f0 e0       	ldi	r31, 0x00	; 0
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    58b6:	80 81       	ld	r24, Z
    58b8:	8f 77       	andi	r24, 0x7F	; 127
    58ba:	80 83       	st	Z, r24
    58bc:	19 bc       	out	0x29, r1	; 41
    58be:	a7 ed       	ldi	r26, 0xD7	; 215
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    58c0:	b0 e0       	ldi	r27, 0x00	; 0

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    58c2:	8c 91       	ld	r24, X
    58c4:	8e 7f       	andi	r24, 0xFE	; 254
    58c6:	8c 93       	st	X, r24
    58c8:	80 81       	ld	r24, Z
    58ca:	8f 7e       	andi	r24, 0xEF	; 239
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    58cc:	80 83       	st	Z, r24
    58ce:	10 92 fb 03 	sts	0x03FB, r1
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
    58d2:	10 92 cf 0d 	sts	0x0DCF, r1
	#endif

	USB_IsInitialized = false;
    58d6:	08 95       	ret

000058d8 <USB_ResetInterface>:
    58d8:	cf 93       	push	r28
}
    58da:	c0 91 d7 00 	lds	r28, 0x00D7
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    58de:	b2 d0       	rcall	.+356    	; 0x5a44 <USB_INT_DisableAllInterrupts>
    58e0:	bd d0       	rcall	.+378    	; 0x5a5c <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    58e2:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    58e6:	8f 77       	andi	r24, 0x7F	; 127
    58e8:	80 93 d8 00 	sts	0x00D8, r24
    58ec:	80 91 d8 00 	lds	r24, 0x00D8
				USBCON |=  (1 << USBE);
    58f0:	80 68       	ori	r24, 0x80	; 128
    58f2:	80 93 d8 00 	sts	0x00D8, r24
    58f6:	c6 ff       	sbrs	r28, 6
    58f8:	05 c0       	rjmp	.+10     	; 0x5904 <USB_ResetInterface+0x2c>

	USB_Controller_Reset();

	#if defined(USB_CAN_BE_BOTH)
	if (UIDModeSelectEnabled)
    58fa:	80 91 d8 00 	lds	r24, 0x00D8
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    58fe:	82 60       	ori	r24, 0x02	; 2
    5900:	80 93 d8 00 	sts	0x00D8, r24
    5904:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    5908:	8f 7d       	andi	r24, 0xDF	; 223
    590a:	80 93 d8 00 	sts	0x00D8, r24
    590e:	80 91 fb 03 	lds	r24, 0x03FB
	  USB_INT_Enable(USB_INT_IDTI);
	#endif

	USB_CLK_Unfreeze();

	if (USB_CurrentMode == USB_MODE_Device)
    5912:	81 30       	cpi	r24, 0x01	; 1
    5914:	59 f5       	brne	.+86     	; 0x596c <USB_ResetInterface+0x94>
    5916:	80 91 d7 00 	lds	r24, 0x00D7
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    591a:	80 68       	ori	r24, 0x80	; 128
    591c:	80 93 d7 00 	sts	0x00D7, r24
    5920:	19 bc       	out	0x29, r1	; 41
    5922:	1e ba       	out	0x1e, r1	; 30
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5924:	10 92 cb 0d 	sts	0x0DCB, r1

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
	USB_Device_ConfigurationNumber  = 0;
    5928:	10 92 cd 0d 	sts	0x0DCD, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    592c:	10 92 cc 0d 	sts	0x0DCC, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    5930:	80 91 e0 00 	lds	r24, 0x00E0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    5934:	8b 7f       	andi	r24, 0xFB	; 251
    5936:	80 93 e0 00 	sts	0x00E0, r24
    593a:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    593e:	81 60       	ori	r24, 0x01	; 1
    5940:	80 93 d8 00 	sts	0x00D8, r24
    5944:	80 e0       	ldi	r24, 0x00	; 0
    5946:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    5948:	42 e0       	ldi	r20, 0x02	; 2
    594a:	37 db       	rcall	.-2450   	; 0x4fba <Endpoint_ConfigureEndpoint_Prv>
    594c:	80 91 e1 00 	lds	r24, 0x00E1
    5950:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    5952:	80 93 e1 00 	sts	0x00E1, r24
    5956:	80 91 e2 00 	lds	r24, 0x00E2
    595a:	81 60       	ori	r24, 0x01	; 1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    595c:	80 93 e2 00 	sts	0x00E2, r24
    5960:	80 91 e2 00 	lds	r24, 0x00E2
    5964:	88 60       	ori	r24, 0x08	; 8
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    5966:	80 93 e2 00 	sts	0x00E2, r24
    596a:	37 c0       	rjmp	.+110    	; 0x59da <USB_ResetInterface+0x102>
    596c:	80 91 fb 03 	lds	r24, 0x03FB
    5970:	82 30       	cpi	r24, 0x02	; 2
		}

		USB_Init_Device();
		#endif
	}
	else if (USB_CurrentMode == USB_MODE_Host)
    5972:	c1 f5       	brne	.+112    	; 0x59e4 <USB_ResetInterface+0x10c>
    5974:	80 91 d7 00 	lds	r24, 0x00D7
    5978:	8f 77       	andi	r24, 0x7F	; 127
	{
		#if defined(USB_CAN_BE_HOST)
		UHWCON &= ~(1 << UIMOD);
    597a:	80 93 d7 00 	sts	0x00D7, r24
    597e:	8c e0       	ldi	r24, 0x0C	; 12
    5980:	89 bd       	out	0x29, r24	; 41
    5982:	8e e0       	ldi	r24, 0x0E	; 14

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5984:	89 bd       	out	0x29, r24	; 41
    5986:	09 b4       	in	r0, 0x29	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5988:	00 fe       	sbrs	r0, 0
    598a:	fd cf       	rjmp	.-6      	; 0x5986 <USB_ResetInterface+0xae>

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			#if defined(USB_CAN_BE_HOST)
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    598c:	81 e0       	ldi	r24, 0x01	; 1
    598e:	8e bb       	out	0x1e, r24	; 30
    5990:	10 92 ce 0d 	sts	0x0DCE, r1
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_Init_Host(void)
{
	USB_HostState                = HOST_STATE_Unattached;
    5994:	80 e4       	ldi	r24, 0x40	; 64
	USB_Host_ConfigurationNumber = 0;
    5996:	80 93 4d 03 	sts	0x034D, r24
	USB_Host_ControlPipeSize     = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    599a:	80 91 d8 00 	lds	r24, 0x00D8
    599e:	80 64       	ori	r24, 0x40	; 64
	#if !defined(__DOXYGEN__)
		/* Macros: */
			static inline void USB_Host_HostMode_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_HostMode_On(void)
			{
				USBCON |=  (1 << HOST);
    59a0:	80 93 d8 00 	sts	0x00D8, r24
    59a4:	80 91 dd 00 	lds	r24, 0x00DD
    59a8:	81 60       	ori	r24, 0x01	; 1
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    59aa:	80 93 dd 00 	sts	0x00DD, r24
    59ae:	80 91 dd 00 	lds	r24, 0x00DD
    59b2:	84 60       	ori	r24, 0x04	; 4
			}

			static inline void USB_Host_VBUS_Manual_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Enable(void)
			{
				OTGCON |=  (1 << VBUSHWC);
    59b4:	80 93 dd 00 	sts	0x00DD, r24
    59b8:	80 91 d7 00 	lds	r24, 0x00D7
    59bc:	8f 7e       	andi	r24, 0xEF	; 239
				UHWCON &= ~(1 << UVCONE);
    59be:	80 93 d7 00 	sts	0x00D7, r24
    59c2:	6f 9a       	sbi	0x0d, 7	; 13
    59c4:	77 9a       	sbi	0x0e, 7	; 14
    59c6:	80 91 de 00 	lds	r24, 0x00DE
			static inline void USB_Host_VBUS_Manual_On(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  &= ~(1 << 7);
				#else
				PORTE  |=  (1 << 7);
    59ca:	81 60       	ori	r24, 0x01	; 1
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN |= (1 << SRPE);
    59cc:	80 93 de 00 	sts	0x00DE, r24
    59d0:	80 91 de 00 	lds	r24, 0x00DE
    59d4:	84 60       	ori	r24, 0x04	; 4
						break;
					case USB_INT_RSTI:
						UHIEN  |= (1 << RSTE);
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
    59d6:	80 93 de 00 	sts	0x00DE, r24
    59da:	80 91 e0 00 	lds	r24, 0x00E0
    59de:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    59e0:	80 93 e0 00 	sts	0x00E0, r24
    59e4:	80 91 d8 00 	lds	r24, 0x00D8
    59e8:	80 61       	ori	r24, 0x10	; 16

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    59ea:	80 93 d8 00 	sts	0x00D8, r24
    59ee:	cf 91       	pop	r28
    59f0:	08 95       	ret

000059f2 <USB_Init>:
    59f2:	90 91 d8 00 	lds	r25, 0x00D8
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    59f6:	9f 7e       	andi	r25, 0xEF	; 239
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    59f8:	90 93 d8 00 	sts	0x00D8, r25

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    59fc:	90 91 d7 00 	lds	r25, 0x00D7
    5a00:	91 60       	ori	r25, 0x01	; 1
    5a02:	90 93 d7 00 	sts	0x00D7, r25
		PLLFRQ = (1 << PDIV2);
		#endif
	}

	#if defined(USB_CAN_BE_BOTH)
	if (Mode == USB_MODE_UID)
    5a06:	83 30       	cpi	r24, 0x03	; 3
    5a08:	91 f4       	brne	.+36     	; 0x5a2e <USB_Init+0x3c>
	{
		UHWCON |=  (1 << UIDE);
    5a0a:	80 91 d7 00 	lds	r24, 0x00D7
    5a0e:	80 64       	ori	r24, 0x40	; 64
    5a10:	80 93 d7 00 	sts	0x00D7, r24
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    5a14:	80 91 d8 00 	lds	r24, 0x00D8
    5a18:	82 60       	ori	r24, 0x02	; 2
    5a1a:	80 93 d8 00 	sts	0x00D8, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5a1e:	80 91 d9 00 	lds	r24, 0x00D9
    5a22:	81 ff       	sbrs	r24, 1
    5a24:	02 c0       	rjmp	.+4      	; 0x5a2a <USB_Init+0x38>
				  return USB_MODE_Device;
    5a26:	81 e0       	ldi	r24, 0x01	; 1
    5a28:	07 c0       	rjmp	.+14     	; 0x5a38 <USB_Init+0x46>
				else
				  return USB_MODE_Host;
    5a2a:	82 e0       	ldi	r24, 0x02	; 2
    5a2c:	05 c0       	rjmp	.+10     	; 0x5a38 <USB_Init+0x46>
		USB_INT_Enable(USB_INT_IDTI);
		USB_CurrentMode = USB_GetUSBModeFromUID();
	}
	else
	{
		UHWCON &= ~(1 << UIDE);
    5a2e:	90 91 d7 00 	lds	r25, 0x00D7
    5a32:	9f 7b       	andi	r25, 0xBF	; 191
    5a34:	90 93 d7 00 	sts	0x00D7, r25
		USB_CurrentMode = Mode;
    5a38:	80 93 fb 03 	sts	0x03FB, r24
	}
	#endif

	USB_IsInitialized = true;
    5a3c:	81 e0       	ldi	r24, 0x01	; 1
    5a3e:	80 93 cf 0d 	sts	0x0DCF, r24

	USB_ResetInterface();
    5a42:	4a cf       	rjmp	.-364    	; 0x58d8 <USB_ResetInterface>

00005a44 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    5a44:	e8 ed       	ldi	r30, 0xD8	; 216
    5a46:	f0 e0       	ldi	r31, 0x00	; 0
    5a48:	80 81       	ld	r24, Z
    5a4a:	8c 7f       	andi	r24, 0xFC	; 252
    5a4c:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGIEN  = 0;
    5a4e:	10 92 de 00 	sts	0x00DE, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    5a52:	10 92 a0 00 	sts	0x00A0, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    5a56:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    5a5a:	08 95       	ret

00005a5c <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    5a5c:	10 92 da 00 	sts	0x00DA, r1
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGINT = 0;
    5a60:	10 92 df 00 	sts	0x00DF, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
    5a64:	10 92 9f 00 	sts	0x009F, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    5a68:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    5a6c:	08 95       	ret

00005a6e <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    5a6e:	1f 92       	push	r1
    5a70:	0f 92       	push	r0
    5a72:	0f b6       	in	r0, 0x3f	; 63
    5a74:	0f 92       	push	r0
    5a76:	0b b6       	in	r0, 0x3b	; 59
    5a78:	0f 92       	push	r0
    5a7a:	11 24       	eor	r1, r1
    5a7c:	2f 93       	push	r18
    5a7e:	3f 93       	push	r19
    5a80:	4f 93       	push	r20
    5a82:	5f 93       	push	r21
    5a84:	6f 93       	push	r22
    5a86:	7f 93       	push	r23
    5a88:	8f 93       	push	r24
    5a8a:	9f 93       	push	r25
    5a8c:	af 93       	push	r26
    5a8e:	bf 93       	push	r27
    5a90:	ef 93       	push	r30
    5a92:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    5a94:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    5a98:	82 ff       	sbrs	r24, 2
    5a9a:	0a c0       	rjmp	.+20     	; 0x5ab0 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    5a9c:	80 91 e2 00 	lds	r24, 0x00E2
    5aa0:	82 ff       	sbrs	r24, 2
    5aa2:	06 c0       	rjmp	.+12     	; 0x5ab0 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    5aa4:	80 91 e1 00 	lds	r24, 0x00E1
    5aa8:	8b 7f       	andi	r24, 0xFB	; 251
    5aaa:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    5aae:	84 d3       	rcall	.+1800   	; 0x61b8 <USB_Event_Stub>
    5ab0:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    5ab4:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    5ab6:	1d c0       	rjmp	.+58     	; 0x5af2 <__vector_10+0x84>
    5ab8:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    5abc:	80 ff       	sbrs	r24, 0
    5abe:	19 c0       	rjmp	.+50     	; 0x5af2 <__vector_10+0x84>
    5ac0:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    5ac4:	8e 7f       	andi	r24, 0xFE	; 254
    5ac6:	80 93 da 00 	sts	0x00DA, r24
    5aca:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    5ace:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    5ad0:	0c c0       	rjmp	.+24     	; 0x5aea <__vector_10+0x7c>
    5ad2:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5ad4:	89 bd       	out	0x29, r24	; 41
    5ad6:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5ad8:	89 bd       	out	0x29, r24	; 41
    5ada:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    5adc:	00 fe       	sbrs	r0, 0
    5ade:	fd cf       	rjmp	.-6      	; 0x5ada <__vector_10+0x6c>
    5ae0:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    5ae2:	8e bb       	out	0x1e, r24	; 30
    5ae4:	0e 94 a7 02 	call	0x54e	; 0x54e <EVENT_USB_Device_Connect>
			EVENT_USB_Device_Connect();
    5ae8:	04 c0       	rjmp	.+8      	; 0x5af2 <__vector_10+0x84>
    5aea:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5aec:	1e ba       	out	0x1e, r1	; 30
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    5aee:	0e 94 aa 02 	call	0x554	; 0x554 <EVENT_USB_Device_Disconnect>
			EVENT_USB_Device_Disconnect();
    5af2:	80 91 e1 00 	lds	r24, 0x00E1
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    5af6:	80 ff       	sbrs	r24, 0
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5af8:	17 c0       	rjmp	.+46     	; 0x5b28 <__vector_10+0xba>
    5afa:	80 91 e2 00 	lds	r24, 0x00E2
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    5afe:	80 ff       	sbrs	r24, 0
    5b00:	13 c0       	rjmp	.+38     	; 0x5b28 <__vector_10+0xba>
    5b02:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5b06:	8e 7f       	andi	r24, 0xFE	; 254
    5b08:	80 93 e2 00 	sts	0x00E2, r24
    5b0c:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5b10:	80 61       	ori	r24, 0x10	; 16
    5b12:	80 93 e2 00 	sts	0x00E2, r24
    5b16:	80 91 d8 00 	lds	r24, 0x00D8
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    5b1a:	80 62       	ori	r24, 0x20	; 32
    5b1c:	80 93 d8 00 	sts	0x00D8, r24
    5b20:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5b22:	85 e0       	ldi	r24, 0x05	; 5

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    5b24:	8e bb       	out	0x1e, r24	; 30
    5b26:	48 d3       	rcall	.+1680   	; 0x61b8 <USB_Event_Stub>
		EVENT_USB_Device_Suspend();
    5b28:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    5b2c:	84 ff       	sbrs	r24, 4
    5b2e:	2c c0       	rjmp	.+88     	; 0x5b88 <__vector_10+0x11a>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    5b30:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    5b34:	84 ff       	sbrs	r24, 4
    5b36:	28 c0       	rjmp	.+80     	; 0x5b88 <__vector_10+0x11a>
    5b38:	8c e0       	ldi	r24, 0x0C	; 12
    5b3a:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5b3c:	8e e0       	ldi	r24, 0x0E	; 14
    5b3e:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5b40:	09 b4       	in	r0, 0x29	; 41
    5b42:	00 fe       	sbrs	r0, 0
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    5b44:	fd cf       	rjmp	.-6      	; 0x5b40 <__vector_10+0xd2>
    5b46:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    5b4a:	8f 7d       	andi	r24, 0xDF	; 223
    5b4c:	80 93 d8 00 	sts	0x00D8, r24
    5b50:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    5b54:	8f 7e       	andi	r24, 0xEF	; 239
    5b56:	80 93 e1 00 	sts	0x00E1, r24
    5b5a:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    5b5e:	8f 7e       	andi	r24, 0xEF	; 239
    5b60:	80 93 e2 00 	sts	0x00E2, r24
    5b64:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5b68:	81 60       	ori	r24, 0x01	; 1
    5b6a:	80 93 e2 00 	sts	0x00E2, r24
    5b6e:	80 91 cb 0d 	lds	r24, 0x0DCB
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    5b72:	88 23       	and	r24, r24
    5b74:	21 f4       	brne	.+8      	; 0x5b7e <__vector_10+0x110>
    5b76:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5b7a:	87 ff       	sbrs	r24, 7
    5b7c:	02 c0       	rjmp	.+4      	; 0x5b82 <__vector_10+0x114>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    5b7e:	84 e0       	ldi	r24, 0x04	; 4
    5b80:	01 c0       	rjmp	.+2      	; 0x5b84 <__vector_10+0x116>
    5b82:	81 e0       	ldi	r24, 0x01	; 1
    5b84:	8e bb       	out	0x1e, r24	; 30
    5b86:	18 d3       	rcall	.+1584   	; 0x61b8 <USB_Event_Stub>
    5b88:	80 91 e1 00 	lds	r24, 0x00E1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    5b8c:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    5b8e:	26 c0       	rjmp	.+76     	; 0x5bdc <__vector_10+0x16e>
    5b90:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    5b94:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    5b96:	22 c0       	rjmp	.+68     	; 0x5bdc <__vector_10+0x16e>
    5b98:	80 91 e1 00 	lds	r24, 0x00E1
    5b9c:	87 7f       	andi	r24, 0xF7	; 247
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    5b9e:	80 93 e1 00 	sts	0x00E1, r24
    5ba2:	82 e0       	ldi	r24, 0x02	; 2
    5ba4:	8e bb       	out	0x1e, r24	; 30
    5ba6:	10 92 cb 0d 	sts	0x0DCB, r1
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    5baa:	80 91 e1 00 	lds	r24, 0x00E1
		USB_Device_ConfigurationNumber = 0;
    5bae:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    5bb0:	80 93 e1 00 	sts	0x00E1, r24
    5bb4:	80 91 e2 00 	lds	r24, 0x00E2
    5bb8:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5bba:	80 93 e2 00 	sts	0x00E2, r24
    5bbe:	80 91 e2 00 	lds	r24, 0x00E2
    5bc2:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5bc4:	80 93 e2 00 	sts	0x00E2, r24
    5bc8:	80 e0       	ldi	r24, 0x00	; 0
    5bca:	60 e0       	ldi	r22, 0x00	; 0
    5bcc:	42 e0       	ldi	r20, 0x02	; 2
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    5bce:	f5 d9       	rcall	.-3094   	; 0x4fba <Endpoint_ConfigureEndpoint_Prv>
    5bd0:	80 91 f0 00 	lds	r24, 0x00F0
    5bd4:	88 60       	ori	r24, 0x08	; 8
    5bd6:	80 93 f0 00 	sts	0x00F0, r24
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5bda:	ee d2       	rcall	.+1500   	; 0x61b8 <USB_Event_Stub>
    5bdc:	80 91 9f 00 	lds	r24, 0x009F
    5be0:	85 ff       	sbrs	r24, 5

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    5be2:	0a c0       	rjmp	.+20     	; 0x5bf8 <__vector_10+0x18a>
    5be4:	80 91 a0 00 	lds	r24, 0x00A0
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    5be8:	85 ff       	sbrs	r24, 5
	}
	#endif

	#if defined(USB_CAN_BE_HOST)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_HSOFI) && USB_INT_IsEnabled(USB_INT_HSOFI))
    5bea:	06 c0       	rjmp	.+12     	; 0x5bf8 <__vector_10+0x18a>
    5bec:	80 91 9f 00 	lds	r24, 0x009F
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    5bf0:	8f 7d       	andi	r24, 0xDF	; 223
    5bf2:	80 93 9f 00 	sts	0x009F, r24
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5bf6:	e0 d2       	rcall	.+1472   	; 0x61b8 <USB_Event_Stub>
    5bf8:	80 91 9f 00 	lds	r24, 0x009F
    5bfc:	81 ff       	sbrs	r24, 1
    5bfe:	16 c0       	rjmp	.+44     	; 0x5c2c <__vector_10+0x1be>
	{
		USB_INT_Clear(USB_INT_HSOFI);

		EVENT_USB_Host_StartOfFrame();
    5c00:	80 91 a0 00 	lds	r24, 0x00A0
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
    5c04:	81 ff       	sbrs	r24, 1
    5c06:	12 c0       	rjmp	.+36     	; 0x5c2c <__vector_10+0x1be>
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    5c08:	80 91 9f 00 	lds	r24, 0x009F
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
					case USB_INT_DCONNI:
						return (UHIEN  & (1 << DCONNE));
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
    5c0c:	8d 7f       	andi	r24, 0xFD	; 253
    5c0e:	80 93 9f 00 	sts	0x009F, r24
    5c12:	80 91 9f 00 	lds	r24, 0x009F
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    5c16:	8e 7f       	andi	r24, 0xFE	; 254
    5c18:	80 93 9f 00 	sts	0x009F, r24
    5c1c:	80 91 a0 00 	lds	r24, 0x00A0
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    5c20:	8d 7f       	andi	r24, 0xFD	; 253
    5c22:	80 93 a0 00 	sts	0x00A0, r24
    5c26:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    5c2a:	56 de       	rcall	.-852    	; 0x58d8 <USB_ResetInterface>
    5c2c:	80 91 df 00 	lds	r24, 0x00DF
    5c30:	81 ff       	sbrs	r24, 1
	{
		USB_INT_Clear(USB_INT_DDISCI);
		USB_INT_Clear(USB_INT_DCONNI);
		USB_INT_Disable(USB_INT_DDISCI);

		EVENT_USB_Host_DeviceUnattached();
    5c32:	16 c0       	rjmp	.+44     	; 0x5c60 <__vector_10+0x1f2>
    5c34:	80 91 de 00 	lds	r24, 0x00DE

		USB_ResetInterface();
    5c38:	81 ff       	sbrs	r24, 1
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
    5c3a:	12 c0       	rjmp	.+36     	; 0x5c60 <__vector_10+0x1f2>
    5c3c:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    5c40:	8d 7f       	andi	r24, 0xFD	; 253
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
    5c42:	80 93 df 00 	sts	0x00DF, r24
    5c46:	77 98       	cbi	0x0e, 7	; 14
    5c48:	80 91 dd 00 	lds	r24, 0x00DD
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    5c4c:	81 60       	ori	r24, 0x01	; 1
    5c4e:	80 93 dd 00 	sts	0x00DD, r24
    5c52:	80 e0       	ldi	r24, 0x00	; 0
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  |=  (1 << 7);
				#else
				PORTE  &= ~(1 << 7);
    5c54:	0e 94 58 03 	call	0x6b0	; 0x6b0 <EVENT_USB_Host_HostError>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5c58:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>
    5c5c:	81 e0       	ldi	r24, 0x01	; 1
    5c5e:	8e bb       	out	0x1e, r24	; 30
		USB_INT_Clear(USB_INT_VBERRI);

		USB_Host_VBUS_Manual_Off();
		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    5c60:	80 91 df 00 	lds	r24, 0x00DF
    5c64:	80 ff       	sbrs	r24, 0
		EVENT_USB_Host_DeviceUnattached();
    5c66:	17 c0       	rjmp	.+46     	; 0x5c96 <__vector_10+0x228>
    5c68:	80 91 de 00 	lds	r24, 0x00DE

		USB_HostState = HOST_STATE_Unattached;
    5c6c:	80 ff       	sbrs	r24, 0
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
					case USB_INT_SRPI:
						return (OTGINT & (1 << SRPI));
    5c6e:	13 c0       	rjmp	.+38     	; 0x5c96 <__vector_10+0x228>
    5c70:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    5c74:	8e 7f       	andi	r24, 0xFE	; 254
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
					case USB_INT_SRPI:
						return (OTGIEN & (1 << SRPE));
    5c76:	80 93 df 00 	sts	0x00DF, r24
    5c7a:	80 91 de 00 	lds	r24, 0x00DE
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
						break;
					case USB_INT_SRPI:
						OTGINT &= ~(1 << SRPI);
    5c7e:	8e 7f       	andi	r24, 0xFE	; 254
    5c80:	80 93 de 00 	sts	0x00DE, r24
    5c84:	0e 94 e6 02 	call	0x5cc	; 0x5cc <EVENT_USB_Host_DeviceAttached>
						break;
					case USB_INT_VBERRI:
						OTGIEN &= ~(1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN &= ~(1 << SRPE);
    5c88:	80 91 a0 00 	lds	r24, 0x00A0
    5c8c:	82 60       	ori	r24, 0x02	; 2
    5c8e:	80 93 a0 00 	sts	0x00A0, r24
	{
		USB_INT_Clear(USB_INT_SRPI);
		USB_INT_Disable(USB_INT_SRPI);

		EVENT_USB_Host_DeviceAttached();
    5c92:	82 e0       	ldi	r24, 0x02	; 2
    5c94:	8e bb       	out	0x1e, r24	; 30
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    5c96:	80 91 df 00 	lds	r24, 0x00DF
    5c9a:	82 ff       	sbrs	r24, 2
    5c9c:	10 c0       	rjmp	.+32     	; 0x5cbe <__vector_10+0x250>
    5c9e:	80 91 de 00 	lds	r24, 0x00DE

		USB_INT_Enable(USB_INT_DDISCI);

		USB_HostState = HOST_STATE_Powered;
    5ca2:	82 ff       	sbrs	r24, 2
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
    5ca4:	0c c0       	rjmp	.+24     	; 0x5cbe <__vector_10+0x250>
    5ca6:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    5caa:	8b 7f       	andi	r24, 0xFB	; 251
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
    5cac:	80 93 df 00 	sts	0x00DF, r24
    5cb0:	82 e0       	ldi	r24, 0x02	; 2
    5cb2:	60 e0       	ldi	r22, 0x00	; 0
						break;
					case USB_INT_RSTI:
						UHINT  &= ~(1 << RSTI);
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
    5cb4:	0e 94 5d 03 	call	0x6ba	; 0x6ba <EVENT_USB_Host_DeviceEnumerationFailed>
    5cb8:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>
    5cbc:	0d de       	rcall	.-998    	; 0x58d8 <USB_ResetInterface>
	{
		USB_INT_Clear(USB_INT_BCERRI);

		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    5cbe:	80 91 da 00 	lds	r24, 0x00DA
    5cc2:	81 ff       	sbrs	r24, 1
    5cc4:	1e c0       	rjmp	.+60     	; 0x5d02 <__vector_10+0x294>
		EVENT_USB_Host_DeviceUnattached();
    5cc6:	80 91 d8 00 	lds	r24, 0x00D8

		USB_ResetInterface();
    5cca:	81 ff       	sbrs	r24, 1
    5ccc:	1a c0       	rjmp	.+52     	; 0x5d02 <__vector_10+0x294>
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
    5cce:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_CAN_BE_BOTH)
	if (USB_INT_HasOccurred(USB_INT_IDTI) && USB_INT_IsEnabled(USB_INT_IDTI))
    5cd2:	8d 7f       	andi	r24, 0xFD	; 253
    5cd4:	80 93 da 00 	sts	0x00DA, r24
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
    5cd8:	8e b3       	in	r24, 0x1e	; 30
    5cda:	88 23       	and	r24, r24
    5cdc:	11 f0       	breq	.+4      	; 0x5ce2 <__vector_10+0x274>
						USBINT &= ~(1 << VBUSTI);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBINT &= ~(1 << IDTI);
    5cde:	0e 94 aa 02 	call	0x554	; 0x554 <EVENT_USB_Device_Disconnect>
    5ce2:	8e b3       	in	r24, 0x1e	; 30
    5ce4:	81 30       	cpi	r24, 0x01	; 1
    5ce6:	11 f0       	breq	.+4      	; 0x5cec <__vector_10+0x27e>
	{
		USB_INT_Clear(USB_INT_IDTI);

		if (USB_DeviceState != DEVICE_STATE_Unattached)
    5ce8:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>
    5cec:	80 91 d9 00 	lds	r24, 0x00D9
		  EVENT_USB_Device_Disconnect();
    5cf0:	81 ff       	sbrs	r24, 1

		if (USB_HostState != HOST_STATE_Unattached)
    5cf2:	02 c0       	rjmp	.+4      	; 0x5cf8 <__vector_10+0x28a>
    5cf4:	81 e0       	ldi	r24, 0x01	; 1
    5cf6:	01 c0       	rjmp	.+2      	; 0x5cfa <__vector_10+0x28c>
		  EVENT_USB_Host_DeviceUnattached();
    5cf8:	82 e0       	ldi	r24, 0x02	; 2
    5cfa:	80 93 fb 03 	sts	0x03FB, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5cfe:	ec dd       	rcall	.-1064   	; 0x58d8 <USB_ResetInterface>
    5d00:	5b d2       	rcall	.+1206   	; 0x61b8 <USB_Event_Stub>
    5d02:	ff 91       	pop	r31
				  return USB_MODE_Device;
    5d04:	ef 91       	pop	r30
    5d06:	bf 91       	pop	r27
				else
				  return USB_MODE_Host;
    5d08:	af 91       	pop	r26

		USB_CurrentMode = USB_GetUSBModeFromUID();
    5d0a:	9f 91       	pop	r25
    5d0c:	8f 91       	pop	r24
		USB_ResetInterface();
    5d0e:	7f 91       	pop	r23
    5d10:	6f 91       	pop	r22

		EVENT_USB_UIDChange();
    5d12:	5f 91       	pop	r21
    5d14:	4f 91       	pop	r20
	}
	#endif
}
    5d16:	3f 91       	pop	r19
    5d18:	2f 91       	pop	r18
    5d1a:	0f 90       	pop	r0
    5d1c:	0b be       	out	0x3b, r0	; 59
    5d1e:	0f 90       	pop	r0
    5d20:	0f be       	out	0x3f, r0	; 63
    5d22:	0f 90       	pop	r0
    5d24:	1f 90       	pop	r1
    5d26:	18 95       	reti

00005d28 <__vector_11>:
    5d28:	1f 92       	push	r1
    5d2a:	0f 92       	push	r0
    5d2c:	0f b6       	in	r0, 0x3f	; 63
    5d2e:	0f 92       	push	r0
    5d30:	0b b6       	in	r0, 0x3b	; 59
    5d32:	0f 92       	push	r0
    5d34:	11 24       	eor	r1, r1
    5d36:	2f 93       	push	r18
    5d38:	3f 93       	push	r19
    5d3a:	4f 93       	push	r20

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    5d3c:	5f 93       	push	r21
    5d3e:	6f 93       	push	r22
    5d40:	7f 93       	push	r23
    5d42:	8f 93       	push	r24
    5d44:	9f 93       	push	r25
    5d46:	af 93       	push	r26
    5d48:	bf 93       	push	r27
    5d4a:	cf 93       	push	r28
    5d4c:	ef 93       	push	r30
    5d4e:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    5d50:	c0 91 e9 00 	lds	r28, 0x00E9
    5d54:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    5d56:	80 91 ec 00 	lds	r24, 0x00EC
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5d5a:	10 92 e9 00 	sts	0x00E9, r1
						break;
					case USB_INT_SOFI:
						UDIEN  &= ~(1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX &= ~(1 << RXSTPE);
    5d5e:	80 91 f0 00 	lds	r24, 0x00F0
    5d62:	87 7f       	andi	r24, 0xF7	; 247
    5d64:	80 93 f0 00 	sts	0x00F0, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5d68:	78 94       	sei
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);

	GlobalInterruptEnable();

	USB_Device_ProcessControlRequest();
    5d6a:	bb d0       	rcall	.+374    	; 0x5ee2 <USB_Device_ProcessControlRequest>
    5d6c:	10 92 e9 00 	sts	0x00E9, r1
    5d70:	80 91 f0 00 	lds	r24, 0x00F0
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5d74:	88 60       	ori	r24, 0x08	; 8
    5d76:	80 93 f0 00 	sts	0x00F0, r24
    5d7a:	c0 93 e9 00 	sts	0x00E9, r28
    5d7e:	ff 91       	pop	r31

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    5d80:	ef 91       	pop	r30
    5d82:	cf 91       	pop	r28
    5d84:	bf 91       	pop	r27
    5d86:	af 91       	pop	r26
    5d88:	9f 91       	pop	r25
    5d8a:	8f 91       	pop	r24
    5d8c:	7f 91       	pop	r23
    5d8e:	6f 91       	pop	r22
    5d90:	5f 91       	pop	r21
    5d92:	4f 91       	pop	r20
    5d94:	3f 91       	pop	r19
    5d96:	2f 91       	pop	r18
    5d98:	0f 90       	pop	r0
    5d9a:	0b be       	out	0x3b, r0	; 59
    5d9c:	0f 90       	pop	r0
    5d9e:	0f be       	out	0x3f, r0	; 63
    5da0:	0f 90       	pop	r0
    5da2:	1f 90       	pop	r1
    5da4:	18 95       	reti

00005da6 <USB_Host_GetDeviceConfigDescriptor>:
#if defined(USB_CAN_BE_HOST)
uint8_t USB_Host_GetDeviceConfigDescriptor(const uint8_t ConfigNumber,
                                           uint16_t* const ConfigSizePtr,
                                           void* const BufferPtr,
                                           const uint16_t BufferSize)
{
    5da6:	cf 92       	push	r12
    5da8:	df 92       	push	r13
    5daa:	ef 92       	push	r14
    5dac:	ff 92       	push	r15
    5dae:	0f 93       	push	r16
    5db0:	1f 93       	push	r17
    5db2:	cf 93       	push	r28
    5db4:	df 93       	push	r29
    5db6:	cd b7       	in	r28, 0x3d	; 61
    5db8:	de b7       	in	r29, 0x3e	; 62
    5dba:	29 97       	sbiw	r28, 0x09	; 9
    5dbc:	0f b6       	in	r0, 0x3f	; 63
    5dbe:	f8 94       	cli
    5dc0:	de bf       	out	0x3e, r29	; 62
    5dc2:	0f be       	out	0x3f, r0	; 63
    5dc4:	cd bf       	out	0x3d, r28	; 61
    5dc6:	6b 01       	movw	r12, r22
    5dc8:	8a 01       	movw	r16, r20
    5dca:	79 01       	movw	r14, r18
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5dcc:	90 e8       	ldi	r25, 0x80	; 128
    5dce:	90 93 d0 0d 	sts	0x0DD0, r25
    5dd2:	96 e0       	ldi	r25, 0x06	; 6
    5dd4:	90 93 d1 0d 	sts	0x0DD1, r25
		{
			.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
			.bRequest      = REQ_GetDescriptor,
			.wValue        = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
    5dd8:	90 e0       	ldi	r25, 0x00	; 0
    5dda:	01 97       	sbiw	r24, 0x01	; 1
    5ddc:	92 60       	ori	r25, 0x02	; 2
                                           const uint16_t BufferSize)
{
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5dde:	90 93 d3 0d 	sts	0x0DD3, r25
    5de2:	80 93 d2 0d 	sts	0x0DD2, r24
    5de6:	10 92 d5 0d 	sts	0x0DD5, r1
    5dea:	10 92 d4 0d 	sts	0x0DD4, r1
    5dee:	89 e0       	ldi	r24, 0x09	; 9
    5df0:	90 e0       	ldi	r25, 0x00	; 0
    5df2:	90 93 d7 0d 	sts	0x0DD7, r25
    5df6:	80 93 d6 0d 	sts	0x0DD6, r24
    5dfa:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = sizeof(USB_Descriptor_Configuration_Header_t),
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) != HOST_SENDCONTROL_Successful)
    5dfe:	ce 01       	movw	r24, r28
    5e00:	01 96       	adiw	r24, 0x01	; 1
    5e02:	03 d2       	rcall	.+1030   	; 0x620a <USB_Host_SendControlRequest>
    5e04:	88 23       	and	r24, r24
    5e06:	b9 f4       	brne	.+46     	; 0x5e36 <USB_Host_GetDeviceConfigDescriptor+0x90>
    5e08:	8b 81       	ldd	r24, Y+3	; 0x03
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);
    5e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    5e0c:	f6 01       	movw	r30, r12
    5e0e:	91 83       	std	Z+1, r25	; 0x01
    5e10:	80 83       	st	Z, r24
    5e12:	e8 16       	cp	r14, r24

	if (*ConfigSizePtr > BufferSize)
    5e14:	f9 06       	cpc	r15, r25
    5e16:	70 f0       	brcs	.+28     	; 0x5e34 <USB_Host_GetDeviceConfigDescriptor+0x8e>
    5e18:	90 93 d7 0d 	sts	0x0DD7, r25
	  return HOST_GETCONFIG_BuffOverflow;

	USB_ControlRequest.wLength = *ConfigSizePtr;
    5e1c:	80 93 d6 0d 	sts	0x0DD6, r24
    5e20:	c8 01       	movw	r24, r16

	if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) != HOST_SENDCONTROL_Successful)
    5e22:	f3 d1       	rcall	.+998    	; 0x620a <USB_Host_SendControlRequest>
    5e24:	88 23       	and	r24, r24
    5e26:	39 f4       	brne	.+14     	; 0x5e36 <USB_Host_GetDeviceConfigDescriptor+0x90>
    5e28:	f8 01       	movw	r30, r16
    5e2a:	91 81       	ldd	r25, Z+1	; 0x01
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    5e2c:	92 30       	cpi	r25, 0x02	; 2
    5e2e:	19 f0       	breq	.+6      	; 0x5e36 <USB_Host_GetDeviceConfigDescriptor+0x90>
    5e30:	86 e0       	ldi	r24, 0x06	; 6
    5e32:	01 c0       	rjmp	.+2      	; 0x5e36 <USB_Host_GetDeviceConfigDescriptor+0x90>
	  return HOST_GETCONFIG_InvalidData;
    5e34:	85 e0       	ldi	r24, 0x05	; 5
    5e36:	29 96       	adiw	r28, 0x09	; 9
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);

	if (*ConfigSizePtr > BufferSize)
	  return HOST_GETCONFIG_BuffOverflow;
    5e38:	0f b6       	in	r0, 0x3f	; 63

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
	  return HOST_GETCONFIG_InvalidData;

	return HOST_GETCONFIG_Successful;
}
    5e3a:	f8 94       	cli
    5e3c:	de bf       	out	0x3e, r29	; 62
    5e3e:	0f be       	out	0x3f, r0	; 63
    5e40:	cd bf       	out	0x3d, r28	; 61
    5e42:	df 91       	pop	r29
    5e44:	cf 91       	pop	r28
    5e46:	1f 91       	pop	r17
    5e48:	0f 91       	pop	r16
    5e4a:	ff 90       	pop	r15
    5e4c:	ef 90       	pop	r14
    5e4e:	df 90       	pop	r13
    5e50:	cf 90       	pop	r12
    5e52:	08 95       	ret

00005e54 <USB_GetNextDescriptorComp>:
    5e54:	af 92       	push	r10
    5e56:	bf 92       	push	r11
}

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem,
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
    5e58:	cf 92       	push	r12
    5e5a:	df 92       	push	r13
    5e5c:	ef 92       	push	r14
    5e5e:	ff 92       	push	r15
    5e60:	0f 93       	push	r16
    5e62:	1f 93       	push	r17
    5e64:	cf 93       	push	r28
    5e66:	df 93       	push	r29
    5e68:	7c 01       	movw	r14, r24
    5e6a:	8b 01       	movw	r16, r22
    5e6c:	5a 01       	movw	r10, r20
	uint8_t ErrorCode;

	while (*BytesRem)
    5e6e:	28 c0       	rjmp	.+80     	; 0x5ec0 <USB_GetNextDescriptorComp+0x6c>
	{
		uint8_t* PrevDescLoc  = *CurrConfigLoc;
    5e70:	f8 01       	movw	r30, r16
    5e72:	c0 80       	ld	r12, Z
    5e74:	d1 80       	ldd	r13, Z+1	; 0x01
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc)
			{
				uint16_t CurrDescriptorSize = DESCRIPTOR_CAST(*CurrConfigLoc, USB_Descriptor_Header_t).Size;
    5e76:	f6 01       	movw	r30, r12
    5e78:	80 81       	ld	r24, Z
    5e7a:	90 e0       	ldi	r25, 0x00	; 0
    5e7c:	9e 01       	movw	r18, r28
    5e7e:	8c 17       	cp	r24, r28
    5e80:	9d 07       	cpc	r25, r29
    5e82:	08 f4       	brcc	.+2      	; 0x5e86 <USB_GetNextDescriptorComp+0x32>
    5e84:	9c 01       	movw	r18, r24

				if (*BytesRem < CurrDescriptorSize)
				  CurrDescriptorSize = *BytesRem;

				*CurrConfigLoc  = (void*)((uintptr_t)*CurrConfigLoc + CurrDescriptorSize);
    5e86:	c6 01       	movw	r24, r12
    5e88:	82 0f       	add	r24, r18
    5e8a:	93 1f       	adc	r25, r19
    5e8c:	f8 01       	movw	r30, r16
    5e8e:	91 83       	std	Z+1, r25	; 0x01
    5e90:	80 83       	st	Z, r24
				*BytesRem      -= CurrDescriptorSize;
    5e92:	f7 01       	movw	r30, r14
    5e94:	80 81       	ld	r24, Z
    5e96:	91 81       	ldd	r25, Z+1	; 0x01
    5e98:	82 1b       	sub	r24, r18
    5e9a:	93 0b       	sbc	r25, r19
    5e9c:	91 83       	std	Z+1, r25	; 0x01
    5e9e:	80 83       	st	Z, r24
		uint16_t PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    5ea0:	f8 01       	movw	r30, r16
    5ea2:	80 81       	ld	r24, Z
    5ea4:	91 81       	ldd	r25, Z+1	; 0x01
    5ea6:	f5 01       	movw	r30, r10
    5ea8:	09 95       	icall
    5eaa:	82 30       	cpi	r24, 0x02	; 2
    5eac:	49 f0       	breq	.+18     	; 0x5ec0 <USB_GetNextDescriptorComp+0x6c>
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    5eae:	81 30       	cpi	r24, 0x01	; 1
    5eb0:	69 f4       	brne	.+26     	; 0x5ecc <USB_GetNextDescriptorComp+0x78>
			{
				*CurrConfigLoc = PrevDescLoc;
    5eb2:	f8 01       	movw	r30, r16
    5eb4:	d1 82       	std	Z+1, r13	; 0x01
    5eb6:	c0 82       	st	Z, r12
				*BytesRem      = PrevBytesRem;
    5eb8:	f7 01       	movw	r30, r14
    5eba:	d1 83       	std	Z+1, r29	; 0x01
    5ebc:	c0 83       	st	Z, r28
    5ebe:	06 c0       	rjmp	.+12     	; 0x5ecc <USB_GetNextDescriptorComp+0x78>
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
	uint8_t ErrorCode;

	while (*BytesRem)
    5ec0:	f7 01       	movw	r30, r14
    5ec2:	c0 81       	ld	r28, Z
    5ec4:	d1 81       	ldd	r29, Z+1	; 0x01
    5ec6:	20 97       	sbiw	r28, 0x00	; 0
    5ec8:	99 f6       	brne	.-90     	; 0x5e70 <USB_GetNextDescriptorComp+0x1c>

			return ErrorCode;
		}
	}

	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
    5eca:	82 e0       	ldi	r24, 0x02	; 2
}
    5ecc:	df 91       	pop	r29
    5ece:	cf 91       	pop	r28
    5ed0:	1f 91       	pop	r17
    5ed2:	0f 91       	pop	r16
    5ed4:	ff 90       	pop	r15
    5ed6:	ef 90       	pop	r14
    5ed8:	df 90       	pop	r13
    5eda:	cf 90       	pop	r12
    5edc:	bf 90       	pop	r11
    5ede:	af 90       	pop	r10
    5ee0:	08 95       	ret

00005ee2 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    5ee2:	1f 93       	push	r17
    5ee4:	cf 93       	push	r28
    5ee6:	df 93       	push	r29
    5ee8:	cd b7       	in	r28, 0x3d	; 61
    5eea:	de b7       	in	r29, 0x3e	; 62
    5eec:	ac 97       	sbiw	r28, 0x2c	; 44
    5eee:	0f b6       	in	r0, 0x3f	; 63
    5ef0:	f8 94       	cli
    5ef2:	de bf       	out	0x3e, r29	; 62
    5ef4:	0f be       	out	0x3f, r0	; 63
    5ef6:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    5ef8:	80 e0       	ldi	r24, 0x00	; 0
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    5efa:	e0 ed       	ldi	r30, 0xD0	; 208
    5efc:	fd e0       	ldi	r31, 0x0D	; 13
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    5efe:	90 91 f1 00 	lds	r25, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    5f02:	91 93       	st	Z+, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    5f04:	8f 5f       	subi	r24, 0xFF	; 255
    5f06:	88 30       	cpi	r24, 0x08	; 8
    5f08:	d1 f7       	brne	.-12     	; 0x5efe <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    5f0a:	0e 94 c5 02 	call	0x58a	; 0x58a <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5f0e:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    5f12:	83 ff       	sbrs	r24, 3
    5f14:	39 c1       	rjmp	.+626    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    5f16:	80 91 d0 0d 	lds	r24, 0x0DD0

		switch (USB_ControlRequest.bRequest)
    5f1a:	20 91 d1 0d 	lds	r18, 0x0DD1
    5f1e:	25 30       	cpi	r18, 0x05	; 5
    5f20:	09 f4       	brne	.+2      	; 0x5f24 <USB_Device_ProcessControlRequest+0x42>
    5f22:	84 c0       	rjmp	.+264    	; 0x602c <USB_Device_ProcessControlRequest+0x14a>
    5f24:	26 30       	cpi	r18, 0x06	; 6
    5f26:	40 f4       	brcc	.+16     	; 0x5f38 <USB_Device_ProcessControlRequest+0x56>
    5f28:	21 30       	cpi	r18, 0x01	; 1
    5f2a:	a1 f1       	breq	.+104    	; 0x5f94 <USB_Device_ProcessControlRequest+0xb2>
    5f2c:	21 30       	cpi	r18, 0x01	; 1
    5f2e:	70 f0       	brcs	.+28     	; 0x5f4c <USB_Device_ProcessControlRequest+0x6a>
    5f30:	23 30       	cpi	r18, 0x03	; 3
    5f32:	09 f0       	breq	.+2      	; 0x5f36 <USB_Device_ProcessControlRequest+0x54>
    5f34:	29 c1       	rjmp	.+594    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    5f36:	2e c0       	rjmp	.+92     	; 0x5f94 <USB_Device_ProcessControlRequest+0xb2>
    5f38:	28 30       	cpi	r18, 0x08	; 8
    5f3a:	09 f4       	brne	.+2      	; 0x5f3e <USB_Device_ProcessControlRequest+0x5c>
    5f3c:	f5 c0       	rjmp	.+490    	; 0x6128 <USB_Device_ProcessControlRequest+0x246>
    5f3e:	29 30       	cpi	r18, 0x09	; 9
    5f40:	09 f4       	brne	.+2      	; 0x5f44 <USB_Device_ProcessControlRequest+0x62>
    5f42:	05 c1       	rjmp	.+522    	; 0x614e <USB_Device_ProcessControlRequest+0x26c>
    5f44:	26 30       	cpi	r18, 0x06	; 6
    5f46:	09 f0       	breq	.+2      	; 0x5f4a <USB_Device_ProcessControlRequest+0x68>
    5f48:	1f c1       	rjmp	.+574    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    5f4a:	92 c0       	rjmp	.+292    	; 0x6070 <USB_Device_ProcessControlRequest+0x18e>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5f4c:	80 38       	cpi	r24, 0x80	; 128
    5f4e:	21 f0       	breq	.+8      	; 0x5f58 <USB_Device_ProcessControlRequest+0x76>
    5f50:	82 38       	cpi	r24, 0x82	; 130
    5f52:	09 f0       	breq	.+2      	; 0x5f56 <USB_Device_ProcessControlRequest+0x74>
    5f54:	19 c1       	rjmp	.+562    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    5f56:	08 c0       	rjmp	.+16     	; 0x5f68 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    5f58:	80 91 cc 0d 	lds	r24, 0x0DCC
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    5f5c:	90 91 cd 0d 	lds	r25, 0x0DCD
    5f60:	99 23       	and	r25, r25
    5f62:	71 f0       	breq	.+28     	; 0x5f80 <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    5f64:	82 60       	ori	r24, 0x02	; 2
    5f66:	0c c0       	rjmp	.+24     	; 0x5f80 <USB_Device_ProcessControlRequest+0x9e>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5f68:	80 91 d4 0d 	lds	r24, 0x0DD4
    5f6c:	8f 70       	andi	r24, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5f6e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5f72:	90 91 eb 00 	lds	r25, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    5f76:	81 e0       	ldi	r24, 0x01	; 1
    5f78:	95 ff       	sbrs	r25, 5
    5f7a:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5f7c:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5f80:	90 91 e8 00 	lds	r25, 0x00E8
    5f84:	97 7f       	andi	r25, 0xF7	; 247
    5f86:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    5f8a:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    5f8e:	10 92 f1 00 	sts	0x00F1, r1
    5f92:	d5 c0       	rjmp	.+426    	; 0x613e <USB_Device_ProcessControlRequest+0x25c>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5f94:	88 23       	and	r24, r24
    5f96:	19 f0       	breq	.+6      	; 0x5f9e <USB_Device_ProcessControlRequest+0xbc>
    5f98:	82 30       	cpi	r24, 0x02	; 2
    5f9a:	09 f0       	breq	.+2      	; 0x5f9e <USB_Device_ProcessControlRequest+0xbc>
    5f9c:	f5 c0       	rjmp	.+490    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    5f9e:	90 e0       	ldi	r25, 0x00	; 0
    5fa0:	8f 71       	andi	r24, 0x1F	; 31
    5fa2:	90 70       	andi	r25, 0x00	; 0
    5fa4:	00 97       	sbiw	r24, 0x00	; 0
    5fa6:	29 f0       	breq	.+10     	; 0x5fb2 <USB_Device_ProcessControlRequest+0xd0>
    5fa8:	82 30       	cpi	r24, 0x02	; 2
    5faa:	91 05       	cpc	r25, r1
    5fac:	09 f0       	breq	.+2      	; 0x5fb0 <USB_Device_ProcessControlRequest+0xce>
    5fae:	ec c0       	rjmp	.+472    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    5fb0:	0b c0       	rjmp	.+22     	; 0x5fc8 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    5fb2:	80 91 d2 0d 	lds	r24, 0x0DD2
    5fb6:	81 30       	cpi	r24, 0x01	; 1
    5fb8:	09 f0       	breq	.+2      	; 0x5fbc <USB_Device_ProcessControlRequest+0xda>
    5fba:	e6 c0       	rjmp	.+460    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    5fbc:	23 30       	cpi	r18, 0x03	; 3
    5fbe:	09 f0       	breq	.+2      	; 0x5fc2 <USB_Device_ProcessControlRequest+0xe0>
    5fc0:	80 e0       	ldi	r24, 0x00	; 0
    5fc2:	80 93 cd 0d 	sts	0x0DCD, r24
    5fc6:	2c c0       	rjmp	.+88     	; 0x6020 <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    5fc8:	80 91 d2 0d 	lds	r24, 0x0DD2
    5fcc:	88 23       	and	r24, r24
    5fce:	41 f5       	brne	.+80     	; 0x6020 <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5fd0:	20 91 d4 0d 	lds	r18, 0x0DD4
    5fd4:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    5fd6:	09 f4       	brne	.+2      	; 0x5fda <USB_Device_ProcessControlRequest+0xf8>
    5fd8:	d7 c0       	rjmp	.+430    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5fda:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    5fde:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    5fe2:	80 ff       	sbrs	r24, 0
    5fe4:	1d c0       	rjmp	.+58     	; 0x6020 <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    5fe6:	80 91 d1 0d 	lds	r24, 0x0DD1
    5fea:	83 30       	cpi	r24, 0x03	; 3
    5fec:	21 f4       	brne	.+8      	; 0x5ff6 <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5fee:	80 91 eb 00 	lds	r24, 0x00EB
    5ff2:	80 62       	ori	r24, 0x20	; 32
    5ff4:	13 c0       	rjmp	.+38     	; 0x601c <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    5ff6:	80 91 eb 00 	lds	r24, 0x00EB
    5ffa:	80 61       	ori	r24, 0x10	; 16
    5ffc:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6000:	81 e0       	ldi	r24, 0x01	; 1
    6002:	90 e0       	ldi	r25, 0x00	; 0
    6004:	02 c0       	rjmp	.+4      	; 0x600a <USB_Device_ProcessControlRequest+0x128>
    6006:	88 0f       	add	r24, r24
    6008:	99 1f       	adc	r25, r25
    600a:	2a 95       	dec	r18
    600c:	e2 f7       	brpl	.-8      	; 0x6006 <USB_Device_ProcessControlRequest+0x124>
    600e:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    6012:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6016:	80 91 eb 00 	lds	r24, 0x00EB
    601a:	88 60       	ori	r24, 0x08	; 8
    601c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6020:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6024:	80 91 e8 00 	lds	r24, 0x00E8
    6028:	87 7f       	andi	r24, 0xF7	; 247
    602a:	8c c0       	rjmp	.+280    	; 0x6144 <USB_Device_ProcessControlRequest+0x262>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    602c:	88 23       	and	r24, r24
    602e:	09 f0       	breq	.+2      	; 0x6032 <USB_Device_ProcessControlRequest+0x150>
    6030:	ab c0       	rjmp	.+342    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    6032:	10 91 d2 0d 	lds	r17, 0x0DD2
    6036:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    6038:	80 91 e3 00 	lds	r24, 0x00E3
    603c:	80 78       	andi	r24, 0x80	; 128
    603e:	81 2b       	or	r24, r17
    6040:	80 93 e3 00 	sts	0x00E3, r24
    6044:	80 91 e8 00 	lds	r24, 0x00E8
    6048:	87 7f       	andi	r24, 0xF7	; 247
    604a:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    604e:	26 d8       	rcall	.-4020   	; 0x509c <Endpoint_ClearStatusStage>
    6050:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6054:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    6056:	fc cf       	rjmp	.-8      	; 0x6050 <USB_Device_ProcessControlRequest+0x16e>
    6058:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;
				
				UDADDR |= (1 << ADDEN);
    605c:	80 68       	ori	r24, 0x80	; 128
    605e:	80 93 e3 00 	sts	0x00E3, r24
    6062:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    6064:	11 f0       	breq	.+4      	; 0x606a <USB_Device_ProcessControlRequest+0x188>
    6066:	83 e0       	ldi	r24, 0x03	; 3
    6068:	01 c0       	rjmp	.+2      	; 0x606c <USB_Device_ProcessControlRequest+0x18a>
    606a:	82 e0       	ldi	r24, 0x02	; 2
    606c:	8e bb       	out	0x1e, r24	; 30
    606e:	8c c0       	rjmp	.+280    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    6070:	80 58       	subi	r24, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6072:	82 30       	cpi	r24, 0x02	; 2
    6074:	08 f0       	brcs	.+2      	; 0x6078 <USB_Device_ProcessControlRequest+0x196>
    6076:	88 c0       	rjmp	.+272    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    6078:	80 91 d2 0d 	lds	r24, 0x0DD2
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    607c:	90 91 d3 0d 	lds	r25, 0x0DD3
    6080:	23 e0       	ldi	r18, 0x03	; 3
    6082:	8c 3d       	cpi	r24, 0xDC	; 220
    6084:	92 07       	cpc	r25, r18
    6086:	b1 f5       	brne	.+108    	; 0x60f4 <USB_Device_ProcessControlRequest+0x212>
    6088:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    608a:	8c 83       	std	Y+4, r24	; 0x04
    608c:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    608e:	8b 83       	std	Y+3, r24	; 0x03
    6090:	5f b7       	in	r21, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    6092:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    6094:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    6096:	13 96       	adiw	r26, 0x03	; 3
    6098:	80 e0       	ldi	r24, 0x00	; 0
    609a:	90 e0       	ldi	r25, 0x00	; 0
    609c:	4e e0       	ldi	r20, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    609e:	61 e2       	ldi	r22, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    60a0:	e4 2f       	mov	r30, r20
    60a2:	f0 e0       	ldi	r31, 0x00	; 0
    60a4:	60 93 57 00 	sts	0x0057, r22
    60a8:	e4 91       	lpm	r30, Z
    60aa:	80 ff       	sbrs	r24, 0

					if (SerialCharNum & 0x01)
    60ac:	03 c0       	rjmp	.+6      	; 0x60b4 <USB_Device_ProcessControlRequest+0x1d2>
    60ae:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    60b0:	ef 70       	andi	r30, 0x0F	; 15
    60b2:	4f 5f       	subi	r20, 0xFF	; 255
						SigReadAddress++;
    60b4:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    60b6:	2e 2f       	mov	r18, r30
    60b8:	30 e0       	ldi	r19, 0x00	; 0
    60ba:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    60bc:	18 f0       	brcs	.+6      	; 0x60c4 <USB_Device_ProcessControlRequest+0x1e2>
    60be:	29 5c       	subi	r18, 0xC9	; 201
    60c0:	3f 4f       	sbci	r19, 0xFF	; 255
    60c2:	02 c0       	rjmp	.+4      	; 0x60c8 <USB_Device_ProcessControlRequest+0x1e6>
    60c4:	20 5d       	subi	r18, 0xD0	; 208
    60c6:	3f 4f       	sbci	r19, 0xFF	; 255
    60c8:	13 96       	adiw	r26, 0x03	; 3
    60ca:	3c 93       	st	X, r19
    60cc:	2e 93       	st	-X, r18
    60ce:	12 97       	sbiw	r26, 0x02	; 2
    60d0:	01 96       	adiw	r24, 0x01	; 1
    60d2:	12 96       	adiw	r26, 0x02	; 2
    60d4:	84 31       	cpi	r24, 0x14	; 20
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    60d6:	91 05       	cpc	r25, r1
    60d8:	19 f7       	brne	.-58     	; 0x60a0 <USB_Device_ProcessControlRequest+0x1be>
    60da:	5f bf       	out	0x3f, r21	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    60dc:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    60e0:	87 7f       	andi	r24, 0xF7	; 247
    60e2:	80 93 e8 00 	sts	0x00E8, r24
    60e6:	ce 01       	movw	r24, r28

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    60e8:	03 96       	adiw	r24, 0x03	; 3
    60ea:	6a e2       	ldi	r22, 0x2A	; 42
    60ec:	70 e0       	ldi	r23, 0x00	; 0
    60ee:	0e 94 e2 26 	call	0x4dc4	; 0x4dc4 <Endpoint_Write_Control_Stream_LE>
    60f2:	14 c0       	rjmp	.+40     	; 0x611c <USB_Device_ProcessControlRequest+0x23a>
    60f4:	60 91 d4 0d 	lds	r22, 0x0DD4
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    60f8:	ae 01       	movw	r20, r28
    60fa:	4f 5f       	subi	r20, 0xFF	; 255
    60fc:	5f 4f       	sbci	r21, 0xFF	; 255
    60fe:	0e 94 68 02 	call	0x4d0	; 0x4d0 <CALLBACK_USB_GetDescriptor>
    6102:	bc 01       	movw	r22, r24
    6104:	00 97       	sbiw	r24, 0x00	; 0
    6106:	09 f4       	brne	.+2      	; 0x610a <USB_Device_ProcessControlRequest+0x228>
    6108:	3f c0       	rjmp	.+126    	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    610a:	80 91 e8 00 	lds	r24, 0x00E8
    610e:	87 7f       	andi	r24, 0xF7	; 247
    6110:	80 93 e8 00 	sts	0x00E8, r24
    6114:	89 81       	ldd	r24, Y+1	; 0x01
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    6116:	9a 81       	ldd	r25, Y+2	; 0x02
    6118:	0e 94 82 27 	call	0x4f04	; 0x4f04 <Endpoint_Write_Control_PStream_LE>
    611c:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6120:	8b 77       	andi	r24, 0x7B	; 123
    6122:	80 93 e8 00 	sts	0x00E8, r24
    6126:	30 c0       	rjmp	.+96     	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    6128:	80 38       	cpi	r24, 0x80	; 128
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    612a:	71 f5       	brne	.+92     	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    612c:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6130:	87 7f       	andi	r24, 0xF7	; 247
    6132:	80 93 e8 00 	sts	0x00E8, r24
    6136:	80 91 cb 0d 	lds	r24, 0x0DCB

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    613a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    613e:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6142:	8e 77       	andi	r24, 0x7E	; 126
    6144:	80 93 e8 00 	sts	0x00E8, r24
    6148:	0e 94 4e 28 	call	0x509c	; 0x509c <Endpoint_ClearStatusStage>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    614c:	1d c0       	rjmp	.+58     	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    614e:	88 23       	and	r24, r24
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6150:	d9 f4       	brne	.+54     	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    6152:	90 91 d2 0d 	lds	r25, 0x0DD2
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    6156:	92 30       	cpi	r25, 0x02	; 2
    6158:	b8 f4       	brcc	.+46     	; 0x6188 <USB_Device_ProcessControlRequest+0x2a6>
    615a:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    615e:	87 7f       	andi	r24, 0xF7	; 247
    6160:	80 93 e8 00 	sts	0x00E8, r24
    6164:	90 93 cb 0d 	sts	0x0DCB, r25
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    6168:	0e 94 4e 28 	call	0x509c	; 0x509c <Endpoint_ClearStatusStage>

	Endpoint_ClearStatusStage();
    616c:	80 91 cb 0d 	lds	r24, 0x0DCB

	if (USB_Device_ConfigurationNumber)
    6170:	88 23       	and	r24, r24
    6172:	21 f4       	brne	.+8      	; 0x617c <USB_Device_ProcessControlRequest+0x29a>
    6174:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6178:	87 ff       	sbrs	r24, 7
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    617a:	02 c0       	rjmp	.+4      	; 0x6180 <USB_Device_ProcessControlRequest+0x29e>
    617c:	84 e0       	ldi	r24, 0x04	; 4
    617e:	01 c0       	rjmp	.+2      	; 0x6182 <USB_Device_ProcessControlRequest+0x2a0>
    6180:	81 e0       	ldi	r24, 0x01	; 1
    6182:	8e bb       	out	0x1e, r24	; 30
    6184:	0e 94 ac 02 	call	0x558	; 0x558 <EVENT_USB_Device_ConfigurationChanged>

	EVENT_USB_Device_ConfigurationChanged();
    6188:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    618c:	83 ff       	sbrs	r24, 3
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    618e:	0a c0       	rjmp	.+20     	; 0x61a4 <USB_Device_ProcessControlRequest+0x2c2>
    6190:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6194:	87 7f       	andi	r24, 0xF7	; 247
    6196:	80 93 e8 00 	sts	0x00E8, r24
    619a:	80 91 eb 00 	lds	r24, 0x00EB
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    619e:	80 62       	ori	r24, 0x20	; 32
    61a0:	80 93 eb 00 	sts	0x00EB, r24
    61a4:	ac 96       	adiw	r28, 0x2c	; 44
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    61a6:	0f b6       	in	r0, 0x3f	; 63
    61a8:	f8 94       	cli
    61aa:	de bf       	out	0x3e, r29	; 62
    61ac:	0f be       	out	0x3f, r0	; 63
    61ae:	cd bf       	out	0x3d, r28	; 61
    61b0:	df 91       	pop	r29
    61b2:	cf 91       	pop	r28
    61b4:	1f 91       	pop	r17
    61b6:	08 95       	ret

000061b8 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    61b8:	08 95       	ret

000061ba <USB_Host_WaitForIOS>:
	
	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    61ba:	1f 93       	push	r17
    61bc:	cf 93       	push	r28
    61be:	df 93       	push	r29
    61c0:	18 2f       	mov	r17, r24
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    61c2:	c9 ee       	ldi	r28, 0xE9	; 233
    61c4:	d3 e0       	ldi	r29, 0x03	; 3
    61c6:	06 c0       	rjmp	.+12     	; 0x61d4 <USB_Host_WaitForIOS+0x1a>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    61c8:	81 e0       	ldi	r24, 0x01	; 1
    61ca:	0f d8       	rcall	.-4066   	; 0x51ea <USB_Host_WaitMS>
    61cc:	88 23       	and	r24, r24
    61ce:	c9 f4       	brne	.+50     	; 0x6202 <USB_Host_WaitForIOS+0x48>
    61d0:	21 97       	sbiw	r28, 0x01	; 1
    61d2:	b1 f0       	breq	.+44     	; 0x6200 <USB_Host_WaitForIOS+0x46>
		  return ErrorCode;

		if (!(TimeoutCounter--))
    61d4:	11 23       	and	r17, r17
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    61d6:	29 f4       	brne	.+10     	; 0x61e2 <USB_Host_WaitForIOS+0x28>
    61d8:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
			 */
			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsSETUPSent(void)
			{
				return ((UPINTX & (1 << TXSTPI)) ? true : false);
    61dc:	83 ff       	sbrs	r24, 3
    61de:	f4 cf       	rjmp	.-24     	; 0x61c8 <USB_Host_WaitForIOS+0xe>
    61e0:	0d c0       	rjmp	.+26     	; 0x61fc <USB_Host_WaitForIOS+0x42>
    61e2:	11 30       	cpi	r17, 0x01	; 1
    61e4:	29 f4       	brne	.+10     	; 0x61f0 <USB_Host_WaitForIOS+0x36>
    61e6:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    61ea:	80 ff       	sbrs	r24, 0
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
    61ec:	ed cf       	rjmp	.-38     	; 0x61c8 <USB_Host_WaitForIOS+0xe>
    61ee:	06 c0       	rjmp	.+12     	; 0x61fc <USB_Host_WaitForIOS+0x42>
    61f0:	12 30       	cpi	r17, 0x02	; 2
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    61f2:	51 f7       	brne	.-44     	; 0x61c8 <USB_Host_WaitForIOS+0xe>
    61f4:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    61f8:	82 ff       	sbrs	r24, 2
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
    61fa:	e6 cf       	rjmp	.-52     	; 0x61c8 <USB_Host_WaitForIOS+0xe>
    61fc:	80 e0       	ldi	r24, 0x00	; 0

		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
    61fe:	01 c0       	rjmp	.+2      	; 0x6202 <USB_Host_WaitForIOS+0x48>
    6200:	84 e0       	ldi	r24, 0x04	; 4

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
		  return ErrorCode;

		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
    6202:	df 91       	pop	r29
	}

	return HOST_SENDCONTROL_Successful;
}
    6204:	cf 91       	pop	r28
    6206:	1f 91       	pop	r17
    6208:	08 95       	ret

0000620a <USB_Host_SendControlRequest>:
    620a:	ef 92       	push	r14

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
    620c:	ff 92       	push	r15
    620e:	0f 93       	push	r16
    6210:	1f 93       	push	r17
    6212:	cf 93       	push	r28
    6214:	df 93       	push	r29
    6216:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    6218:	e0 90 9e 00 	lds	r14, 0x009E
    621c:	ff 24       	eor	r15, r15
    621e:	81 e0       	ldi	r24, 0x01	; 1
    6220:	e8 22       	and	r14, r24
    6222:	ff 24       	eor	r15, r15

static uint8_t USB_Host_SendControlRequest_PRV(void* const BufferPtr)
{
	uint8_t* DataStream   = (uint8_t*)BufferPtr;
	uint8_t  ReturnStatus = HOST_SENDCONTROL_Successful;
	uint16_t DataLen      = USB_ControlRequest.wLength;
    6224:	00 91 d6 0d 	lds	r16, 0x0DD6
    6228:	10 91 d7 0d 	lds	r17, 0x0DD7
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    622c:	80 91 9e 00 	lds	r24, 0x009E
    6230:	81 60       	ori	r24, 0x01	; 1
    6232:	80 93 9e 00 	sts	0x009E, r24

	USB_Host_ResumeBus();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    6236:	81 e0       	ldi	r24, 0x01	; 1
    6238:	0e 94 f5 28 	call	0x51ea	; 0x51ea <USB_Host_WaitMS>
    623c:	88 23       	and	r24, r24
    623e:	09 f0       	breq	.+2      	; 0x6242 <USB_Host_SendControlRequest+0x38>
    6240:	cb c0       	rjmp	.+406    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6242:	80 91 aa 00 	lds	r24, 0x00AA
    6246:	8f 7c       	andi	r24, 0xCF	; 207
    6248:	80 93 aa 00 	sts	0x00AA, r24

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    624c:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    6250:	80 91 a6 00 	lds	r24, 0x00A6
    6254:	8f 7e       	andi	r24, 0xEF	; 239
    6256:	80 93 a6 00 	sts	0x00A6, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    625a:	80 91 a9 00 	lds	r24, 0x00A9
    625e:	8f 7b       	andi	r24, 0xBF	; 191
    6260:	80 93 a9 00 	sts	0x00A9, r24
    6264:	88 e0       	ldi	r24, 0x08	; 8
	Pipe_Write_8(USB_ControlRequest.bRequest);
	Pipe_Write_16_LE(USB_ControlRequest.wValue);
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;
    6266:	e0 ed       	ldi	r30, 0xD0	; 208
    6268:	fd e0       	ldi	r31, 0x0D	; 13

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
	  Pipe_Write_8(*(HeaderStream++));
    626a:	91 91       	ld	r25, Z+
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    626c:	90 93 af 00 	sts	0x00AF, r25
    6270:	81 50       	subi	r24, 0x01	; 1
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
    6272:	d9 f7       	brne	.-10     	; 0x626a <USB_Host_SendControlRequest+0x60>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearSETUP(void)
			{
				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
    6274:	80 91 a6 00 	lds	r24, 0x00A6
    6278:	87 77       	andi	r24, 0x77	; 119
    627a:	80 93 a6 00 	sts	0x00A6, r24
	  Pipe_Write_8(*(HeaderStream++));
	#endif

	Pipe_ClearSETUP();

	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    627e:	80 e0       	ldi	r24, 0x00	; 0
    6280:	9c df       	rcall	.-200    	; 0x61ba <USB_Host_WaitForIOS>
    6282:	88 23       	and	r24, r24
    6284:	09 f0       	breq	.+2      	; 0x6288 <USB_Host_SendControlRequest+0x7e>
    6286:	a8 c0       	rjmp	.+336    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    6288:	80 91 a9 00 	lds	r24, 0x00A9

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    628c:	80 64       	ori	r24, 0x40	; 64
    628e:	80 93 a9 00 	sts	0x00A9, r24
    6292:	81 e0       	ldi	r24, 0x01	; 1
	  return ReturnStatus;

	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    6294:	0e 94 f5 28 	call	0x51ea	; 0x51ea <USB_Host_WaitMS>
    6298:	88 23       	and	r24, r24
    629a:	09 f0       	breq	.+2      	; 0x629e <USB_Host_SendControlRequest+0x94>
    629c:	9d c0       	rjmp	.+314    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    629e:	80 91 d0 0d 	lds	r24, 0x0DD0
	  return ReturnStatus;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    62a2:	87 ff       	sbrs	r24, 7
    62a4:	4f c0       	rjmp	.+158    	; 0x6344 <USB_Host_SendControlRequest+0x13a>
    62a6:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    62aa:	8f 7c       	andi	r24, 0xCF	; 207
    62ac:	80 61       	ori	r24, 0x10	; 16
    62ae:	80 93 aa 00 	sts	0x00AA, r24
    62b2:	20 97       	sbiw	r28, 0x00	; 0
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
    62b4:	61 f5       	brne	.+88     	; 0x630e <USB_Host_SendControlRequest+0x104>
    62b6:	2e c0       	rjmp	.+92     	; 0x6314 <USB_Host_SendControlRequest+0x10a>
    62b8:	80 91 a9 00 	lds	r24, 0x00A9

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    62bc:	8f 7b       	andi	r24, 0xBF	; 191
    62be:	80 93 a9 00 	sts	0x00A9, r24
    62c2:	81 e0       	ldi	r24, 0x01	; 1
		{
			while (DataLen)
			{
				Pipe_Unfreeze();

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    62c4:	7a df       	rcall	.-268    	; 0x61ba <USB_Host_WaitForIOS>
    62c6:	88 23       	and	r24, r24
    62c8:	09 f0       	breq	.+2      	; 0x62cc <USB_Host_SendControlRequest+0xc2>
    62ca:	86 c0       	rjmp	.+268    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    62cc:	80 91 f6 00 	lds	r24, 0x00F6
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    62d0:	90 91 f7 00 	lds	r25, 0x00F7
    62d4:	00 97       	sbiw	r24, 0x00	; 0
    62d6:	41 f4       	brne	.+16     	; 0x62e8 <USB_Host_SendControlRequest+0xde>
				  return ReturnStatus;

				if (!(Pipe_BytesInPipe()))
    62d8:	00 e0       	ldi	r16, 0x00	; 0
    62da:	10 e0       	ldi	r17, 0x00	; 0
				  DataLen = 0;
    62dc:	05 c0       	rjmp	.+10     	; 0x62e8 <USB_Host_SendControlRequest+0xde>
    62de:	80 91 af 00 	lds	r24, 0x00AF
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    62e2:	89 93       	st	Y+, r24
    62e4:	01 50       	subi	r16, 0x01	; 1

				while (Pipe_BytesInPipe() && DataLen)
				{
					*(DataStream++) = Pipe_Read_8();
    62e6:	10 40       	sbci	r17, 0x00	; 0
					DataLen--;
    62e8:	80 91 f6 00 	lds	r24, 0x00F6
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    62ec:	90 91 f7 00 	lds	r25, 0x00F7
    62f0:	00 97       	sbiw	r24, 0x00	; 0
    62f2:	19 f0       	breq	.+6      	; 0x62fa <USB_Host_SendControlRequest+0xf0>
				  return ReturnStatus;

				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
    62f4:	01 15       	cp	r16, r1
    62f6:	11 05       	cpc	r17, r1
    62f8:	91 f7       	brne	.-28     	; 0x62de <USB_Host_SendControlRequest+0xd4>
    62fa:	80 91 a9 00 	lds	r24, 0x00A9

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    62fe:	80 64       	ori	r24, 0x40	; 64
    6300:	80 93 a9 00 	sts	0x00A9, r24
    6304:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    6308:	8e 77       	andi	r24, 0x7E	; 126
    630a:	80 93 a6 00 	sts	0x00A6, r24
    630e:	01 15       	cp	r16, r1
    6310:	11 05       	cpc	r17, r1
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
		{
			while (DataLen)
    6312:	91 f6       	brne	.-92     	; 0x62b8 <USB_Host_SendControlRequest+0xae>
    6314:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6318:	8f 7c       	andi	r24, 0xCF	; 207
    631a:	80 62       	ori	r24, 0x20	; 32
    631c:	80 93 aa 00 	sts	0x00AA, r24
    6320:	80 91 a9 00 	lds	r24, 0x00A9

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6324:	8f 7b       	andi	r24, 0xBF	; 191
    6326:	80 93 a9 00 	sts	0x00A9, r24
    632a:	82 e0       	ldi	r24, 0x02	; 2
    632c:	46 df       	rcall	.-372    	; 0x61ba <USB_Host_WaitForIOS>
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    632e:	88 23       	and	r24, r24
    6330:	09 f0       	breq	.+2      	; 0x6334 <USB_Host_SendControlRequest+0x12a>
    6332:	52 c0       	rjmp	.+164    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    6334:	80 91 a6 00 	lds	r24, 0x00A6
    6338:	8b 77       	andi	r24, 0x7B	; 123
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    633a:	80 93 a6 00 	sts	0x00A6, r24
    633e:	82 e0       	ldi	r24, 0x02	; 2
    6340:	3c df       	rcall	.-392    	; 0x61ba <USB_Host_WaitForIOS>
    6342:	4a c0       	rjmp	.+148    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
		  return ReturnStatus;

		Pipe_ClearOUT();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6344:	20 97       	sbiw	r28, 0x00	; 0
    6346:	a1 f1       	breq	.+104    	; 0x63b0 <USB_Host_SendControlRequest+0x1a6>
    6348:	80 91 aa 00 	lds	r24, 0x00AA
		  return ReturnStatus;
	}
	else
	{
		if (DataStream != NULL)
    634c:	8f 7c       	andi	r24, 0xCF	; 207
    634e:	80 62       	ori	r24, 0x20	; 32
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6350:	80 93 aa 00 	sts	0x00AA, r24
    6354:	80 91 a9 00 	lds	r24, 0x00A9
    6358:	8f 7b       	andi	r24, 0xBF	; 191
    635a:	80 93 a9 00 	sts	0x00A9, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    635e:	1c c0       	rjmp	.+56     	; 0x6398 <USB_Host_SendControlRequest+0x18e>
    6360:	2c df       	rcall	.-424    	; 0x61ba <USB_Host_WaitForIOS>
    6362:	88 23       	and	r24, r24
    6364:	c9 f5       	brne	.+114    	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    6366:	fe 01       	movw	r30, r28
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6368:	07 c0       	rjmp	.+14     	; 0x6378 <USB_Host_SendControlRequest+0x16e>
    636a:	81 91       	ld	r24, Z+
    636c:	ef 01       	movw	r28, r30
    636e:	80 93 af 00 	sts	0x00AF, r24
    6372:	01 50       	subi	r16, 0x01	; 1
				  return ReturnStatus;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
				{
					Pipe_Write_8(*(DataStream++));
    6374:	10 40       	sbci	r17, 0x00	; 0
    6376:	59 f0       	breq	.+22     	; 0x638e <USB_Host_SendControlRequest+0x184>
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    6378:	ef 01       	movw	r28, r30
    637a:	20 91 f6 00 	lds	r18, 0x00F6
					DataLen--;
    637e:	30 91 f7 00 	lds	r19, 0x00F7
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  return ReturnStatus;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    6382:	80 91 4d 03 	lds	r24, 0x034D
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    6386:	90 e0       	ldi	r25, 0x00	; 0
    6388:	28 17       	cp	r18, r24
    638a:	39 07       	cpc	r19, r25
    638c:	70 f3       	brcs	.-36     	; 0x636a <USB_Host_SendControlRequest+0x160>
    638e:	80 91 a6 00 	lds	r24, 0x00A6
    6392:	8b 77       	andi	r24, 0x7B	; 123
    6394:	80 93 a6 00 	sts	0x00A6, r24
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    6398:	82 e0       	ldi	r24, 0x02	; 2
    639a:	01 15       	cp	r16, r1
    639c:	11 05       	cpc	r17, r1
    639e:	01 f7       	brne	.-64     	; 0x6360 <USB_Host_SendControlRequest+0x156>
    63a0:	0c df       	rcall	.-488    	; 0x61ba <USB_Host_WaitForIOS>
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    63a2:	88 23       	and	r24, r24
		if (DataStream != NULL)
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
    63a4:	c9 f4       	brne	.+50     	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    63a6:	80 91 a9 00 	lds	r24, 0x00A9
				}

				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    63aa:	80 64       	ori	r24, 0x40	; 64
    63ac:	80 93 a9 00 	sts	0x00A9, r24
    63b0:	80 91 aa 00 	lds	r24, 0x00AA

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    63b4:	8f 7c       	andi	r24, 0xCF	; 207
    63b6:	80 61       	ori	r24, 0x10	; 16
    63b8:	80 93 aa 00 	sts	0x00AA, r24
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    63bc:	80 91 a9 00 	lds	r24, 0x00A9
    63c0:	8f 7b       	andi	r24, 0xBF	; 191
    63c2:	80 93 a9 00 	sts	0x00A9, r24
    63c6:	81 e0       	ldi	r24, 0x01	; 1

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    63c8:	f8 de       	rcall	.-528    	; 0x61ba <USB_Host_WaitForIOS>
    63ca:	88 23       	and	r24, r24
    63cc:	29 f4       	brne	.+10     	; 0x63d8 <USB_Host_SendControlRequest+0x1ce>
    63ce:	90 91 a6 00 	lds	r25, 0x00A6
		}

		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    63d2:	9e 77       	andi	r25, 0x7E	; 126
    63d4:	90 93 a6 00 	sts	0x00A6, r25
    63d8:	90 91 a9 00 	lds	r25, 0x00A9
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    63dc:	90 64       	ori	r25, 0x40	; 64
    63de:	90 93 a9 00 	sts	0x00A9, r25
    63e2:	e1 14       	cp	r14, r1
    63e4:	f1 04       	cpc	r15, r1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    63e6:	29 f4       	brne	.+10     	; 0x63f2 <USB_Host_SendControlRequest+0x1e8>
    63e8:	90 91 9e 00 	lds	r25, 0x009E
    63ec:	9e 7f       	andi	r25, 0xFE	; 254
    63ee:	90 93 9e 00 	sts	0x009E, r25
	bool BusSuspended    = USB_Host_IsBusSuspended();
	uint8_t ReturnStatus = USB_Host_SendControlRequest_PRV(BufferPtr);

	Pipe_Freeze();

	if (BusSuspended)
    63f2:	91 e0       	ldi	r25, 0x01	; 1
    63f4:	90 93 a8 00 	sts	0x00A8, r25
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    63f8:	10 92 a8 00 	sts	0x00A8, r1
    63fc:	df 91       	pop	r29
    63fe:	cf 91       	pop	r28
			 *  \param[in] Address  Address of the pipe to reset.
			 */
			static inline void Pipe_ResetPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ResetPipe(const uint8_t Address)
			{
				UPRST = (1 << (Address & PIPE_PIPENUM_MASK));
    6400:	1f 91       	pop	r17
    6402:	0f 91       	pop	r16
    6404:	ff 90       	pop	r15
				UPRST = 0;
    6406:	ef 90       	pop	r14
    6408:	08 95       	ret

0000640a <USB_Host_SetDeviceConfiguration>:
	  USB_Host_SuspendBus();

	Pipe_ResetPipe(PIPE_CONTROLPIPE);

	return ReturnStatus;
}
    640a:	cf 93       	push	r28
    640c:	c8 2f       	mov	r28, r24
    640e:	10 92 d0 0d 	sts	0x0DD0, r1
    6412:	89 e0       	ldi	r24, 0x09	; 9
    6414:	80 93 d1 0d 	sts	0x0DD1, r24

uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber)
{
	uint8_t ErrorCode;

	USB_ControlRequest = (USB_Request_Header_t)
    6418:	c0 93 d2 0d 	sts	0x0DD2, r28
    641c:	10 92 d3 0d 	sts	0x0DD3, r1
    6420:	10 92 d5 0d 	sts	0x0DD5, r1
    6424:	10 92 d4 0d 	sts	0x0DD4, r1
    6428:	10 92 d7 0d 	sts	0x0DD7, r1
    642c:	10 92 d6 0d 	sts	0x0DD6, r1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    6430:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = 0,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(NULL)) == HOST_SENDCONTROL_Successful)
    6434:	80 e0       	ldi	r24, 0x00	; 0
    6436:	90 e0       	ldi	r25, 0x00	; 0
    6438:	e8 de       	rcall	.-560    	; 0x620a <USB_Host_SendControlRequest>
    643a:	88 23       	and	r24, r24
    643c:	41 f4       	brne	.+16     	; 0x644e <USB_Host_SetDeviceConfiguration+0x44>
    643e:	c0 93 ce 0d 	sts	0x0DCE, r28
	{
		USB_Host_ConfigurationNumber = ConfigNumber;
    6442:	cc 23       	and	r28, r28
		USB_HostState                = (ConfigNumber) ? HOST_STATE_Configured : HOST_STATE_Addressed;
    6444:	11 f0       	breq	.+4      	; 0x644a <USB_Host_SetDeviceConfiguration+0x40>
    6446:	9b e0       	ldi	r25, 0x0B	; 11
    6448:	01 c0       	rjmp	.+2      	; 0x644c <USB_Host_SetDeviceConfiguration+0x42>
    644a:	9a e0       	ldi	r25, 0x0A	; 10
    644c:	9e bb       	out	0x1e, r25	; 30
    644e:	cf 91       	pop	r28
	}

	return ErrorCode;
}
    6450:	08 95       	ret

00006452 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    6452:	cf 93       	push	r28
	#if defined(USB_CAN_BE_BOTH)
		if (USB_CurrentMode == USB_MODE_Device)
    6454:	80 91 fb 03 	lds	r24, 0x03FB
    6458:	81 30       	cpi	r24, 0x01	; 1
    645a:	c9 f4       	brne	.+50     	; 0x648e <USB_USBTask+0x3c>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    645c:	8e b3       	in	r24, 0x1e	; 30
    645e:	88 23       	and	r24, r24
    6460:	29 f1       	breq	.+74     	; 0x64ac <USB_USBTask+0x5a>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6462:	80 91 e9 00 	lds	r24, 0x00E9
    6466:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6468:	90 91 ec 00 	lds	r25, 0x00EC
    646c:	90 ff       	sbrs	r25, 0
    646e:	02 c0       	rjmp	.+4      	; 0x6474 <USB_USBTask+0x22>
    6470:	c0 e8       	ldi	r28, 0x80	; 128
    6472:	01 c0       	rjmp	.+2      	; 0x6476 <USB_USBTask+0x24>
    6474:	c0 e0       	ldi	r28, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6476:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6478:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    647c:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    6480:	83 ff       	sbrs	r24, 3
    6482:	01 c0       	rjmp	.+2      	; 0x6486 <USB_USBTask+0x34>
	  USB_Device_ProcessControlRequest();
    6484:	2e dd       	rcall	.-1444   	; 0x5ee2 <USB_Device_ProcessControlRequest>
    6486:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6488:	c0 93 e9 00 	sts	0x00E9, r28
    648c:	0f c0       	rjmp	.+30     	; 0x64ac <USB_USBTask+0x5a>
    648e:	80 91 fb 03 	lds	r24, 0x03FB
void USB_USBTask(void)
{
	#if defined(USB_CAN_BE_BOTH)
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
    6492:	82 30       	cpi	r24, 0x02	; 2
    6494:	59 f4       	brne	.+22     	; 0x64ac <USB_USBTask+0x5a>
    6496:	c0 91 a7 00 	lds	r28, 0x00A7
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    649a:	cf 70       	andi	r28, 0x0F	; 15
    649c:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \return The currently selected pipe's direction, as a \c PIPE_DIR_* mask.
			 */
			static inline uint8_t Pipe_GetPipeDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeDirection(void)
			{
				return (UPCFG0X & (1 << EPDIR)) ? PIPE_DIR_IN : PIPE_DIR_OUT;
    64a0:	10 92 a7 00 	sts	0x00A7, r1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    64a4:	0e 94 4d 29 	call	0x529a	; 0x529a <USB_Host_ProcessNextHostState>
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	USB_Host_ProcessNextHostState();
    64a8:	c0 93 a7 00 	sts	0x00A7, r28
    64ac:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    64ae:	08 95       	ret

000064b0 <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    64b0:	cf 93       	push	r28
    64b2:	df 93       	push	r29
    64b4:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    64b6:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    64ba:	83 ff       	sbrs	r24, 3
    64bc:	35 c0       	rjmp	.+106    	; 0x6528 <MS_Device_ProcessControlRequest+0x78>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    64be:	88 81       	ld	r24, Y
    64c0:	90 e0       	ldi	r25, 0x00	; 0
    64c2:	20 91 d4 0d 	lds	r18, 0x0DD4
    64c6:	30 91 d5 0d 	lds	r19, 0x0DD5
    64ca:	28 17       	cp	r18, r24
    64cc:	39 07       	cpc	r19, r25
    64ce:	61 f5       	brne	.+88     	; 0x6528 <MS_Device_ProcessControlRequest+0x78>
	  return;

	switch (USB_ControlRequest.bRequest)
    64d0:	80 91 d1 0d 	lds	r24, 0x0DD1
    64d4:	8e 3f       	cpi	r24, 0xFE	; 254
    64d6:	81 f0       	breq	.+32     	; 0x64f8 <MS_Device_ProcessControlRequest+0x48>
    64d8:	8f 3f       	cpi	r24, 0xFF	; 255
    64da:	31 f5       	brne	.+76     	; 0x6528 <MS_Device_ProcessControlRequest+0x78>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    64dc:	80 91 d0 0d 	lds	r24, 0x0DD0
    64e0:	81 32       	cpi	r24, 0x21	; 33
    64e2:	11 f5       	brne	.+68     	; 0x6528 <MS_Device_ProcessControlRequest+0x78>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    64e4:	80 91 e8 00 	lds	r24, 0x00E8
    64e8:	87 7f       	andi	r24, 0xF7	; 247
    64ea:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    64ee:	0e 94 4e 28 	call	0x509c	; 0x509c <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    64f2:	81 e0       	ldi	r24, 0x01	; 1
    64f4:	88 af       	sts	0x78, r24
    64f6:	18 c0       	rjmp	.+48     	; 0x6528 <MS_Device_ProcessControlRequest+0x78>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    64f8:	80 91 d0 0d 	lds	r24, 0x0DD0
    64fc:	81 3a       	cpi	r24, 0xA1	; 161
    64fe:	a1 f4       	brne	.+40     	; 0x6528 <MS_Device_ProcessControlRequest+0x78>
    6500:	80 91 e8 00 	lds	r24, 0x00E8
    6504:	87 7f       	andi	r24, 0xF7	; 247
    6506:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    650a:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    650e:	80 ff       	sbrs	r24, 0
    6510:	fc cf       	rjmp	.-8      	; 0x650a <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    6512:	8b 85       	ldd	r24, Y+11	; 0x0b
    6514:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6516:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    651a:	80 91 e8 00 	lds	r24, 0x00E8
    651e:	8e 77       	andi	r24, 0x7E	; 126
    6520:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    6524:	0e 94 4e 28 	call	0x509c	; 0x509c <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    6528:	df 91       	pop	r29
    652a:	cf 91       	pop	r28
    652c:	08 95       	ret

0000652e <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    652e:	cf 93       	push	r28
    6530:	df 93       	push	r29
    6532:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    6534:	0c 96       	adiw	r24, 0x0c	; 12
    6536:	fc 01       	movw	r30, r24
    6538:	8d e2       	ldi	r24, 0x2D	; 45
    653a:	df 01       	movw	r26, r30
    653c:	1d 92       	st	X+, r1
    653e:	8a 95       	dec	r24
    6540:	e9 f7       	brne	.-6      	; 0x653c <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    6542:	82 e0       	ldi	r24, 0x02	; 2
    6544:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    6546:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    6548:	ce 01       	movw	r24, r28
    654a:	01 96       	adiw	r24, 0x01	; 1
    654c:	61 e0       	ldi	r22, 0x01	; 1
    654e:	0e 94 12 28 	call	0x5024	; 0x5024 <Endpoint_ConfigureEndpointTable>
    6552:	88 23       	and	r24, r24
    6554:	31 f0       	breq	.+12     	; 0x6562 <MS_Device_ConfigureEndpoints+0x34>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6556:	ce 01       	movw	r24, r28
    6558:	06 96       	adiw	r24, 0x06	; 6
    655a:	61 e0       	ldi	r22, 0x01	; 1
    655c:	0e 94 12 28 	call	0x5024	; 0x5024 <Endpoint_ConfigureEndpointTable>
    6560:	01 c0       	rjmp	.+2      	; 0x6564 <MS_Device_ConfigureEndpoints+0x36>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;
    6562:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;

	return true;
}
    6564:	df 91       	pop	r29
    6566:	cf 91       	pop	r28
    6568:	08 95       	ret

0000656a <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    656a:	ef 92       	push	r14
    656c:	ff 92       	push	r15
    656e:	0f 93       	push	r16
    6570:	1f 93       	push	r17
    6572:	cf 93       	push	r28
    6574:	df 93       	push	r29
    6576:	00 d0       	rcall	.+0      	; 0x6578 <MS_Device_USBTask+0xe>
    6578:	cd b7       	in	r28, 0x3d	; 61
    657a:	de b7       	in	r29, 0x3e	; 62
    657c:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    657e:	8e b3       	in	r24, 0x1e	; 30
    6580:	84 30       	cpi	r24, 0x04	; 4
    6582:	09 f0       	breq	.+2      	; 0x6586 <MS_Device_USBTask+0x1c>
    6584:	10 c1       	rjmp	.+544    	; 0x67a6 <MS_Device_USBTask+0x23c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6586:	f8 01       	movw	r30, r16
    6588:	86 81       	ldd	r24, Z+6	; 0x06
    658a:	8f 70       	andi	r24, 0x0F	; 15
    658c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6590:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    6594:	82 ff       	sbrs	r24, 2
    6596:	cd c0       	rjmp	.+410    	; 0x6732 <MS_Device_USBTask+0x1c8>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6598:	86 81       	ldd	r24, Z+6	; 0x06
    659a:	8f 70       	andi	r24, 0x0F	; 15
    659c:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);
	
	BytesProcessed = 0;
    65a0:	1a 82       	std	Y+2, r1	; 0x02
    65a2:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    65a4:	2c e0       	ldi	r18, 0x0C	; 12
    65a6:	e2 2e       	mov	r14, r18
    65a8:	f1 2c       	mov	r15, r1
    65aa:	e0 0e       	add	r14, r16
    65ac:	f1 1e       	adc	r15, r17
    65ae:	04 c0       	rjmp	.+8      	; 0x65b8 <MS_Device_USBTask+0x4e>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    65b0:	80 ad       	sts	0x60, r24
    65b2:	88 23       	and	r24, r24
    65b4:	09 f0       	breq	.+2      	; 0x65b8 <MS_Device_USBTask+0x4e>
    65b6:	bd c0       	rjmp	.+378    	; 0x6732 <MS_Device_USBTask+0x1c8>
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);
	
	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    65b8:	c7 01       	movw	r24, r14
    65ba:	6f e0       	ldi	r22, 0x0F	; 15
    65bc:	70 e0       	ldi	r23, 0x00	; 0
    65be:	ae 01       	movw	r20, r28
    65c0:	4f 5f       	subi	r20, 0xFF	; 255
    65c2:	5f 4f       	sbci	r21, 0xFF	; 255
    65c4:	0e 94 93 26 	call	0x4d26	; 0x4d26 <Endpoint_Read_Stream_LE>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    65c8:	f8 01       	movw	r30, r16
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);
	
	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    65ca:	85 30       	cpi	r24, 0x05	; 5
    65cc:	89 f3       	breq	.-30     	; 0x65b0 <MS_Device_USBTask+0x46>
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    65ce:	84 85       	ldd	r24, Z+12	; 0x0c
    65d0:	95 85       	ldd	r25, Z+13	; 0x0d
    65d2:	a6 85       	ldd	r26, Z+14	; 0x0e
    65d4:	b7 85       	ldd	r27, Z+15	; 0x0f
    65d6:	85 35       	cpi	r24, 0x55	; 85
    65d8:	f3 e5       	ldi	r31, 0x53	; 83
    65da:	9f 07       	cpc	r25, r31
    65dc:	f2 e4       	ldi	r31, 0x42	; 66
    65de:	af 07       	cpc	r26, r31
    65e0:	f3 e4       	ldi	r31, 0x43	; 67
    65e2:	bf 07       	cpc	r27, r31
    65e4:	81 f4       	brne	.+32     	; 0x6606 <MS_Device_USBTask+0x9c>
    65e6:	f8 01       	movw	r30, r16
    65e8:	91 8d       	ldd	r25, Z+25	; 0x19
    65ea:	83 85       	ldd	r24, Z+11	; 0x0b
    65ec:	98 17       	cp	r25, r24
    65ee:	58 f4       	brcc	.+22     	; 0x6606 <MS_Device_USBTask+0x9c>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    65f0:	80 8d       	ldd	r24, Z+24	; 0x18
    65f2:	90 e0       	ldi	r25, 0x00	; 0
    65f4:	8f 71       	andi	r24, 0x1F	; 31
    65f6:	90 70       	andi	r25, 0x00	; 0
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    65f8:	00 97       	sbiw	r24, 0x00	; 0
    65fa:	29 f4       	brne	.+10     	; 0x6606 <MS_Device_USBTask+0x9c>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
    65fc:	82 8d       	ldd	r24, Z+26	; 0x1a
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    65fe:	88 23       	and	r24, r24
    6600:	11 f0       	breq	.+4      	; 0x6606 <MS_Device_USBTask+0x9c>
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
    6602:	81 31       	cpi	r24, 0x11	; 17
    6604:	80 f0       	brcs	.+32     	; 0x6626 <MS_Device_USBTask+0xbc>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6606:	80 91 eb 00 	lds	r24, 0x00EB
    660a:	80 62       	ori	r24, 0x20	; 32
    660c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6610:	f8 01       	movw	r30, r16
    6612:	81 81       	ldd	r24, Z+1	; 0x01
    6614:	8f 70       	andi	r24, 0x0F	; 15
    6616:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    661a:	80 91 eb 00 	lds	r24, 0x00EB
    661e:	80 62       	ori	r24, 0x20	; 32
    6620:	80 93 eb 00 	sts	0x00EB, r24
    6624:	86 c0       	rjmp	.+268    	; 0x6732 <MS_Device_USBTask+0x1c8>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    6626:	1a 82       	std	Y+2, r1	; 0x02
    6628:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    662a:	9b e1       	ldi	r25, 0x1B	; 27
    662c:	e9 2e       	mov	r14, r25
    662e:	f1 2c       	mov	r15, r1
    6630:	e0 0e       	add	r14, r16
    6632:	f1 1e       	adc	r15, r17
    6634:	05 c0       	rjmp	.+10     	; 0x6640 <MS_Device_USBTask+0xd6>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6636:	f8 01       	movw	r30, r16
    6638:	80 ad       	sts	0x60, r24
    663a:	88 23       	and	r24, r24
    663c:	09 f0       	breq	.+2      	; 0x6640 <MS_Device_USBTask+0xd6>
    663e:	79 c0       	rjmp	.+242    	; 0x6732 <MS_Device_USBTask+0x1c8>

		return false;
	}

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6640:	f8 01       	movw	r30, r16
    6642:	62 8d       	ldd	r22, Z+26	; 0x1a
    6644:	c7 01       	movw	r24, r14
    6646:	70 e0       	ldi	r23, 0x00	; 0
    6648:	ae 01       	movw	r20, r28
    664a:	4f 5f       	subi	r20, 0xFF	; 255
    664c:	5f 4f       	sbci	r21, 0xFF	; 255
    664e:	0e 94 93 26 	call	0x4d26	; 0x4d26 <Endpoint_Read_Stream_LE>
    6652:	85 30       	cpi	r24, 0x05	; 5
    6654:	81 f3       	breq	.-32     	; 0x6636 <MS_Device_USBTask+0xcc>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6656:	80 91 e8 00 	lds	r24, 0x00E8
    665a:	8b 77       	andi	r24, 0x7B	; 123
    665c:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    6660:	f8 01       	movw	r30, r16
    6662:	80 8d       	ldd	r24, Z+24	; 0x18
    6664:	87 ff       	sbrs	r24, 7
    6666:	04 c0       	rjmp	.+8      	; 0x6670 <MS_Device_USBTask+0x106>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6668:	81 81       	ldd	r24, Z+1	; 0x01
    666a:	8f 70       	andi	r24, 0x0F	; 15
    666c:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    6670:	c8 01       	movw	r24, r16
    6672:	0e 94 cd 02 	call	0x59a	; 0x59a <CALLBACK_MS_Device_SCSICommandReceived>
	  return false;

	return true;
}

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
    6676:	91 e0       	ldi	r25, 0x01	; 1
    6678:	98 27       	eor	r25, r24
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    667a:	f8 01       	movw	r30, r16
    667c:	97 ab       	sts	0x57, r25
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    667e:	45 e5       	ldi	r20, 0x55	; 85
    6680:	53 e5       	ldi	r21, 0x53	; 83
    6682:	62 e4       	ldi	r22, 0x42	; 66
    6684:	73 e5       	ldi	r23, 0x53	; 83
    6686:	43 a7       	lds	r20, 0x73
    6688:	54 a7       	lds	r21, 0x74
    668a:	65 a7       	lds	r22, 0x75
    668c:	76 a7       	lds	r23, 0x76
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    668e:	40 89       	ldd	r20, Z+16	; 0x10
    6690:	51 89       	ldd	r21, Z+17	; 0x11
    6692:	62 89       	ldd	r22, Z+18	; 0x12
    6694:	73 89       	ldd	r23, Z+19	; 0x13
    6696:	47 a7       	lds	r20, 0x77
    6698:	50 ab       	sts	0x50, r21
    669a:	61 ab       	sts	0x51, r22
    669c:	72 ab       	sts	0x52, r23
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    669e:	44 89       	ldd	r20, Z+20	; 0x14
    66a0:	55 89       	ldd	r21, Z+21	; 0x15
    66a2:	66 89       	ldd	r22, Z+22	; 0x16
    66a4:	77 89       	ldd	r23, Z+23	; 0x17
    66a6:	43 ab       	sts	0x53, r20
    66a8:	54 ab       	sts	0x54, r21
    66aa:	65 ab       	sts	0x55, r22
    66ac:	76 ab       	sts	0x56, r23

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    66ae:	88 23       	and	r24, r24
    66b0:	51 f4       	brne	.+20     	; 0x66c6 <MS_Device_USBTask+0x15c>
    66b2:	41 15       	cp	r20, r1
    66b4:	51 05       	cpc	r21, r1
    66b6:	61 05       	cpc	r22, r1
    66b8:	71 05       	cpc	r23, r1
    66ba:	29 f0       	breq	.+10     	; 0x66c6 <MS_Device_USBTask+0x15c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    66bc:	80 91 eb 00 	lds	r24, 0x00EB
    66c0:	80 62       	ori	r24, 0x20	; 32
    66c2:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    66c6:	f8 01       	movw	r30, r16
    66c8:	86 81       	ldd	r24, Z+6	; 0x06
    66ca:	8f 70       	andi	r24, 0x0F	; 15
    66cc:	80 93 e9 00 	sts	0x00E9, r24
    66d0:	03 c0       	rjmp	.+6      	; 0x66d8 <MS_Device_USBTask+0x16e>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    66d2:	80 ad       	sts	0x60, r24
    66d4:	88 23       	and	r24, r24
    66d6:	69 f5       	brne	.+90     	; 0x6732 <MS_Device_USBTask+0x1c8>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    66d8:	80 91 eb 00 	lds	r24, 0x00EB
    66dc:	f8 01       	movw	r30, r16

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    66de:	85 fd       	sbrc	r24, 5
    66e0:	f8 cf       	rjmp	.-16     	; 0x66d2 <MS_Device_USBTask+0x168>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    66e2:	81 81       	ldd	r24, Z+1	; 0x01
    66e4:	8f 70       	andi	r24, 0x0F	; 15
    66e6:	80 93 e9 00 	sts	0x00E9, r24
    66ea:	04 c0       	rjmp	.+8      	; 0x66f4 <MS_Device_USBTask+0x18a>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    66ec:	f8 01       	movw	r30, r16
    66ee:	80 ad       	sts	0x60, r24
    66f0:	88 23       	and	r24, r24
    66f2:	f9 f4       	brne	.+62     	; 0x6732 <MS_Device_USBTask+0x1c8>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    66f4:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    66f8:	85 fd       	sbrc	r24, 5
    66fa:	f8 cf       	rjmp	.-16     	; 0x66ec <MS_Device_USBTask+0x182>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
    66fc:	1a 82       	std	Y+2, r1	; 0x02
    66fe:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6700:	8b e2       	ldi	r24, 0x2B	; 43
    6702:	e8 2e       	mov	r14, r24
    6704:	f1 2c       	mov	r15, r1
    6706:	e0 0e       	add	r14, r16
    6708:	f1 1e       	adc	r15, r17
    670a:	04 c0       	rjmp	.+8      	; 0x6714 <MS_Device_USBTask+0x1aa>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    670c:	f8 01       	movw	r30, r16
    670e:	80 ad       	sts	0x60, r24
    6710:	88 23       	and	r24, r24
    6712:	79 f4       	brne	.+30     	; 0x6732 <MS_Device_USBTask+0x1c8>
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6714:	c7 01       	movw	r24, r14
    6716:	6d e0       	ldi	r22, 0x0D	; 13
    6718:	70 e0       	ldi	r23, 0x00	; 0
    671a:	ae 01       	movw	r20, r28
    671c:	4f 5f       	subi	r20, 0xFF	; 255
    671e:	5f 4f       	sbci	r21, 0xFF	; 255
    6720:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <Endpoint_Write_Stream_LE>
    6724:	85 30       	cpi	r24, 0x05	; 5
    6726:	91 f3       	breq	.-28     	; 0x670c <MS_Device_USBTask+0x1a2>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6728:	80 91 e8 00 	lds	r24, 0x00E8
    672c:	8e 77       	andi	r24, 0x7E	; 126
    672e:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    6732:	f8 01       	movw	r30, r16
    6734:	80 ad       	sts	0x60, r24
    6736:	88 23       	and	r24, r24
    6738:	b1 f1       	breq	.+108    	; 0x67a6 <MS_Device_USBTask+0x23c>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    673a:	26 81       	ldd	r18, Z+6	; 0x06
    673c:	2f 70       	andi	r18, 0x0F	; 15
    673e:	81 e0       	ldi	r24, 0x01	; 1
    6740:	90 e0       	ldi	r25, 0x00	; 0
    6742:	ac 01       	movw	r20, r24
    6744:	02 c0       	rjmp	.+4      	; 0x674a <MS_Device_USBTask+0x1e0>
    6746:	44 0f       	add	r20, r20
    6748:	55 1f       	adc	r21, r21
    674a:	2a 95       	dec	r18
    674c:	e2 f7       	brpl	.-8      	; 0x6746 <MS_Device_USBTask+0x1dc>
    674e:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    6752:	10 92 ea 00 	sts	0x00EA, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6756:	21 81       	ldd	r18, Z+1	; 0x01
    6758:	2f 70       	andi	r18, 0x0F	; 15
    675a:	02 c0       	rjmp	.+4      	; 0x6760 <MS_Device_USBTask+0x1f6>
    675c:	88 0f       	add	r24, r24
    675e:	99 1f       	adc	r25, r25
    6760:	2a 95       	dec	r18
    6762:	e2 f7       	brpl	.-8      	; 0x675c <MS_Device_USBTask+0x1f2>
    6764:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    6768:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    676c:	86 81       	ldd	r24, Z+6	; 0x06
    676e:	8f 70       	andi	r24, 0x0F	; 15
    6770:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6774:	80 91 eb 00 	lds	r24, 0x00EB
    6778:	80 61       	ori	r24, 0x10	; 16
    677a:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    677e:	80 91 eb 00 	lds	r24, 0x00EB
    6782:	88 60       	ori	r24, 0x08	; 8
    6784:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6788:	81 81       	ldd	r24, Z+1	; 0x01
    678a:	8f 70       	andi	r24, 0x0F	; 15
    678c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6790:	80 91 eb 00 	lds	r24, 0x00EB
    6794:	80 61       	ori	r24, 0x10	; 16
    6796:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    679a:	80 91 eb 00 	lds	r24, 0x00EB
    679e:	88 60       	ori	r24, 0x08	; 8
    67a0:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    67a4:	10 ae       	sts	0xb0, r17
	}
}
    67a6:	0f 90       	pop	r0
    67a8:	0f 90       	pop	r0
    67aa:	df 91       	pop	r29
    67ac:	cf 91       	pop	r28
    67ae:	1f 91       	pop	r17
    67b0:	0f 91       	pop	r16
    67b2:	ff 90       	pop	r15
    67b4:	ef 90       	pop	r14
    67b6:	08 95       	ret

000067b8 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    67b8:	0f 93       	push	r16
    67ba:	1f 93       	push	r17
    67bc:	cf 93       	push	r28
    67be:	df 93       	push	r29
    67c0:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    67c2:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    67c6:	83 ff       	sbrs	r24, 3
    67c8:	c7 c2       	rjmp	.+1422   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    67ca:	88 81       	ld	r24, Y
    67cc:	90 e0       	ldi	r25, 0x00	; 0
    67ce:	20 91 d4 0d 	lds	r18, 0x0DD4
    67d2:	30 91 d5 0d 	lds	r19, 0x0DD5
    67d6:	28 17       	cp	r18, r24
    67d8:	39 07       	cpc	r19, r25
    67da:	09 f0       	breq	.+2      	; 0x67de <RNDIS_Device_ProcessControlRequest+0x26>
    67dc:	bd c2       	rjmp	.+1402   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
	  return;

	switch (USB_ControlRequest.bRequest)
    67de:	80 91 d1 0d 	lds	r24, 0x0DD1
    67e2:	88 23       	and	r24, r24
    67e4:	21 f0       	breq	.+8      	; 0x67ee <RNDIS_Device_ProcessControlRequest+0x36>
    67e6:	81 30       	cpi	r24, 0x01	; 1
    67e8:	09 f0       	breq	.+2      	; 0x67ec <RNDIS_Device_ProcessControlRequest+0x34>
    67ea:	b6 c2       	rjmp	.+1388   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    67ec:	70 c2       	rjmp	.+1248   	; 0x6cce <RNDIS_Device_ProcessControlRequest+0x516>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    67ee:	80 91 d0 0d 	lds	r24, 0x0DD0
    67f2:	81 32       	cpi	r24, 0x21	; 33
    67f4:	09 f0       	breq	.+2      	; 0x67f8 <RNDIS_Device_ProcessControlRequest+0x40>
    67f6:	b0 c2       	rjmp	.+1376   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    67f8:	80 91 e8 00 	lds	r24, 0x00E8
    67fc:	87 7f       	andi	r24, 0xF7	; 247
    67fe:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    6802:	60 91 d6 0d 	lds	r22, 0x0DD6
    6806:	70 91 d7 0d 	lds	r23, 0x0DD7
    680a:	ce 01       	movw	r24, r28
    680c:	48 96       	adiw	r24, 0x18	; 24
    680e:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6812:	80 91 e8 00 	lds	r24, 0x00E8
    6816:	8e 77       	andi	r24, 0x7E	; 126
    6818:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    681c:	88 8d       	ldd	r24, Y+24	; 0x18
    681e:	99 8d       	ldd	r25, Y+25	; 0x19
    6820:	aa 8d       	ldd	r26, Y+26	; 0x1a
    6822:	bb 8d       	ldd	r27, Y+27	; 0x1b
    6824:	84 30       	cpi	r24, 0x04	; 4
    6826:	91 05       	cpc	r25, r1
    6828:	a1 05       	cpc	r26, r1
    682a:	b1 05       	cpc	r27, r1
    682c:	09 f4       	brne	.+2      	; 0x6830 <RNDIS_Device_ProcessControlRequest+0x78>
    682e:	82 c0       	rjmp	.+260    	; 0x6934 <RNDIS_Device_ProcessControlRequest+0x17c>
    6830:	85 30       	cpi	r24, 0x05	; 5
    6832:	91 05       	cpc	r25, r1
    6834:	a1 05       	cpc	r26, r1
    6836:	b1 05       	cpc	r27, r1
    6838:	60 f4       	brcc	.+24     	; 0x6852 <RNDIS_Device_ProcessControlRequest+0x9a>
    683a:	82 30       	cpi	r24, 0x02	; 2
    683c:	91 05       	cpc	r25, r1
    683e:	a1 05       	cpc	r26, r1
    6840:	b1 05       	cpc	r27, r1
    6842:	d1 f0       	breq	.+52     	; 0x6878 <RNDIS_Device_ProcessControlRequest+0xc0>
    6844:	83 30       	cpi	r24, 0x03	; 3
    6846:	91 05       	cpc	r25, r1
    6848:	a1 05       	cpc	r26, r1
    684a:	b1 05       	cpc	r27, r1
    684c:	09 f0       	breq	.+2      	; 0x6850 <RNDIS_Device_ProcessControlRequest+0x98>
    684e:	84 c2       	rjmp	.+1288   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6850:	65 c0       	rjmp	.+202    	; 0x691c <RNDIS_Device_ProcessControlRequest+0x164>
    6852:	86 30       	cpi	r24, 0x06	; 6
    6854:	91 05       	cpc	r25, r1
    6856:	a1 05       	cpc	r26, r1
    6858:	b1 05       	cpc	r27, r1
    685a:	09 f4       	brne	.+2      	; 0x685e <RNDIS_Device_ProcessControlRequest+0xa6>
    685c:	04 c2       	rjmp	.+1032   	; 0x6c66 <RNDIS_Device_ProcessControlRequest+0x4ae>
    685e:	86 30       	cpi	r24, 0x06	; 6
    6860:	91 05       	cpc	r25, r1
    6862:	a1 05       	cpc	r26, r1
    6864:	b1 05       	cpc	r27, r1
    6866:	08 f4       	brcc	.+2      	; 0x686a <RNDIS_Device_ProcessControlRequest+0xb2>
    6868:	aa c1       	rjmp	.+852    	; 0x6bbe <RNDIS_Device_ProcessControlRequest+0x406>
    686a:	88 30       	cpi	r24, 0x08	; 8
    686c:	91 05       	cpc	r25, r1
    686e:	a1 05       	cpc	r26, r1
    6870:	b1 05       	cpc	r27, r1
    6872:	09 f0       	breq	.+2      	; 0x6876 <RNDIS_Device_ProcessControlRequest+0xbe>
    6874:	71 c2       	rjmp	.+1250   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6876:	11 c2       	rjmp	.+1058   	; 0x6c9a <RNDIS_Device_ProcessControlRequest+0x4e2>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6878:	fe 01       	movw	r30, r28
    687a:	e8 56       	subi	r30, 0x68	; 104
    687c:	ff 4f       	sbci	r31, 0xFF	; 255
    687e:	21 e0       	ldi	r18, 0x01	; 1
    6880:	20 83       	st	Z, r18
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    6882:	82 e0       	ldi	r24, 0x02	; 2
    6884:	90 e0       	ldi	r25, 0x00	; 0
    6886:	a0 e0       	ldi	r26, 0x00	; 0
    6888:	b0 e8       	ldi	r27, 0x80	; 128
    688a:	88 8f       	std	Y+24, r24	; 0x18
    688c:	99 8f       	std	Y+25, r25	; 0x19
    688e:	aa 8f       	std	Y+26, r26	; 0x1a
    6890:	bb 8f       	std	Y+27, r27	; 0x1b
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    6892:	84 e3       	ldi	r24, 0x34	; 52
    6894:	90 e0       	ldi	r25, 0x00	; 0
    6896:	a0 e0       	ldi	r26, 0x00	; 0
    6898:	b0 e0       	ldi	r27, 0x00	; 0
    689a:	8c 8f       	std	Y+28, r24	; 0x1c
    689c:	9d 8f       	std	Y+29, r25	; 0x1d
    689e:	ae 8f       	std	Y+30, r26	; 0x1e
    68a0:	bf 8f       	std	Y+31, r27	; 0x1f
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    68a2:	1c a2       	lds	r17, 0x9c
    68a4:	1d a2       	lds	r17, 0x9d
    68a6:	1e a2       	lds	r17, 0x9e
    68a8:	1f a2       	lds	r17, 0x9f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    68aa:	81 e0       	ldi	r24, 0x01	; 1
    68ac:	90 e0       	ldi	r25, 0x00	; 0
    68ae:	a0 e0       	ldi	r26, 0x00	; 0
    68b0:	b0 e0       	ldi	r27, 0x00	; 0
    68b2:	88 a7       	lds	r24, 0x78
    68b4:	99 a7       	lds	r25, 0x79
    68b6:	aa a7       	lds	r26, 0x7a
    68b8:	bb a7       	lds	r27, 0x7b
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    68ba:	1c a6       	lds	r17, 0xbc
    68bc:	1d a6       	lds	r17, 0xbd
    68be:	1e a6       	lds	r17, 0xbe
    68c0:	1f a6       	lds	r17, 0xbf
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    68c2:	88 ab       	sts	0x58, r24
    68c4:	99 ab       	sts	0x59, r25
    68c6:	aa ab       	sts	0x5a, r26
    68c8:	bb ab       	sts	0x5b, r27
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    68ca:	1c aa       	sts	0x9c, r17
    68cc:	1d aa       	sts	0x9d, r17
    68ce:	1e aa       	sts	0x9e, r17
    68d0:	1f aa       	sts	0x9f, r17
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    68d2:	88 af       	sts	0x78, r24
    68d4:	99 af       	sts	0x79, r25
    68d6:	aa af       	sts	0x7a, r26
    68d8:	bb af       	sts	0x7b, r27
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    68da:	88 e0       	ldi	r24, 0x08	; 8
    68dc:	96 e0       	ldi	r25, 0x06	; 6
    68de:	a0 e0       	ldi	r26, 0x00	; 0
    68e0:	b0 e0       	ldi	r27, 0x00	; 0
    68e2:	8c af       	sts	0x7c, r24
    68e4:	9d af       	sts	0x7d, r25
    68e6:	ae af       	sts	0x7e, r26
    68e8:	bf af       	sts	0x7f, r27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    68ea:	fe 01       	movw	r30, r28
    68ec:	e0 5c       	subi	r30, 0xC0	; 192
    68ee:	ff 4f       	sbci	r31, 0xFF	; 255
    68f0:	10 82       	st	Z, r1
    68f2:	11 82       	std	Z+1, r1	; 0x01
    68f4:	12 82       	std	Z+2, r1	; 0x02
    68f6:	13 82       	std	Z+3, r1	; 0x03
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    68f8:	fe 01       	movw	r30, r28
    68fa:	ec 5b       	subi	r30, 0xBC	; 188
    68fc:	ff 4f       	sbci	r31, 0xFF	; 255
    68fe:	10 82       	st	Z, r1
    6900:	11 82       	std	Z+1, r1	; 0x01
    6902:	12 82       	std	Z+2, r1	; 0x02
    6904:	13 82       	std	Z+3, r1	; 0x03
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    6906:	fe 01       	movw	r30, r28
    6908:	e8 5b       	subi	r30, 0xB8	; 184
    690a:	ff 4f       	sbci	r31, 0xFF	; 255
    690c:	10 82       	st	Z, r1
    690e:	11 82       	std	Z+1, r1	; 0x01
    6910:	12 82       	std	Z+2, r1	; 0x02
    6912:	13 82       	std	Z+3, r1	; 0x03

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    6914:	c7 56       	subi	r28, 0x67	; 103
    6916:	df 4f       	sbci	r29, 0xFF	; 255
    6918:	28 83       	st	Y, r18
    691a:	1e c2       	rjmp	.+1084   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    691c:	fe 01       	movw	r30, r28
    691e:	e8 56       	subi	r30, 0x68	; 104
    6920:	ff 4f       	sbci	r31, 0xFF	; 255
    6922:	10 82       	st	Z, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    6924:	1c 8e       	std	Y+28, r1	; 0x1c
    6926:	1d 8e       	std	Y+29, r1	; 0x1d
    6928:	1e 8e       	std	Y+30, r1	; 0x1e
    692a:	1f 8e       	std	Y+31, r1	; 0x1f

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    692c:	c7 56       	subi	r28, 0x67	; 103
    692e:	df 4f       	sbci	r29, 0xFF	; 255
    6930:	18 82       	st	Y, r1
    6932:	12 c2       	rjmp	.+1060   	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6934:	fe 01       	movw	r30, r28
    6936:	e8 56       	subi	r30, 0x68	; 104
    6938:	ff 4f       	sbci	r31, 0xFF	; 255
    693a:	81 e0       	ldi	r24, 0x01	; 1
    693c:	80 83       	st	Z, r24

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    693e:	8c a1       	lds	r24, 0x4c
    6940:	9d a1       	lds	r25, 0x4d
    6942:	ae a1       	lds	r26, 0x4e
    6944:	bf a1       	lds	r27, 0x4f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    6946:	9e 01       	movw	r18, r28
    6948:	20 5d       	subi	r18, 0xD0	; 208
    694a:	3f 4f       	sbci	r19, 0xFF	; 255
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    694c:	44 e0       	ldi	r20, 0x04	; 4
    694e:	50 e0       	ldi	r21, 0x00	; 0
    6950:	60 e0       	ldi	r22, 0x00	; 0
    6952:	70 e8       	ldi	r23, 0x80	; 128
    6954:	48 8f       	std	Y+24, r20	; 0x18
    6956:	59 8f       	std	Y+25, r21	; 0x19
    6958:	6a 8f       	std	Y+26, r22	; 0x1a
    695a:	7b 8f       	std	Y+27, r23	; 0x1b
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    695c:	8e 30       	cpi	r24, 0x0E	; 14
    695e:	41 e0       	ldi	r20, 0x01	; 1
    6960:	94 07       	cpc	r25, r20
    6962:	41 e0       	ldi	r20, 0x01	; 1
    6964:	a4 07       	cpc	r26, r20
    6966:	40 e0       	ldi	r20, 0x00	; 0
    6968:	b4 07       	cpc	r27, r20
    696a:	09 f4       	brne	.+2      	; 0x696e <RNDIS_Device_ProcessControlRequest+0x1b6>
    696c:	f7 c0       	rjmp	.+494    	; 0x6b5c <RNDIS_Device_ProcessControlRequest+0x3a4>
    696e:	8f 30       	cpi	r24, 0x0F	; 15
    6970:	e1 e0       	ldi	r30, 0x01	; 1
    6972:	9e 07       	cpc	r25, r30
    6974:	e1 e0       	ldi	r30, 0x01	; 1
    6976:	ae 07       	cpc	r26, r30
    6978:	e0 e0       	ldi	r30, 0x00	; 0
    697a:	be 07       	cpc	r27, r30
    697c:	08 f0       	brcs	.+2      	; 0x6980 <RNDIS_Device_ProcessControlRequest+0x1c8>
    697e:	64 c0       	rjmp	.+200    	; 0x6a48 <RNDIS_Device_ProcessControlRequest+0x290>
    6980:	86 30       	cpi	r24, 0x06	; 6
    6982:	f1 e0       	ldi	r31, 0x01	; 1
    6984:	9f 07       	cpc	r25, r31
    6986:	f1 e0       	ldi	r31, 0x01	; 1
    6988:	af 07       	cpc	r26, r31
    698a:	f0 e0       	ldi	r31, 0x00	; 0
    698c:	bf 07       	cpc	r27, r31
    698e:	09 f4       	brne	.+2      	; 0x6992 <RNDIS_Device_ProcessControlRequest+0x1da>
    6990:	bd c0       	rjmp	.+378    	; 0x6b0c <RNDIS_Device_ProcessControlRequest+0x354>
    6992:	87 30       	cpi	r24, 0x07	; 7
    6994:	41 e0       	ldi	r20, 0x01	; 1
    6996:	94 07       	cpc	r25, r20
    6998:	41 e0       	ldi	r20, 0x01	; 1
    699a:	a4 07       	cpc	r26, r20
    699c:	40 e0       	ldi	r20, 0x00	; 0
    699e:	b4 07       	cpc	r27, r20
    69a0:	28 f5       	brcc	.+74     	; 0x69ec <RNDIS_Device_ProcessControlRequest+0x234>
    69a2:	82 30       	cpi	r24, 0x02	; 2
    69a4:	e1 e0       	ldi	r30, 0x01	; 1
    69a6:	9e 07       	cpc	r25, r30
    69a8:	e1 e0       	ldi	r30, 0x01	; 1
    69aa:	ae 07       	cpc	r26, r30
    69ac:	e0 e0       	ldi	r30, 0x00	; 0
    69ae:	be 07       	cpc	r27, r30
    69b0:	09 f4       	brne	.+2      	; 0x69b4 <RNDIS_Device_ProcessControlRequest+0x1fc>
    69b2:	dc c0       	rjmp	.+440    	; 0x6b6c <RNDIS_Device_ProcessControlRequest+0x3b4>
    69b4:	83 30       	cpi	r24, 0x03	; 3
    69b6:	f1 e0       	ldi	r31, 0x01	; 1
    69b8:	9f 07       	cpc	r25, r31
    69ba:	f1 e0       	ldi	r31, 0x01	; 1
    69bc:	af 07       	cpc	r26, r31
    69be:	f0 e0       	ldi	r31, 0x00	; 0
    69c0:	bf 07       	cpc	r27, r31
    69c2:	50 f4       	brcc	.+20     	; 0x69d8 <RNDIS_Device_ProcessControlRequest+0x220>
    69c4:	81 30       	cpi	r24, 0x01	; 1
    69c6:	41 e0       	ldi	r20, 0x01	; 1
    69c8:	94 07       	cpc	r25, r20
    69ca:	41 e0       	ldi	r20, 0x01	; 1
    69cc:	a4 07       	cpc	r26, r20
    69ce:	40 e0       	ldi	r20, 0x00	; 0
    69d0:	b4 07       	cpc	r27, r20
    69d2:	09 f0       	breq	.+2      	; 0x69d6 <RNDIS_Device_ProcessControlRequest+0x21e>
    69d4:	db c0       	rjmp	.+438    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    69d6:	8c c0       	rjmp	.+280    	; 0x6af0 <RNDIS_Device_ProcessControlRequest+0x338>
    69d8:	85 30       	cpi	r24, 0x05	; 5
    69da:	e1 e0       	ldi	r30, 0x01	; 1
    69dc:	9e 07       	cpc	r25, r30
    69de:	e1 e0       	ldi	r30, 0x01	; 1
    69e0:	ae 07       	cpc	r26, r30
    69e2:	e0 e0       	ldi	r30, 0x00	; 0
    69e4:	be 07       	cpc	r27, r30
    69e6:	08 f0       	brcs	.+2      	; 0x69ea <RNDIS_Device_ProcessControlRequest+0x232>
    69e8:	d1 c0       	rjmp	.+418    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    69ea:	c0 c0       	rjmp	.+384    	; 0x6b6c <RNDIS_Device_ProcessControlRequest+0x3b4>
    69ec:	8c 30       	cpi	r24, 0x0C	; 12
    69ee:	f1 e0       	ldi	r31, 0x01	; 1
    69f0:	9f 07       	cpc	r25, r31
    69f2:	f1 e0       	ldi	r31, 0x01	; 1
    69f4:	af 07       	cpc	r26, r31
    69f6:	f0 e0       	ldi	r31, 0x00	; 0
    69f8:	bf 07       	cpc	r27, r31
    69fa:	98 f4       	brcc	.+38     	; 0x6a22 <RNDIS_Device_ProcessControlRequest+0x26a>
    69fc:	8a 30       	cpi	r24, 0x0A	; 10
    69fe:	21 e0       	ldi	r18, 0x01	; 1
    6a00:	92 07       	cpc	r25, r18
    6a02:	21 e0       	ldi	r18, 0x01	; 1
    6a04:	a2 07       	cpc	r26, r18
    6a06:	20 e0       	ldi	r18, 0x00	; 0
    6a08:	b2 07       	cpc	r27, r18
    6a0a:	08 f0       	brcs	.+2      	; 0x6a0e <RNDIS_Device_ProcessControlRequest+0x256>
    6a0c:	7f c0       	rjmp	.+254    	; 0x6b0c <RNDIS_Device_ProcessControlRequest+0x354>
    6a0e:	87 30       	cpi	r24, 0x07	; 7
    6a10:	41 e0       	ldi	r20, 0x01	; 1
    6a12:	94 07       	cpc	r25, r20
    6a14:	41 e0       	ldi	r20, 0x01	; 1
    6a16:	a4 07       	cpc	r26, r20
    6a18:	40 e0       	ldi	r20, 0x00	; 0
    6a1a:	b4 07       	cpc	r27, r20
    6a1c:	09 f0       	breq	.+2      	; 0x6a20 <RNDIS_Device_ProcessControlRequest+0x268>
    6a1e:	b6 c0       	rjmp	.+364    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    6a20:	88 c0       	rjmp	.+272    	; 0x6b32 <RNDIS_Device_ProcessControlRequest+0x37a>
    6a22:	8c 30       	cpi	r24, 0x0C	; 12
    6a24:	e1 e0       	ldi	r30, 0x01	; 1
    6a26:	9e 07       	cpc	r25, r30
    6a28:	e1 e0       	ldi	r30, 0x01	; 1
    6a2a:	ae 07       	cpc	r26, r30
    6a2c:	e0 e0       	ldi	r30, 0x00	; 0
    6a2e:	be 07       	cpc	r27, r30
    6a30:	09 f4       	brne	.+2      	; 0x6a34 <RNDIS_Device_ProcessControlRequest+0x27c>
    6a32:	67 c0       	rjmp	.+206    	; 0x6b02 <RNDIS_Device_ProcessControlRequest+0x34a>
    6a34:	8d 30       	cpi	r24, 0x0D	; 13
    6a36:	f1 e0       	ldi	r31, 0x01	; 1
    6a38:	9f 07       	cpc	r25, r31
    6a3a:	f1 e0       	ldi	r31, 0x01	; 1
    6a3c:	af 07       	cpc	r26, r31
    6a3e:	f0 e0       	ldi	r31, 0x00	; 0
    6a40:	bf 07       	cpc	r27, r31
    6a42:	09 f0       	breq	.+2      	; 0x6a46 <RNDIS_Device_ProcessControlRequest+0x28e>
    6a44:	a3 c0       	rjmp	.+326    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    6a46:	67 c0       	rjmp	.+206    	; 0x6b16 <RNDIS_Device_ProcessControlRequest+0x35e>
    6a48:	86 30       	cpi	r24, 0x06	; 6
    6a4a:	41 e0       	ldi	r20, 0x01	; 1
    6a4c:	94 07       	cpc	r25, r20
    6a4e:	42 e0       	ldi	r20, 0x02	; 2
    6a50:	a4 07       	cpc	r26, r20
    6a52:	40 e0       	ldi	r20, 0x00	; 0
    6a54:	b4 07       	cpc	r27, r20
    6a56:	28 f5       	brcc	.+74     	; 0x6aa2 <RNDIS_Device_ProcessControlRequest+0x2ea>
    6a58:	81 30       	cpi	r24, 0x01	; 1
    6a5a:	e1 e0       	ldi	r30, 0x01	; 1
    6a5c:	9e 07       	cpc	r25, r30
    6a5e:	e2 e0       	ldi	r30, 0x02	; 2
    6a60:	ae 07       	cpc	r26, r30
    6a62:	e0 e0       	ldi	r30, 0x00	; 0
    6a64:	be 07       	cpc	r27, r30
    6a66:	08 f0       	brcs	.+2      	; 0x6a6a <RNDIS_Device_ProcessControlRequest+0x2b2>
    6a68:	81 c0       	rjmp	.+258    	; 0x6b6c <RNDIS_Device_ProcessControlRequest+0x3b4>
    6a6a:	84 31       	cpi	r24, 0x14	; 20
    6a6c:	f1 e0       	ldi	r31, 0x01	; 1
    6a6e:	9f 07       	cpc	r25, r31
    6a70:	f1 e0       	ldi	r31, 0x01	; 1
    6a72:	af 07       	cpc	r26, r31
    6a74:	f0 e0       	ldi	r31, 0x00	; 0
    6a76:	bf 07       	cpc	r27, r31
    6a78:	09 f4       	brne	.+2      	; 0x6a7c <RNDIS_Device_ProcessControlRequest+0x2c4>
    6a7a:	78 c0       	rjmp	.+240    	; 0x6b6c <RNDIS_Device_ProcessControlRequest+0x3b4>
    6a7c:	82 30       	cpi	r24, 0x02	; 2
    6a7e:	22 e0       	ldi	r18, 0x02	; 2
    6a80:	92 07       	cpc	r25, r18
    6a82:	21 e0       	ldi	r18, 0x01	; 1
    6a84:	a2 07       	cpc	r26, r18
    6a86:	20 e0       	ldi	r18, 0x00	; 0
    6a88:	b2 07       	cpc	r27, r18
    6a8a:	09 f4       	brne	.+2      	; 0x6a8e <RNDIS_Device_ProcessControlRequest+0x2d6>
    6a8c:	6f c0       	rjmp	.+222    	; 0x6b6c <RNDIS_Device_ProcessControlRequest+0x3b4>
    6a8e:	81 31       	cpi	r24, 0x11	; 17
    6a90:	41 e0       	ldi	r20, 0x01	; 1
    6a92:	94 07       	cpc	r25, r20
    6a94:	41 e0       	ldi	r20, 0x01	; 1
    6a96:	a4 07       	cpc	r26, r20
    6a98:	40 e0       	ldi	r20, 0x00	; 0
    6a9a:	b4 07       	cpc	r27, r20
    6a9c:	09 f0       	breq	.+2      	; 0x6aa0 <RNDIS_Device_ProcessControlRequest+0x2e8>
    6a9e:	76 c0       	rjmp	.+236    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    6aa0:	6a c0       	rjmp	.+212    	; 0x6b76 <RNDIS_Device_ProcessControlRequest+0x3be>
    6aa2:	84 30       	cpi	r24, 0x04	; 4
    6aa4:	e1 e0       	ldi	r30, 0x01	; 1
    6aa6:	9e 07       	cpc	r25, r30
    6aa8:	e1 e0       	ldi	r30, 0x01	; 1
    6aaa:	ae 07       	cpc	r26, r30
    6aac:	e1 e0       	ldi	r30, 0x01	; 1
    6aae:	be 07       	cpc	r27, r30
    6ab0:	09 f4       	brne	.+2      	; 0x6ab4 <RNDIS_Device_ProcessControlRequest+0x2fc>
    6ab2:	4f c0       	rjmp	.+158    	; 0x6b52 <RNDIS_Device_ProcessControlRequest+0x39a>
    6ab4:	85 30       	cpi	r24, 0x05	; 5
    6ab6:	f1 e0       	ldi	r31, 0x01	; 1
    6ab8:	9f 07       	cpc	r25, r31
    6aba:	f1 e0       	ldi	r31, 0x01	; 1
    6abc:	af 07       	cpc	r26, r31
    6abe:	f1 e0       	ldi	r31, 0x01	; 1
    6ac0:	bf 07       	cpc	r27, r31
    6ac2:	58 f4       	brcc	.+22     	; 0x6ada <RNDIS_Device_ProcessControlRequest+0x322>
    6ac4:	81 50       	subi	r24, 0x01	; 1
    6ac6:	91 40       	sbci	r25, 0x01	; 1
    6ac8:	a1 40       	sbci	r26, 0x01	; 1
    6aca:	b1 40       	sbci	r27, 0x01	; 1
    6acc:	82 30       	cpi	r24, 0x02	; 2
    6ace:	91 05       	cpc	r25, r1
    6ad0:	a1 05       	cpc	r26, r1
    6ad2:	b1 05       	cpc	r27, r1
    6ad4:	08 f0       	brcs	.+2      	; 0x6ad8 <RNDIS_Device_ProcessControlRequest+0x320>
    6ad6:	5a c0       	rjmp	.+180    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    6ad8:	31 c0       	rjmp	.+98     	; 0x6b3c <RNDIS_Device_ProcessControlRequest+0x384>
    6ada:	81 50       	subi	r24, 0x01	; 1
    6adc:	91 40       	sbci	r25, 0x01	; 1
    6ade:	a2 40       	sbci	r26, 0x02	; 2
    6ae0:	b1 40       	sbci	r27, 0x01	; 1
    6ae2:	83 30       	cpi	r24, 0x03	; 3
    6ae4:	91 05       	cpc	r25, r1
    6ae6:	a1 05       	cpc	r26, r1
    6ae8:	b1 05       	cpc	r27, r1
    6aea:	08 f0       	brcs	.+2      	; 0x6aee <RNDIS_Device_ProcessControlRequest+0x336>
    6aec:	4f c0       	rjmp	.+158    	; 0x6b8c <RNDIS_Device_ProcessControlRequest+0x3d4>
    6aee:	3e c0       	rjmp	.+124    	; 0x6b6c <RNDIS_Device_ProcessControlRequest+0x3b4>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    6af0:	c9 01       	movw	r24, r18
    6af2:	63 ea       	ldi	r22, 0xA3	; 163
    6af4:	73 e0       	ldi	r23, 0x03	; 3
    6af6:	4c e6       	ldi	r20, 0x6C	; 108
    6af8:	50 e0       	ldi	r21, 0x00	; 0
    6afa:	c0 d6       	rcall	.+3456   	; 0x787c <memcpy_P>
    6afc:	0c e6       	ldi	r16, 0x6C	; 108
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    6afe:	10 e0       	ldi	r17, 0x00	; 0
    6b00:	11 c1       	rjmp	.+546    	; 0x6d24 <RNDIS_Device_ProcessControlRequest+0x56c>
    6b02:	8f ef       	ldi	r24, 0xFF	; 255
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    6b04:	9f ef       	ldi	r25, 0xFF	; 255
    6b06:	af ef       	ldi	r26, 0xFF	; 255
    6b08:	b0 e0       	ldi	r27, 0x00	; 0
    6b0a:	39 c0       	rjmp	.+114    	; 0x6b7e <RNDIS_Device_ProcessControlRequest+0x3c6>
    6b0c:	8c ed       	ldi	r24, 0xDC	; 220
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    6b0e:	95 e0       	ldi	r25, 0x05	; 5
    6b10:	a0 e0       	ldi	r26, 0x00	; 0
    6b12:	b0 e0       	ldi	r27, 0x00	; 0
    6b14:	34 c0       	rjmp	.+104    	; 0x6b7e <RNDIS_Device_ProcessControlRequest+0x3c6>
    6b16:	68 89       	ldd	r22, Y+16	; 0x10

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    6b18:	79 89       	ldd	r23, Y+17	; 0x11
    6b1a:	fb 01       	movw	r30, r22
    6b1c:	df 01       	movw	r26, r30
    6b1e:	0d 90       	ld	r0, X+
    6b20:	00 20       	and	r0, r0
    6b22:	e9 f7       	brne	.-6      	; 0x6b1e <RNDIS_Device_ProcessControlRequest+0x366>
    6b24:	8d 01       	movw	r16, r26
    6b26:	0e 1b       	sub	r16, r30
    6b28:	1f 0b       	sbc	r17, r31
    6b2a:	c9 01       	movw	r24, r18

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    6b2c:	a8 01       	movw	r20, r16
    6b2e:	e1 d6       	rcall	.+3522   	; 0x78f2 <memcpy>
    6b30:	f9 c0       	rjmp	.+498    	; 0x6d24 <RNDIS_Device_ProcessControlRequest+0x56c>
    6b32:	80 ea       	ldi	r24, 0xA0	; 160
    6b34:	96 e8       	ldi	r25, 0x86	; 134
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    6b36:	a1 e0       	ldi	r26, 0x01	; 1
    6b38:	b0 e0       	ldi	r27, 0x00	; 0
    6b3a:	21 c0       	rjmp	.+66     	; 0x6b7e <RNDIS_Device_ProcessControlRequest+0x3c6>
    6b3c:	d9 01       	movw	r26, r18
    6b3e:	fe 01       	movw	r30, r28
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    6b40:	72 96       	adiw	r30, 0x12	; 18
    6b42:	86 e0       	ldi	r24, 0x06	; 6
    6b44:	01 90       	ld	r0, Z+
    6b46:	0d 92       	st	X+, r0
    6b48:	81 50       	subi	r24, 0x01	; 1
    6b4a:	e1 f7       	brne	.-8      	; 0x6b44 <RNDIS_Device_ProcessControlRequest+0x38c>
    6b4c:	06 e0       	ldi	r16, 0x06	; 6
    6b4e:	10 e0       	ldi	r17, 0x00	; 0
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    6b50:	e9 c0       	rjmp	.+466    	; 0x6d24 <RNDIS_Device_ProcessControlRequest+0x56c>
    6b52:	81 e0       	ldi	r24, 0x01	; 1
    6b54:	90 e0       	ldi	r25, 0x00	; 0
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    6b56:	a0 e0       	ldi	r26, 0x00	; 0
    6b58:	b0 e0       	ldi	r27, 0x00	; 0
    6b5a:	11 c0       	rjmp	.+34     	; 0x6b7e <RNDIS_Device_ProcessControlRequest+0x3c6>
    6b5c:	fe 01       	movw	r30, r28
    6b5e:	e6 56       	subi	r30, 0x66	; 102

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    6b60:	ff 4f       	sbci	r31, 0xFF	; 255
    6b62:	80 81       	ld	r24, Z
    6b64:	91 81       	ldd	r25, Z+1	; 0x01
    6b66:	a2 81       	ldd	r26, Z+2	; 0x02
    6b68:	b3 81       	ldd	r27, Z+3	; 0x03
    6b6a:	09 c0       	rjmp	.+18     	; 0x6b7e <RNDIS_Device_ProcessControlRequest+0x3c6>
    6b6c:	18 aa       	sts	0x98, r17
    6b6e:	19 aa       	sts	0x99, r17
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    6b70:	1a aa       	sts	0x9a, r17
    6b72:	1b aa       	sts	0x9b, r17
    6b74:	08 c0       	rjmp	.+16     	; 0x6b86 <RNDIS_Device_ProcessControlRequest+0x3ce>
    6b76:	8c e5       	ldi	r24, 0x5C	; 92
    6b78:	96 e0       	ldi	r25, 0x06	; 6
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    6b7a:	a0 e0       	ldi	r26, 0x00	; 0
    6b7c:	b0 e0       	ldi	r27, 0x00	; 0
    6b7e:	88 ab       	sts	0x58, r24
    6b80:	99 ab       	sts	0x59, r25
    6b82:	aa ab       	sts	0x5a, r26
    6b84:	bb ab       	sts	0x5b, r27
    6b86:	04 e0       	ldi	r16, 0x04	; 4
    6b88:	10 e0       	ldi	r17, 0x00	; 0
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    6b8a:	cc c0       	rjmp	.+408    	; 0x6d24 <RNDIS_Device_ProcessControlRequest+0x56c>
    6b8c:	8b eb       	ldi	r24, 0xBB	; 187
    6b8e:	90 e0       	ldi	r25, 0x00	; 0
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    6b90:	a0 e0       	ldi	r26, 0x00	; 0
    6b92:	b0 ec       	ldi	r27, 0xC0	; 192
    6b94:	8c a3       	lds	r24, 0x5c
    6b96:	9d a3       	lds	r25, 0x5d
    6b98:	ae a3       	lds	r26, 0x5e
    6b9a:	bf a3       	lds	r27, 0x5f
    6b9c:	88 e1       	ldi	r24, 0x18	; 24
    6b9e:	90 e0       	ldi	r25, 0x00	; 0
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    6ba0:	a0 e0       	ldi	r26, 0x00	; 0
    6ba2:	b0 e0       	ldi	r27, 0x00	; 0
    6ba4:	8c 8f       	std	Y+28, r24	; 0x1c
    6ba6:	9d 8f       	std	Y+29, r25	; 0x1d
    6ba8:	ae 8f       	std	Y+30, r26	; 0x1e
    6baa:	bf 8f       	std	Y+31, r27	; 0x1f
    6bac:	18 a6       	lds	r17, 0xb8
    6bae:	19 a6       	lds	r17, 0xb9

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    6bb0:	1a a6       	lds	r17, 0xba
    6bb2:	1b a6       	lds	r17, 0xbb
    6bb4:	1c a6       	lds	r17, 0xbc
    6bb6:	1d a6       	lds	r17, 0xbd
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    6bb8:	1e a6       	lds	r17, 0xbe
    6bba:	1f a6       	lds	r17, 0xbf
    6bbc:	cd c0       	rjmp	.+410    	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6bbe:	fe 01       	movw	r30, r28
    6bc0:	e8 56       	subi	r30, 0x68	; 104
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6bc2:	ff 4f       	sbci	r31, 0xFF	; 255
    6bc4:	81 e0       	ldi	r24, 0x01	; 1
    6bc6:	80 83       	st	Z, r24
    6bc8:	8c a1       	lds	r24, 0x4c
    6bca:	9d a1       	lds	r25, 0x4d

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    6bcc:	ae a1       	lds	r26, 0x4e
    6bce:	bf a1       	lds	r27, 0x4f
    6bd0:	45 e0       	ldi	r20, 0x05	; 5
    6bd2:	50 e0       	ldi	r21, 0x00	; 0

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    6bd4:	60 e0       	ldi	r22, 0x00	; 0
    6bd6:	70 e8       	ldi	r23, 0x80	; 128
    6bd8:	48 8f       	std	Y+24, r20	; 0x18
    6bda:	59 8f       	std	Y+25, r21	; 0x19
    6bdc:	6a 8f       	std	Y+26, r22	; 0x1a
    6bde:	7b 8f       	std	Y+27, r23	; 0x1b
    6be0:	40 e1       	ldi	r20, 0x10	; 16
    6be2:	50 e0       	ldi	r21, 0x00	; 0
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    6be4:	60 e0       	ldi	r22, 0x00	; 0
    6be6:	70 e0       	ldi	r23, 0x00	; 0
    6be8:	4c 8f       	std	Y+28, r20	; 0x1c
    6bea:	5d 8f       	std	Y+29, r21	; 0x1d
    6bec:	6e 8f       	std	Y+30, r22	; 0x1e
    6bee:	7f 8f       	std	Y+31, r23	; 0x1f
    6bf0:	4c a5       	lds	r20, 0x6c
    6bf2:	5d a5       	lds	r21, 0x6d
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    6bf4:	6e a5       	lds	r22, 0x6e
    6bf6:	7f a5       	lds	r23, 0x6f
    6bf8:	8e 30       	cpi	r24, 0x0E	; 14
    6bfa:	e1 e0       	ldi	r30, 0x01	; 1
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    6bfc:	9e 07       	cpc	r25, r30
    6bfe:	e1 e0       	ldi	r30, 0x01	; 1
    6c00:	ae 07       	cpc	r26, r30
    6c02:	e0 e0       	ldi	r30, 0x00	; 0
    6c04:	be 07       	cpc	r27, r30
    6c06:	49 f0       	breq	.+18     	; 0x6c1a <RNDIS_Device_ProcessControlRequest+0x462>
    6c08:	83 30       	cpi	r24, 0x03	; 3
    6c0a:	f1 e0       	ldi	r31, 0x01	; 1
    6c0c:	9f 07       	cpc	r25, r31
    6c0e:	f1 e0       	ldi	r31, 0x01	; 1
    6c10:	af 07       	cpc	r26, r31
    6c12:	f1 e0       	ldi	r31, 0x01	; 1
    6c14:	bf 07       	cpc	r27, r31
    6c16:	f1 f4       	brne	.+60     	; 0x6c54 <RNDIS_Device_ProcessControlRequest+0x49c>
    6c18:	19 c0       	rjmp	.+50     	; 0x6c4c <RNDIS_Device_ProcessControlRequest+0x494>
    6c1a:	4c 0f       	add	r20, r28
    6c1c:	5d 1f       	adc	r21, r29
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    6c1e:	fa 01       	movw	r30, r20
    6c20:	80 a1       	lds	r24, 0x40
    6c22:	91 a1       	lds	r25, 0x41
    6c24:	a2 a1       	lds	r26, 0x42
    6c26:	b3 a1       	lds	r27, 0x43
    6c28:	fe 01       	movw	r30, r28
    6c2a:	e6 56       	subi	r30, 0x66	; 102
    6c2c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c2e:	80 83       	st	Z, r24
    6c30:	91 83       	std	Z+1, r25	; 0x01
    6c32:	a2 83       	std	Z+2, r26	; 0x02
    6c34:	b3 83       	std	Z+3, r27	; 0x03
    6c36:	00 97       	sbiw	r24, 0x00	; 0
    6c38:	a1 05       	cpc	r26, r1
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    6c3a:	b1 05       	cpc	r27, r1
    6c3c:	11 f0       	breq	.+4      	; 0x6c42 <RNDIS_Device_ProcessControlRequest+0x48a>
    6c3e:	82 e0       	ldi	r24, 0x02	; 2
    6c40:	01 c0       	rjmp	.+2      	; 0x6c44 <RNDIS_Device_ProcessControlRequest+0x48c>
    6c42:	81 e0       	ldi	r24, 0x01	; 1
    6c44:	fe 01       	movw	r30, r28
    6c46:	e7 56       	subi	r30, 0x67	; 103
    6c48:	ff 4f       	sbci	r31, 0xFF	; 255
    6c4a:	80 83       	st	Z, r24
    6c4c:	80 e0       	ldi	r24, 0x00	; 0
    6c4e:	90 e0       	ldi	r25, 0x00	; 0
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    6c50:	dc 01       	movw	r26, r24
    6c52:	04 c0       	rjmp	.+8      	; 0x6c5c <RNDIS_Device_ProcessControlRequest+0x4a4>
    6c54:	8b eb       	ldi	r24, 0xBB	; 187
    6c56:	90 e0       	ldi	r25, 0x00	; 0
    6c58:	a0 e0       	ldi	r26, 0x00	; 0
    6c5a:	b0 ec       	ldi	r27, 0xC0	; 192
    6c5c:	8c a3       	lds	r24, 0x5c
    6c5e:	9d a3       	lds	r25, 0x5d
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    6c60:	ae a3       	lds	r26, 0x5e
    6c62:	bf a3       	lds	r27, 0x5f
    6c64:	79 c0       	rjmp	.+242    	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6c66:	fe 01       	movw	r30, r28
    6c68:	e8 56       	subi	r30, 0x68	; 104
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6c6a:	ff 4f       	sbci	r31, 0xFF	; 255
    6c6c:	81 e0       	ldi	r24, 0x01	; 1
    6c6e:	80 83       	st	Z, r24
    6c70:	86 e0       	ldi	r24, 0x06	; 6
    6c72:	90 e0       	ldi	r25, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    6c74:	a0 e0       	ldi	r26, 0x00	; 0
    6c76:	b0 e8       	ldi	r27, 0x80	; 128
    6c78:	88 8f       	std	Y+24, r24	; 0x18
    6c7a:	99 8f       	std	Y+25, r25	; 0x19
    6c7c:	aa 8f       	std	Y+26, r26	; 0x1a
    6c7e:	bb 8f       	std	Y+27, r27	; 0x1b
    6c80:	80 e1       	ldi	r24, 0x10	; 16
    6c82:	90 e0       	ldi	r25, 0x00	; 0
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    6c84:	a0 e0       	ldi	r26, 0x00	; 0
    6c86:	b0 e0       	ldi	r27, 0x00	; 0
    6c88:	8c 8f       	std	Y+28, r24	; 0x1c
    6c8a:	9d 8f       	std	Y+29, r25	; 0x1d
    6c8c:	ae 8f       	std	Y+30, r26	; 0x1e
    6c8e:	bf 8f       	std	Y+31, r27	; 0x1f
    6c90:	18 a2       	lds	r17, 0x98
    6c92:	19 a2       	lds	r17, 0x99
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6c94:	1a a2       	lds	r17, 0x9a
    6c96:	1b a2       	lds	r17, 0x9b
    6c98:	15 c0       	rjmp	.+42     	; 0x6cc4 <RNDIS_Device_ProcessControlRequest+0x50c>
    6c9a:	fe 01       	movw	r30, r28
    6c9c:	e8 56       	subi	r30, 0x68	; 104
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6c9e:	ff 4f       	sbci	r31, 0xFF	; 255
    6ca0:	81 e0       	ldi	r24, 0x01	; 1
    6ca2:	80 83       	st	Z, r24
    6ca4:	88 e0       	ldi	r24, 0x08	; 8
    6ca6:	90 e0       	ldi	r25, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    6ca8:	a0 e0       	ldi	r26, 0x00	; 0
    6caa:	b0 e8       	ldi	r27, 0x80	; 128
    6cac:	88 8f       	std	Y+24, r24	; 0x18
    6cae:	99 8f       	std	Y+25, r25	; 0x19
    6cb0:	aa 8f       	std	Y+26, r26	; 0x1a
    6cb2:	bb 8f       	std	Y+27, r27	; 0x1b
    6cb4:	80 e1       	ldi	r24, 0x10	; 16
    6cb6:	90 e0       	ldi	r25, 0x00	; 0
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    6cb8:	a0 e0       	ldi	r26, 0x00	; 0
    6cba:	b0 e0       	ldi	r27, 0x00	; 0
    6cbc:	8c 8f       	std	Y+28, r24	; 0x1c
    6cbe:	9d 8f       	std	Y+29, r25	; 0x1d
    6cc0:	ae 8f       	std	Y+30, r26	; 0x1e
    6cc2:	bf 8f       	std	Y+31, r27	; 0x1f
    6cc4:	1c a2       	lds	r17, 0x9c
    6cc6:	1d a2       	lds	r17, 0x9d
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6cc8:	1e a2       	lds	r17, 0x9e
    6cca:	1f a2       	lds	r17, 0x9f
    6ccc:	45 c0       	rjmp	.+138    	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6cce:	80 91 d0 0d 	lds	r24, 0x0DD0
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6cd2:	81 3a       	cpi	r24, 0xA1	; 161
    6cd4:	09 f0       	breq	.+2      	; 0x6cd8 <RNDIS_Device_ProcessControlRequest+0x520>
    6cd6:	40 c0       	rjmp	.+128    	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6cd8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    6cda:	9d 8d       	ldd	r25, Y+29	; 0x1d
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

				if (!(MessageHeader->MessageLength))
    6cdc:	ae 8d       	ldd	r26, Y+30	; 0x1e
    6cde:	bf 8d       	ldd	r27, Y+31	; 0x1f
    6ce0:	00 97       	sbiw	r24, 0x00	; 0
    6ce2:	a1 05       	cpc	r26, r1
    6ce4:	b1 05       	cpc	r27, r1
    6ce6:	49 f4       	brne	.+18     	; 0x6cfa <RNDIS_Device_ProcessControlRequest+0x542>
    6ce8:	18 8e       	std	Y+24, r1	; 0x18
    6cea:	81 e0       	ldi	r24, 0x01	; 1
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    6cec:	90 e0       	ldi	r25, 0x00	; 0
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    6cee:	a0 e0       	ldi	r26, 0x00	; 0
    6cf0:	b0 e0       	ldi	r27, 0x00	; 0
    6cf2:	8c 8f       	std	Y+28, r24	; 0x1c
    6cf4:	9d 8f       	std	Y+29, r25	; 0x1d
    6cf6:	ae 8f       	std	Y+30, r26	; 0x1e
    6cf8:	bf 8f       	std	Y+31, r27	; 0x1f
    6cfa:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6cfe:	87 7f       	andi	r24, 0xF7	; 247
    6d00:	80 93 e8 00 	sts	0x00E8, r24
    6d04:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d06:	7d 8d       	ldd	r23, Y+29	; 0x1d
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    6d08:	ce 01       	movw	r24, r28
    6d0a:	48 96       	adiw	r24, 0x18	; 24
    6d0c:	0e 94 e2 26 	call	0x4dc4	; 0x4dc4 <Endpoint_Write_Control_Stream_LE>
    6d10:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6d14:	8b 77       	andi	r24, 0x7B	; 123
    6d16:	80 93 e8 00 	sts	0x00E8, r24
    6d1a:	1c 8e       	std	Y+28, r1	; 0x1c
    6d1c:	1d 8e       	std	Y+29, r1	; 0x1d
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    6d1e:	1e 8e       	std	Y+30, r1	; 0x1e
    6d20:	1f 8e       	std	Y+31, r1	; 0x1f
    6d22:	1a c0       	rjmp	.+52     	; 0x6d58 <RNDIS_Device_ProcessControlRequest+0x5a0>
    6d24:	1c a2       	lds	r17, 0x9c
    6d26:	1d a2       	lds	r17, 0x9d
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6d28:	1e a2       	lds	r17, 0x9e
    6d2a:	1f a2       	lds	r17, 0x9f
    6d2c:	c8 01       	movw	r24, r16
    6d2e:	48 96       	adiw	r24, 0x18	; 24
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    6d30:	a0 e0       	ldi	r26, 0x00	; 0
    6d32:	b0 e0       	ldi	r27, 0x00	; 0
    6d34:	8c 8f       	std	Y+28, r24	; 0x1c
    6d36:	9d 8f       	std	Y+29, r25	; 0x1d
    6d38:	ae 8f       	std	Y+30, r26	; 0x1e
    6d3a:	bf 8f       	std	Y+31, r27	; 0x1f
    6d3c:	20 e0       	ldi	r18, 0x00	; 0
    6d3e:	30 e0       	ldi	r19, 0x00	; 0

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    6d40:	08 a7       	lds	r16, 0x78
    6d42:	19 a7       	lds	r17, 0x79
    6d44:	2a a7       	lds	r18, 0x7a
    6d46:	3b a7       	lds	r19, 0x7b
    6d48:	80 e1       	ldi	r24, 0x10	; 16
    6d4a:	90 e0       	ldi	r25, 0x00	; 0
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    6d4c:	a0 e0       	ldi	r26, 0x00	; 0
    6d4e:	b0 e0       	ldi	r27, 0x00	; 0
    6d50:	8c a7       	lds	r24, 0x7c
    6d52:	9d a7       	lds	r25, 0x7d
    6d54:	ae a7       	lds	r26, 0x7e
    6d56:	bf a7       	lds	r27, 0x7f
    6d58:	df 91       	pop	r29
    6d5a:	cf 91       	pop	r28
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    6d5c:	1f 91       	pop	r17
    6d5e:	0f 91       	pop	r16
    6d60:	08 95       	ret

00006d62 <RNDIS_Device_ConfigureEndpoints>:
    6d62:	cf 93       	push	r28
    6d64:	df 93       	push	r29

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6d66:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    6d68:	48 96       	adiw	r24, 0x18	; 24
    6d6a:	fc 01       	movw	r30, r24
    6d6c:	86 e8       	ldi	r24, 0x86	; 134
    6d6e:	df 01       	movw	r26, r30
    6d70:	1d 92       	st	X+, r1
    6d72:	8a 95       	dec	r24
    6d74:	e9 f7       	brne	.-6      	; 0x6d70 <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    6d76:	82 e0       	ldi	r24, 0x02	; 2
    6d78:	8c 83       	std	Y+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    6d7a:	89 87       	std	Y+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    6d7c:	83 e0       	ldi	r24, 0x03	; 3
    6d7e:	8e 87       	std	Y+14, r24	; 0x0e

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    6d80:	ce 01       	movw	r24, r28
    6d82:	01 96       	adiw	r24, 0x01	; 1
    6d84:	61 e0       	ldi	r22, 0x01	; 1
    6d86:	0e 94 12 28 	call	0x5024	; 0x5024 <Endpoint_ConfigureEndpointTable>
    6d8a:	88 23       	and	r24, r24
    6d8c:	69 f0       	breq	.+26     	; 0x6da8 <RNDIS_Device_ConfigureEndpoints+0x46>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6d8e:	ce 01       	movw	r24, r28
    6d90:	06 96       	adiw	r24, 0x06	; 6
    6d92:	61 e0       	ldi	r22, 0x01	; 1
    6d94:	0e 94 12 28 	call	0x5024	; 0x5024 <Endpoint_ConfigureEndpointTable>
    6d98:	88 23       	and	r24, r24
    6d9a:	31 f0       	breq	.+12     	; 0x6da8 <RNDIS_Device_ConfigureEndpoints+0x46>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    6d9c:	ce 01       	movw	r24, r28
    6d9e:	0b 96       	adiw	r24, 0x0b	; 11
    6da0:	61 e0       	ldi	r22, 0x01	; 1
    6da2:	0e 94 12 28 	call	0x5024	; 0x5024 <Endpoint_ConfigureEndpointTable>
    6da6:	01 c0       	rjmp	.+2      	; 0x6daa <RNDIS_Device_ConfigureEndpoints+0x48>

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;
    6da8:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
	  return false;

	return true;
}
    6daa:	df 91       	pop	r29
    6dac:	cf 91       	pop	r28
    6dae:	08 95       	ret

00006db0 <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6db0:	0f 93       	push	r16
    6db2:	1f 93       	push	r17
    6db4:	cf 93       	push	r28
    6db6:	df 93       	push	r29
    6db8:	cd b7       	in	r28, 0x3d	; 61
    6dba:	de b7       	in	r29, 0x3e	; 62
    6dbc:	28 97       	sbiw	r28, 0x08	; 8
    6dbe:	0f b6       	in	r0, 0x3f	; 63
    6dc0:	f8 94       	cli
    6dc2:	de bf       	out	0x3e, r29	; 62
    6dc4:	0f be       	out	0x3f, r0	; 63
    6dc6:	cd bf       	out	0x3d, r28	; 61
    6dc8:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    6dca:	8e b3       	in	r24, 0x1e	; 30
    6dcc:	84 30       	cpi	r24, 0x04	; 4
    6dce:	41 f5       	brne	.+80     	; 0x6e20 <RNDIS_Device_USBTask+0x70>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6dd0:	f8 01       	movw	r30, r16
    6dd2:	83 85       	ldd	r24, Z+11	; 0x0b
    6dd4:	8f 70       	andi	r24, 0x0F	; 15
    6dd6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6dda:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    6dde:	80 ff       	sbrs	r24, 0
    6de0:	1f c0       	rjmp	.+62     	; 0x6e20 <RNDIS_Device_USBTask+0x70>
    6de2:	e8 56       	subi	r30, 0x68	; 104
    6de4:	ff 4f       	sbci	r31, 0xFF	; 255
    6de6:	80 81       	ld	r24, Z
    6de8:	88 23       	and	r24, r24
    6dea:	d1 f0       	breq	.+52     	; 0x6e20 <RNDIS_Device_USBTask+0x70>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    6dec:	de 01       	movw	r26, r28
    6dee:	11 96       	adiw	r26, 0x01	; 1
    6df0:	ee e5       	ldi	r30, 0x5E	; 94
    6df2:	f3 e0       	ldi	r31, 0x03	; 3
    6df4:	88 e0       	ldi	r24, 0x08	; 8
    6df6:	01 90       	ld	r0, Z+
    6df8:	0d 92       	st	X+, r0
    6dfa:	81 50       	subi	r24, 0x01	; 1
    6dfc:	e1 f7       	brne	.-8      	; 0x6df6 <RNDIS_Device_USBTask+0x46>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    6dfe:	ce 01       	movw	r24, r28
    6e00:	01 96       	adiw	r24, 0x01	; 1
    6e02:	68 e0       	ldi	r22, 0x08	; 8
    6e04:	70 e0       	ldi	r23, 0x00	; 0
    6e06:	40 e0       	ldi	r20, 0x00	; 0
    6e08:	50 e0       	ldi	r21, 0x00	; 0
    6e0a:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6e0e:	80 91 e8 00 	lds	r24, 0x00E8
    6e12:	8e 77       	andi	r24, 0x7E	; 126
    6e14:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    6e18:	f8 01       	movw	r30, r16
    6e1a:	e8 56       	subi	r30, 0x68	; 104
    6e1c:	ff 4f       	sbci	r31, 0xFF	; 255
    6e1e:	10 82       	st	Z, r1
	}
}
    6e20:	28 96       	adiw	r28, 0x08	; 8
    6e22:	0f b6       	in	r0, 0x3f	; 63
    6e24:	f8 94       	cli
    6e26:	de bf       	out	0x3e, r29	; 62
    6e28:	0f be       	out	0x3f, r0	; 63
    6e2a:	cd bf       	out	0x3d, r28	; 61
    6e2c:	df 91       	pop	r29
    6e2e:	cf 91       	pop	r28
    6e30:	1f 91       	pop	r17
    6e32:	0f 91       	pop	r16
    6e34:	08 95       	ret

00006e36 <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6e36:	2e b3       	in	r18, 0x1e	; 30
    6e38:	24 30       	cpi	r18, 0x04	; 4
    6e3a:	81 f4       	brne	.+32     	; 0x6e5c <RNDIS_Device_IsPacketReceived+0x26>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    6e3c:	fc 01       	movw	r30, r24
    6e3e:	e7 56       	subi	r30, 0x67	; 103
    6e40:	ff 4f       	sbci	r31, 0xFF	; 255
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6e42:	20 81       	ld	r18, Z
    6e44:	22 30       	cpi	r18, 0x02	; 2
    6e46:	61 f4       	brne	.+24     	; 0x6e60 <RNDIS_Device_IsPacketReceived+0x2a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6e48:	fc 01       	movw	r30, r24
    6e4a:	86 81       	ldd	r24, Z+6	; 0x06
    6e4c:	8f 70       	andi	r24, 0x0F	; 15
    6e4e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6e52:	90 91 e8 00 	lds	r25, 0x00E8
    6e56:	81 e0       	ldi	r24, 0x01	; 1
    6e58:	92 fd       	sbrc	r25, 2
    6e5a:	03 c0       	rjmp	.+6      	; 0x6e62 <RNDIS_Device_IsPacketReceived+0x2c>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    6e5c:	80 e0       	ldi	r24, 0x00	; 0
    6e5e:	08 95       	ret
    6e60:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    6e62:	08 95       	ret

00006e64 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    6e64:	ef 92       	push	r14
    6e66:	ff 92       	push	r15
    6e68:	0f 93       	push	r16
    6e6a:	1f 93       	push	r17
    6e6c:	cf 93       	push	r28
    6e6e:	df 93       	push	r29
    6e70:	cd b7       	in	r28, 0x3d	; 61
    6e72:	de b7       	in	r29, 0x3e	; 62
    6e74:	ac 97       	sbiw	r28, 0x2c	; 44
    6e76:	0f b6       	in	r0, 0x3f	; 63
    6e78:	f8 94       	cli
    6e7a:	de bf       	out	0x3e, r29	; 62
    6e7c:	0f be       	out	0x3f, r0	; 63
    6e7e:	cd bf       	out	0x3d, r28	; 61
    6e80:	7b 01       	movw	r14, r22
    6e82:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6e84:	2e b3       	in	r18, 0x1e	; 30
    6e86:	24 30       	cpi	r18, 0x04	; 4
    6e88:	e1 f5       	brne	.+120    	; 0x6f02 <RNDIS_Device_ReadPacket+0x9e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    6e8a:	fc 01       	movw	r30, r24
    6e8c:	e7 56       	subi	r30, 0x67	; 103
    6e8e:	ff 4f       	sbci	r31, 0xFF	; 255

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6e90:	20 81       	ld	r18, Z
    6e92:	22 30       	cpi	r18, 0x02	; 2
    6e94:	b1 f5       	brne	.+108    	; 0x6f02 <RNDIS_Device_ReadPacket+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6e96:	fc 01       	movw	r30, r24
    6e98:	86 81       	ldd	r24, Z+6	; 0x06
    6e9a:	8f 70       	andi	r24, 0x0F	; 15
    6e9c:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;
    6ea0:	fa 01       	movw	r30, r20
    6ea2:	11 82       	std	Z+1, r1	; 0x01
    6ea4:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6ea6:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    6eaa:	82 ff       	sbrs	r24, 2
    6eac:	2c c0       	rjmp	.+88     	; 0x6f06 <RNDIS_Device_ReadPacket+0xa2>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6eae:	ce 01       	movw	r24, r28
    6eb0:	01 96       	adiw	r24, 0x01	; 1
    6eb2:	6c e2       	ldi	r22, 0x2C	; 44
    6eb4:	70 e0       	ldi	r23, 0x00	; 0
    6eb6:	40 e0       	ldi	r20, 0x00	; 0
    6eb8:	50 e0       	ldi	r21, 0x00	; 0
    6eba:	0e 94 93 26 	call	0x4d26	; 0x4d26 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    6ebe:	4d 85       	ldd	r20, Y+13	; 0x0d
    6ec0:	5e 85       	ldd	r21, Y+14	; 0x0e
    6ec2:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ec4:	78 89       	ldd	r23, Y+16	; 0x10
    6ec6:	4d 3d       	cpi	r20, 0xDD	; 221
    6ec8:	f5 e0       	ldi	r31, 0x05	; 5
    6eca:	5f 07       	cpc	r21, r31
    6ecc:	f0 e0       	ldi	r31, 0x00	; 0
    6ece:	6f 07       	cpc	r22, r31
    6ed0:	f0 e0       	ldi	r31, 0x00	; 0
    6ed2:	7f 07       	cpc	r23, r31
    6ed4:	38 f0       	brcs	.+14     	; 0x6ee4 <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6ed6:	80 91 eb 00 	lds	r24, 0x00EB
    6eda:	80 62       	ori	r24, 0x20	; 32
    6edc:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    6ee0:	80 e8       	ldi	r24, 0x80	; 128
    6ee2:	12 c0       	rjmp	.+36     	; 0x6f08 <RNDIS_Device_ReadPacket+0xa4>
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    6ee4:	f8 01       	movw	r30, r16
    6ee6:	51 83       	std	Z+1, r21	; 0x01
    6ee8:	40 83       	st	Z, r20

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    6eea:	c7 01       	movw	r24, r14
    6eec:	ba 01       	movw	r22, r20
    6eee:	40 e0       	ldi	r20, 0x00	; 0
    6ef0:	50 e0       	ldi	r21, 0x00	; 0
    6ef2:	0e 94 93 26 	call	0x4d26	; 0x4d26 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6ef6:	80 91 e8 00 	lds	r24, 0x00E8
    6efa:	8b 77       	andi	r24, 0x7B	; 123
    6efc:	80 93 e8 00 	sts	0x00E8, r24
    6f00:	02 c0       	rjmp	.+4      	; 0x6f06 <RNDIS_Device_ReadPacket+0xa2>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    6f02:	82 e0       	ldi	r24, 0x02	; 2
    6f04:	01 c0       	rjmp	.+2      	; 0x6f08 <RNDIS_Device_ReadPacket+0xa4>
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;

	if (!(Endpoint_IsOUTReceived()))
		return ENDPOINT_RWSTREAM_NoError;
    6f06:	80 e0       	ldi	r24, 0x00	; 0

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    6f08:	ac 96       	adiw	r28, 0x2c	; 44
    6f0a:	0f b6       	in	r0, 0x3f	; 63
    6f0c:	f8 94       	cli
    6f0e:	de bf       	out	0x3e, r29	; 62
    6f10:	0f be       	out	0x3f, r0	; 63
    6f12:	cd bf       	out	0x3d, r28	; 61
    6f14:	df 91       	pop	r29
    6f16:	cf 91       	pop	r28
    6f18:	1f 91       	pop	r17
    6f1a:	0f 91       	pop	r16
    6f1c:	ff 90       	pop	r15
    6f1e:	ef 90       	pop	r14
    6f20:	08 95       	ret

00006f22 <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    6f22:	cf 92       	push	r12
    6f24:	df 92       	push	r13
    6f26:	ef 92       	push	r14
    6f28:	ff 92       	push	r15
    6f2a:	1f 93       	push	r17
    6f2c:	cf 93       	push	r28
    6f2e:	df 93       	push	r29
    6f30:	cd b7       	in	r28, 0x3d	; 61
    6f32:	de b7       	in	r29, 0x3e	; 62
    6f34:	ac 97       	sbiw	r28, 0x2c	; 44
    6f36:	0f b6       	in	r0, 0x3f	; 63
    6f38:	f8 94       	cli
    6f3a:	de bf       	out	0x3e, r29	; 62
    6f3c:	0f be       	out	0x3f, r0	; 63
    6f3e:	cd bf       	out	0x3d, r28	; 61
    6f40:	6b 01       	movw	r12, r22
    6f42:	7a 01       	movw	r14, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6f44:	2e b3       	in	r18, 0x1e	; 30
    6f46:	24 30       	cpi	r18, 0x04	; 4
    6f48:	09 f0       	breq	.+2      	; 0x6f4c <RNDIS_Device_SendPacket+0x2a>
    6f4a:	4b c0       	rjmp	.+150    	; 0x6fe2 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    6f4c:	fc 01       	movw	r30, r24
    6f4e:	e7 56       	subi	r30, 0x67	; 103
    6f50:	ff 4f       	sbci	r31, 0xFF	; 255
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6f52:	20 81       	ld	r18, Z
    6f54:	22 30       	cpi	r18, 0x02	; 2
    6f56:	09 f0       	breq	.+2      	; 0x6f5a <RNDIS_Device_SendPacket+0x38>
    6f58:	44 c0       	rjmp	.+136    	; 0x6fe2 <RNDIS_Device_SendPacket+0xc0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6f5a:	dc 01       	movw	r26, r24
    6f5c:	11 96       	adiw	r26, 0x01	; 1
    6f5e:	8c 91       	ld	r24, X
    6f60:	8f 70       	andi	r24, 0x0F	; 15
    6f62:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    6f66:	0e 94 6d 28 	call	0x50da	; 0x50da <Endpoint_WaitUntilReady>
    6f6a:	18 2f       	mov	r17, r24
    6f6c:	88 23       	and	r24, r24
    6f6e:	d1 f5       	brne	.+116    	; 0x6fe4 <RNDIS_Device_SendPacket+0xc2>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    6f70:	fe 01       	movw	r30, r28
    6f72:	31 96       	adiw	r30, 0x01	; 1
    6f74:	8c e2       	ldi	r24, 0x2C	; 44
    6f76:	df 01       	movw	r26, r30
    6f78:	1d 92       	st	X+, r1
    6f7a:	8a 95       	dec	r24
    6f7c:	e9 f7       	brne	.-6      	; 0x6f78 <RNDIS_Device_SendPacket+0x56>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    6f7e:	81 e0       	ldi	r24, 0x01	; 1
    6f80:	90 e0       	ldi	r25, 0x00	; 0
    6f82:	a0 e0       	ldi	r26, 0x00	; 0
    6f84:	b0 e0       	ldi	r27, 0x00	; 0
    6f86:	89 83       	std	Y+1, r24	; 0x01
    6f88:	9a 83       	std	Y+2, r25	; 0x02
    6f8a:	ab 83       	std	Y+3, r26	; 0x03
    6f8c:	bc 83       	std	Y+4, r27	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    6f8e:	c7 01       	movw	r24, r14
    6f90:	8c 96       	adiw	r24, 0x2c	; 44
    6f92:	a0 e0       	ldi	r26, 0x00	; 0
    6f94:	b0 e0       	ldi	r27, 0x00	; 0
    6f96:	8d 83       	std	Y+5, r24	; 0x05
    6f98:	9e 83       	std	Y+6, r25	; 0x06
    6f9a:	af 83       	std	Y+7, r26	; 0x07
    6f9c:	b8 87       	std	Y+8, r27	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    6f9e:	84 e2       	ldi	r24, 0x24	; 36
    6fa0:	90 e0       	ldi	r25, 0x00	; 0
    6fa2:	a0 e0       	ldi	r26, 0x00	; 0
    6fa4:	b0 e0       	ldi	r27, 0x00	; 0
    6fa6:	89 87       	std	Y+9, r24	; 0x09
    6fa8:	9a 87       	std	Y+10, r25	; 0x0a
    6faa:	ab 87       	std	Y+11, r26	; 0x0b
    6fac:	bc 87       	std	Y+12, r27	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    6fae:	c7 01       	movw	r24, r14
    6fb0:	a0 e0       	ldi	r26, 0x00	; 0
    6fb2:	b0 e0       	ldi	r27, 0x00	; 0
    6fb4:	8d 87       	std	Y+13, r24	; 0x0d
    6fb6:	9e 87       	std	Y+14, r25	; 0x0e
    6fb8:	af 87       	std	Y+15, r26	; 0x0f
    6fba:	b8 8b       	std	Y+16, r27	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6fbc:	cf 01       	movw	r24, r30
    6fbe:	6c e2       	ldi	r22, 0x2C	; 44
    6fc0:	70 e0       	ldi	r23, 0x00	; 0
    6fc2:	40 e0       	ldi	r20, 0x00	; 0
    6fc4:	50 e0       	ldi	r21, 0x00	; 0
    6fc6:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    6fca:	c6 01       	movw	r24, r12
    6fcc:	b7 01       	movw	r22, r14
    6fce:	40 e0       	ldi	r20, 0x00	; 0
    6fd0:	50 e0       	ldi	r21, 0x00	; 0
    6fd2:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6fd6:	80 91 e8 00 	lds	r24, 0x00E8
    6fda:	8e 77       	andi	r24, 0x7E	; 126
    6fdc:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    6fe0:	01 c0       	rjmp	.+2      	; 0x6fe4 <RNDIS_Device_SendPacket+0xc2>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    6fe2:	12 e0       	ldi	r17, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    6fe4:	81 2f       	mov	r24, r17
    6fe6:	ac 96       	adiw	r28, 0x2c	; 44
    6fe8:	0f b6       	in	r0, 0x3f	; 63
    6fea:	f8 94       	cli
    6fec:	de bf       	out	0x3e, r29	; 62
    6fee:	0f be       	out	0x3f, r0	; 63
    6ff0:	cd bf       	out	0x3d, r28	; 61
    6ff2:	df 91       	pop	r29
    6ff4:	cf 91       	pop	r28
    6ff6:	1f 91       	pop	r17
    6ff8:	ff 90       	pop	r15
    6ffa:	ef 90       	pop	r14
    6ffc:	df 90       	pop	r13
    6ffe:	cf 90       	pop	r12
    7000:	08 95       	ret

00007002 <DCOMP_RNDIS_Host_NextRNDISControlInterface>:

	return RNDIS_ENUMERROR_NoError;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISControlInterface(void* const CurrentDescriptor)
{
    7002:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    7004:	81 81       	ldd	r24, Z+1	; 0x01
    7006:	84 30       	cpi	r24, 0x04	; 4
    7008:	49 f4       	brne	.+18     	; 0x701c <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1a>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
    700a:	85 81       	ldd	r24, Z+5	; 0x05
    700c:	82 30       	cpi	r24, 0x02	; 2
    700e:	31 f4       	brne	.+12     	; 0x701c <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1a>
    7010:	86 81       	ldd	r24, Z+6	; 0x06
    7012:	82 30       	cpi	r24, 0x02	; 2
    7014:	19 f4       	brne	.+6      	; 0x701c <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1a>
		    (Interface->SubClass == CDC_CSCP_ACMSubclass) &&
    7016:	87 81       	ldd	r24, Z+7	; 0x07
    7018:	8f 3f       	cpi	r24, 0xFF	; 255
    701a:	11 f0       	breq	.+4      	; 0x7020 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
    701c:	82 e0       	ldi	r24, 0x02	; 2
    701e:	08 95       	ret

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
		    (Interface->SubClass == CDC_CSCP_ACMSubclass) &&
		    (Interface->Protocol == CDC_CSCP_VendorSpecificProtocol))
		{
			return DESCRIPTOR_SEARCH_Found;
    7020:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    7022:	08 95       	ret

00007024 <DCOMP_RNDIS_Host_NextRNDISDataInterface>:

static uint8_t DCOMP_RNDIS_Host_NextRNDISDataInterface(void* const CurrentDescriptor)
{
    7024:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    7026:	81 81       	ldd	r24, Z+1	; 0x01
    7028:	84 30       	cpi	r24, 0x04	; 4
    702a:	49 f4       	brne	.+18     	; 0x703e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1a>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor,
		                                                         USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
    702c:	85 81       	ldd	r24, Z+5	; 0x05
    702e:	8a 30       	cpi	r24, 0x0A	; 10
    7030:	31 f4       	brne	.+12     	; 0x703e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1a>
    7032:	86 81       	ldd	r24, Z+6	; 0x06
    7034:	88 23       	and	r24, r24
    7036:	19 f4       	brne	.+6      	; 0x703e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1a>
		    (Interface->SubClass == CDC_CSCP_NoDataSubclass) &&
    7038:	87 81       	ldd	r24, Z+7	; 0x07
    703a:	88 23       	and	r24, r24
    703c:	11 f0       	breq	.+4      	; 0x7042 <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1e>
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
    703e:	82 e0       	ldi	r24, 0x02	; 2
    7040:	08 95       	ret

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
		    (Interface->SubClass == CDC_CSCP_NoDataSubclass) &&
		    (Interface->Protocol == CDC_CSCP_NoDataProtocol))
		{
			return DESCRIPTOR_SEARCH_Found;
    7042:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    7044:	08 95       	ret

00007046 <RNDIS_SendEncapsulatedCommand>:

static uint8_t RNDIS_SendEncapsulatedCommand(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    7046:	fc 01       	movw	r30, r24
    7048:	87 89       	ldd	r24, Z+23	; 0x17
    704a:	91 e2       	ldi	r25, 0x21	; 33
    704c:	90 93 d0 0d 	sts	0x0DD0, r25
    7050:	10 92 d1 0d 	sts	0x0DD1, r1
    7054:	10 92 d3 0d 	sts	0x0DD3, r1
    7058:	10 92 d2 0d 	sts	0x0DD2, r1
    705c:	80 93 d4 0d 	sts	0x0DD4, r24
    7060:	10 92 d5 0d 	sts	0x0DD5, r1
    7064:	50 93 d7 0d 	sts	0x0DD7, r21
    7068:	40 93 d6 0d 	sts	0x0DD6, r20
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    706c:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(Buffer);
    7070:	cb 01       	movw	r24, r22
    7072:	cb c8       	rjmp	.-3690   	; 0x620a <USB_Host_SendControlRequest>

00007074 <RNDIS_GetEncapsulatedResponse>:
    7074:	fc 01       	movw	r30, r24
}
    7076:	87 89       	ldd	r24, Z+23	; 0x17

static uint8_t RNDIS_GetEncapsulatedResponse(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    7078:	91 ea       	ldi	r25, 0xA1	; 161
    707a:	90 93 d0 0d 	sts	0x0DD0, r25
    707e:	91 e0       	ldi	r25, 0x01	; 1
    7080:	90 93 d1 0d 	sts	0x0DD1, r25
    7084:	10 92 d3 0d 	sts	0x0DD3, r1
    7088:	10 92 d2 0d 	sts	0x0DD2, r1
    708c:	80 93 d4 0d 	sts	0x0DD4, r24
    7090:	10 92 d5 0d 	sts	0x0DD5, r1
    7094:	50 93 d7 0d 	sts	0x0DD7, r21
    7098:	40 93 d6 0d 	sts	0x0DD6, r20
    709c:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(Buffer);
    70a0:	cb 01       	movw	r24, r22
    70a2:	b3 c8       	rjmp	.-3738   	; 0x620a <USB_Host_SendControlRequest>

000070a4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint>:
    70a4:	fc 01       	movw	r30, r24
}
    70a6:	81 81       	ldd	r24, Z+1	; 0x01

static uint8_t DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint(void* const CurrentDescriptor)
{
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Endpoint)
    70a8:	85 30       	cpi	r24, 0x05	; 5
    70aa:	59 f4       	brne	.+22     	; 0x70c2 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1e>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);
    70ac:	83 81       	ldd	r24, Z+3	; 0x03
    70ae:	83 70       	andi	r24, 0x03	; 3

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    70b0:	82 50       	subi	r24, 0x02	; 2
    70b2:	82 30       	cpi	r24, 0x02	; 2
    70b4:	40 f4       	brcc	.+16     	; 0x70c6 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x22>
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
    70b6:	82 81       	ldd	r24, Z+2	; 0x02
    70b8:	0e 94 03 2c 	call	0x5806	; 0x5806 <Pipe_IsEndpointBound>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    70bc:	88 23       	and	r24, r24
    70be:	19 f4       	brne	.+6      	; 0x70c6 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x22>
    70c0:	04 c0       	rjmp	.+8      	; 0x70ca <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	else if (Header->Type == DTYPE_Interface)
    70c2:	84 30       	cpi	r24, 0x04	; 4
    70c4:	21 f0       	breq	.+8      	; 0x70ce <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x2a>
	{
		return DESCRIPTOR_SEARCH_Fail;
	}

	return DESCRIPTOR_SEARCH_NotFound;
    70c6:	82 e0       	ldi	r24, 0x02	; 2
    70c8:	08 95       	ret
		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
    70ca:	80 e0       	ldi	r24, 0x00	; 0
    70cc:	08 95       	ret
		}
	}
	else if (Header->Type == DTYPE_Interface)
	{
		return DESCRIPTOR_SEARCH_Fail;
    70ce:	81 e0       	ldi	r24, 0x01	; 1
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    70d0:	08 95       	ret

000070d2 <RNDIS_Host_ConfigurePipes>:
#include "RNDISClassHost.h"

uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
    70d2:	8f 92       	push	r8
    70d4:	9f 92       	push	r9
    70d6:	af 92       	push	r10
    70d8:	bf 92       	push	r11
    70da:	cf 92       	push	r12
    70dc:	df 92       	push	r13
    70de:	ef 92       	push	r14
    70e0:	ff 92       	push	r15
    70e2:	0f 93       	push	r16
    70e4:	1f 93       	push	r17
    70e6:	cf 93       	push	r28
    70e8:	df 93       	push	r29
    70ea:	00 d0       	rcall	.+0      	; 0x70ec <RNDIS_Host_ConfigurePipes+0x1a>
    70ec:	00 d0       	rcall	.+0      	; 0x70ee <RNDIS_Host_ConfigurePipes+0x1c>
    70ee:	cd b7       	in	r28, 0x3d	; 61
    70f0:	de b7       	in	r29, 0x3e	; 62
    70f2:	8c 01       	movw	r16, r24
    70f4:	7a 83       	std	Y+2, r23	; 0x02
    70f6:	69 83       	std	Y+1, r22	; 0x01
    70f8:	5c 83       	std	Y+4, r21	; 0x04
    70fa:	4b 83       	std	Y+3, r20	; 0x03
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
	USB_Descriptor_Endpoint_t*  NotificationEndpoint  = NULL;
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    70fc:	46 96       	adiw	r24, 0x16	; 22
    70fe:	fc 01       	movw	r30, r24
    7100:	8a e0       	ldi	r24, 0x0A	; 10
    7102:	df 01       	movw	r26, r30
    7104:	1d 92       	st	X+, r1
    7106:	8a 95       	dec	r24
    7108:	e9 f7       	brne	.-6      	; 0x7104 <RNDIS_Host_ConfigurePipes+0x32>

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
    710a:	8b 80       	ldd	r8, Y+3	; 0x03
    710c:	9c 80       	ldd	r9, Y+4	; 0x04
    710e:	f4 01       	movw	r30, r8
    7110:	81 81       	ldd	r24, Z+1	; 0x01
    7112:	82 30       	cpi	r24, 0x02	; 2
    7114:	09 f0       	breq	.+2      	; 0x7118 <RNDIS_Host_ConfigurePipes+0x46>
    7116:	8b c0       	rjmp	.+278    	; 0x722e <RNDIS_Host_ConfigurePipes+0x15c>
    7118:	aa 24       	eor	r10, r10
    711a:	bb 24       	eor	r11, r11
    711c:	cc 24       	eor	r12, r12
    711e:	dd 24       	eor	r13, r13
    7120:	ee 24       	eor	r14, r14
    7122:	ff 24       	eor	r15, r15

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    7124:	81 14       	cp	r8, r1
    7126:	91 04       	cpc	r9, r1
    7128:	59 f0       	breq	.+22     	; 0x7140 <RNDIS_Host_ConfigurePipes+0x6e>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    712a:	ce 01       	movw	r24, r28
    712c:	01 96       	adiw	r24, 0x01	; 1
    712e:	be 01       	movw	r22, r28
    7130:	6d 5f       	subi	r22, 0xFD	; 253
    7132:	7f 4f       	sbci	r23, 0xFF	; 255
    7134:	42 e5       	ldi	r20, 0x52	; 82
    7136:	58 e3       	ldi	r21, 0x38	; 56
    7138:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <USB_GetNextDescriptorComp>

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    713c:	88 23       	and	r24, r24
    713e:	d1 f0       	breq	.+52     	; 0x7174 <RNDIS_Host_ConfigurePipes+0xa2>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7140:	ce 01       	movw	r24, r28
    7142:	01 96       	adiw	r24, 0x01	; 1
    7144:	be 01       	movw	r22, r28
    7146:	6d 5f       	subi	r22, 0xFD	; 253
    7148:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		if (!(RNDISControlInterface) ||
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
    714a:	a1 14       	cp	r10, r1
    714c:	b1 04       	cpc	r11, r1
    714e:	41 f0       	breq	.+16     	; 0x7160 <RNDIS_Host_ConfigurePipes+0x8e>
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7150:	42 e1       	ldi	r20, 0x12	; 18
    7152:	58 e3       	ldi	r21, 0x38	; 56
    7154:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <USB_GetNextDescriptorComp>
    7158:	88 23       	and	r24, r24
    715a:	09 f0       	breq	.+2      	; 0x715e <RNDIS_Host_ConfigurePipes+0x8c>
    715c:	6a c0       	rjmp	.+212    	; 0x7232 <RNDIS_Host_ConfigurePipes+0x160>
    715e:	de cf       	rjmp	.-68     	; 0x711c <RNDIS_Host_ConfigurePipes+0x4a>
				DataINEndpoint  = NULL;
				DataOUTEndpoint = NULL;
			}
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7160:	41 e0       	ldi	r20, 0x01	; 1
    7162:	58 e3       	ldi	r21, 0x38	; 56
    7164:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <USB_GetNextDescriptorComp>
    7168:	88 23       	and	r24, r24
    716a:	09 f0       	breq	.+2      	; 0x716e <RNDIS_Host_ConfigurePipes+0x9c>
    716c:	62 c0       	rjmp	.+196    	; 0x7232 <RNDIS_Host_ConfigurePipes+0x160>
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    716e:	8b 80       	ldd	r8, Y+3	; 0x03
    7170:	9c 80       	ldd	r9, Y+4	; 0x04
    7172:	0e c0       	rjmp	.+28     	; 0x7190 <RNDIS_Host_ConfigurePipes+0xbe>
			}

			continue;
		}

		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Endpoint_t);
    7174:	eb 81       	ldd	r30, Y+3	; 0x03
    7176:	fc 81       	ldd	r31, Y+4	; 0x04

		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
    7178:	82 81       	ldd	r24, Z+2	; 0x02
    717a:	87 ff       	sbrs	r24, 7
    717c:	06 c0       	rjmp	.+12     	; 0x718a <RNDIS_Host_ConfigurePipes+0xb8>
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
    717e:	83 81       	ldd	r24, Z+3	; 0x03
    7180:	83 70       	andi	r24, 0x03	; 3
    7182:	83 30       	cpi	r24, 0x03	; 3
    7184:	21 f4       	brne	.+8      	; 0x718e <RNDIS_Host_ConfigurePipes+0xbc>
			  NotificationEndpoint = EndpointData;
    7186:	5f 01       	movw	r10, r30
    7188:	03 c0       	rjmp	.+6      	; 0x7190 <RNDIS_Host_ConfigurePipes+0xbe>
			else
			  DataINEndpoint = EndpointData;
		}
		else
		{
			DataOUTEndpoint = EndpointData;
    718a:	6f 01       	movw	r12, r30
    718c:	01 c0       	rjmp	.+2      	; 0x7190 <RNDIS_Host_ConfigurePipes+0xbe>
		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
			  NotificationEndpoint = EndpointData;
			else
			  DataINEndpoint = EndpointData;
    718e:	7f 01       	movw	r14, r30
	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
    7190:	e1 14       	cp	r14, r1
    7192:	f1 04       	cpc	r15, r1
    7194:	39 f2       	breq	.-114    	; 0x7124 <RNDIS_Host_ConfigurePipes+0x52>
    7196:	c1 14       	cp	r12, r1
    7198:	d1 04       	cpc	r13, r1
    719a:	21 f2       	breq	.-120    	; 0x7124 <RNDIS_Host_ConfigurePipes+0x52>
    719c:	a1 14       	cp	r10, r1
    719e:	b1 04       	cpc	r11, r1
    71a0:	09 f2       	breq	.-126    	; 0x7124 <RNDIS_Host_ConfigurePipes+0x52>
		{
			DataOUTEndpoint = EndpointData;
		}
	}

	RNDISInterfaceInfo->Config.DataINPipe.Size  = le16_to_cpu(DataINEndpoint->EndpointSize);
    71a2:	d7 01       	movw	r26, r14
    71a4:	14 96       	adiw	r26, 0x04	; 4
    71a6:	8d 91       	ld	r24, X+
    71a8:	9c 91       	ld	r25, X
    71aa:	15 97       	sbiw	r26, 0x05	; 5
    71ac:	f8 01       	movw	r30, r16
    71ae:	92 83       	std	Z+2, r25	; 0x02
    71b0:	81 83       	std	Z+1, r24	; 0x01
	RNDISInterfaceInfo->Config.DataINPipe.EndpointAddress = DataINEndpoint->EndpointAddress;
    71b2:	12 96       	adiw	r26, 0x02	; 2
    71b4:	8c 91       	ld	r24, X
    71b6:	83 83       	std	Z+3, r24	; 0x03
	RNDISInterfaceInfo->Config.DataINPipe.Type  = EP_TYPE_BULK;
    71b8:	22 e0       	ldi	r18, 0x02	; 2
    71ba:	24 83       	std	Z+4, r18	; 0x04
	
	RNDISInterfaceInfo->Config.DataOUTPipe.Size = le16_to_cpu(DataOUTEndpoint->EndpointSize);
    71bc:	d6 01       	movw	r26, r12
    71be:	14 96       	adiw	r26, 0x04	; 4
    71c0:	8d 91       	ld	r24, X+
    71c2:	9c 91       	ld	r25, X
    71c4:	15 97       	sbiw	r26, 0x05	; 5
    71c6:	90 87       	std	Z+8, r25	; 0x08
    71c8:	87 83       	std	Z+7, r24	; 0x07
	RNDISInterfaceInfo->Config.DataOUTPipe.EndpointAddress = DataOUTEndpoint->EndpointAddress;
    71ca:	12 96       	adiw	r26, 0x02	; 2
    71cc:	8c 91       	ld	r24, X
    71ce:	81 87       	std	Z+9, r24	; 0x09
	RNDISInterfaceInfo->Config.DataOUTPipe.Type = EP_TYPE_BULK;
    71d0:	22 87       	std	Z+10, r18	; 0x0a
	
	RNDISInterfaceInfo->Config.NotificationPipe.Size = le16_to_cpu(NotificationEndpoint->EndpointSize);
    71d2:	f5 01       	movw	r30, r10
    71d4:	84 81       	ldd	r24, Z+4	; 0x04
    71d6:	95 81       	ldd	r25, Z+5	; 0x05
    71d8:	d8 01       	movw	r26, r16
    71da:	1e 96       	adiw	r26, 0x0e	; 14
    71dc:	9c 93       	st	X, r25
    71de:	8e 93       	st	-X, r24
    71e0:	1d 97       	sbiw	r26, 0x0d	; 13
	RNDISInterfaceInfo->Config.NotificationPipe.EndpointAddress = NotificationEndpoint->EndpointAddress;
    71e2:	82 81       	ldd	r24, Z+2	; 0x02
    71e4:	1f 96       	adiw	r26, 0x0f	; 15
    71e6:	8c 93       	st	X, r24
    71e8:	1f 97       	sbiw	r26, 0x0f	; 15
	RNDISInterfaceInfo->Config.NotificationPipe.Type = EP_TYPE_INTERRUPT;
    71ea:	83 e0       	ldi	r24, 0x03	; 3
    71ec:	50 96       	adiw	r26, 0x10	; 16
    71ee:	8c 93       	st	X, r24

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataINPipe, 1)))
    71f0:	c8 01       	movw	r24, r16
    71f2:	61 e0       	ldi	r22, 0x01	; 1
    71f4:	0e 94 ce 2b 	call	0x579c	; 0x579c <Pipe_ConfigurePipeTable>
    71f8:	88 23       	and	r24, r24
    71fa:	e9 f0       	breq	.+58     	; 0x7236 <RNDIS_Host_ConfigurePipes+0x164>
	  return false;
	
	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataOUTPipe, 1)))
    71fc:	c8 01       	movw	r24, r16
    71fe:	06 96       	adiw	r24, 0x06	; 6
    7200:	61 e0       	ldi	r22, 0x01	; 1
    7202:	0e 94 ce 2b 	call	0x579c	; 0x579c <Pipe_ConfigurePipeTable>
    7206:	88 23       	and	r24, r24
    7208:	b1 f0       	breq	.+44     	; 0x7236 <RNDIS_Host_ConfigurePipes+0x164>
	  return false;

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.NotificationPipe, 1)))
    720a:	c8 01       	movw	r24, r16
    720c:	0c 96       	adiw	r24, 0x0c	; 12
    720e:	61 e0       	ldi	r22, 0x01	; 1
    7210:	0e 94 ce 2b 	call	0x579c	; 0x579c <Pipe_ConfigurePipeTable>
    7214:	88 23       	and	r24, r24
    7216:	79 f0       	breq	.+30     	; 0x7236 <RNDIS_Host_ConfigurePipes+0x164>
	  return false;

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
    7218:	f4 01       	movw	r30, r8
    721a:	82 81       	ldd	r24, Z+2	; 0x02
    721c:	d8 01       	movw	r26, r16
    721e:	57 96       	adiw	r26, 0x17	; 23
    7220:	8c 93       	st	X, r24
    7222:	57 97       	sbiw	r26, 0x17	; 23
	RNDISInterfaceInfo->State.IsActive = true;
    7224:	81 e0       	ldi	r24, 0x01	; 1
    7226:	56 96       	adiw	r26, 0x16	; 22
    7228:	8c 93       	st	X, r24
    722a:	56 97       	sbiw	r26, 0x16	; 22
    722c:	04 c0       	rjmp	.+8      	; 0x7236 <RNDIS_Host_ConfigurePipes+0x164>
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;
    722e:	81 e0       	ldi	r24, 0x01	; 1
    7230:	03 c0       	rjmp	.+6      	; 0x7238 <RNDIS_Host_ConfigurePipes+0x166>
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
    7232:	82 e0       	ldi	r24, 0x02	; 2
    7234:	01 c0       	rjmp	.+2      	; 0x7238 <RNDIS_Host_ConfigurePipes+0x166>
	
	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataOUTPipe, 1)))
	  return false;

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.NotificationPipe, 1)))
	  return false;
    7236:	80 e0       	ldi	r24, 0x00	; 0

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
	RNDISInterfaceInfo->State.IsActive = true;

	return RNDIS_ENUMERROR_NoError;
}
    7238:	0f 90       	pop	r0
    723a:	0f 90       	pop	r0
    723c:	0f 90       	pop	r0
    723e:	0f 90       	pop	r0
    7240:	df 91       	pop	r29
    7242:	cf 91       	pop	r28
    7244:	1f 91       	pop	r17
    7246:	0f 91       	pop	r16
    7248:	ff 90       	pop	r15
    724a:	ef 90       	pop	r14
    724c:	df 90       	pop	r13
    724e:	cf 90       	pop	r12
    7250:	bf 90       	pop	r11
    7252:	af 90       	pop	r10
    7254:	9f 90       	pop	r9
    7256:	8f 90       	pop	r8
    7258:	08 95       	ret

0000725a <RNDIS_Host_InitializeDevice>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t RNDIS_Host_InitializeDevice(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    725a:	0f 93       	push	r16
    725c:	1f 93       	push	r17
    725e:	cf 93       	push	r28
    7260:	df 93       	push	r29
    7262:	cd b7       	in	r28, 0x3d	; 61
    7264:	de b7       	in	r29, 0x3e	; 62
    7266:	cc 54       	subi	r28, 0x4C	; 76
    7268:	d0 40       	sbci	r29, 0x00	; 0
    726a:	0f b6       	in	r0, 0x3f	; 63
    726c:	f8 94       	cli
    726e:	de bf       	out	0x3e, r29	; 62
    7270:	0f be       	out	0x3f, r0	; 63
    7272:	cd bf       	out	0x3d, r28	; 61
    7274:	8c 01       	movw	r16, r24
	uint8_t ErrorCode;

	RNDIS_Initialize_Message_t  InitMessage;
	RNDIS_Initialize_Complete_t InitMessageResponse;

	InitMessage.MessageType     = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_MSG);
    7276:	82 e0       	ldi	r24, 0x02	; 2
    7278:	90 e0       	ldi	r25, 0x00	; 0
    727a:	a0 e0       	ldi	r26, 0x00	; 0
    727c:	b0 e0       	ldi	r27, 0x00	; 0
    727e:	89 83       	std	Y+1, r24	; 0x01
    7280:	9a 83       	std	Y+2, r25	; 0x02
    7282:	ab 83       	std	Y+3, r26	; 0x03
    7284:	bc 83       	std	Y+4, r27	; 0x04
	InitMessage.MessageLength   = CPU_TO_LE32(sizeof(RNDIS_Initialize_Message_t));
    7286:	88 e1       	ldi	r24, 0x18	; 24
    7288:	90 e0       	ldi	r25, 0x00	; 0
    728a:	a0 e0       	ldi	r26, 0x00	; 0
    728c:	b0 e0       	ldi	r27, 0x00	; 0
    728e:	8d 83       	std	Y+5, r24	; 0x05
    7290:	9e 83       	std	Y+6, r25	; 0x06
    7292:	af 83       	std	Y+7, r26	; 0x07
    7294:	b8 87       	std	Y+8, r27	; 0x08
	InitMessage.RequestId       = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    7296:	f8 01       	movw	r30, r16
    7298:	84 8d       	ldd	r24, Z+28	; 0x1c
    729a:	95 8d       	ldd	r25, Z+29	; 0x1d
    729c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    729e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    72a0:	89 87       	std	Y+9, r24	; 0x09
    72a2:	9a 87       	std	Y+10, r25	; 0x0a
    72a4:	ab 87       	std	Y+11, r26	; 0x0b
    72a6:	bc 87       	std	Y+12, r27	; 0x0c
    72a8:	01 96       	adiw	r24, 0x01	; 1
    72aa:	a1 1d       	adc	r26, r1
    72ac:	b1 1d       	adc	r27, r1
    72ae:	84 8f       	std	Z+28, r24	; 0x1c
    72b0:	95 8f       	std	Z+29, r25	; 0x1d
    72b2:	a6 8f       	std	Z+30, r26	; 0x1e
    72b4:	b7 8f       	std	Z+31, r27	; 0x1f

	InitMessage.MajorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    72b6:	81 e0       	ldi	r24, 0x01	; 1
    72b8:	90 e0       	ldi	r25, 0x00	; 0
    72ba:	a0 e0       	ldi	r26, 0x00	; 0
    72bc:	b0 e0       	ldi	r27, 0x00	; 0
    72be:	8d 87       	std	Y+13, r24	; 0x0d
    72c0:	9e 87       	std	Y+14, r25	; 0x0e
    72c2:	af 87       	std	Y+15, r26	; 0x0f
    72c4:	b8 8b       	std	Y+16, r27	; 0x10
	InitMessage.MinorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    72c6:	19 8a       	std	Y+17, r1	; 0x11
    72c8:	1a 8a       	std	Y+18, r1	; 0x12
    72ca:	1b 8a       	std	Y+19, r1	; 0x13
    72cc:	1c 8a       	std	Y+20, r1	; 0x14
	InitMessage.MaxTransferSize = cpu_to_le32(RNDISInterfaceInfo->Config.HostMaxPacketSize);
    72ce:	82 89       	ldd	r24, Z+18	; 0x12
    72d0:	93 89       	ldd	r25, Z+19	; 0x13
    72d2:	a4 89       	ldd	r26, Z+20	; 0x14
    72d4:	b5 89       	ldd	r27, Z+21	; 0x15
    72d6:	8d 8b       	std	Y+21, r24	; 0x15
    72d8:	9e 8b       	std	Y+22, r25	; 0x16
    72da:	af 8b       	std	Y+23, r26	; 0x17
    72dc:	b8 8f       	std	Y+24, r27	; 0x18

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &InitMessage,
    72de:	c8 01       	movw	r24, r16
    72e0:	be 01       	movw	r22, r28
    72e2:	6f 5f       	subi	r22, 0xFF	; 255
    72e4:	7f 4f       	sbci	r23, 0xFF	; 255
    72e6:	48 e1       	ldi	r20, 0x18	; 24
    72e8:	50 e0       	ldi	r21, 0x00	; 0
    72ea:	ad de       	rcall	.-678    	; 0x7046 <RNDIS_SendEncapsulatedCommand>
    72ec:	88 23       	and	r24, r24
    72ee:	f9 f4       	brne	.+62     	; 0x732e <RNDIS_Host_InitializeDevice+0xd4>
    72f0:	c8 01       	movw	r24, r16
	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &InitMessageResponse,
    72f2:	be 01       	movw	r22, r28
    72f4:	67 5e       	subi	r22, 0xE7	; 231
    72f6:	7f 4f       	sbci	r23, 0xFF	; 255
    72f8:	44 e3       	ldi	r20, 0x34	; 52
    72fa:	50 e0       	ldi	r21, 0x00	; 0
    72fc:	bb de       	rcall	.-650    	; 0x7074 <RNDIS_GetEncapsulatedResponse>
    72fe:	88 23       	and	r24, r24
    7300:	b1 f4       	brne	.+44     	; 0x732e <RNDIS_Host_InitializeDevice+0xd4>
    7302:	4d a1       	lds	r20, 0x4d
    7304:	5e a1       	lds	r21, 0x4e
	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7306:	6f a1       	lds	r22, 0x4f
    7308:	78 a5       	lds	r23, 0x68
    730a:	41 15       	cp	r20, r1
    730c:	51 05       	cpc	r21, r1
    730e:	61 05       	cpc	r22, r1
    7310:	71 05       	cpc	r23, r1
    7312:	61 f4       	brne	.+24     	; 0x732c <RNDIS_Host_InitializeDevice+0xd2>
    7314:	21 96       	adiw	r28, 0x01	; 1
    7316:	4c ad       	sts	0x6c, r20
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);
    7318:	5d ad       	sts	0x6d, r21
    731a:	6e ad       	sts	0x6e, r22
    731c:	7f ad       	sts	0x6f, r23
    731e:	21 97       	sbiw	r28, 0x01	; 1
    7320:	f8 01       	movw	r30, r16
    7322:	40 8f       	std	Z+24, r20	; 0x18
    7324:	51 8f       	std	Z+25, r21	; 0x19
    7326:	62 8f       	std	Z+26, r22	; 0x1a
    7328:	73 8f       	std	Z+27, r23	; 0x1b
    732a:	01 c0       	rjmp	.+2      	; 0x732e <RNDIS_Host_InitializeDevice+0xd4>
    732c:	80 e8       	ldi	r24, 0x80	; 128

	return HOST_SENDCONTROL_Successful;
    732e:	c4 5b       	subi	r28, 0xB4	; 180
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    7330:	df 4f       	sbci	r29, 0xFF	; 255

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);

	return HOST_SENDCONTROL_Successful;
}
    7332:	0f b6       	in	r0, 0x3f	; 63
    7334:	f8 94       	cli
    7336:	de bf       	out	0x3e, r29	; 62
    7338:	0f be       	out	0x3f, r0	; 63
    733a:	cd bf       	out	0x3d, r28	; 61
    733c:	df 91       	pop	r29
    733e:	cf 91       	pop	r28
    7340:	1f 91       	pop	r17
    7342:	0f 91       	pop	r16
    7344:	08 95       	ret

00007346 <RNDIS_Host_SetRNDISProperty>:
    7346:	4f 92       	push	r4
    7348:	5f 92       	push	r5

uint8_t RNDIS_Host_SetRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                    const uint32_t Oid,
                                    void* Buffer,
                                    const uint16_t Length)
{
    734a:	6f 92       	push	r6
    734c:	7f 92       	push	r7
    734e:	8f 92       	push	r8
    7350:	9f 92       	push	r9
    7352:	af 92       	push	r10
    7354:	bf 92       	push	r11
    7356:	cf 92       	push	r12
    7358:	df 92       	push	r13
    735a:	ef 92       	push	r14
    735c:	ff 92       	push	r15
    735e:	0f 93       	push	r16
    7360:	1f 93       	push	r17
    7362:	cf 93       	push	r28
    7364:	df 93       	push	r29
    7366:	cd b7       	in	r28, 0x3d	; 61
    7368:	de b7       	in	r29, 0x3e	; 62
    736a:	60 97       	sbiw	r28, 0x10	; 16
    736c:	0f b6       	in	r0, 0x3f	; 63
    736e:	f8 94       	cli
    7370:	de bf       	out	0x3e, r29	; 62
    7372:	0f be       	out	0x3f, r0	; 63
    7374:	cd bf       	out	0x3d, r28	; 61
    7376:	7c 01       	movw	r14, r24
    7378:	48 01       	movw	r8, r16

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    737a:	ad b6       	in	r10, 0x3d	; 61
    737c:	be b6       	in	r11, 0x3e	; 62

	struct
	{
		RNDIS_Set_Message_t SetMessage;
		uint8_t             ContiguousBuffer[Length];
	} SetMessageData;
    737e:	ec e1       	ldi	r30, 0x1C	; 28
    7380:	ce 2e       	mov	r12, r30
    7382:	d1 2c       	mov	r13, r1
    7384:	c0 0e       	add	r12, r16
    7386:	d1 1e       	adc	r13, r17
    7388:	8d b7       	in	r24, 0x3d	; 61
    738a:	9e b7       	in	r25, 0x3e	; 62
    738c:	8c 19       	sub	r24, r12
    738e:	9d 09       	sbc	r25, r13
    7390:	0f b6       	in	r0, 0x3f	; 63
    7392:	f8 94       	cli
    7394:	9e bf       	out	0x3e, r25	; 62
    7396:	0f be       	out	0x3f, r0	; 63
    7398:	8d bf       	out	0x3d, r24	; 61
    739a:	0d b7       	in	r16, 0x3d	; 61
    739c:	1e b7       	in	r17, 0x3e	; 62
    739e:	0f 5f       	subi	r16, 0xFF	; 255
    73a0:	1f 4f       	sbci	r17, 0xFF	; 255

	RNDIS_Set_Complete_t SetMessageResponse;

	SetMessageData.SetMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_SET_MSG);
    73a2:	f5 e0       	ldi	r31, 0x05	; 5
    73a4:	4f 2e       	mov	r4, r31
    73a6:	51 2c       	mov	r5, r1
    73a8:	61 2c       	mov	r6, r1
    73aa:	71 2c       	mov	r7, r1
    73ac:	ad b7       	in	r26, 0x3d	; 61
    73ae:	be b7       	in	r27, 0x3e	; 62
    73b0:	11 96       	adiw	r26, 0x01	; 1
    73b2:	4d 92       	st	X+, r4
    73b4:	5d 92       	st	X+, r5
    73b6:	6d 92       	st	X+, r6
    73b8:	7c 92       	st	X, r7
    73ba:	14 97       	sbiw	r26, 0x04	; 4
	SetMessageData.SetMessage.MessageLength  = cpu_to_le32(sizeof(RNDIS_Set_Message_t) + Length);
    73bc:	26 01       	movw	r4, r12
    73be:	66 24       	eor	r6, r6
    73c0:	77 24       	eor	r7, r7
    73c2:	f8 01       	movw	r30, r16
    73c4:	44 82       	std	Z+4, r4	; 0x04
    73c6:	55 82       	std	Z+5, r5	; 0x05
    73c8:	66 82       	std	Z+6, r6	; 0x06
    73ca:	77 82       	std	Z+7, r7	; 0x07
	SetMessageData.SetMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    73cc:	f7 01       	movw	r30, r14
    73ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    73d0:	95 8d       	ldd	r25, Z+29	; 0x1d
    73d2:	a6 8d       	ldd	r26, Z+30	; 0x1e
    73d4:	b7 8d       	ldd	r27, Z+31	; 0x1f
    73d6:	f8 01       	movw	r30, r16
    73d8:	80 87       	std	Z+8, r24	; 0x08
    73da:	91 87       	std	Z+9, r25	; 0x09
    73dc:	a2 87       	std	Z+10, r26	; 0x0a
    73de:	b3 87       	std	Z+11, r27	; 0x0b
    73e0:	01 96       	adiw	r24, 0x01	; 1
    73e2:	a1 1d       	adc	r26, r1
    73e4:	b1 1d       	adc	r27, r1
    73e6:	f7 01       	movw	r30, r14
    73e8:	84 8f       	std	Z+28, r24	; 0x1c
    73ea:	95 8f       	std	Z+29, r25	; 0x1d
    73ec:	a6 8f       	std	Z+30, r26	; 0x1e
    73ee:	b7 8f       	std	Z+31, r27	; 0x1f

	SetMessageData.SetMessage.Oid            = cpu_to_le32(Oid);
    73f0:	d8 01       	movw	r26, r16
    73f2:	1c 96       	adiw	r26, 0x0c	; 12
    73f4:	4d 93       	st	X+, r20
    73f6:	5d 93       	st	X+, r21
    73f8:	6d 93       	st	X+, r22
    73fa:	7c 93       	st	X, r23
    73fc:	1f 97       	sbiw	r26, 0x0f	; 15
	SetMessageData.SetMessage.InformationBufferLength = cpu_to_le32(Length);
    73fe:	c4 01       	movw	r24, r8
    7400:	a0 e0       	ldi	r26, 0x00	; 0
    7402:	b0 e0       	ldi	r27, 0x00	; 0
    7404:	f8 01       	movw	r30, r16
    7406:	80 8b       	std	Z+16, r24	; 0x10
    7408:	91 8b       	std	Z+17, r25	; 0x11
    740a:	a2 8b       	std	Z+18, r26	; 0x12
    740c:	b3 8b       	std	Z+19, r27	; 0x13
	SetMessageData.SetMessage.InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Message_Header_t));
    740e:	84 e1       	ldi	r24, 0x14	; 20
    7410:	90 e0       	ldi	r25, 0x00	; 0
    7412:	a0 e0       	ldi	r26, 0x00	; 0
    7414:	b0 e0       	ldi	r27, 0x00	; 0
    7416:	84 8b       	std	Z+20, r24	; 0x14
    7418:	95 8b       	std	Z+21, r25	; 0x15
    741a:	a6 8b       	std	Z+22, r26	; 0x16
    741c:	b7 8b       	std	Z+23, r27	; 0x17
	SetMessageData.SetMessage.DeviceVcHandle = CPU_TO_LE32(0);
    741e:	10 8e       	std	Z+24, r1	; 0x18
    7420:	11 8e       	std	Z+25, r1	; 0x19
    7422:	12 8e       	std	Z+26, r1	; 0x1a
    7424:	13 8e       	std	Z+27, r1	; 0x1b

	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
    7426:	8d b7       	in	r24, 0x3d	; 61
    7428:	9e b7       	in	r25, 0x3e	; 62
    742a:	4d 96       	adiw	r24, 0x1d	; 29
    742c:	b9 01       	movw	r22, r18
    742e:	a4 01       	movw	r20, r8
    7430:	60 d2       	rcall	.+1216   	; 0x78f2 <memcpy>
    7432:	c7 01       	movw	r24, r14

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &SetMessageData,
    7434:	b8 01       	movw	r22, r16
    7436:	a6 01       	movw	r20, r12
    7438:	06 de       	rcall	.-1012   	; 0x7046 <RNDIS_SendEncapsulatedCommand>
    743a:	88 23       	and	r24, r24
    743c:	99 f4       	brne	.+38     	; 0x7464 <RNDIS_Host_SetRNDISProperty+0x11e>
    743e:	c7 01       	movw	r24, r14
    7440:	be 01       	movw	r22, r28
	                                               (sizeof(RNDIS_Set_Message_t) + Length))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &SetMessageResponse,
    7442:	6f 5f       	subi	r22, 0xFF	; 255
    7444:	7f 4f       	sbci	r23, 0xFF	; 255
    7446:	40 e1       	ldi	r20, 0x10	; 16
    7448:	50 e0       	ldi	r21, 0x00	; 0
    744a:	14 de       	rcall	.-984    	; 0x7074 <RNDIS_GetEncapsulatedResponse>
    744c:	88 23       	and	r24, r24
    744e:	51 f4       	brne	.+20     	; 0x7464 <RNDIS_Host_SetRNDISProperty+0x11e>
    7450:	4d 85       	ldd	r20, Y+13	; 0x0d
    7452:	5e 85       	ldd	r21, Y+14	; 0x0e
    7454:	6f 85       	ldd	r22, Y+15	; 0x0f
	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7456:	78 89       	ldd	r23, Y+16	; 0x10
    7458:	41 15       	cp	r20, r1
    745a:	51 05       	cpc	r21, r1
    745c:	61 05       	cpc	r22, r1
    745e:	71 05       	cpc	r23, r1
    7460:	09 f0       	breq	.+2      	; 0x7464 <RNDIS_Host_SetRNDISProperty+0x11e>
    7462:	80 e8       	ldi	r24, 0x80	; 128
    7464:	0f b6       	in	r0, 0x3f	; 63
    7466:	f8 94       	cli
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    7468:	be be       	out	0x3e, r11	; 62

	return HOST_SENDCONTROL_Successful;
}
    746a:	0f be       	out	0x3f, r0	; 63
    746c:	ad be       	out	0x3d, r10	; 61
    746e:	60 96       	adiw	r28, 0x10	; 16
    7470:	0f b6       	in	r0, 0x3f	; 63
    7472:	f8 94       	cli
    7474:	de bf       	out	0x3e, r29	; 62
    7476:	0f be       	out	0x3f, r0	; 63
    7478:	cd bf       	out	0x3d, r28	; 61
    747a:	df 91       	pop	r29
    747c:	cf 91       	pop	r28
    747e:	1f 91       	pop	r17
    7480:	0f 91       	pop	r16
    7482:	ff 90       	pop	r15
    7484:	ef 90       	pop	r14
    7486:	df 90       	pop	r13
    7488:	cf 90       	pop	r12
    748a:	bf 90       	pop	r11
    748c:	af 90       	pop	r10
    748e:	9f 90       	pop	r9
    7490:	8f 90       	pop	r8
    7492:	7f 90       	pop	r7
    7494:	6f 90       	pop	r6
    7496:	5f 90       	pop	r5
    7498:	4f 90       	pop	r4
    749a:	08 95       	ret

0000749c <RNDIS_Host_QueryRNDISProperty>:
    749c:	4f 92       	push	r4
    749e:	5f 92       	push	r5
    74a0:	6f 92       	push	r6

uint8_t RNDIS_Host_QueryRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                      const uint32_t Oid,
                                      void* Buffer,
                                      const uint16_t MaxLength)
{
    74a2:	7f 92       	push	r7
    74a4:	8f 92       	push	r8
    74a6:	9f 92       	push	r9
    74a8:	af 92       	push	r10
    74aa:	bf 92       	push	r11
    74ac:	cf 92       	push	r12
    74ae:	df 92       	push	r13
    74b0:	ef 92       	push	r14
    74b2:	ff 92       	push	r15
    74b4:	0f 93       	push	r16
    74b6:	1f 93       	push	r17
    74b8:	cf 93       	push	r28
    74ba:	df 93       	push	r29
    74bc:	cd b7       	in	r28, 0x3d	; 61
    74be:	de b7       	in	r29, 0x3e	; 62
    74c0:	6c 97       	sbiw	r28, 0x1c	; 28
    74c2:	0f b6       	in	r0, 0x3f	; 63
    74c4:	f8 94       	cli
    74c6:	de bf       	out	0x3e, r29	; 62
    74c8:	0f be       	out	0x3f, r0	; 63
    74ca:	cd bf       	out	0x3d, r28	; 61
    74cc:	7c 01       	movw	r14, r24
    74ce:	49 01       	movw	r8, r18
    74d0:	68 01       	movw	r12, r16
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    74d2:	4d b6       	in	r4, 0x3d	; 61
    74d4:	5e b6       	in	r5, 0x3e	; 62

	struct
	{
		RNDIS_Query_Complete_t QueryMessageResponse;
		uint8_t                ContiguousBuffer[MaxLength];
	} QueryMessageResponseData;
    74d6:	a8 e1       	ldi	r26, 0x18	; 24
    74d8:	6a 2e       	mov	r6, r26
    74da:	71 2c       	mov	r7, r1
    74dc:	60 0e       	add	r6, r16
    74de:	71 1e       	adc	r7, r17
    74e0:	8d b7       	in	r24, 0x3d	; 61
    74e2:	9e b7       	in	r25, 0x3e	; 62
    74e4:	86 19       	sub	r24, r6
    74e6:	97 09       	sbc	r25, r7
    74e8:	0f b6       	in	r0, 0x3f	; 63
    74ea:	f8 94       	cli
    74ec:	9e bf       	out	0x3e, r25	; 62
    74ee:	0f be       	out	0x3f, r0	; 63
    74f0:	8d bf       	out	0x3d, r24	; 61
    74f2:	ad b6       	in	r10, 0x3d	; 61
    74f4:	be b6       	in	r11, 0x3e	; 62
    74f6:	08 94       	sec
    74f8:	a1 1c       	adc	r10, r1
    74fa:	b1 1c       	adc	r11, r1

	QueryMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_QUERY_MSG);
    74fc:	84 e0       	ldi	r24, 0x04	; 4
    74fe:	90 e0       	ldi	r25, 0x00	; 0
    7500:	a0 e0       	ldi	r26, 0x00	; 0
    7502:	b0 e0       	ldi	r27, 0x00	; 0
    7504:	89 83       	std	Y+1, r24	; 0x01
    7506:	9a 83       	std	Y+2, r25	; 0x02
    7508:	ab 83       	std	Y+3, r26	; 0x03
    750a:	bc 83       	std	Y+4, r27	; 0x04
	QueryMessage.MessageLength  = CPU_TO_LE32(sizeof(RNDIS_Query_Message_t));
    750c:	8c e1       	ldi	r24, 0x1C	; 28
    750e:	90 e0       	ldi	r25, 0x00	; 0
    7510:	a0 e0       	ldi	r26, 0x00	; 0
    7512:	b0 e0       	ldi	r27, 0x00	; 0
    7514:	8d 83       	std	Y+5, r24	; 0x05
    7516:	9e 83       	std	Y+6, r25	; 0x06
    7518:	af 83       	std	Y+7, r26	; 0x07
    751a:	b8 87       	std	Y+8, r27	; 0x08
	QueryMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    751c:	f7 01       	movw	r30, r14
    751e:	84 8d       	ldd	r24, Z+28	; 0x1c
    7520:	95 8d       	ldd	r25, Z+29	; 0x1d
    7522:	a6 8d       	ldd	r26, Z+30	; 0x1e
    7524:	b7 8d       	ldd	r27, Z+31	; 0x1f
    7526:	89 87       	std	Y+9, r24	; 0x09
    7528:	9a 87       	std	Y+10, r25	; 0x0a
    752a:	ab 87       	std	Y+11, r26	; 0x0b
    752c:	bc 87       	std	Y+12, r27	; 0x0c
    752e:	01 96       	adiw	r24, 0x01	; 1
    7530:	a1 1d       	adc	r26, r1
    7532:	b1 1d       	adc	r27, r1
    7534:	84 8f       	std	Z+28, r24	; 0x1c
    7536:	95 8f       	std	Z+29, r25	; 0x1d
    7538:	a6 8f       	std	Z+30, r26	; 0x1e
    753a:	b7 8f       	std	Z+31, r27	; 0x1f

	QueryMessage.Oid            = cpu_to_le32(Oid);
    753c:	4d 87       	std	Y+13, r20	; 0x0d
    753e:	5e 87       	std	Y+14, r21	; 0x0e
    7540:	6f 87       	std	Y+15, r22	; 0x0f
    7542:	78 8b       	std	Y+16, r23	; 0x10
	QueryMessage.InformationBufferLength = CPU_TO_LE32(0);
    7544:	19 8a       	std	Y+17, r1	; 0x11
    7546:	1a 8a       	std	Y+18, r1	; 0x12
    7548:	1b 8a       	std	Y+19, r1	; 0x13
    754a:	1c 8a       	std	Y+20, r1	; 0x14
	QueryMessage.InformationBufferOffset = CPU_TO_LE32(0);
    754c:	1d 8a       	std	Y+21, r1	; 0x15
    754e:	1e 8a       	std	Y+22, r1	; 0x16
    7550:	1f 8a       	std	Y+23, r1	; 0x17
    7552:	18 8e       	std	Y+24, r1	; 0x18
	QueryMessage.DeviceVcHandle = CPU_TO_LE32(0);
    7554:	19 8e       	std	Y+25, r1	; 0x19
    7556:	1a 8e       	std	Y+26, r1	; 0x1a
    7558:	1b 8e       	std	Y+27, r1	; 0x1b
    755a:	1c 8e       	std	Y+28, r1	; 0x1c

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &QueryMessage,
    755c:	c7 01       	movw	r24, r14
    755e:	be 01       	movw	r22, r28
    7560:	6f 5f       	subi	r22, 0xFF	; 255
    7562:	7f 4f       	sbci	r23, 0xFF	; 255
    7564:	4c e1       	ldi	r20, 0x1C	; 28
    7566:	50 e0       	ldi	r21, 0x00	; 0
    7568:	6e dd       	rcall	.-1316   	; 0x7046 <RNDIS_SendEncapsulatedCommand>
    756a:	18 2f       	mov	r17, r24
    756c:	88 23       	and	r24, r24
    756e:	c1 f4       	brne	.+48     	; 0x75a0 <RNDIS_Host_QueryRNDISProperty+0x104>
    7570:	c7 01       	movw	r24, r14
	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &QueryMessageResponseData,
    7572:	b5 01       	movw	r22, r10
    7574:	a3 01       	movw	r20, r6
    7576:	7e dd       	rcall	.-1284   	; 0x7074 <RNDIS_GetEncapsulatedResponse>
    7578:	18 2f       	mov	r17, r24
    757a:	88 23       	and	r24, r24
    757c:	89 f4       	brne	.+34     	; 0x75a0 <RNDIS_Host_QueryRNDISProperty+0x104>
    757e:	f5 01       	movw	r30, r10
    7580:	84 85       	ldd	r24, Z+12	; 0x0c
	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7582:	95 85       	ldd	r25, Z+13	; 0x0d
    7584:	a6 85       	ldd	r26, Z+14	; 0x0e
    7586:	b7 85       	ldd	r27, Z+15	; 0x0f
    7588:	00 97       	sbiw	r24, 0x00	; 0
    758a:	a1 05       	cpc	r26, r1
    758c:	b1 05       	cpc	r27, r1
    758e:	39 f4       	brne	.+14     	; 0x759e <RNDIS_Host_QueryRNDISProperty+0x102>
    7590:	b5 01       	movw	r22, r10
    7592:	68 5e       	subi	r22, 0xE8	; 232
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
    7594:	7f 4f       	sbci	r23, 0xFF	; 255
    7596:	c4 01       	movw	r24, r8
    7598:	a6 01       	movw	r20, r12
    759a:	ab d1       	rcall	.+854    	; 0x78f2 <memcpy>
    759c:	01 c0       	rjmp	.+2      	; 0x75a0 <RNDIS_Host_QueryRNDISProperty+0x104>
    759e:	10 e8       	ldi	r17, 0x80	; 128
    75a0:	81 2f       	mov	r24, r17
    75a2:	0f b6       	in	r0, 0x3f	; 63
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    75a4:	f8 94       	cli

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    75a6:	5e be       	out	0x3e, r5	; 62
    75a8:	0f be       	out	0x3f, r0	; 63
    75aa:	4d be       	out	0x3d, r4	; 61
    75ac:	6c 96       	adiw	r28, 0x1c	; 28
    75ae:	0f b6       	in	r0, 0x3f	; 63
    75b0:	f8 94       	cli
    75b2:	de bf       	out	0x3e, r29	; 62
    75b4:	0f be       	out	0x3f, r0	; 63
    75b6:	cd bf       	out	0x3d, r28	; 61
    75b8:	df 91       	pop	r29
    75ba:	cf 91       	pop	r28
    75bc:	1f 91       	pop	r17
    75be:	0f 91       	pop	r16
    75c0:	ff 90       	pop	r15
    75c2:	ef 90       	pop	r14
    75c4:	df 90       	pop	r13
    75c6:	cf 90       	pop	r12
    75c8:	bf 90       	pop	r11
    75ca:	af 90       	pop	r10
    75cc:	9f 90       	pop	r9
    75ce:	8f 90       	pop	r8
    75d0:	7f 90       	pop	r7
    75d2:	6f 90       	pop	r6
    75d4:	5f 90       	pop	r5
    75d6:	4f 90       	pop	r4
    75d8:	08 95       	ret

000075da <RNDIS_Host_IsPacketReceived>:
    75da:	fc 01       	movw	r30, r24
    75dc:	8e b3       	in	r24, 0x1e	; 30
    75de:	8b 30       	cpi	r24, 0x0B	; 11

bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    75e0:	a9 f4       	brne	.+42     	; 0x760c <RNDIS_Host_IsPacketReceived+0x32>
    75e2:	86 89       	ldd	r24, Z+22	; 0x16
    75e4:	88 23       	and	r24, r24
    75e6:	a1 f0       	breq	.+40     	; 0x7610 <RNDIS_Host_IsPacketReceived+0x36>
    75e8:	80 81       	ld	r24, Z
    75ea:	8f 70       	andi	r24, 0x0F	; 15
    75ec:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    75f0:	80 91 a9 00 	lds	r24, 0x00A9
    75f4:	8f 7b       	andi	r24, 0xBF	; 191
    75f6:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    75fa:	80 91 a6 00 	lds	r24, 0x00A6
    75fe:	81 70       	andi	r24, 0x01	; 1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7600:	90 91 a9 00 	lds	r25, 0x00A9
    7604:	90 64       	ori	r25, 0x40	; 64
    7606:	90 93 a9 00 	sts	0x00A9, r25

	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
    760a:	08 95       	ret
bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return false;
    760c:	80 e0       	ldi	r24, 0x00	; 0
    760e:	08 95       	ret
    7610:	80 e0       	ldi	r24, 0x00	; 0
	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
}
    7612:	08 95       	ret

00007614 <RNDIS_Host_ReadPacket>:

uint8_t RNDIS_Host_ReadPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              uint16_t* const PacketLength)
{
    7614:	cf 92       	push	r12
    7616:	df 92       	push	r13
    7618:	ef 92       	push	r14
    761a:	ff 92       	push	r15
    761c:	1f 93       	push	r17
    761e:	cf 93       	push	r28
    7620:	df 93       	push	r29
    7622:	cd b7       	in	r28, 0x3d	; 61
    7624:	de b7       	in	r29, 0x3e	; 62
    7626:	ac 97       	sbiw	r28, 0x2c	; 44
    7628:	0f b6       	in	r0, 0x3f	; 63
    762a:	f8 94       	cli
    762c:	de bf       	out	0x3e, r29	; 62
    762e:	0f be       	out	0x3f, r0	; 63
    7630:	cd bf       	out	0x3d, r28	; 61
    7632:	fc 01       	movw	r30, r24
    7634:	6b 01       	movw	r12, r22
    7636:	7a 01       	movw	r14, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7638:	8e b3       	in	r24, 0x1e	; 30
    763a:	8b 30       	cpi	r24, 0x0B	; 11
    763c:	09 f0       	breq	.+2      	; 0x7640 <RNDIS_Host_ReadPacket+0x2c>
    763e:	54 c0       	rjmp	.+168    	; 0x76e8 <RNDIS_Host_ReadPacket+0xd4>
    7640:	86 89       	ldd	r24, Z+22	; 0x16
    7642:	88 23       	and	r24, r24
    7644:	09 f4       	brne	.+2      	; 0x7648 <RNDIS_Host_ReadPacket+0x34>
    7646:	50 c0       	rjmp	.+160    	; 0x76e8 <RNDIS_Host_ReadPacket+0xd4>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    7648:	80 81       	ld	r24, Z
    764a:	8f 70       	andi	r24, 0x0F	; 15
    764c:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    7650:	80 91 a9 00 	lds	r24, 0x00A9
    7654:	8f 7b       	andi	r24, 0xBF	; 191
    7656:	80 93 a9 00 	sts	0x00A9, r24
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    765a:	80 91 a6 00 	lds	r24, 0x00A6
	  return PIPE_READYWAIT_DeviceDisconnected;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipe.Address);
	Pipe_Unfreeze();

	if (!(Pipe_IsReadWriteAllowed()))
    765e:	85 fd       	sbrc	r24, 5
    7660:	13 c0       	rjmp	.+38     	; 0x7688 <RNDIS_Host_ReadPacket+0x74>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    7662:	80 91 a6 00 	lds	r24, 0x00A6
	{
		if (Pipe_IsINReceived())
    7666:	80 ff       	sbrs	r24, 0
    7668:	05 c0       	rjmp	.+10     	; 0x7674 <RNDIS_Host_ReadPacket+0x60>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    766a:	80 91 a6 00 	lds	r24, 0x00A6
    766e:	8e 77       	andi	r24, 0x7E	; 126
    7670:	80 93 a6 00 	sts	0x00A6, r24
		  Pipe_ClearIN();

		*PacketLength = 0;
    7674:	f7 01       	movw	r30, r14
    7676:	11 82       	std	Z+1, r1	; 0x01
    7678:	10 82       	st	Z, r1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    767a:	80 91 a9 00 	lds	r24, 0x00A9
    767e:	80 64       	ori	r24, 0x40	; 64
    7680:	80 93 a9 00 	sts	0x00A9, r24
		Pipe_Freeze();
		return PIPE_RWSTREAM_NoError;
    7684:	10 e0       	ldi	r17, 0x00	; 0
    7686:	31 c0       	rjmp	.+98     	; 0x76ea <RNDIS_Host_ReadPacket+0xd6>
	}

	RNDIS_Packet_Message_t DeviceMessage;

	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    7688:	ce 01       	movw	r24, r28
    768a:	01 96       	adiw	r24, 0x01	; 1
    768c:	6c e2       	ldi	r22, 0x2C	; 44
    768e:	70 e0       	ldi	r23, 0x00	; 0
    7690:	40 e0       	ldi	r20, 0x00	; 0
    7692:	50 e0       	ldi	r21, 0x00	; 0
    7694:	0e 94 12 2b 	call	0x5624	; 0x5624 <Pipe_Read_Stream_LE>
    7698:	18 2f       	mov	r17, r24
    769a:	88 23       	and	r24, r24
    769c:	31 f5       	brne	.+76     	; 0x76ea <RNDIS_Host_ReadPacket+0xd6>
	                                     NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	*PacketLength = (uint16_t)le32_to_cpu(DeviceMessage.DataLength);
    769e:	8d 85       	ldd	r24, Y+13	; 0x0d
    76a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    76a2:	f7 01       	movw	r30, r14
    76a4:	91 83       	std	Z+1, r25	; 0x01
    76a6:	80 83       	st	Z, r24

	Pipe_Discard_Stream(le32_to_cpu(DeviceMessage.DataOffset) -
    76a8:	89 85       	ldd	r24, Y+9	; 0x09
    76aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    76ac:	84 97       	sbiw	r24, 0x24	; 36
    76ae:	60 e0       	ldi	r22, 0x00	; 0
    76b0:	70 e0       	ldi	r23, 0x00	; 0
    76b2:	0e 94 70 2a 	call	0x54e0	; 0x54e0 <Pipe_Discard_Stream>
	                    (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t)),
	                    NULL);

	Pipe_Read_Stream_LE(Buffer, *PacketLength, NULL);
    76b6:	f7 01       	movw	r30, r14
    76b8:	60 81       	ld	r22, Z
    76ba:	71 81       	ldd	r23, Z+1	; 0x01
    76bc:	c6 01       	movw	r24, r12
    76be:	40 e0       	ldi	r20, 0x00	; 0
    76c0:	50 e0       	ldi	r21, 0x00	; 0
    76c2:	0e 94 12 2b 	call	0x5624	; 0x5624 <Pipe_Read_Stream_LE>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    76c6:	80 91 f6 00 	lds	r24, 0x00F6
    76ca:	90 91 f7 00 	lds	r25, 0x00F7

	if (!(Pipe_BytesInPipe()))
    76ce:	00 97       	sbiw	r24, 0x00	; 0
    76d0:	29 f4       	brne	.+10     	; 0x76dc <RNDIS_Host_ReadPacket+0xc8>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    76d2:	80 91 a6 00 	lds	r24, 0x00A6
    76d6:	8e 77       	andi	r24, 0x7E	; 126
    76d8:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    76dc:	80 91 a9 00 	lds	r24, 0x00A9
    76e0:	80 64       	ori	r24, 0x40	; 64
    76e2:	80 93 a9 00 	sts	0x00A9, r24
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    76e6:	01 c0       	rjmp	.+2      	; 0x76ea <RNDIS_Host_ReadPacket+0xd6>
                              uint16_t* const PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    76e8:	12 e0       	ldi	r17, 0x02	; 2
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    76ea:	81 2f       	mov	r24, r17
    76ec:	ac 96       	adiw	r28, 0x2c	; 44
    76ee:	0f b6       	in	r0, 0x3f	; 63
    76f0:	f8 94       	cli
    76f2:	de bf       	out	0x3e, r29	; 62
    76f4:	0f be       	out	0x3f, r0	; 63
    76f6:	cd bf       	out	0x3d, r28	; 61
    76f8:	df 91       	pop	r29
    76fa:	cf 91       	pop	r28
    76fc:	1f 91       	pop	r17
    76fe:	ff 90       	pop	r15
    7700:	ef 90       	pop	r14
    7702:	df 90       	pop	r13
    7704:	cf 90       	pop	r12
    7706:	08 95       	ret

00007708 <RNDIS_Host_SendPacket>:

uint8_t RNDIS_Host_SendPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              const uint16_t PacketLength)
{
    7708:	ef 92       	push	r14
    770a:	ff 92       	push	r15
    770c:	0f 93       	push	r16
    770e:	1f 93       	push	r17
    7710:	cf 93       	push	r28
    7712:	df 93       	push	r29
    7714:	cd b7       	in	r28, 0x3d	; 61
    7716:	de b7       	in	r29, 0x3e	; 62
    7718:	ad 97       	sbiw	r28, 0x2d	; 45
    771a:	0f b6       	in	r0, 0x3f	; 63
    771c:	f8 94       	cli
    771e:	de bf       	out	0x3e, r29	; 62
    7720:	0f be       	out	0x3f, r0	; 63
    7722:	cd bf       	out	0x3d, r28	; 61
    7724:	9c 01       	movw	r18, r24
    7726:	7b 01       	movw	r14, r22
    7728:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    772a:	8e b3       	in	r24, 0x1e	; 30
    772c:	8b 30       	cpi	r24, 0x0B	; 11
    772e:	09 f0       	breq	.+2      	; 0x7732 <RNDIS_Host_SendPacket+0x2a>
    7730:	55 c0       	rjmp	.+170    	; 0x77dc <RNDIS_Host_SendPacket+0xd4>
    7732:	d9 01       	movw	r26, r18
    7734:	56 96       	adiw	r26, 0x16	; 22
    7736:	8c 91       	ld	r24, X
    7738:	56 97       	sbiw	r26, 0x16	; 22
    773a:	88 23       	and	r24, r24
    773c:	09 f4       	brne	.+2      	; 0x7740 <RNDIS_Host_SendPacket+0x38>
    773e:	4e c0       	rjmp	.+156    	; 0x77dc <RNDIS_Host_SendPacket+0xd4>
	  return PIPE_READYWAIT_DeviceDisconnected;

	RNDIS_Packet_Message_t DeviceMessage;

	memset(&DeviceMessage, 0, sizeof(RNDIS_Packet_Message_t));
    7740:	fe 01       	movw	r30, r28
    7742:	31 96       	adiw	r30, 0x01	; 1
    7744:	8c e2       	ldi	r24, 0x2C	; 44
    7746:	df 01       	movw	r26, r30
    7748:	1d 92       	st	X+, r1
    774a:	8a 95       	dec	r24
    774c:	e9 f7       	brne	.-6      	; 0x7748 <RNDIS_Host_SendPacket+0x40>
	DeviceMessage.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    774e:	81 e0       	ldi	r24, 0x01	; 1
    7750:	90 e0       	ldi	r25, 0x00	; 0
    7752:	a0 e0       	ldi	r26, 0x00	; 0
    7754:	b0 e0       	ldi	r27, 0x00	; 0
    7756:	89 83       	std	Y+1, r24	; 0x01
    7758:	9a 83       	std	Y+2, r25	; 0x02
    775a:	ab 83       	std	Y+3, r26	; 0x03
    775c:	bc 83       	std	Y+4, r27	; 0x04
	DeviceMessage.MessageLength = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    775e:	ca 01       	movw	r24, r20
    7760:	8c 96       	adiw	r24, 0x2c	; 44
    7762:	a0 e0       	ldi	r26, 0x00	; 0
    7764:	b0 e0       	ldi	r27, 0x00	; 0
    7766:	8d 83       	std	Y+5, r24	; 0x05
    7768:	9e 83       	std	Y+6, r25	; 0x06
    776a:	af 83       	std	Y+7, r26	; 0x07
    776c:	b8 87       	std	Y+8, r27	; 0x08
	DeviceMessage.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    776e:	84 e2       	ldi	r24, 0x24	; 36
    7770:	90 e0       	ldi	r25, 0x00	; 0
    7772:	a0 e0       	ldi	r26, 0x00	; 0
    7774:	b0 e0       	ldi	r27, 0x00	; 0
    7776:	89 87       	std	Y+9, r24	; 0x09
    7778:	9a 87       	std	Y+10, r25	; 0x0a
    777a:	ab 87       	std	Y+11, r26	; 0x0b
    777c:	bc 87       	std	Y+12, r27	; 0x0c
	DeviceMessage.DataLength    = cpu_to_le32(PacketLength);
    777e:	ca 01       	movw	r24, r20
    7780:	a0 e0       	ldi	r26, 0x00	; 0
    7782:	b0 e0       	ldi	r27, 0x00	; 0
    7784:	8d 87       	std	Y+13, r24	; 0x0d
    7786:	9e 87       	std	Y+14, r25	; 0x0e
    7788:	af 87       	std	Y+15, r26	; 0x0f
    778a:	b8 8b       	std	Y+16, r27	; 0x10
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    778c:	d9 01       	movw	r26, r18
    778e:	16 96       	adiw	r26, 0x06	; 6
    7790:	8c 91       	ld	r24, X
    7792:	8f 70       	andi	r24, 0x0F	; 15
    7794:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    7798:	80 91 a9 00 	lds	r24, 0x00A9
    779c:	8f 7b       	andi	r24, 0xBF	; 191
    779e:	80 93 a9 00 	sts	0x00A9, r24

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataOUTPipe.Address);
	Pipe_Unfreeze();

	if ((ErrorCode = Pipe_Write_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    77a2:	cf 01       	movw	r24, r30
    77a4:	6c e2       	ldi	r22, 0x2C	; 44
    77a6:	70 e0       	ldi	r23, 0x00	; 0
    77a8:	40 e0       	ldi	r20, 0x00	; 0
    77aa:	50 e0       	ldi	r21, 0x00	; 0
    77ac:	0e 94 bb 2a 	call	0x5576	; 0x5576 <Pipe_Write_Stream_LE>
    77b0:	28 2f       	mov	r18, r24
    77b2:	88 23       	and	r24, r24
    77b4:	a1 f4       	brne	.+40     	; 0x77de <RNDIS_Host_SendPacket+0xd6>
	                                      NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	Pipe_Write_Stream_LE(Buffer, PacketLength, NULL);
    77b6:	c7 01       	movw	r24, r14
    77b8:	b8 01       	movw	r22, r16
    77ba:	40 e0       	ldi	r20, 0x00	; 0
    77bc:	50 e0       	ldi	r21, 0x00	; 0
    77be:	2d a7       	lds	r18, 0x7d
    77c0:	0e 94 bb 2a 	call	0x5576	; 0x5576 <Pipe_Write_Stream_LE>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    77c4:	80 91 a6 00 	lds	r24, 0x00A6
    77c8:	8b 77       	andi	r24, 0x7B	; 123
    77ca:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    77ce:	80 91 a9 00 	lds	r24, 0x00A9
    77d2:	80 64       	ori	r24, 0x40	; 64
    77d4:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    77d8:	2d a5       	lds	r18, 0x6d
    77da:	01 c0       	rjmp	.+2      	; 0x77de <RNDIS_Host_SendPacket+0xd6>
                              const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    77dc:	22 e0       	ldi	r18, 0x02	; 2
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    77de:	82 2f       	mov	r24, r18
    77e0:	ad 96       	adiw	r28, 0x2d	; 45
    77e2:	0f b6       	in	r0, 0x3f	; 63
    77e4:	f8 94       	cli
    77e6:	de bf       	out	0x3e, r29	; 62
    77e8:	0f be       	out	0x3f, r0	; 63
    77ea:	cd bf       	out	0x3d, r28	; 61
    77ec:	df 91       	pop	r29
    77ee:	cf 91       	pop	r28
    77f0:	1f 91       	pop	r17
    77f2:	0f 91       	pop	r16
    77f4:	ff 90       	pop	r15
    77f6:	ef 90       	pop	r14
    77f8:	08 95       	ret

000077fa <__mulsi3>:
    77fa:	62 9f       	mul	r22, r18
    77fc:	d0 01       	movw	r26, r0
    77fe:	73 9f       	mul	r23, r19
    7800:	f0 01       	movw	r30, r0
    7802:	82 9f       	mul	r24, r18
    7804:	e0 0d       	add	r30, r0
    7806:	f1 1d       	adc	r31, r1
    7808:	64 9f       	mul	r22, r20
    780a:	e0 0d       	add	r30, r0
    780c:	f1 1d       	adc	r31, r1
    780e:	92 9f       	mul	r25, r18
    7810:	f0 0d       	add	r31, r0
    7812:	83 9f       	mul	r24, r19
    7814:	f0 0d       	add	r31, r0
    7816:	74 9f       	mul	r23, r20
    7818:	f0 0d       	add	r31, r0
    781a:	65 9f       	mul	r22, r21
    781c:	f0 0d       	add	r31, r0
    781e:	99 27       	eor	r25, r25
    7820:	72 9f       	mul	r23, r18
    7822:	b0 0d       	add	r27, r0
    7824:	e1 1d       	adc	r30, r1
    7826:	f9 1f       	adc	r31, r25
    7828:	63 9f       	mul	r22, r19
    782a:	b0 0d       	add	r27, r0
    782c:	e1 1d       	adc	r30, r1
    782e:	f9 1f       	adc	r31, r25
    7830:	bd 01       	movw	r22, r26
    7832:	cf 01       	movw	r24, r30
    7834:	11 24       	eor	r1, r1
    7836:	08 95       	ret

00007838 <__udivmodsi4>:
    7838:	a1 e2       	ldi	r26, 0x21	; 33
    783a:	1a 2e       	mov	r1, r26
    783c:	aa 1b       	sub	r26, r26
    783e:	bb 1b       	sub	r27, r27
    7840:	fd 01       	movw	r30, r26
    7842:	0d c0       	rjmp	.+26     	; 0x785e <__udivmodsi4_ep>

00007844 <__udivmodsi4_loop>:
    7844:	aa 1f       	adc	r26, r26
    7846:	bb 1f       	adc	r27, r27
    7848:	ee 1f       	adc	r30, r30
    784a:	ff 1f       	adc	r31, r31
    784c:	a2 17       	cp	r26, r18
    784e:	b3 07       	cpc	r27, r19
    7850:	e4 07       	cpc	r30, r20
    7852:	f5 07       	cpc	r31, r21
    7854:	20 f0       	brcs	.+8      	; 0x785e <__udivmodsi4_ep>
    7856:	a2 1b       	sub	r26, r18
    7858:	b3 0b       	sbc	r27, r19
    785a:	e4 0b       	sbc	r30, r20
    785c:	f5 0b       	sbc	r31, r21

0000785e <__udivmodsi4_ep>:
    785e:	66 1f       	adc	r22, r22
    7860:	77 1f       	adc	r23, r23
    7862:	88 1f       	adc	r24, r24
    7864:	99 1f       	adc	r25, r25
    7866:	1a 94       	dec	r1
    7868:	69 f7       	brne	.-38     	; 0x7844 <__udivmodsi4_loop>
    786a:	60 95       	com	r22
    786c:	70 95       	com	r23
    786e:	80 95       	com	r24
    7870:	90 95       	com	r25
    7872:	9b 01       	movw	r18, r22
    7874:	ac 01       	movw	r20, r24
    7876:	bd 01       	movw	r22, r26
    7878:	cf 01       	movw	r24, r30
    787a:	08 95       	ret

0000787c <memcpy_P>:
    787c:	fb 01       	movw	r30, r22
    787e:	dc 01       	movw	r26, r24
    7880:	02 c0       	rjmp	.+4      	; 0x7886 <memcpy_P+0xa>
    7882:	05 90       	lpm	r0, Z+
    7884:	0d 92       	st	X+, r0
    7886:	41 50       	subi	r20, 0x01	; 1
    7888:	50 40       	sbci	r21, 0x00	; 0
    788a:	d8 f7       	brcc	.-10     	; 0x7882 <memcpy_P+0x6>
    788c:	08 95       	ret

0000788e <strcat_P>:
    788e:	fb 01       	movw	r30, r22
    7890:	dc 01       	movw	r26, r24
    7892:	0d 90       	ld	r0, X+
    7894:	00 20       	and	r0, r0
    7896:	e9 f7       	brne	.-6      	; 0x7892 <strcat_P+0x4>
    7898:	11 97       	sbiw	r26, 0x01	; 1
    789a:	05 90       	lpm	r0, Z+
    789c:	0d 92       	st	X+, r0
    789e:	00 20       	and	r0, r0
    78a0:	e1 f7       	brne	.-8      	; 0x789a <strcat_P+0xc>
    78a2:	08 95       	ret

000078a4 <strcmp_P>:
    78a4:	fb 01       	movw	r30, r22
    78a6:	dc 01       	movw	r26, r24
    78a8:	8d 91       	ld	r24, X+
    78aa:	05 90       	lpm	r0, Z+
    78ac:	80 19       	sub	r24, r0
    78ae:	01 10       	cpse	r0, r1
    78b0:	d9 f3       	breq	.-10     	; 0x78a8 <strcmp_P+0x4>
    78b2:	99 0b       	sbc	r25, r25
    78b4:	08 95       	ret

000078b6 <strcpy_P>:
    78b6:	fb 01       	movw	r30, r22
    78b8:	dc 01       	movw	r26, r24
    78ba:	05 90       	lpm	r0, Z+
    78bc:	0d 92       	st	X+, r0
    78be:	00 20       	and	r0, r0
    78c0:	e1 f7       	brne	.-8      	; 0x78ba <strcpy_P+0x4>
    78c2:	08 95       	ret

000078c4 <strlcpy_P>:
    78c4:	dc 01       	movw	r26, r24
    78c6:	fb 01       	movw	r30, r22
    78c8:	41 50       	subi	r20, 0x01	; 1
    78ca:	50 40       	sbci	r21, 0x00	; 0
    78cc:	58 f0       	brcs	.+22     	; 0x78e4 <strlcpy_P+0x20>
    78ce:	49 f0       	breq	.+18     	; 0x78e2 <strlcpy_P+0x1e>
    78d0:	05 90       	lpm	r0, Z+
    78d2:	0d 92       	st	X+, r0
    78d4:	00 20       	and	r0, r0
    78d6:	c1 f7       	brne	.-16     	; 0x78c8 <strlcpy_P+0x4>
    78d8:	e6 1b       	sub	r30, r22
    78da:	f7 0b       	sbc	r31, r23
    78dc:	31 97       	sbiw	r30, 0x01	; 1
    78de:	cf 01       	movw	r24, r30
    78e0:	08 95       	ret
    78e2:	1c 92       	st	X, r1
    78e4:	05 90       	lpm	r0, Z+
    78e6:	00 20       	and	r0, r0
    78e8:	e9 f7       	brne	.-6      	; 0x78e4 <strlcpy_P+0x20>
    78ea:	f6 cf       	rjmp	.-20     	; 0x78d8 <strlcpy_P+0x14>

000078ec <strtok>:
    78ec:	4c ef       	ldi	r20, 0xFC	; 252
    78ee:	53 e0       	ldi	r21, 0x03	; 3
    78f0:	43 c0       	rjmp	.+134    	; 0x7978 <strtok_r>

000078f2 <memcpy>:
    78f2:	fb 01       	movw	r30, r22
    78f4:	dc 01       	movw	r26, r24
    78f6:	02 c0       	rjmp	.+4      	; 0x78fc <memcpy+0xa>
    78f8:	01 90       	ld	r0, Z+
    78fa:	0d 92       	st	X+, r0
    78fc:	41 50       	subi	r20, 0x01	; 1
    78fe:	50 40       	sbci	r21, 0x00	; 0
    7900:	d8 f7       	brcc	.-10     	; 0x78f8 <memcpy+0x6>
    7902:	08 95       	ret

00007904 <memset>:
    7904:	dc 01       	movw	r26, r24
    7906:	01 c0       	rjmp	.+2      	; 0x790a <memset+0x6>
    7908:	6d 93       	st	X+, r22
    790a:	41 50       	subi	r20, 0x01	; 1
    790c:	50 40       	sbci	r21, 0x00	; 0
    790e:	e0 f7       	brcc	.-8      	; 0x7908 <memset+0x4>
    7910:	08 95       	ret

00007912 <strcat>:
    7912:	fb 01       	movw	r30, r22
    7914:	dc 01       	movw	r26, r24
    7916:	0d 90       	ld	r0, X+
    7918:	00 20       	and	r0, r0
    791a:	e9 f7       	brne	.-6      	; 0x7916 <strcat+0x4>
    791c:	11 97       	sbiw	r26, 0x01	; 1
    791e:	01 90       	ld	r0, Z+
    7920:	0d 92       	st	X+, r0
    7922:	00 20       	and	r0, r0
    7924:	e1 f7       	brne	.-8      	; 0x791e <strcat+0xc>
    7926:	08 95       	ret

00007928 <strchr>:
    7928:	fc 01       	movw	r30, r24
    792a:	81 91       	ld	r24, Z+
    792c:	86 17       	cp	r24, r22
    792e:	21 f0       	breq	.+8      	; 0x7938 <strchr+0x10>
    7930:	88 23       	and	r24, r24
    7932:	d9 f7       	brne	.-10     	; 0x792a <strchr+0x2>
    7934:	99 27       	eor	r25, r25
    7936:	08 95       	ret
    7938:	31 97       	sbiw	r30, 0x01	; 1
    793a:	cf 01       	movw	r24, r30
    793c:	08 95       	ret

0000793e <strcmp>:
    793e:	fb 01       	movw	r30, r22
    7940:	dc 01       	movw	r26, r24
    7942:	8d 91       	ld	r24, X+
    7944:	01 90       	ld	r0, Z+
    7946:	80 19       	sub	r24, r0
    7948:	01 10       	cpse	r0, r1
    794a:	d9 f3       	breq	.-10     	; 0x7942 <strcmp+0x4>
    794c:	99 0b       	sbc	r25, r25
    794e:	08 95       	ret

00007950 <strlcpy>:
    7950:	dc 01       	movw	r26, r24
    7952:	fb 01       	movw	r30, r22
    7954:	41 50       	subi	r20, 0x01	; 1
    7956:	50 40       	sbci	r21, 0x00	; 0
    7958:	58 f0       	brcs	.+22     	; 0x7970 <strlcpy+0x20>
    795a:	49 f0       	breq	.+18     	; 0x796e <strlcpy+0x1e>
    795c:	01 90       	ld	r0, Z+
    795e:	0d 92       	st	X+, r0
    7960:	00 20       	and	r0, r0
    7962:	c1 f7       	brne	.-16     	; 0x7954 <strlcpy+0x4>
    7964:	e6 1b       	sub	r30, r22
    7966:	f7 0b       	sbc	r31, r23
    7968:	31 97       	sbiw	r30, 0x01	; 1
    796a:	cf 01       	movw	r24, r30
    796c:	08 95       	ret
    796e:	1c 92       	st	X, r1
    7970:	01 90       	ld	r0, Z+
    7972:	00 20       	and	r0, r0
    7974:	e9 f7       	brne	.-6      	; 0x7970 <strlcpy+0x20>
    7976:	f6 cf       	rjmp	.-20     	; 0x7964 <strlcpy+0x14>

00007978 <strtok_r>:
    7978:	fa 01       	movw	r30, r20
    797a:	a1 91       	ld	r26, Z+
    797c:	b0 81       	ld	r27, Z
    797e:	00 97       	sbiw	r24, 0x00	; 0
    7980:	19 f4       	brne	.+6      	; 0x7988 <strtok_r+0x10>
    7982:	10 97       	sbiw	r26, 0x00	; 0
    7984:	e1 f0       	breq	.+56     	; 0x79be <strtok_r+0x46>
    7986:	cd 01       	movw	r24, r26
    7988:	dc 01       	movw	r26, r24
    798a:	cd 01       	movw	r24, r26
    798c:	0d 90       	ld	r0, X+
    798e:	00 20       	and	r0, r0
    7990:	11 f4       	brne	.+4      	; 0x7996 <strtok_r+0x1e>
    7992:	c0 01       	movw	r24, r0
    7994:	13 c0       	rjmp	.+38     	; 0x79bc <strtok_r+0x44>
    7996:	fb 01       	movw	r30, r22
    7998:	21 91       	ld	r18, Z+
    799a:	22 23       	and	r18, r18
    799c:	19 f0       	breq	.+6      	; 0x79a4 <strtok_r+0x2c>
    799e:	20 15       	cp	r18, r0
    79a0:	d9 f7       	brne	.-10     	; 0x7998 <strtok_r+0x20>
    79a2:	f3 cf       	rjmp	.-26     	; 0x798a <strtok_r+0x12>
    79a4:	fb 01       	movw	r30, r22
    79a6:	21 91       	ld	r18, Z+
    79a8:	20 15       	cp	r18, r0
    79aa:	19 f4       	brne	.+6      	; 0x79b2 <strtok_r+0x3a>
    79ac:	1e 92       	st	-X, r1
    79ae:	11 96       	adiw	r26, 0x01	; 1
    79b0:	06 c0       	rjmp	.+12     	; 0x79be <strtok_r+0x46>
    79b2:	22 23       	and	r18, r18
    79b4:	c1 f7       	brne	.-16     	; 0x79a6 <strtok_r+0x2e>
    79b6:	0d 90       	ld	r0, X+
    79b8:	00 20       	and	r0, r0
    79ba:	a1 f7       	brne	.-24     	; 0x79a4 <strtok_r+0x2c>
    79bc:	d0 01       	movw	r26, r0
    79be:	fa 01       	movw	r30, r20
    79c0:	a1 93       	st	Z+, r26
    79c2:	b0 83       	st	Z, r27
    79c4:	08 95       	ret

000079c6 <sprintf_P>:
    79c6:	0f 93       	push	r16
    79c8:	1f 93       	push	r17
    79ca:	cf 93       	push	r28
    79cc:	df 93       	push	r29
    79ce:	cd b7       	in	r28, 0x3d	; 61
    79d0:	de b7       	in	r29, 0x3e	; 62
    79d2:	2e 97       	sbiw	r28, 0x0e	; 14
    79d4:	0f b6       	in	r0, 0x3f	; 63
    79d6:	f8 94       	cli
    79d8:	de bf       	out	0x3e, r29	; 62
    79da:	0f be       	out	0x3f, r0	; 63
    79dc:	cd bf       	out	0x3d, r28	; 61
    79de:	0d 89       	ldd	r16, Y+21	; 0x15
    79e0:	1e 89       	ldd	r17, Y+22	; 0x16
    79e2:	8e e0       	ldi	r24, 0x0E	; 14
    79e4:	8c 83       	std	Y+4, r24	; 0x04
    79e6:	1a 83       	std	Y+2, r17	; 0x02
    79e8:	09 83       	std	Y+1, r16	; 0x01
    79ea:	8f ef       	ldi	r24, 0xFF	; 255
    79ec:	9f e7       	ldi	r25, 0x7F	; 127
    79ee:	9e 83       	std	Y+6, r25	; 0x06
    79f0:	8d 83       	std	Y+5, r24	; 0x05
    79f2:	ae 01       	movw	r20, r28
    79f4:	47 5e       	subi	r20, 0xE7	; 231
    79f6:	5f 4f       	sbci	r21, 0xFF	; 255
    79f8:	ce 01       	movw	r24, r28
    79fa:	01 96       	adiw	r24, 0x01	; 1
    79fc:	6f 89       	ldd	r22, Y+23	; 0x17
    79fe:	78 8d       	ldd	r23, Y+24	; 0x18
    7a00:	10 d0       	rcall	.+32     	; 0x7a22 <vfprintf>
    7a02:	ef 81       	ldd	r30, Y+7	; 0x07
    7a04:	f8 85       	ldd	r31, Y+8	; 0x08
    7a06:	e0 0f       	add	r30, r16
    7a08:	f1 1f       	adc	r31, r17
    7a0a:	10 82       	st	Z, r1
    7a0c:	2e 96       	adiw	r28, 0x0e	; 14
    7a0e:	0f b6       	in	r0, 0x3f	; 63
    7a10:	f8 94       	cli
    7a12:	de bf       	out	0x3e, r29	; 62
    7a14:	0f be       	out	0x3f, r0	; 63
    7a16:	cd bf       	out	0x3d, r28	; 61
    7a18:	df 91       	pop	r29
    7a1a:	cf 91       	pop	r28
    7a1c:	1f 91       	pop	r17
    7a1e:	0f 91       	pop	r16
    7a20:	08 95       	ret

00007a22 <vfprintf>:
    7a22:	2f 92       	push	r2
    7a24:	3f 92       	push	r3
    7a26:	4f 92       	push	r4
    7a28:	5f 92       	push	r5
    7a2a:	6f 92       	push	r6
    7a2c:	7f 92       	push	r7
    7a2e:	8f 92       	push	r8
    7a30:	9f 92       	push	r9
    7a32:	af 92       	push	r10
    7a34:	bf 92       	push	r11
    7a36:	cf 92       	push	r12
    7a38:	df 92       	push	r13
    7a3a:	ef 92       	push	r14
    7a3c:	ff 92       	push	r15
    7a3e:	0f 93       	push	r16
    7a40:	1f 93       	push	r17
    7a42:	cf 93       	push	r28
    7a44:	df 93       	push	r29
    7a46:	cd b7       	in	r28, 0x3d	; 61
    7a48:	de b7       	in	r29, 0x3e	; 62
    7a4a:	2d 97       	sbiw	r28, 0x0d	; 13
    7a4c:	0f b6       	in	r0, 0x3f	; 63
    7a4e:	f8 94       	cli
    7a50:	de bf       	out	0x3e, r29	; 62
    7a52:	0f be       	out	0x3f, r0	; 63
    7a54:	cd bf       	out	0x3d, r28	; 61
    7a56:	3c 01       	movw	r6, r24
    7a58:	7d 87       	std	Y+13, r23	; 0x0d
    7a5a:	6c 87       	std	Y+12, r22	; 0x0c
    7a5c:	5a 01       	movw	r10, r20
    7a5e:	fc 01       	movw	r30, r24
    7a60:	17 82       	std	Z+7, r1	; 0x07
    7a62:	16 82       	std	Z+6, r1	; 0x06
    7a64:	83 81       	ldd	r24, Z+3	; 0x03
    7a66:	81 ff       	sbrs	r24, 1
    7a68:	bb c1       	rjmp	.+886    	; 0x7de0 <vfprintf+0x3be>
    7a6a:	2e 01       	movw	r4, r28
    7a6c:	08 94       	sec
    7a6e:	41 1c       	adc	r4, r1
    7a70:	51 1c       	adc	r5, r1
    7a72:	f3 01       	movw	r30, r6
    7a74:	93 81       	ldd	r25, Z+3	; 0x03
    7a76:	ec 85       	ldd	r30, Y+12	; 0x0c
    7a78:	fd 85       	ldd	r31, Y+13	; 0x0d
    7a7a:	93 fd       	sbrc	r25, 3
    7a7c:	85 91       	lpm	r24, Z+
    7a7e:	93 ff       	sbrs	r25, 3
    7a80:	81 91       	ld	r24, Z+
    7a82:	fd 87       	std	Y+13, r31	; 0x0d
    7a84:	ec 87       	std	Y+12, r30	; 0x0c
    7a86:	88 23       	and	r24, r24
    7a88:	09 f4       	brne	.+2      	; 0x7a8c <vfprintf+0x6a>
    7a8a:	a6 c1       	rjmp	.+844    	; 0x7dd8 <vfprintf+0x3b6>
    7a8c:	85 32       	cpi	r24, 0x25	; 37
    7a8e:	41 f4       	brne	.+16     	; 0x7aa0 <vfprintf+0x7e>
    7a90:	93 fd       	sbrc	r25, 3
    7a92:	85 91       	lpm	r24, Z+
    7a94:	93 ff       	sbrs	r25, 3
    7a96:	81 91       	ld	r24, Z+
    7a98:	fd 87       	std	Y+13, r31	; 0x0d
    7a9a:	ec 87       	std	Y+12, r30	; 0x0c
    7a9c:	85 32       	cpi	r24, 0x25	; 37
    7a9e:	21 f4       	brne	.+8      	; 0x7aa8 <vfprintf+0x86>
    7aa0:	90 e0       	ldi	r25, 0x00	; 0
    7aa2:	b3 01       	movw	r22, r6
    7aa4:	ce d1       	rcall	.+924    	; 0x7e42 <fputc>
    7aa6:	e5 cf       	rjmp	.-54     	; 0x7a72 <vfprintf+0x50>
    7aa8:	ff 24       	eor	r15, r15
    7aaa:	ee 24       	eor	r14, r14
    7aac:	10 e0       	ldi	r17, 0x00	; 0
    7aae:	10 32       	cpi	r17, 0x20	; 32
    7ab0:	b0 f4       	brcc	.+44     	; 0x7ade <vfprintf+0xbc>
    7ab2:	8b 32       	cpi	r24, 0x2B	; 43
    7ab4:	69 f0       	breq	.+26     	; 0x7ad0 <vfprintf+0xae>
    7ab6:	8c 32       	cpi	r24, 0x2C	; 44
    7ab8:	28 f4       	brcc	.+10     	; 0x7ac4 <vfprintf+0xa2>
    7aba:	80 32       	cpi	r24, 0x20	; 32
    7abc:	51 f0       	breq	.+20     	; 0x7ad2 <vfprintf+0xb0>
    7abe:	83 32       	cpi	r24, 0x23	; 35
    7ac0:	71 f4       	brne	.+28     	; 0x7ade <vfprintf+0xbc>
    7ac2:	0b c0       	rjmp	.+22     	; 0x7ada <vfprintf+0xb8>
    7ac4:	8d 32       	cpi	r24, 0x2D	; 45
    7ac6:	39 f0       	breq	.+14     	; 0x7ad6 <vfprintf+0xb4>
    7ac8:	80 33       	cpi	r24, 0x30	; 48
    7aca:	49 f4       	brne	.+18     	; 0x7ade <vfprintf+0xbc>
    7acc:	11 60       	ori	r17, 0x01	; 1
    7ace:	2c c0       	rjmp	.+88     	; 0x7b28 <vfprintf+0x106>
    7ad0:	12 60       	ori	r17, 0x02	; 2
    7ad2:	14 60       	ori	r17, 0x04	; 4
    7ad4:	29 c0       	rjmp	.+82     	; 0x7b28 <vfprintf+0x106>
    7ad6:	18 60       	ori	r17, 0x08	; 8
    7ad8:	27 c0       	rjmp	.+78     	; 0x7b28 <vfprintf+0x106>
    7ada:	10 61       	ori	r17, 0x10	; 16
    7adc:	25 c0       	rjmp	.+74     	; 0x7b28 <vfprintf+0x106>
    7ade:	17 fd       	sbrc	r17, 7
    7ae0:	2e c0       	rjmp	.+92     	; 0x7b3e <vfprintf+0x11c>
    7ae2:	28 2f       	mov	r18, r24
    7ae4:	20 53       	subi	r18, 0x30	; 48
    7ae6:	2a 30       	cpi	r18, 0x0A	; 10
    7ae8:	98 f4       	brcc	.+38     	; 0x7b10 <vfprintf+0xee>
    7aea:	16 ff       	sbrs	r17, 6
    7aec:	08 c0       	rjmp	.+16     	; 0x7afe <vfprintf+0xdc>
    7aee:	8f 2d       	mov	r24, r15
    7af0:	88 0f       	add	r24, r24
    7af2:	f8 2e       	mov	r15, r24
    7af4:	ff 0c       	add	r15, r15
    7af6:	ff 0c       	add	r15, r15
    7af8:	f8 0e       	add	r15, r24
    7afa:	f2 0e       	add	r15, r18
    7afc:	15 c0       	rjmp	.+42     	; 0x7b28 <vfprintf+0x106>
    7afe:	8e 2d       	mov	r24, r14
    7b00:	88 0f       	add	r24, r24
    7b02:	e8 2e       	mov	r14, r24
    7b04:	ee 0c       	add	r14, r14
    7b06:	ee 0c       	add	r14, r14
    7b08:	e8 0e       	add	r14, r24
    7b0a:	e2 0e       	add	r14, r18
    7b0c:	10 62       	ori	r17, 0x20	; 32
    7b0e:	0c c0       	rjmp	.+24     	; 0x7b28 <vfprintf+0x106>
    7b10:	8e 32       	cpi	r24, 0x2E	; 46
    7b12:	21 f4       	brne	.+8      	; 0x7b1c <vfprintf+0xfa>
    7b14:	16 fd       	sbrc	r17, 6
    7b16:	60 c1       	rjmp	.+704    	; 0x7dd8 <vfprintf+0x3b6>
    7b18:	10 64       	ori	r17, 0x40	; 64
    7b1a:	06 c0       	rjmp	.+12     	; 0x7b28 <vfprintf+0x106>
    7b1c:	8c 36       	cpi	r24, 0x6C	; 108
    7b1e:	11 f4       	brne	.+4      	; 0x7b24 <vfprintf+0x102>
    7b20:	10 68       	ori	r17, 0x80	; 128
    7b22:	02 c0       	rjmp	.+4      	; 0x7b28 <vfprintf+0x106>
    7b24:	88 36       	cpi	r24, 0x68	; 104
    7b26:	59 f4       	brne	.+22     	; 0x7b3e <vfprintf+0x11c>
    7b28:	ec 85       	ldd	r30, Y+12	; 0x0c
    7b2a:	fd 85       	ldd	r31, Y+13	; 0x0d
    7b2c:	93 fd       	sbrc	r25, 3
    7b2e:	85 91       	lpm	r24, Z+
    7b30:	93 ff       	sbrs	r25, 3
    7b32:	81 91       	ld	r24, Z+
    7b34:	fd 87       	std	Y+13, r31	; 0x0d
    7b36:	ec 87       	std	Y+12, r30	; 0x0c
    7b38:	88 23       	and	r24, r24
    7b3a:	09 f0       	breq	.+2      	; 0x7b3e <vfprintf+0x11c>
    7b3c:	b8 cf       	rjmp	.-144    	; 0x7aae <vfprintf+0x8c>
    7b3e:	98 2f       	mov	r25, r24
    7b40:	95 54       	subi	r25, 0x45	; 69
    7b42:	93 30       	cpi	r25, 0x03	; 3
    7b44:	18 f0       	brcs	.+6      	; 0x7b4c <vfprintf+0x12a>
    7b46:	90 52       	subi	r25, 0x20	; 32
    7b48:	93 30       	cpi	r25, 0x03	; 3
    7b4a:	38 f4       	brcc	.+14     	; 0x7b5a <vfprintf+0x138>
    7b4c:	24 e0       	ldi	r18, 0x04	; 4
    7b4e:	30 e0       	ldi	r19, 0x00	; 0
    7b50:	a2 0e       	add	r10, r18
    7b52:	b3 1e       	adc	r11, r19
    7b54:	3f e3       	ldi	r19, 0x3F	; 63
    7b56:	39 83       	std	Y+1, r19	; 0x01
    7b58:	0f c0       	rjmp	.+30     	; 0x7b78 <vfprintf+0x156>
    7b5a:	83 36       	cpi	r24, 0x63	; 99
    7b5c:	31 f0       	breq	.+12     	; 0x7b6a <vfprintf+0x148>
    7b5e:	83 37       	cpi	r24, 0x73	; 115
    7b60:	81 f0       	breq	.+32     	; 0x7b82 <vfprintf+0x160>
    7b62:	83 35       	cpi	r24, 0x53	; 83
    7b64:	09 f0       	breq	.+2      	; 0x7b68 <vfprintf+0x146>
    7b66:	56 c0       	rjmp	.+172    	; 0x7c14 <vfprintf+0x1f2>
    7b68:	21 c0       	rjmp	.+66     	; 0x7bac <vfprintf+0x18a>
    7b6a:	f5 01       	movw	r30, r10
    7b6c:	80 81       	ld	r24, Z
    7b6e:	89 83       	std	Y+1, r24	; 0x01
    7b70:	22 e0       	ldi	r18, 0x02	; 2
    7b72:	30 e0       	ldi	r19, 0x00	; 0
    7b74:	a2 0e       	add	r10, r18
    7b76:	b3 1e       	adc	r11, r19
    7b78:	21 e0       	ldi	r18, 0x01	; 1
    7b7a:	c2 2e       	mov	r12, r18
    7b7c:	d1 2c       	mov	r13, r1
    7b7e:	42 01       	movw	r8, r4
    7b80:	13 c0       	rjmp	.+38     	; 0x7ba8 <vfprintf+0x186>
    7b82:	92 e0       	ldi	r25, 0x02	; 2
    7b84:	29 2e       	mov	r2, r25
    7b86:	31 2c       	mov	r3, r1
    7b88:	2a 0c       	add	r2, r10
    7b8a:	3b 1c       	adc	r3, r11
    7b8c:	f5 01       	movw	r30, r10
    7b8e:	80 80       	ld	r8, Z
    7b90:	91 80       	ldd	r9, Z+1	; 0x01
    7b92:	16 ff       	sbrs	r17, 6
    7b94:	03 c0       	rjmp	.+6      	; 0x7b9c <vfprintf+0x17a>
    7b96:	6f 2d       	mov	r22, r15
    7b98:	70 e0       	ldi	r23, 0x00	; 0
    7b9a:	02 c0       	rjmp	.+4      	; 0x7ba0 <vfprintf+0x17e>
    7b9c:	6f ef       	ldi	r22, 0xFF	; 255
    7b9e:	7f ef       	ldi	r23, 0xFF	; 255
    7ba0:	c4 01       	movw	r24, r8
    7ba2:	44 d1       	rcall	.+648    	; 0x7e2c <strnlen>
    7ba4:	6c 01       	movw	r12, r24
    7ba6:	51 01       	movw	r10, r2
    7ba8:	1f 77       	andi	r17, 0x7F	; 127
    7baa:	14 c0       	rjmp	.+40     	; 0x7bd4 <vfprintf+0x1b2>
    7bac:	82 e0       	ldi	r24, 0x02	; 2
    7bae:	28 2e       	mov	r2, r24
    7bb0:	31 2c       	mov	r3, r1
    7bb2:	2a 0c       	add	r2, r10
    7bb4:	3b 1c       	adc	r3, r11
    7bb6:	f5 01       	movw	r30, r10
    7bb8:	80 80       	ld	r8, Z
    7bba:	91 80       	ldd	r9, Z+1	; 0x01
    7bbc:	16 ff       	sbrs	r17, 6
    7bbe:	03 c0       	rjmp	.+6      	; 0x7bc6 <vfprintf+0x1a4>
    7bc0:	6f 2d       	mov	r22, r15
    7bc2:	70 e0       	ldi	r23, 0x00	; 0
    7bc4:	02 c0       	rjmp	.+4      	; 0x7bca <vfprintf+0x1a8>
    7bc6:	6f ef       	ldi	r22, 0xFF	; 255
    7bc8:	7f ef       	ldi	r23, 0xFF	; 255
    7bca:	c4 01       	movw	r24, r8
    7bcc:	24 d1       	rcall	.+584    	; 0x7e16 <strnlen_P>
    7bce:	6c 01       	movw	r12, r24
    7bd0:	10 68       	ori	r17, 0x80	; 128
    7bd2:	51 01       	movw	r10, r2
    7bd4:	13 fd       	sbrc	r17, 3
    7bd6:	1a c0       	rjmp	.+52     	; 0x7c0c <vfprintf+0x1ea>
    7bd8:	05 c0       	rjmp	.+10     	; 0x7be4 <vfprintf+0x1c2>
    7bda:	80 e2       	ldi	r24, 0x20	; 32
    7bdc:	90 e0       	ldi	r25, 0x00	; 0
    7bde:	b3 01       	movw	r22, r6
    7be0:	30 d1       	rcall	.+608    	; 0x7e42 <fputc>
    7be2:	ea 94       	dec	r14
    7be4:	8e 2d       	mov	r24, r14
    7be6:	90 e0       	ldi	r25, 0x00	; 0
    7be8:	c8 16       	cp	r12, r24
    7bea:	d9 06       	cpc	r13, r25
    7bec:	b0 f3       	brcs	.-20     	; 0x7bda <vfprintf+0x1b8>
    7bee:	0e c0       	rjmp	.+28     	; 0x7c0c <vfprintf+0x1ea>
    7bf0:	f4 01       	movw	r30, r8
    7bf2:	17 fd       	sbrc	r17, 7
    7bf4:	85 91       	lpm	r24, Z+
    7bf6:	17 ff       	sbrs	r17, 7
    7bf8:	81 91       	ld	r24, Z+
    7bfa:	4f 01       	movw	r8, r30
    7bfc:	90 e0       	ldi	r25, 0x00	; 0
    7bfe:	b3 01       	movw	r22, r6
    7c00:	20 d1       	rcall	.+576    	; 0x7e42 <fputc>
    7c02:	e1 10       	cpse	r14, r1
    7c04:	ea 94       	dec	r14
    7c06:	08 94       	sec
    7c08:	c1 08       	sbc	r12, r1
    7c0a:	d1 08       	sbc	r13, r1
    7c0c:	c1 14       	cp	r12, r1
    7c0e:	d1 04       	cpc	r13, r1
    7c10:	79 f7       	brne	.-34     	; 0x7bf0 <vfprintf+0x1ce>
    7c12:	df c0       	rjmp	.+446    	; 0x7dd2 <vfprintf+0x3b0>
    7c14:	84 36       	cpi	r24, 0x64	; 100
    7c16:	11 f0       	breq	.+4      	; 0x7c1c <vfprintf+0x1fa>
    7c18:	89 36       	cpi	r24, 0x69	; 105
    7c1a:	49 f5       	brne	.+82     	; 0x7c6e <vfprintf+0x24c>
    7c1c:	f5 01       	movw	r30, r10
    7c1e:	17 ff       	sbrs	r17, 7
    7c20:	07 c0       	rjmp	.+14     	; 0x7c30 <vfprintf+0x20e>
    7c22:	80 81       	ld	r24, Z
    7c24:	91 81       	ldd	r25, Z+1	; 0x01
    7c26:	a2 81       	ldd	r26, Z+2	; 0x02
    7c28:	b3 81       	ldd	r27, Z+3	; 0x03
    7c2a:	24 e0       	ldi	r18, 0x04	; 4
    7c2c:	30 e0       	ldi	r19, 0x00	; 0
    7c2e:	08 c0       	rjmp	.+16     	; 0x7c40 <vfprintf+0x21e>
    7c30:	80 81       	ld	r24, Z
    7c32:	91 81       	ldd	r25, Z+1	; 0x01
    7c34:	aa 27       	eor	r26, r26
    7c36:	97 fd       	sbrc	r25, 7
    7c38:	a0 95       	com	r26
    7c3a:	ba 2f       	mov	r27, r26
    7c3c:	22 e0       	ldi	r18, 0x02	; 2
    7c3e:	30 e0       	ldi	r19, 0x00	; 0
    7c40:	a2 0e       	add	r10, r18
    7c42:	b3 1e       	adc	r11, r19
    7c44:	01 2f       	mov	r16, r17
    7c46:	0f 76       	andi	r16, 0x6F	; 111
    7c48:	b7 ff       	sbrs	r27, 7
    7c4a:	08 c0       	rjmp	.+16     	; 0x7c5c <vfprintf+0x23a>
    7c4c:	b0 95       	com	r27
    7c4e:	a0 95       	com	r26
    7c50:	90 95       	com	r25
    7c52:	81 95       	neg	r24
    7c54:	9f 4f       	sbci	r25, 0xFF	; 255
    7c56:	af 4f       	sbci	r26, 0xFF	; 255
    7c58:	bf 4f       	sbci	r27, 0xFF	; 255
    7c5a:	00 68       	ori	r16, 0x80	; 128
    7c5c:	bc 01       	movw	r22, r24
    7c5e:	cd 01       	movw	r24, r26
    7c60:	a2 01       	movw	r20, r4
    7c62:	2a e0       	ldi	r18, 0x0A	; 10
    7c64:	30 e0       	ldi	r19, 0x00	; 0
    7c66:	19 d1       	rcall	.+562    	; 0x7e9a <__ultoa_invert>
    7c68:	d8 2e       	mov	r13, r24
    7c6a:	d4 18       	sub	r13, r4
    7c6c:	3e c0       	rjmp	.+124    	; 0x7cea <vfprintf+0x2c8>
    7c6e:	85 37       	cpi	r24, 0x75	; 117
    7c70:	21 f4       	brne	.+8      	; 0x7c7a <vfprintf+0x258>
    7c72:	1f 7e       	andi	r17, 0xEF	; 239
    7c74:	2a e0       	ldi	r18, 0x0A	; 10
    7c76:	30 e0       	ldi	r19, 0x00	; 0
    7c78:	20 c0       	rjmp	.+64     	; 0x7cba <vfprintf+0x298>
    7c7a:	19 7f       	andi	r17, 0xF9	; 249
    7c7c:	8f 36       	cpi	r24, 0x6F	; 111
    7c7e:	a9 f0       	breq	.+42     	; 0x7caa <vfprintf+0x288>
    7c80:	80 37       	cpi	r24, 0x70	; 112
    7c82:	20 f4       	brcc	.+8      	; 0x7c8c <vfprintf+0x26a>
    7c84:	88 35       	cpi	r24, 0x58	; 88
    7c86:	09 f0       	breq	.+2      	; 0x7c8a <vfprintf+0x268>
    7c88:	a7 c0       	rjmp	.+334    	; 0x7dd8 <vfprintf+0x3b6>
    7c8a:	0b c0       	rjmp	.+22     	; 0x7ca2 <vfprintf+0x280>
    7c8c:	80 37       	cpi	r24, 0x70	; 112
    7c8e:	21 f0       	breq	.+8      	; 0x7c98 <vfprintf+0x276>
    7c90:	88 37       	cpi	r24, 0x78	; 120
    7c92:	09 f0       	breq	.+2      	; 0x7c96 <vfprintf+0x274>
    7c94:	a1 c0       	rjmp	.+322    	; 0x7dd8 <vfprintf+0x3b6>
    7c96:	01 c0       	rjmp	.+2      	; 0x7c9a <vfprintf+0x278>
    7c98:	10 61       	ori	r17, 0x10	; 16
    7c9a:	14 ff       	sbrs	r17, 4
    7c9c:	09 c0       	rjmp	.+18     	; 0x7cb0 <vfprintf+0x28e>
    7c9e:	14 60       	ori	r17, 0x04	; 4
    7ca0:	07 c0       	rjmp	.+14     	; 0x7cb0 <vfprintf+0x28e>
    7ca2:	14 ff       	sbrs	r17, 4
    7ca4:	08 c0       	rjmp	.+16     	; 0x7cb6 <vfprintf+0x294>
    7ca6:	16 60       	ori	r17, 0x06	; 6
    7ca8:	06 c0       	rjmp	.+12     	; 0x7cb6 <vfprintf+0x294>
    7caa:	28 e0       	ldi	r18, 0x08	; 8
    7cac:	30 e0       	ldi	r19, 0x00	; 0
    7cae:	05 c0       	rjmp	.+10     	; 0x7cba <vfprintf+0x298>
    7cb0:	20 e1       	ldi	r18, 0x10	; 16
    7cb2:	30 e0       	ldi	r19, 0x00	; 0
    7cb4:	02 c0       	rjmp	.+4      	; 0x7cba <vfprintf+0x298>
    7cb6:	20 e1       	ldi	r18, 0x10	; 16
    7cb8:	32 e0       	ldi	r19, 0x02	; 2
    7cba:	f5 01       	movw	r30, r10
    7cbc:	17 ff       	sbrs	r17, 7
    7cbe:	07 c0       	rjmp	.+14     	; 0x7cce <vfprintf+0x2ac>
    7cc0:	60 81       	ld	r22, Z
    7cc2:	71 81       	ldd	r23, Z+1	; 0x01
    7cc4:	82 81       	ldd	r24, Z+2	; 0x02
    7cc6:	93 81       	ldd	r25, Z+3	; 0x03
    7cc8:	44 e0       	ldi	r20, 0x04	; 4
    7cca:	50 e0       	ldi	r21, 0x00	; 0
    7ccc:	06 c0       	rjmp	.+12     	; 0x7cda <vfprintf+0x2b8>
    7cce:	60 81       	ld	r22, Z
    7cd0:	71 81       	ldd	r23, Z+1	; 0x01
    7cd2:	80 e0       	ldi	r24, 0x00	; 0
    7cd4:	90 e0       	ldi	r25, 0x00	; 0
    7cd6:	42 e0       	ldi	r20, 0x02	; 2
    7cd8:	50 e0       	ldi	r21, 0x00	; 0
    7cda:	a4 0e       	add	r10, r20
    7cdc:	b5 1e       	adc	r11, r21
    7cde:	a2 01       	movw	r20, r4
    7ce0:	dc d0       	rcall	.+440    	; 0x7e9a <__ultoa_invert>
    7ce2:	d8 2e       	mov	r13, r24
    7ce4:	d4 18       	sub	r13, r4
    7ce6:	01 2f       	mov	r16, r17
    7ce8:	0f 77       	andi	r16, 0x7F	; 127
    7cea:	06 ff       	sbrs	r16, 6
    7cec:	09 c0       	rjmp	.+18     	; 0x7d00 <vfprintf+0x2de>
    7cee:	0e 7f       	andi	r16, 0xFE	; 254
    7cf0:	df 14       	cp	r13, r15
    7cf2:	30 f4       	brcc	.+12     	; 0x7d00 <vfprintf+0x2de>
    7cf4:	04 ff       	sbrs	r16, 4
    7cf6:	06 c0       	rjmp	.+12     	; 0x7d04 <vfprintf+0x2e2>
    7cf8:	02 fd       	sbrc	r16, 2
    7cfa:	04 c0       	rjmp	.+8      	; 0x7d04 <vfprintf+0x2e2>
    7cfc:	0f 7e       	andi	r16, 0xEF	; 239
    7cfe:	02 c0       	rjmp	.+4      	; 0x7d04 <vfprintf+0x2e2>
    7d00:	1d 2d       	mov	r17, r13
    7d02:	01 c0       	rjmp	.+2      	; 0x7d06 <vfprintf+0x2e4>
    7d04:	1f 2d       	mov	r17, r15
    7d06:	80 2f       	mov	r24, r16
    7d08:	90 e0       	ldi	r25, 0x00	; 0
    7d0a:	04 ff       	sbrs	r16, 4
    7d0c:	0c c0       	rjmp	.+24     	; 0x7d26 <vfprintf+0x304>
    7d0e:	fe 01       	movw	r30, r28
    7d10:	ed 0d       	add	r30, r13
    7d12:	f1 1d       	adc	r31, r1
    7d14:	20 81       	ld	r18, Z
    7d16:	20 33       	cpi	r18, 0x30	; 48
    7d18:	11 f4       	brne	.+4      	; 0x7d1e <vfprintf+0x2fc>
    7d1a:	09 7e       	andi	r16, 0xE9	; 233
    7d1c:	09 c0       	rjmp	.+18     	; 0x7d30 <vfprintf+0x30e>
    7d1e:	02 ff       	sbrs	r16, 2
    7d20:	06 c0       	rjmp	.+12     	; 0x7d2e <vfprintf+0x30c>
    7d22:	1e 5f       	subi	r17, 0xFE	; 254
    7d24:	05 c0       	rjmp	.+10     	; 0x7d30 <vfprintf+0x30e>
    7d26:	86 78       	andi	r24, 0x86	; 134
    7d28:	90 70       	andi	r25, 0x00	; 0
    7d2a:	00 97       	sbiw	r24, 0x00	; 0
    7d2c:	09 f0       	breq	.+2      	; 0x7d30 <vfprintf+0x30e>
    7d2e:	1f 5f       	subi	r17, 0xFF	; 255
    7d30:	80 2e       	mov	r8, r16
    7d32:	99 24       	eor	r9, r9
    7d34:	03 fd       	sbrc	r16, 3
    7d36:	11 c0       	rjmp	.+34     	; 0x7d5a <vfprintf+0x338>
    7d38:	00 ff       	sbrs	r16, 0
    7d3a:	0c c0       	rjmp	.+24     	; 0x7d54 <vfprintf+0x332>
    7d3c:	fd 2c       	mov	r15, r13
    7d3e:	1e 15       	cp	r17, r14
    7d40:	48 f4       	brcc	.+18     	; 0x7d54 <vfprintf+0x332>
    7d42:	fe 0c       	add	r15, r14
    7d44:	f1 1a       	sub	r15, r17
    7d46:	1e 2d       	mov	r17, r14
    7d48:	05 c0       	rjmp	.+10     	; 0x7d54 <vfprintf+0x332>
    7d4a:	80 e2       	ldi	r24, 0x20	; 32
    7d4c:	90 e0       	ldi	r25, 0x00	; 0
    7d4e:	b3 01       	movw	r22, r6
    7d50:	78 d0       	rcall	.+240    	; 0x7e42 <fputc>
    7d52:	1f 5f       	subi	r17, 0xFF	; 255
    7d54:	1e 15       	cp	r17, r14
    7d56:	c8 f3       	brcs	.-14     	; 0x7d4a <vfprintf+0x328>
    7d58:	04 c0       	rjmp	.+8      	; 0x7d62 <vfprintf+0x340>
    7d5a:	1e 15       	cp	r17, r14
    7d5c:	10 f4       	brcc	.+4      	; 0x7d62 <vfprintf+0x340>
    7d5e:	e1 1a       	sub	r14, r17
    7d60:	01 c0       	rjmp	.+2      	; 0x7d64 <vfprintf+0x342>
    7d62:	ee 24       	eor	r14, r14
    7d64:	84 fe       	sbrs	r8, 4
    7d66:	0e c0       	rjmp	.+28     	; 0x7d84 <vfprintf+0x362>
    7d68:	80 e3       	ldi	r24, 0x30	; 48
    7d6a:	90 e0       	ldi	r25, 0x00	; 0
    7d6c:	b3 01       	movw	r22, r6
    7d6e:	69 d0       	rcall	.+210    	; 0x7e42 <fputc>
    7d70:	82 fe       	sbrs	r8, 2
    7d72:	1d c0       	rjmp	.+58     	; 0x7dae <vfprintf+0x38c>
    7d74:	81 fe       	sbrs	r8, 1
    7d76:	03 c0       	rjmp	.+6      	; 0x7d7e <vfprintf+0x35c>
    7d78:	88 e5       	ldi	r24, 0x58	; 88
    7d7a:	90 e0       	ldi	r25, 0x00	; 0
    7d7c:	10 c0       	rjmp	.+32     	; 0x7d9e <vfprintf+0x37c>
    7d7e:	88 e7       	ldi	r24, 0x78	; 120
    7d80:	90 e0       	ldi	r25, 0x00	; 0
    7d82:	0d c0       	rjmp	.+26     	; 0x7d9e <vfprintf+0x37c>
    7d84:	c4 01       	movw	r24, r8
    7d86:	86 78       	andi	r24, 0x86	; 134
    7d88:	90 70       	andi	r25, 0x00	; 0
    7d8a:	00 97       	sbiw	r24, 0x00	; 0
    7d8c:	81 f0       	breq	.+32     	; 0x7dae <vfprintf+0x38c>
    7d8e:	81 fc       	sbrc	r8, 1
    7d90:	02 c0       	rjmp	.+4      	; 0x7d96 <vfprintf+0x374>
    7d92:	80 e2       	ldi	r24, 0x20	; 32
    7d94:	01 c0       	rjmp	.+2      	; 0x7d98 <vfprintf+0x376>
    7d96:	8b e2       	ldi	r24, 0x2B	; 43
    7d98:	07 fd       	sbrc	r16, 7
    7d9a:	8d e2       	ldi	r24, 0x2D	; 45
    7d9c:	90 e0       	ldi	r25, 0x00	; 0
    7d9e:	b3 01       	movw	r22, r6
    7da0:	50 d0       	rcall	.+160    	; 0x7e42 <fputc>
    7da2:	05 c0       	rjmp	.+10     	; 0x7dae <vfprintf+0x38c>
    7da4:	80 e3       	ldi	r24, 0x30	; 48
    7da6:	90 e0       	ldi	r25, 0x00	; 0
    7da8:	b3 01       	movw	r22, r6
    7daa:	4b d0       	rcall	.+150    	; 0x7e42 <fputc>
    7dac:	fa 94       	dec	r15
    7dae:	df 14       	cp	r13, r15
    7db0:	c8 f3       	brcs	.-14     	; 0x7da4 <vfprintf+0x382>
    7db2:	da 94       	dec	r13
    7db4:	f2 01       	movw	r30, r4
    7db6:	ed 0d       	add	r30, r13
    7db8:	f1 1d       	adc	r31, r1
    7dba:	80 81       	ld	r24, Z
    7dbc:	90 e0       	ldi	r25, 0x00	; 0
    7dbe:	b3 01       	movw	r22, r6
    7dc0:	40 d0       	rcall	.+128    	; 0x7e42 <fputc>
    7dc2:	dd 20       	and	r13, r13
    7dc4:	b1 f7       	brne	.-20     	; 0x7db2 <vfprintf+0x390>
    7dc6:	05 c0       	rjmp	.+10     	; 0x7dd2 <vfprintf+0x3b0>
    7dc8:	80 e2       	ldi	r24, 0x20	; 32
    7dca:	90 e0       	ldi	r25, 0x00	; 0
    7dcc:	b3 01       	movw	r22, r6
    7dce:	39 d0       	rcall	.+114    	; 0x7e42 <fputc>
    7dd0:	ea 94       	dec	r14
    7dd2:	ee 20       	and	r14, r14
    7dd4:	c9 f7       	brne	.-14     	; 0x7dc8 <vfprintf+0x3a6>
    7dd6:	4d ce       	rjmp	.-870    	; 0x7a72 <vfprintf+0x50>
    7dd8:	f3 01       	movw	r30, r6
    7dda:	86 81       	ldd	r24, Z+6	; 0x06
    7ddc:	97 81       	ldd	r25, Z+7	; 0x07
    7dde:	02 c0       	rjmp	.+4      	; 0x7de4 <vfprintf+0x3c2>
    7de0:	8f ef       	ldi	r24, 0xFF	; 255
    7de2:	9f ef       	ldi	r25, 0xFF	; 255
    7de4:	2d 96       	adiw	r28, 0x0d	; 13
    7de6:	0f b6       	in	r0, 0x3f	; 63
    7de8:	f8 94       	cli
    7dea:	de bf       	out	0x3e, r29	; 62
    7dec:	0f be       	out	0x3f, r0	; 63
    7dee:	cd bf       	out	0x3d, r28	; 61
    7df0:	df 91       	pop	r29
    7df2:	cf 91       	pop	r28
    7df4:	1f 91       	pop	r17
    7df6:	0f 91       	pop	r16
    7df8:	ff 90       	pop	r15
    7dfa:	ef 90       	pop	r14
    7dfc:	df 90       	pop	r13
    7dfe:	cf 90       	pop	r12
    7e00:	bf 90       	pop	r11
    7e02:	af 90       	pop	r10
    7e04:	9f 90       	pop	r9
    7e06:	8f 90       	pop	r8
    7e08:	7f 90       	pop	r7
    7e0a:	6f 90       	pop	r6
    7e0c:	5f 90       	pop	r5
    7e0e:	4f 90       	pop	r4
    7e10:	3f 90       	pop	r3
    7e12:	2f 90       	pop	r2
    7e14:	08 95       	ret

00007e16 <strnlen_P>:
    7e16:	fc 01       	movw	r30, r24
    7e18:	05 90       	lpm	r0, Z+
    7e1a:	61 50       	subi	r22, 0x01	; 1
    7e1c:	70 40       	sbci	r23, 0x00	; 0
    7e1e:	01 10       	cpse	r0, r1
    7e20:	d8 f7       	brcc	.-10     	; 0x7e18 <strnlen_P+0x2>
    7e22:	80 95       	com	r24
    7e24:	90 95       	com	r25
    7e26:	8e 0f       	add	r24, r30
    7e28:	9f 1f       	adc	r25, r31
    7e2a:	08 95       	ret

00007e2c <strnlen>:
    7e2c:	fc 01       	movw	r30, r24
    7e2e:	61 50       	subi	r22, 0x01	; 1
    7e30:	70 40       	sbci	r23, 0x00	; 0
    7e32:	01 90       	ld	r0, Z+
    7e34:	01 10       	cpse	r0, r1
    7e36:	d8 f7       	brcc	.-10     	; 0x7e2e <strnlen+0x2>
    7e38:	80 95       	com	r24
    7e3a:	90 95       	com	r25
    7e3c:	8e 0f       	add	r24, r30
    7e3e:	9f 1f       	adc	r25, r31
    7e40:	08 95       	ret

00007e42 <fputc>:
    7e42:	0f 93       	push	r16
    7e44:	1f 93       	push	r17
    7e46:	cf 93       	push	r28
    7e48:	df 93       	push	r29
    7e4a:	8c 01       	movw	r16, r24
    7e4c:	eb 01       	movw	r28, r22
    7e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    7e50:	81 ff       	sbrs	r24, 1
    7e52:	1b c0       	rjmp	.+54     	; 0x7e8a <fputc+0x48>
    7e54:	82 ff       	sbrs	r24, 2
    7e56:	0d c0       	rjmp	.+26     	; 0x7e72 <fputc+0x30>
    7e58:	2e 81       	ldd	r18, Y+6	; 0x06
    7e5a:	3f 81       	ldd	r19, Y+7	; 0x07
    7e5c:	8c 81       	ldd	r24, Y+4	; 0x04
    7e5e:	9d 81       	ldd	r25, Y+5	; 0x05
    7e60:	28 17       	cp	r18, r24
    7e62:	39 07       	cpc	r19, r25
    7e64:	64 f4       	brge	.+24     	; 0x7e7e <fputc+0x3c>
    7e66:	e8 81       	ld	r30, Y
    7e68:	f9 81       	ldd	r31, Y+1	; 0x01
    7e6a:	01 93       	st	Z+, r16
    7e6c:	f9 83       	std	Y+1, r31	; 0x01
    7e6e:	e8 83       	st	Y, r30
    7e70:	06 c0       	rjmp	.+12     	; 0x7e7e <fputc+0x3c>
    7e72:	e8 85       	ldd	r30, Y+8	; 0x08
    7e74:	f9 85       	ldd	r31, Y+9	; 0x09
    7e76:	80 2f       	mov	r24, r16
    7e78:	09 95       	icall
    7e7a:	00 97       	sbiw	r24, 0x00	; 0
    7e7c:	31 f4       	brne	.+12     	; 0x7e8a <fputc+0x48>
    7e7e:	8e 81       	ldd	r24, Y+6	; 0x06
    7e80:	9f 81       	ldd	r25, Y+7	; 0x07
    7e82:	01 96       	adiw	r24, 0x01	; 1
    7e84:	9f 83       	std	Y+7, r25	; 0x07
    7e86:	8e 83       	std	Y+6, r24	; 0x06
    7e88:	02 c0       	rjmp	.+4      	; 0x7e8e <fputc+0x4c>
    7e8a:	0f ef       	ldi	r16, 0xFF	; 255
    7e8c:	1f ef       	ldi	r17, 0xFF	; 255
    7e8e:	c8 01       	movw	r24, r16
    7e90:	df 91       	pop	r29
    7e92:	cf 91       	pop	r28
    7e94:	1f 91       	pop	r17
    7e96:	0f 91       	pop	r16
    7e98:	08 95       	ret

00007e9a <__ultoa_invert>:
    7e9a:	fa 01       	movw	r30, r20
    7e9c:	aa 27       	eor	r26, r26
    7e9e:	28 30       	cpi	r18, 0x08	; 8
    7ea0:	51 f1       	breq	.+84     	; 0x7ef6 <__ultoa_invert+0x5c>
    7ea2:	20 31       	cpi	r18, 0x10	; 16
    7ea4:	81 f1       	breq	.+96     	; 0x7f06 <__ultoa_invert+0x6c>
    7ea6:	e8 94       	clt
    7ea8:	6f 93       	push	r22
    7eaa:	6e 7f       	andi	r22, 0xFE	; 254
    7eac:	6e 5f       	subi	r22, 0xFE	; 254
    7eae:	7f 4f       	sbci	r23, 0xFF	; 255
    7eb0:	8f 4f       	sbci	r24, 0xFF	; 255
    7eb2:	9f 4f       	sbci	r25, 0xFF	; 255
    7eb4:	af 4f       	sbci	r26, 0xFF	; 255
    7eb6:	b1 e0       	ldi	r27, 0x01	; 1
    7eb8:	3e d0       	rcall	.+124    	; 0x7f36 <__ultoa_invert+0x9c>
    7eba:	b4 e0       	ldi	r27, 0x04	; 4
    7ebc:	3c d0       	rcall	.+120    	; 0x7f36 <__ultoa_invert+0x9c>
    7ebe:	67 0f       	add	r22, r23
    7ec0:	78 1f       	adc	r23, r24
    7ec2:	89 1f       	adc	r24, r25
    7ec4:	9a 1f       	adc	r25, r26
    7ec6:	a1 1d       	adc	r26, r1
    7ec8:	68 0f       	add	r22, r24
    7eca:	79 1f       	adc	r23, r25
    7ecc:	8a 1f       	adc	r24, r26
    7ece:	91 1d       	adc	r25, r1
    7ed0:	a1 1d       	adc	r26, r1
    7ed2:	6a 0f       	add	r22, r26
    7ed4:	71 1d       	adc	r23, r1
    7ed6:	81 1d       	adc	r24, r1
    7ed8:	91 1d       	adc	r25, r1
    7eda:	a1 1d       	adc	r26, r1
    7edc:	20 d0       	rcall	.+64     	; 0x7f1e <__ultoa_invert+0x84>
    7ede:	09 f4       	brne	.+2      	; 0x7ee2 <__ultoa_invert+0x48>
    7ee0:	68 94       	set
    7ee2:	3f 91       	pop	r19
    7ee4:	2a e0       	ldi	r18, 0x0A	; 10
    7ee6:	26 9f       	mul	r18, r22
    7ee8:	11 24       	eor	r1, r1
    7eea:	30 19       	sub	r19, r0
    7eec:	30 5d       	subi	r19, 0xD0	; 208
    7eee:	31 93       	st	Z+, r19
    7ef0:	de f6       	brtc	.-74     	; 0x7ea8 <__ultoa_invert+0xe>
    7ef2:	cf 01       	movw	r24, r30
    7ef4:	08 95       	ret
    7ef6:	46 2f       	mov	r20, r22
    7ef8:	47 70       	andi	r20, 0x07	; 7
    7efa:	40 5d       	subi	r20, 0xD0	; 208
    7efc:	41 93       	st	Z+, r20
    7efe:	b3 e0       	ldi	r27, 0x03	; 3
    7f00:	0f d0       	rcall	.+30     	; 0x7f20 <__ultoa_invert+0x86>
    7f02:	c9 f7       	brne	.-14     	; 0x7ef6 <__ultoa_invert+0x5c>
    7f04:	f6 cf       	rjmp	.-20     	; 0x7ef2 <__ultoa_invert+0x58>
    7f06:	46 2f       	mov	r20, r22
    7f08:	4f 70       	andi	r20, 0x0F	; 15
    7f0a:	40 5d       	subi	r20, 0xD0	; 208
    7f0c:	4a 33       	cpi	r20, 0x3A	; 58
    7f0e:	18 f0       	brcs	.+6      	; 0x7f16 <__ultoa_invert+0x7c>
    7f10:	49 5d       	subi	r20, 0xD9	; 217
    7f12:	31 fd       	sbrc	r19, 1
    7f14:	40 52       	subi	r20, 0x20	; 32
    7f16:	41 93       	st	Z+, r20
    7f18:	02 d0       	rcall	.+4      	; 0x7f1e <__ultoa_invert+0x84>
    7f1a:	a9 f7       	brne	.-22     	; 0x7f06 <__ultoa_invert+0x6c>
    7f1c:	ea cf       	rjmp	.-44     	; 0x7ef2 <__ultoa_invert+0x58>
    7f1e:	b4 e0       	ldi	r27, 0x04	; 4
    7f20:	a6 95       	lsr	r26
    7f22:	97 95       	ror	r25
    7f24:	87 95       	ror	r24
    7f26:	77 95       	ror	r23
    7f28:	67 95       	ror	r22
    7f2a:	ba 95       	dec	r27
    7f2c:	c9 f7       	brne	.-14     	; 0x7f20 <__ultoa_invert+0x86>
    7f2e:	00 97       	sbiw	r24, 0x00	; 0
    7f30:	61 05       	cpc	r22, r1
    7f32:	71 05       	cpc	r23, r1
    7f34:	08 95       	ret
    7f36:	9b 01       	movw	r18, r22
    7f38:	ac 01       	movw	r20, r24
    7f3a:	0a 2e       	mov	r0, r26
    7f3c:	06 94       	lsr	r0
    7f3e:	57 95       	ror	r21
    7f40:	47 95       	ror	r20
    7f42:	37 95       	ror	r19
    7f44:	27 95       	ror	r18
    7f46:	ba 95       	dec	r27
    7f48:	c9 f7       	brne	.-14     	; 0x7f3c <__ultoa_invert+0xa2>
    7f4a:	62 0f       	add	r22, r18
    7f4c:	73 1f       	adc	r23, r19
    7f4e:	84 1f       	adc	r24, r20
    7f50:	95 1f       	adc	r25, r21
    7f52:	a0 1d       	adc	r26, r0
    7f54:	08 95       	ret

00007f56 <_exit>:
    7f56:	f8 94       	cli

00007f58 <__stop_program>:
    7f58:	ff cf       	rjmp	.-2      	; 0x7f58 <__stop_program>
