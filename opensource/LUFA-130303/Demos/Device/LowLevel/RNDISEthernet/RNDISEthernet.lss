
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00002b1a  00002bae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b1a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012af  00800146  00800146  00002bf4  2**0
                  ALLOC
  3 .stab         00000d8c  00000000  00000000  00002bf4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000425  00000000  00000000  00003980  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000568  00000000  00000000  00003da8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000083ca  00000000  00000000  00004310  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000023c5  00000000  00000000  0000c6da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003c36  00000000  00000000  0000ea9f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e88  00000000  00000000  000126d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003632  00000000  00000000  00013560  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000053d7  00000000  00000000  00016b92  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000738  00000000  00000000  0001bf69  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	1d c2       	rjmp	.+1082   	; 0x43c <__ctors_end>
       2:	00 00       	nop
       4:	3a c2       	rjmp	.+1140   	; 0x47a <__bad_interrupt>
       6:	00 00       	nop
       8:	38 c2       	rjmp	.+1136   	; 0x47a <__bad_interrupt>
       a:	00 00       	nop
       c:	36 c2       	rjmp	.+1132   	; 0x47a <__bad_interrupt>
       e:	00 00       	nop
      10:	34 c2       	rjmp	.+1128   	; 0x47a <__bad_interrupt>
      12:	00 00       	nop
      14:	32 c2       	rjmp	.+1124   	; 0x47a <__bad_interrupt>
      16:	00 00       	nop
      18:	30 c2       	rjmp	.+1120   	; 0x47a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2e c2       	rjmp	.+1116   	; 0x47a <__bad_interrupt>
      1e:	00 00       	nop
      20:	2c c2       	rjmp	.+1112   	; 0x47a <__bad_interrupt>
      22:	00 00       	nop
      24:	2a c2       	rjmp	.+1108   	; 0x47a <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 a6 12 	jmp	0x254c	; 0x254c <__vector_10>
      2c:	26 c2       	rjmp	.+1100   	; 0x47a <__bad_interrupt>
      2e:	00 00       	nop
      30:	24 c2       	rjmp	.+1096   	; 0x47a <__bad_interrupt>
      32:	00 00       	nop
      34:	22 c2       	rjmp	.+1092   	; 0x47a <__bad_interrupt>
      36:	00 00       	nop
      38:	20 c2       	rjmp	.+1088   	; 0x47a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	1e c2       	rjmp	.+1084   	; 0x47a <__bad_interrupt>
      3e:	00 00       	nop
      40:	1c c2       	rjmp	.+1080   	; 0x47a <__bad_interrupt>
      42:	00 00       	nop
      44:	1a c2       	rjmp	.+1076   	; 0x47a <__bad_interrupt>
      46:	00 00       	nop
      48:	18 c2       	rjmp	.+1072   	; 0x47a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	16 c2       	rjmp	.+1068   	; 0x47a <__bad_interrupt>
      4e:	00 00       	nop
      50:	14 c2       	rjmp	.+1064   	; 0x47a <__bad_interrupt>
      52:	00 00       	nop
      54:	12 c2       	rjmp	.+1060   	; 0x47a <__bad_interrupt>
      56:	00 00       	nop
      58:	10 c2       	rjmp	.+1056   	; 0x47a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0e c2       	rjmp	.+1052   	; 0x47a <__bad_interrupt>
      5e:	00 00       	nop
      60:	0c c2       	rjmp	.+1048   	; 0x47a <__bad_interrupt>
      62:	00 00       	nop
      64:	0a c2       	rjmp	.+1044   	; 0x47a <__bad_interrupt>
      66:	00 00       	nop
      68:	08 c2       	rjmp	.+1040   	; 0x47a <__bad_interrupt>
      6a:	00 00       	nop
      6c:	06 c2       	rjmp	.+1036   	; 0x47a <__bad_interrupt>
      6e:	00 00       	nop
      70:	04 c2       	rjmp	.+1032   	; 0x47a <__bad_interrupt>
      72:	00 00       	nop
      74:	02 c2       	rjmp	.+1028   	; 0x47a <__bad_interrupt>
      76:	00 00       	nop
      78:	00 c2       	rjmp	.+1024   	; 0x47a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	fe c1       	rjmp	.+1020   	; 0x47a <__bad_interrupt>
      7e:	00 00       	nop
      80:	fc c1       	rjmp	.+1016   	; 0x47a <__bad_interrupt>
      82:	00 00       	nop
      84:	fa c1       	rjmp	.+1012   	; 0x47a <__bad_interrupt>
      86:	00 00       	nop
      88:	f8 c1       	rjmp	.+1008   	; 0x47a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	f6 c1       	rjmp	.+1004   	; 0x47a <__bad_interrupt>
      8e:	00 00       	nop
      90:	f4 c1       	rjmp	.+1000   	; 0x47a <__bad_interrupt>
      92:	00 00       	nop
      94:	f2 c1       	rjmp	.+996    	; 0x47a <__bad_interrupt>
      96:	00 00       	nop

00000098 <ProductString>:
      98:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
      a8:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
      b8:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000c2 <ManufacturerString>:
      c2:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      d2:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000dc <LanguageString>:
      dc:	04 03 09 04                                         ....

000000e0 <ConfigurationDescriptor>:
      e0:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      f0:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
     100:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     110:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

0000011e <DeviceDescriptor>:
     11e:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
     12e:	00 01                                               ..

00000130 <AdapterSupportedOIDList>:
     130:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     140:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     150:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     160:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     170:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     180:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     190:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

0000019c <AdapterVendorDescription>:
     19c:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt
     1ac:	65 72 00                                            er.

000001af <AdapterMACAddress>:
     1af:	02 00 02 00 02 00                                   ......

000001b5 <HTTPPage>:
     1b5:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1c5:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1d5:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1e5:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     1f5:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     205:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     215:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     225:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     235:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     245:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     255:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     265:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     275:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     285:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     295:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2a5:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2b5:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2c5:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2d5:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2e5:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     2f5:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     305:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     315:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     325:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     335:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     345:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     355:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     365:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     375:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     385:	3c 2f 69 3e 31 33 30 33 30 33 09 09 3c 2f 70 3e     </i>130303..</p>
     395:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003a5 <HTTP404Header>:
     3a5:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     3b5:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     3c5:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     3d5:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     3e5:	0a 00                                               ..

000003e7 <HTTP200Header>:
     3e7:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     3f7:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     407:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     417:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     427:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     437:	0a 0d 0a 00 00                                      .....

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d0 e2       	ldi	r29, 0x20	; 32
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	ea e1       	ldi	r30, 0x1A	; 26
     450:	fb e2       	ldi	r31, 0x2B	; 43
     452:	00 e0       	ldi	r16, 0x00	; 0
     454:	0b bf       	out	0x3b, r16	; 59
     456:	02 c0       	rjmp	.+4      	; 0x45c <__do_copy_data+0x14>
     458:	07 90       	elpm	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	a6 34       	cpi	r26, 0x46	; 70
     45e:	b1 07       	cpc	r27, r17
     460:	d9 f7       	brne	.-10     	; 0x458 <__do_copy_data+0x10>
     462:	1b be       	out	0x3b, r1	; 59

00000464 <__do_clear_bss>:
     464:	13 e1       	ldi	r17, 0x13	; 19
     466:	a6 e4       	ldi	r26, 0x46	; 70
     468:	b1 e0       	ldi	r27, 0x01	; 1
     46a:	01 c0       	rjmp	.+2      	; 0x46e <.do_clear_bss_start>

0000046c <.do_clear_bss_loop>:
     46c:	1d 92       	st	X+, r1

0000046e <.do_clear_bss_start>:
     46e:	a5 3f       	cpi	r26, 0xF5	; 245
     470:	b1 07       	cpc	r27, r17
     472:	e1 f7       	brne	.-8      	; 0x46c <.do_clear_bss_loop>
     474:	93 d1       	rcall	.+806    	; 0x79c <main>
     476:	0c 94 8b 15 	jmp	0x2b16	; 0x2b16 <_exit>

0000047a <__bad_interrupt>:
     47a:	c2 cd       	rjmp	.-1148   	; 0x0 <__vectors>

0000047c <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     47c:	9b b1       	in	r25, 0x0b	; 11
     47e:	9f 70       	andi	r25, 0x0F	; 15
     480:	98 2b       	or	r25, r24
     482:	9b b9       	out	0x0b, r25	; 11
			}
     484:	08 95       	ret

00000486 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     486:	84 b7       	in	r24, 0x34	; 52
     488:	87 7f       	andi	r24, 0xF7	; 247
     48a:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     48c:	28 e1       	ldi	r18, 0x18	; 24
     48e:	0f b6       	in	r0, 0x3f	; 63
     490:	f8 94       	cli
     492:	20 93 60 00 	sts	0x0060, r18
     496:	10 92 60 00 	sts	0x0060, r1
     49a:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     49c:	90 e0       	ldi	r25, 0x00	; 0
     49e:	80 e8       	ldi	r24, 0x80	; 128
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	80 93 61 00 	sts	0x0061, r24
     4a8:	90 93 61 00 	sts	0x0061, r25
     4ac:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4ae:	8a b1       	in	r24, 0x0a	; 10
     4b0:	80 6f       	ori	r24, 0xF0	; 240
     4b2:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4b4:	8b b1       	in	r24, 0x0b	; 11
     4b6:	8f 70       	andi	r24, 0x0F	; 15
     4b8:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4ba:	83 e3       	ldi	r24, 0x33	; 51
     4bc:	90 e0       	ldi	r25, 0x00	; 0
     4be:	90 93 cd 00 	sts	0x00CD, r25
     4c2:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4c6:	86 e0       	ldi	r24, 0x06	; 6
     4c8:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4cc:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4d0:	20 93 c9 00 	sts	0x00C9, r18

				DDRD  |= (1 << 3);
     4d4:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4d6:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4d8:	0e 94 8b 12 	call	0x2516	; 0x2516 <USB_Init>

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	0c 94 11 15 	jmp	0x2a22	; 0x2a22 <Serial_CreateStream>

000004e4 <EVENT_USB_Device_Connect>:
}
     4e4:	80 ea       	ldi	r24, 0xA0	; 160
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     4e6:	ca cf       	rjmp	.-108    	; 0x47c <LEDs_SetAllLEDs>

000004e8 <EVENT_USB_Device_Disconnect>:
     4e8:	80 e1       	ldi	r24, 0x10	; 16
}
     4ea:	c8 cf       	rjmp	.-112    	; 0x47c <LEDs_SetAllLEDs>

000004ec <EVENT_USB_Device_ConfigurationChanged>:
 *  the status LEDs and stops all the relevant tasks.
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     4ec:	1f 93       	push	r17
}
     4ee:	cf 93       	push	r28

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the RNDIS device endpoints and starts the relevant tasks.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     4f0:	df 93       	push	r29
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	61 e8       	ldi	r22, 0x81	; 129
     4f6:	42 e3       	ldi	r20, 0x32	; 50
     4f8:	0e 94 bd 11 	call	0x237a	; 0x237a <Endpoint_ConfigureEndpoint_Prv>
     4fc:	18 2f       	mov	r17, r24
     4fe:	82 e0       	ldi	r24, 0x02	; 2
     500:	60 e8       	ldi	r22, 0x80	; 128
     502:	42 e3       	ldi	r20, 0x32	; 50
     504:	0e 94 bd 11 	call	0x237a	; 0x237a <Endpoint_ConfigureEndpoint_Prv>
	bool ConfigSuccess = true;

	/* Setup RNDIS Data Endpoints */
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     508:	c8 2f       	mov	r28, r24
     50a:	d0 e0       	ldi	r29, 0x00	; 0
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	/* Setup RNDIS Data Endpoints */
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     50c:	81 2f       	mov	r24, r17
     50e:	90 e0       	ldi	r25, 0x00	; 0
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     510:	c8 23       	and	r28, r24
     512:	d9 23       	and	r29, r25
     514:	83 e0       	ldi	r24, 0x03	; 3
     516:	61 ec       	ldi	r22, 0xC1	; 193
     518:	42 e0       	ldi	r20, 0x02	; 2
     51a:	0e 94 bd 11 	call	0x237a	; 0x237a <Endpoint_ConfigureEndpoint_Prv>
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPADDR, EP_TYPE_INTERRUPT, CDC_NOTIFICATION_EPSIZE, 1);
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	8c 23       	and	r24, r28
     522:	9d 23       	and	r25, r29

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     524:	00 97       	sbiw	r24, 0x00	; 0
     526:	11 f0       	breq	.+4      	; 0x52c <EVENT_USB_Device_ConfigurationChanged+0x40>
     528:	80 e6       	ldi	r24, 0x60	; 96
     52a:	01 c0       	rjmp	.+2      	; 0x52e <EVENT_USB_Device_ConfigurationChanged+0x42>
     52c:	80 e9       	ldi	r24, 0x90	; 144
     52e:	a6 df       	rcall	.-180    	; 0x47c <LEDs_SetAllLEDs>
     530:	df 91       	pop	r29
}
     532:	cf 91       	pop	r28
     534:	1f 91       	pop	r17
     536:	08 95       	ret

00000538 <EVENT_USB_Device_ControlRequest>:
     538:	80 91 da 13 	lds	r24, 0x13DA
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Process RNDIS class commands */
	switch (USB_ControlRequest.bRequest)
     53c:	88 23       	and	r24, r24
     53e:	21 f0       	breq	.+8      	; 0x548 <EVENT_USB_Device_ControlRequest+0x10>
     540:	81 30       	cpi	r24, 0x01	; 1
     542:	09 f0       	breq	.+2      	; 0x546 <EVENT_USB_Device_ControlRequest+0xe>
     544:	4b c0       	rjmp	.+150    	; 0x5dc <EVENT_USB_Device_ControlRequest+0xa4>
     546:	18 c0       	rjmp	.+48     	; 0x578 <EVENT_USB_Device_ControlRequest+0x40>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     548:	80 91 d9 13 	lds	r24, 0x13D9
     54c:	81 32       	cpi	r24, 0x21	; 33
     54e:	09 f0       	breq	.+2      	; 0x552 <EVENT_USB_Device_ControlRequest+0x1a>
     550:	45 c0       	rjmp	.+138    	; 0x5dc <EVENT_USB_Device_ControlRequest+0xa4>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     552:	80 91 e8 00 	lds	r24, 0x00E8
     556:	87 7f       	andi	r24, 0xF7	; 247
     558:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Read in the RNDIS message into the message buffer */
				Endpoint_Read_Control_Stream_LE(RNDISMessageBuffer, USB_ControlRequest.wLength);
     55c:	60 91 df 13 	lds	r22, 0x13DF
     560:	70 91 e0 13 	lds	r23, 0x13E0
     564:	89 e0       	ldi	r24, 0x09	; 9
     566:	9d e0       	ldi	r25, 0x0D	; 13
     568:	0e 94 17 11 	call	0x222e	; 0x222e <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     56c:	80 91 e8 00 	lds	r24, 0x00E8
     570:	8e 77       	andi	r24, 0x7E	; 126
     572:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				/* Process the RNDIS message */
				ProcessRNDISControlMessage();
     576:	f0 c1       	rjmp	.+992    	; 0x958 <ProcessRNDISControlMessage>
     578:	80 91 d9 13 	lds	r24, 0x13D9
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     57c:	81 3a       	cpi	r24, 0xA1	; 161
     57e:	71 f5       	brne	.+92     	; 0x5dc <EVENT_USB_Device_ControlRequest+0xa4>
     580:	e0 91 20 01 	lds	r30, 0x0120
			{
				/* Check if a response to the last message is ready */
				if (!(MessageHeader->MessageLength))
     584:	f0 91 21 01 	lds	r31, 0x0121
     588:	84 81       	ldd	r24, Z+4	; 0x04
     58a:	95 81       	ldd	r25, Z+5	; 0x05
     58c:	a6 81       	ldd	r26, Z+6	; 0x06
     58e:	b7 81       	ldd	r27, Z+7	; 0x07
     590:	00 97       	sbiw	r24, 0x00	; 0
     592:	a1 05       	cpc	r26, r1
     594:	b1 05       	cpc	r27, r1
     596:	51 f4       	brne	.+20     	; 0x5ac <EVENT_USB_Device_ControlRequest+0x74>
     598:	10 92 09 0d 	sts	0x0D09, r1
				{
					/* Set the response to a single 0x00 byte to indicate that no response is ready */
					RNDISMessageBuffer[0] = 0;
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	90 e0       	ldi	r25, 0x00	; 0
					MessageHeader->MessageLength = 1;
     5a0:	a0 e0       	ldi	r26, 0x00	; 0
     5a2:	b0 e0       	ldi	r27, 0x00	; 0
     5a4:	84 83       	std	Z+4, r24	; 0x04
     5a6:	95 83       	std	Z+5, r25	; 0x05
     5a8:	a6 83       	std	Z+6, r26	; 0x06
     5aa:	b7 83       	std	Z+7, r27	; 0x07
     5ac:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     5b0:	87 7f       	andi	r24, 0xF7	; 247
     5b2:	80 93 e8 00 	sts	0x00E8, r24
     5b6:	64 81       	ldd	r22, Z+4	; 0x04
     5b8:	75 81       	ldd	r23, Z+5	; 0x05
				}

				Endpoint_ClearSETUP();

				/* Write the message response data to the endpoint */
				Endpoint_Write_Control_Stream_LE(RNDISMessageBuffer, MessageHeader->MessageLength);
     5ba:	89 e0       	ldi	r24, 0x09	; 9
     5bc:	9d e0       	ldi	r25, 0x0D	; 13
     5be:	0e 94 bb 10 	call	0x2176	; 0x2176 <Endpoint_Write_Control_Stream_LE>
     5c2:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     5c6:	8b 77       	andi	r24, 0x7B	; 123
     5c8:	80 93 e8 00 	sts	0x00E8, r24
     5cc:	e0 91 20 01 	lds	r30, 0x0120
				Endpoint_ClearOUT();

				/* Reset the message header once again after transmission */
				MessageHeader->MessageLength = 0;
     5d0:	f0 91 21 01 	lds	r31, 0x0121
     5d4:	14 82       	std	Z+4, r1	; 0x04
     5d6:	15 82       	std	Z+5, r1	; 0x05
     5d8:	16 82       	std	Z+6, r1	; 0x06
     5da:	17 82       	std	Z+7, r1	; 0x07
     5dc:	08 95       	ret

000005de <RNDIS_Task>:
     5de:	0f 93       	push	r16
     5e0:	1f 93       	push	r17
/** Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS
 *  wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper
 *  to a frame in the FrameOUT global before sending the buffer contents to the host.
 */
void RNDIS_Task(void)
{
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	cd b7       	in	r28, 0x3d	; 61
     5e8:	de b7       	in	r29, 0x3e	; 62
     5ea:	ac 97       	sbiw	r28, 0x2c	; 44
     5ec:	0f b6       	in	r0, 0x3f	; 63
     5ee:	f8 94       	cli
     5f0:	de bf       	out	0x3e, r29	; 62
     5f2:	0f be       	out	0x3f, r0	; 63
     5f4:	cd bf       	out	0x3d, r28	; 61
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     5f6:	83 e0       	ldi	r24, 0x03	; 3
     5f8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     5fc:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the notification endpoint */
	Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPADDR);

	/* Check if a message response is ready for the host */
	if (Endpoint_IsINReady() && ResponseReady)
     600:	80 ff       	sbrs	r24, 0
     602:	1c c0       	rjmp	.+56     	; 0x63c <RNDIS_Task+0x5e>
     604:	80 91 4b 01 	lds	r24, 0x014B
     608:	88 23       	and	r24, r24
     60a:	c1 f0       	breq	.+48     	; 0x63c <RNDIS_Task+0x5e>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
     60c:	de 01       	movw	r26, r28
     60e:	11 96       	adiw	r26, 0x01	; 1
     610:	e0 e0       	ldi	r30, 0x00	; 0
     612:	f1 e0       	ldi	r31, 0x01	; 1
     614:	88 e0       	ldi	r24, 0x08	; 8
     616:	01 90       	ld	r0, Z+
     618:	0d 92       	st	X+, r0
     61a:	81 50       	subi	r24, 0x01	; 1
     61c:	e1 f7       	brne	.-8      	; 0x616 <RNDIS_Task+0x38>
				.wIndex        = 0,
				.wLength       = 0,
			};

		/* Indicate that a message response is ready for the host */
		Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);
     61e:	ce 01       	movw	r24, r28
     620:	01 96       	adiw	r24, 0x01	; 1
     622:	68 e0       	ldi	r22, 0x08	; 8
     624:	70 e0       	ldi	r23, 0x00	; 0
     626:	40 e0       	ldi	r20, 0x00	; 0
     628:	50 e0       	ldi	r21, 0x00	; 0
     62a:	0e 94 1b 10 	call	0x2036	; 0x2036 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     62e:	80 91 e8 00 	lds	r24, 0x00E8
     632:	8e 77       	andi	r24, 0x7E	; 126
     634:	80 93 e8 00 	sts	0x00E8, r24

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();

		/* Indicate a response is no longer ready */
		ResponseReady = false;
     638:	10 92 4b 01 	sts	0x014B, r1
	}

	/* Don't process the data endpoints until the system is in the data initialized state, and the buffer is free */
	if ((CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
     63c:	20 91 4a 01 	lds	r18, 0x014A
     640:	22 30       	cpi	r18, 0x02	; 2
     642:	09 f0       	breq	.+2      	; 0x646 <RNDIS_Task+0x68>
     644:	90 c0       	rjmp	.+288    	; 0x766 <RNDIS_Task+0x188>
     646:	e0 91 20 01 	lds	r30, 0x0120
     64a:	f0 91 21 01 	lds	r31, 0x0121
     64e:	84 81       	ldd	r24, Z+4	; 0x04
     650:	95 81       	ldd	r25, Z+5	; 0x05
     652:	a6 81       	ldd	r26, Z+6	; 0x06
     654:	b7 81       	ldd	r27, Z+7	; 0x07
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	a1 05       	cpc	r26, r1
     65a:	b1 05       	cpc	r27, r1
     65c:	09 f0       	breq	.+2      	; 0x660 <RNDIS_Task+0x82>
     65e:	83 c0       	rjmp	.+262    	; 0x766 <RNDIS_Task+0x188>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     660:	20 93 e9 00 	sts	0x00E9, r18
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     664:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPADDR);

		/* Check if the data OUT endpoint contains data, and that the IN buffer is empty */
		if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength))
     668:	82 ff       	sbrs	r24, 2
     66a:	32 c0       	rjmp	.+100    	; 0x6d0 <RNDIS_Task+0xf2>
     66c:	80 91 29 07 	lds	r24, 0x0729
     670:	90 91 2a 07 	lds	r25, 0x072A
     674:	00 97       	sbiw	r24, 0x00	; 0
     676:	61 f5       	brne	.+88     	; 0x6d0 <RNDIS_Task+0xf2>
		{
			/* Read in the packet message header */
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     678:	ce 01       	movw	r24, r28
     67a:	01 96       	adiw	r24, 0x01	; 1
     67c:	6c e2       	ldi	r22, 0x2C	; 44
     67e:	70 e0       	ldi	r23, 0x00	; 0
     680:	40 e0       	ldi	r20, 0x00	; 0
     682:	50 e0       	ldi	r21, 0x00	; 0
     684:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <Endpoint_Read_Stream_LE>

			/* Stall the request if the data is too large */
			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
     688:	4d 85       	ldd	r20, Y+13	; 0x0d
     68a:	5e 85       	ldd	r21, Y+14	; 0x0e
     68c:	6f 85       	ldd	r22, Y+15	; 0x0f
     68e:	78 89       	ldd	r23, Y+16	; 0x10
     690:	4d 3d       	cpi	r20, 0xDD	; 221
     692:	85 e0       	ldi	r24, 0x05	; 5
     694:	58 07       	cpc	r21, r24
     696:	80 e0       	ldi	r24, 0x00	; 0
     698:	68 07       	cpc	r22, r24
     69a:	80 e0       	ldi	r24, 0x00	; 0
     69c:	78 07       	cpc	r23, r24
     69e:	30 f0       	brcs	.+12     	; 0x6ac <RNDIS_Task+0xce>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     6a0:	80 91 eb 00 	lds	r24, 0x00EB
     6a4:	80 62       	ori	r24, 0x20	; 32
     6a6:	80 93 eb 00 	sts	0x00EB, r24
     6aa:	5d c0       	rjmp	.+186    	; 0x766 <RNDIS_Task+0x188>
				Endpoint_StallTransaction();
				return;
			}

			/* Read in the Ethernet frame into the buffer */
			Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength, NULL);
     6ac:	8d e4       	ldi	r24, 0x4D	; 77
     6ae:	91 e0       	ldi	r25, 0x01	; 1
     6b0:	ba 01       	movw	r22, r20
     6b2:	40 e0       	ldi	r20, 0x00	; 0
     6b4:	50 e0       	ldi	r21, 0x00	; 0
     6b6:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     6ba:	80 91 e8 00 	lds	r24, 0x00E8
     6be:	8b 77       	andi	r24, 0x7B	; 123
     6c0:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();

			/* Store the size of the Ethernet frame */
			FrameIN.FrameLength = RNDISPacketHeader.DataLength;
     6c4:	8d 85       	ldd	r24, Y+13	; 0x0d
     6c6:	9e 85       	ldd	r25, Y+14	; 0x0e
     6c8:	90 93 2a 07 	sts	0x072A, r25
     6cc:	80 93 29 07 	sts	0x0729, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     6d6:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPADDR);

		/* Check if the data IN endpoint is ready for more data, and that the IN buffer is full */
		if (Endpoint_IsINReady() && FrameOUT.FrameLength)
     6da:	80 ff       	sbrs	r24, 0
     6dc:	44 c0       	rjmp	.+136    	; 0x766 <RNDIS_Task+0x188>
     6de:	40 91 07 0d 	lds	r20, 0x0D07
     6e2:	50 91 08 0d 	lds	r21, 0x0D08
     6e6:	41 15       	cp	r20, r1
     6e8:	51 05       	cpc	r21, r1
     6ea:	e9 f1       	breq	.+122    	; 0x766 <RNDIS_Task+0x188>
		{
			/* Clear the packet header with all 0s so that the relevant fields can be filled */
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
     6ec:	ce 01       	movw	r24, r28
     6ee:	01 96       	adiw	r24, 0x01	; 1
     6f0:	2c e2       	ldi	r18, 0x2C	; 44
     6f2:	fc 01       	movw	r30, r24
     6f4:	11 92       	st	Z+, r1
     6f6:	2a 95       	dec	r18
     6f8:	e9 f7       	brne	.-6      	; 0x6f4 <RNDIS_Task+0x116>

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
     6fa:	01 e0       	ldi	r16, 0x01	; 1
     6fc:	10 e0       	ldi	r17, 0x00	; 0
     6fe:	20 e0       	ldi	r18, 0x00	; 0
     700:	30 e0       	ldi	r19, 0x00	; 0
     702:	09 83       	std	Y+1, r16	; 0x01
     704:	1a 83       	std	Y+2, r17	; 0x02
     706:	2b 83       	std	Y+3, r18	; 0x03
     708:	3c 83       	std	Y+4, r19	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
     70a:	8a 01       	movw	r16, r20
     70c:	04 5d       	subi	r16, 0xD4	; 212
     70e:	1f 4f       	sbci	r17, 0xFF	; 255
     710:	20 e0       	ldi	r18, 0x00	; 0
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	0d 83       	std	Y+5, r16	; 0x05
     716:	1e 83       	std	Y+6, r17	; 0x06
     718:	2f 83       	std	Y+7, r18	; 0x07
     71a:	38 87       	std	Y+8, r19	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     71c:	04 e2       	ldi	r16, 0x24	; 36
     71e:	10 e0       	ldi	r17, 0x00	; 0
     720:	20 e0       	ldi	r18, 0x00	; 0
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	09 87       	std	Y+9, r16	; 0x09
     726:	1a 87       	std	Y+10, r17	; 0x0a
     728:	2b 87       	std	Y+11, r18	; 0x0b
     72a:	3c 87       	std	Y+12, r19	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     72c:	60 e0       	ldi	r22, 0x00	; 0
     72e:	70 e0       	ldi	r23, 0x00	; 0
     730:	4d 87       	std	Y+13, r20	; 0x0d
     732:	5e 87       	std	Y+14, r21	; 0x0e
     734:	6f 87       	std	Y+15, r22	; 0x0f
     736:	78 8b       	std	Y+16, r23	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     738:	6c e2       	ldi	r22, 0x2C	; 44
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	40 e0       	ldi	r20, 0x00	; 0
     73e:	50 e0       	ldi	r21, 0x00	; 0
     740:	0e 94 1b 10 	call	0x2036	; 0x2036 <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength, NULL);
     744:	6d 85       	ldd	r22, Y+13	; 0x0d
     746:	7e 85       	ldd	r23, Y+14	; 0x0e
     748:	8b e2       	ldi	r24, 0x2B	; 43
     74a:	97 e0       	ldi	r25, 0x07	; 7
     74c:	40 e0       	ldi	r20, 0x00	; 0
     74e:	50 e0       	ldi	r21, 0x00	; 0
     750:	0e 94 1b 10 	call	0x2036	; 0x2036 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     754:	80 91 e8 00 	lds	r24, 0x00E8
     758:	8e 77       	andi	r24, 0x7E	; 126
     75a:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameLength = 0;
     75e:	10 92 08 0d 	sts	0x0D08, r1
     762:	10 92 07 0d 	sts	0x0D07, r1
		}
	}
}
     766:	ac 96       	adiw	r28, 0x2c	; 44
     768:	0f b6       	in	r0, 0x3f	; 63
     76a:	f8 94       	cli
     76c:	de bf       	out	0x3e, r29	; 62
     76e:	0f be       	out	0x3f, r0	; 63
     770:	cd bf       	out	0x3d, r28	; 61
     772:	df 91       	pop	r29
     774:	cf 91       	pop	r28
     776:	1f 91       	pop	r17
     778:	0f 91       	pop	r16
     77a:	08 95       	ret

0000077c <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     77c:	80 91 d8 13 	lds	r24, 0x13D8
     780:	84 30       	cpi	r24, 0x04	; 4
     782:	59 f4       	brne	.+22     	; 0x79a <Ethernet_Task+0x1e>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameLength)
     784:	80 91 29 07 	lds	r24, 0x0729
     788:	90 91 2a 07 	lds	r25, 0x072A
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	29 f0       	breq	.+10     	; 0x79a <Ethernet_Task+0x1e>
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     790:	80 e2       	ldi	r24, 0x20	; 32
     792:	74 de       	rcall	.-792    	; 0x47c <LEDs_SetAllLEDs>
     794:	3c d0       	rcall	.+120    	; 0x80e <Ethernet_ProcessPacket>

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     796:	80 e6       	ldi	r24, 0x60	; 96
     798:	71 ce       	rjmp	.-798    	; 0x47c <LEDs_SetAllLEDs>

		/* Indicate packet processing complete */
		LEDs_SetAllLEDs(LEDMASK_USB_READY);
     79a:	08 95       	ret

0000079c <main>:
     79c:	74 de       	rcall	.-792    	; 0x486 <SetupHardware>
     79e:	ea d5       	rcall	.+3028   	; 0x1374 <TCP_Init>
     7a0:	0e 94 15 10 	call	0x202a	; 0x202a <Webserver_Init>
{
	SetupHardware();

	/* Webserver Initialization */
	TCP_Init();
	Webserver_Init();
     7a4:	80 e1       	ldi	r24, 0x10	; 16
     7a6:	6a de       	rcall	.-812    	; 0x47c <LEDs_SetAllLEDs>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     7a8:	78 94       	sei
     7aa:	e8 df       	rcall	.-48     	; 0x77c <Ethernet_Task>
     7ac:	93 d4       	rcall	.+2342   	; 0x10d4 <TCP_Task>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     7ae:	17 df       	rcall	.-466    	; 0x5de <RNDIS_Task>
	GlobalInterruptEnable();

	for (;;)
	{
		Ethernet_Task();
     7b0:	0e 94 da 14 	call	0x29b4	; 0x29b4 <USB_USBTask>
		TCP_Task();
     7b4:	fa cf       	rjmp	.-12     	; 0x7aa <main+0xe>

000007b6 <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     7b6:	92 30       	cpi	r25, 0x02	; 2
     7b8:	29 f0       	breq	.+10     	; 0x7c4 <CALLBACK_USB_GetDescriptor+0xe>
     7ba:	93 30       	cpi	r25, 0x03	; 3
     7bc:	41 f0       	breq	.+16     	; 0x7ce <CALLBACK_USB_GetDescriptor+0x18>
     7be:	91 30       	cpi	r25, 0x01	; 1
     7c0:	e9 f4       	brne	.+58     	; 0x7fc <CALLBACK_USB_GetDescriptor+0x46>
     7c2:	17 c0       	rjmp	.+46     	; 0x7f2 <CALLBACK_USB_GetDescriptor+0x3c>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     7c4:	8e e3       	ldi	r24, 0x3E	; 62
     7c6:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     7c8:	e0 ee       	ldi	r30, 0xE0	; 224
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     7cc:	1b c0       	rjmp	.+54     	; 0x804 <CALLBACK_USB_GetDescriptor+0x4e>
		case DTYPE_String:
			switch (DescriptorNumber)
     7ce:	81 30       	cpi	r24, 0x01	; 1
     7d0:	41 f0       	breq	.+16     	; 0x7e2 <CALLBACK_USB_GetDescriptor+0x2c>
     7d2:	81 30       	cpi	r24, 0x01	; 1
     7d4:	18 f0       	brcs	.+6      	; 0x7dc <CALLBACK_USB_GetDescriptor+0x26>
     7d6:	82 30       	cpi	r24, 0x02	; 2
     7d8:	89 f4       	brne	.+34     	; 0x7fc <CALLBACK_USB_GetDescriptor+0x46>
     7da:	06 c0       	rjmp	.+12     	; 0x7e8 <CALLBACK_USB_GetDescriptor+0x32>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     7dc:	ec ed       	ldi	r30, 0xDC	; 220
     7de:	f0 e0       	ldi	r31, 0x00	; 0
     7e0:	05 c0       	rjmp	.+10     	; 0x7ec <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     7e2:	e2 ec       	ldi	r30, 0xC2	; 194
     7e4:	f0 e0       	ldi	r31, 0x00	; 0
     7e6:	02 c0       	rjmp	.+4      	; 0x7ec <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     7e8:	e8 e9       	ldi	r30, 0x98	; 152
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	84 91       	lpm	r24, Z
     7ee:	90 e0       	ldi	r25, 0x00	; 0
					break;
     7f0:	09 c0       	rjmp	.+18     	; 0x804 <CALLBACK_USB_GetDescriptor+0x4e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     7f2:	82 e1       	ldi	r24, 0x12	; 18
     7f4:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     7f6:	ee e1       	ldi	r30, 0x1E	; 30
     7f8:	f1 e0       	ldi	r31, 0x01	; 1
     7fa:	04 c0       	rjmp	.+8      	; 0x804 <CALLBACK_USB_GetDescriptor+0x4e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     7fc:	80 e0       	ldi	r24, 0x00	; 0
     7fe:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     800:	e0 e0       	ldi	r30, 0x00	; 0
     802:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     804:	da 01       	movw	r26, r20
     806:	11 96       	adiw	r26, 0x01	; 1
     808:	fc 93       	st	X, r31
     80a:	ee 93       	st	-X, r30
	return Size;
}
     80c:	08 95       	ret

0000080e <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     80e:	8d e4       	ldi	r24, 0x4D	; 77
     810:	91 e0       	ldi	r25, 0x01	; 1
     812:	9b d0       	rcall	.+310    	; 0x94a <DecodeEthernetFrameHeader>
     814:	8d e4       	ldi	r24, 0x4D	; 77
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     816:	91 e0       	ldi	r25, 0x01	; 1
     818:	6a e1       	ldi	r22, 0x1A	; 26
     81a:	71 e0       	ldi	r23, 0x01	; 1
     81c:	46 e0       	ldi	r20, 0x06	; 6
     81e:	50 e0       	ldi	r21, 0x00	; 0
     820:	0e 94 56 15 	call	0x2aac	; 0x2aac <memcmp>
     824:	00 97       	sbiw	r24, 0x00	; 0
     826:	59 f0       	breq	.+22     	; 0x83e <Ethernet_ProcessPacket+0x30>
     828:	8d e4       	ldi	r24, 0x4D	; 77
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     82a:	91 e0       	ldi	r25, 0x01	; 1
     82c:	60 e1       	ldi	r22, 0x10	; 16
     82e:	71 e0       	ldi	r23, 0x01	; 1
     830:	46 e0       	ldi	r20, 0x06	; 6
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	0e 94 56 15 	call	0x2aac	; 0x2aac <memcmp>
     838:	00 97       	sbiw	r24, 0x00	; 0
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     83a:	09 f0       	breq	.+2      	; 0x83e <Ethernet_ProcessPacket+0x30>
     83c:	4f c0       	rjmp	.+158    	; 0x8dc <Ethernet_ProcessPacket+0xce>
     83e:	80 91 29 07 	lds	r24, 0x0729
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     842:	90 91 2a 07 	lds	r25, 0x072A
     846:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
     848:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
     84a:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
     84c:	26 e0       	ldi	r18, 0x06	; 6
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     84e:	81 30       	cpi	r24, 0x01	; 1
     850:	92 07       	cpc	r25, r18
     852:	08 f4       	brcc	.+2      	; 0x856 <Ethernet_ProcessPacket+0x48>
     854:	43 c0       	rjmp	.+134    	; 0x8dc <Ethernet_ProcessPacket+0xce>
     856:	80 91 59 01 	lds	r24, 0x0159
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     85a:	90 91 5a 01 	lds	r25, 0x015A
     85e:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
     860:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
     862:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
     864:	28 e0       	ldi	r18, 0x08	; 8
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     866:	80 30       	cpi	r24, 0x00	; 0
     868:	92 07       	cpc	r25, r18
     86a:	59 f0       	breq	.+22     	; 0x882 <Ethernet_ProcessPacket+0x74>
     86c:	28 e0       	ldi	r18, 0x08	; 8
     86e:	86 30       	cpi	r24, 0x06	; 6
     870:	92 07       	cpc	r25, r18
     872:	a1 f5       	brne	.+104    	; 0x8dc <Ethernet_ProcessPacket+0xce>
     874:	8b e5       	ldi	r24, 0x5B	; 91
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     876:	91 e0       	ldi	r25, 0x01	; 1
     878:	69 e3       	ldi	r22, 0x39	; 57
     87a:	77 e0       	ldi	r23, 0x07	; 7
     87c:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <ARP_ProcessARPPacket>
     880:	06 c0       	rjmp	.+12     	; 0x88e <Ethernet_ProcessPacket+0x80>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     882:	8b e5       	ldi	r24, 0x5B	; 91
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     884:	91 e0       	ldi	r25, 0x01	; 1
     886:	69 e3       	ldi	r22, 0x39	; 57
     888:	77 e0       	ldi	r23, 0x07	; 7
     88a:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <IP_ProcessIPPacket>
     88e:	18 16       	cp	r1, r24
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     890:	19 06       	cpc	r1, r25
     892:	04 f5       	brge	.+64     	; 0x8d4 <Ethernet_ProcessPacket+0xc6>
     894:	a1 e3       	ldi	r26, 0x31	; 49
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     896:	b7 e0       	ldi	r27, 0x07	; 7
     898:	ea e1       	ldi	r30, 0x1A	; 26
     89a:	f1 e0       	ldi	r31, 0x01	; 1
     89c:	26 e0       	ldi	r18, 0x06	; 6
     89e:	01 90       	ld	r0, Z+
     8a0:	0d 92       	st	X+, r0
     8a2:	21 50       	subi	r18, 0x01	; 1
     8a4:	e1 f7       	brne	.-8      	; 0x89e <Ethernet_ProcessPacket+0x90>
     8a6:	ab e2       	ldi	r26, 0x2B	; 43
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     8a8:	b7 e0       	ldi	r27, 0x07	; 7
     8aa:	e3 e5       	ldi	r30, 0x53	; 83
     8ac:	f1 e0       	ldi	r31, 0x01	; 1
     8ae:	26 e0       	ldi	r18, 0x06	; 6
     8b0:	01 90       	ld	r0, Z+
     8b2:	0d 92       	st	X+, r0
     8b4:	21 50       	subi	r18, 0x01	; 1
     8b6:	e1 f7       	brne	.-8      	; 0x8b0 <Ethernet_ProcessPacket+0xa2>
     8b8:	20 91 59 01 	lds	r18, 0x0159
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     8bc:	30 91 5a 01 	lds	r19, 0x015A
     8c0:	30 93 38 07 	sts	0x0738, r19
     8c4:	20 93 37 07 	sts	0x0737, r18
     8c8:	0e 96       	adiw	r24, 0x0e	; 14

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     8ca:	90 93 08 0d 	sts	0x0D08, r25
     8ce:	80 93 07 0d 	sts	0x0D07, r24
     8d2:	04 c0       	rjmp	.+8      	; 0x8dc <Ethernet_ProcessPacket+0xce>
     8d4:	2f ef       	ldi	r18, 0xFF	; 255
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     8d6:	8f 3f       	cpi	r24, 0xFF	; 255
     8d8:	92 07       	cpc	r25, r18
     8da:	21 f0       	breq	.+8      	; 0x8e4 <Ethernet_ProcessPacket+0xd6>
     8dc:	10 92 2a 07 	sts	0x072A, r1
	{
		/* Clear the frame buffer */
		FrameIN.FrameLength = 0;
     8e0:	10 92 29 07 	sts	0x0729, r1
     8e4:	08 95       	ret

000008e6 <Ethernet_Checksum16>:
     8e6:	cf 93       	push	r28
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     8e8:	df 93       	push	r29
     8ea:	9b 01       	movw	r18, r22
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     8ec:	36 95       	lsr	r19
     8ee:	27 95       	ror	r18
     8f0:	ec 01       	movw	r28, r24
     8f2:	e0 e0       	ldi	r30, 0x00	; 0
     8f4:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     8f6:	40 e0       	ldi	r20, 0x00	; 0
     8f8:	50 e0       	ldi	r21, 0x00	; 0
     8fa:	ba 01       	movw	r22, r20

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     8fc:	09 c0       	rjmp	.+18     	; 0x910 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     8fe:	89 91       	ld	r24, Y+
     900:	99 91       	ld	r25, Y+
     902:	a0 e0       	ldi	r26, 0x00	; 0
     904:	b0 e0       	ldi	r27, 0x00	; 0
     906:	48 0f       	add	r20, r24
     908:	59 1f       	adc	r21, r25
     90a:	6a 1f       	adc	r22, r26
     90c:	7b 1f       	adc	r23, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     90e:	31 96       	adiw	r30, 0x01	; 1
     910:	e2 17       	cp	r30, r18
     912:	f3 07       	cpc	r31, r19
     914:	a1 f7       	brne	.-24     	; 0x8fe <Ethernet_Checksum16+0x18>
     916:	0b c0       	rjmp	.+22     	; 0x92e <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     918:	db 01       	movw	r26, r22
     91a:	ca 01       	movw	r24, r20
     91c:	a0 70       	andi	r26, 0x00	; 0
     91e:	b0 70       	andi	r27, 0x00	; 0
     920:	ab 01       	movw	r20, r22
     922:	66 27       	eor	r22, r22
     924:	77 27       	eor	r23, r23
     926:	48 0f       	add	r20, r24
     928:	59 1f       	adc	r21, r25
     92a:	6a 1f       	adc	r22, r26
     92c:	7b 1f       	adc	r23, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     92e:	db 01       	movw	r26, r22
     930:	ca 01       	movw	r24, r20
     932:	80 70       	andi	r24, 0x00	; 0
     934:	90 70       	andi	r25, 0x00	; 0
     936:	00 97       	sbiw	r24, 0x00	; 0
     938:	a1 05       	cpc	r26, r1
     93a:	b1 05       	cpc	r27, r1
     93c:	69 f7       	brne	.-38     	; 0x918 <Ethernet_Checksum16+0x32>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     93e:	ca 01       	movw	r24, r20
     940:	80 95       	com	r24
     942:	90 95       	com	r25
}
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     94a:	08 95       	ret

0000094c <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     94c:	08 95       	ret

0000094e <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     94e:	08 95       	ret

00000950 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     950:	08 95       	ret

00000952 <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     952:	08 95       	ret

00000954 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     954:	08 95       	ret

00000956 <DecodeDHCPHeader>:
		}

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}
	#endif
}
     956:	08 95       	ret

00000958 <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
     958:	e0 91 20 01 	lds	r30, 0x0120
     95c:	f0 91 21 01 	lds	r31, 0x0121
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	a2 81       	ldd	r26, Z+2	; 0x02
     966:	b3 81       	ldd	r27, Z+3	; 0x03
     968:	84 30       	cpi	r24, 0x04	; 4
     96a:	91 05       	cpc	r25, r1
     96c:	a1 05       	cpc	r26, r1
     96e:	b1 05       	cpc	r27, r1
     970:	09 f4       	brne	.+2      	; 0x974 <ProcessRNDISControlMessage+0x1c>
     972:	a3 c0       	rjmp	.+326    	; 0xaba <ProcessRNDISControlMessage+0x162>
     974:	85 30       	cpi	r24, 0x05	; 5
     976:	91 05       	cpc	r25, r1
     978:	a1 05       	cpc	r26, r1
     97a:	b1 05       	cpc	r27, r1
     97c:	60 f4       	brcc	.+24     	; 0x996 <ProcessRNDISControlMessage+0x3e>
     97e:	82 30       	cpi	r24, 0x02	; 2
     980:	91 05       	cpc	r25, r1
     982:	a1 05       	cpc	r26, r1
     984:	b1 05       	cpc	r27, r1
     986:	d1 f0       	breq	.+52     	; 0x9bc <ProcessRNDISControlMessage+0x64>
     988:	83 30       	cpi	r24, 0x03	; 3
     98a:	91 05       	cpc	r25, r1
     98c:	a1 05       	cpc	r26, r1
     98e:	b1 05       	cpc	r27, r1
     990:	09 f0       	breq	.+2      	; 0x994 <ProcessRNDISControlMessage+0x3c>
     992:	d7 c2       	rjmp	.+1454   	; 0xf42 <ProcessRNDISControlMessage+0x5ea>
     994:	89 c0       	rjmp	.+274    	; 0xaa8 <ProcessRNDISControlMessage+0x150>
     996:	86 30       	cpi	r24, 0x06	; 6
     998:	91 05       	cpc	r25, r1
     99a:	a1 05       	cpc	r26, r1
     99c:	b1 05       	cpc	r27, r1
     99e:	09 f4       	brne	.+2      	; 0x9a2 <ProcessRNDISControlMessage+0x4a>
     9a0:	49 c2       	rjmp	.+1170   	; 0xe34 <ProcessRNDISControlMessage+0x4dc>
     9a2:	86 30       	cpi	r24, 0x06	; 6
     9a4:	91 05       	cpc	r25, r1
     9a6:	a1 05       	cpc	r26, r1
     9a8:	b1 05       	cpc	r27, r1
     9aa:	08 f4       	brcc	.+2      	; 0x9ae <ProcessRNDISControlMessage+0x56>
     9ac:	f1 c1       	rjmp	.+994    	; 0xd90 <ProcessRNDISControlMessage+0x438>
     9ae:	88 30       	cpi	r24, 0x08	; 8
     9b0:	91 05       	cpc	r25, r1
     9b2:	a1 05       	cpc	r26, r1
     9b4:	b1 05       	cpc	r27, r1
     9b6:	09 f0       	breq	.+2      	; 0x9ba <ProcessRNDISControlMessage+0x62>
     9b8:	c4 c2       	rjmp	.+1416   	; 0xf42 <ProcessRNDISControlMessage+0x5ea>
     9ba:	60 c2       	rjmp	.+1216   	; 0xe7c <ProcessRNDISControlMessage+0x524>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
     9bc:	21 e0       	ldi	r18, 0x01	; 1
     9be:	20 93 4b 01 	sts	0x014B, r18

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
     9c2:	82 e0       	ldi	r24, 0x02	; 2
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	a0 e0       	ldi	r26, 0x00	; 0
     9c8:	b0 e8       	ldi	r27, 0x80	; 128
     9ca:	80 93 09 0d 	sts	0x0D09, r24
     9ce:	90 93 0a 0d 	sts	0x0D0A, r25
     9d2:	a0 93 0b 0d 	sts	0x0D0B, r26
     9d6:	b0 93 0c 0d 	sts	0x0D0C, r27
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
     9da:	84 e3       	ldi	r24, 0x34	; 52
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	a0 e0       	ldi	r26, 0x00	; 0
     9e0:	b0 e0       	ldi	r27, 0x00	; 0
     9e2:	80 93 0d 0d 	sts	0x0D0D, r24
     9e6:	90 93 0e 0d 	sts	0x0D0E, r25
     9ea:	a0 93 0f 0d 	sts	0x0D0F, r26
     9ee:	b0 93 10 0d 	sts	0x0D10, r27
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
     9f2:	10 92 15 0d 	sts	0x0D15, r1
     9f6:	10 92 16 0d 	sts	0x0D16, r1
     9fa:	10 92 17 0d 	sts	0x0D17, r1
     9fe:	10 92 18 0d 	sts	0x0D18, r1

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
     a02:	81 e0       	ldi	r24, 0x01	; 1
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	a0 e0       	ldi	r26, 0x00	; 0
     a08:	b0 e0       	ldi	r27, 0x00	; 0
     a0a:	80 93 19 0d 	sts	0x0D19, r24
     a0e:	90 93 1a 0d 	sts	0x0D1A, r25
     a12:	a0 93 1b 0d 	sts	0x0D1B, r26
     a16:	b0 93 1c 0d 	sts	0x0D1C, r27
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
     a1a:	10 92 1d 0d 	sts	0x0D1D, r1
     a1e:	10 92 1e 0d 	sts	0x0D1E, r1
     a22:	10 92 1f 0d 	sts	0x0D1F, r1
     a26:	10 92 20 0d 	sts	0x0D20, r1
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
     a2a:	80 93 21 0d 	sts	0x0D21, r24
     a2e:	90 93 22 0d 	sts	0x0D22, r25
     a32:	a0 93 23 0d 	sts	0x0D23, r26
     a36:	b0 93 24 0d 	sts	0x0D24, r27
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
     a3a:	10 92 25 0d 	sts	0x0D25, r1
     a3e:	10 92 26 0d 	sts	0x0D26, r1
     a42:	10 92 27 0d 	sts	0x0D27, r1
     a46:	10 92 28 0d 	sts	0x0D28, r1
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
     a4a:	80 93 29 0d 	sts	0x0D29, r24
     a4e:	90 93 2a 0d 	sts	0x0D2A, r25
     a52:	a0 93 2b 0d 	sts	0x0D2B, r26
     a56:	b0 93 2c 0d 	sts	0x0D2C, r27
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
     a5a:	88 e0       	ldi	r24, 0x08	; 8
     a5c:	96 e0       	ldi	r25, 0x06	; 6
     a5e:	a0 e0       	ldi	r26, 0x00	; 0
     a60:	b0 e0       	ldi	r27, 0x00	; 0
     a62:	80 93 2d 0d 	sts	0x0D2D, r24
     a66:	90 93 2e 0d 	sts	0x0D2E, r25
     a6a:	a0 93 2f 0d 	sts	0x0D2F, r26
     a6e:	b0 93 30 0d 	sts	0x0D30, r27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
     a72:	10 92 31 0d 	sts	0x0D31, r1
     a76:	10 92 32 0d 	sts	0x0D32, r1
     a7a:	10 92 33 0d 	sts	0x0D33, r1
     a7e:	10 92 34 0d 	sts	0x0D34, r1
			INITIALIZE_Response->AFListOffset          = 0;
     a82:	10 92 35 0d 	sts	0x0D35, r1
     a86:	10 92 36 0d 	sts	0x0D36, r1
     a8a:	10 92 37 0d 	sts	0x0D37, r1
     a8e:	10 92 38 0d 	sts	0x0D38, r1
			INITIALIZE_Response->AFListSize            = 0;
     a92:	10 92 39 0d 	sts	0x0D39, r1
     a96:	10 92 3a 0d 	sts	0x0D3A, r1
     a9a:	10 92 3b 0d 	sts	0x0D3B, r1
     a9e:	10 92 3c 0d 	sts	0x0D3C, r1

			CurrRNDISState = RNDIS_Initialized;
     aa2:	20 93 4a 01 	sts	0x014A, r18

			break;
     aa6:	08 95       	ret
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
     aa8:	10 92 4b 01 	sts	0x014B, r1
			MessageHeader->MessageLength = 0;
     aac:	14 82       	std	Z+4, r1	; 0x04
     aae:	15 82       	std	Z+5, r1	; 0x05
     ab0:	16 82       	std	Z+6, r1	; 0x06
     ab2:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
     ab4:	10 92 4a 01 	sts	0x014A, r1

			break;
     ab8:	08 95       	ret
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
     aba:	81 e0       	ldi	r24, 0x01	; 1
     abc:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
			uint32_t                Query_Oid      = QUERY_Message->Oid;
     ac0:	40 91 15 0d 	lds	r20, 0x0D15
     ac4:	50 91 16 0d 	lds	r21, 0x0D16
     ac8:	60 91 17 0d 	lds	r22, 0x0D17
     acc:	70 91 18 0d 	lds	r23, 0x0D18
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
     ad0:	e9 e0       	ldi	r30, 0x09	; 9
     ad2:	fd e0       	ldi	r31, 0x0D	; 13
     ad4:	84 e0       	ldi	r24, 0x04	; 4
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	a0 e0       	ldi	r26, 0x00	; 0
     ada:	b0 e8       	ldi	r27, 0x80	; 128
     adc:	80 93 09 0d 	sts	0x0D09, r24
     ae0:	90 93 0a 0d 	sts	0x0D0A, r25
     ae4:	a0 93 0b 0d 	sts	0x0D0B, r26
     ae8:	b0 93 0c 0d 	sts	0x0D0C, r27
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
     aec:	88 e1       	ldi	r24, 0x18	; 24
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	a0 e0       	ldi	r26, 0x00	; 0
     af2:	b0 e0       	ldi	r27, 0x00	; 0
     af4:	80 93 0d 0d 	sts	0x0D0D, r24
     af8:	90 93 0e 0d 	sts	0x0D0E, r25
     afc:	a0 93 0f 0d 	sts	0x0D0F, r26
     b00:	b0 93 10 0d 	sts	0x0D10, r27
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     b04:	4e 30       	cpi	r20, 0x0E	; 14
     b06:	21 e0       	ldi	r18, 0x01	; 1
     b08:	52 07       	cpc	r21, r18
     b0a:	21 e0       	ldi	r18, 0x01	; 1
     b0c:	62 07       	cpc	r22, r18
     b0e:	20 e0       	ldi	r18, 0x00	; 0
     b10:	72 07       	cpc	r23, r18
     b12:	09 f4       	brne	.+2      	; 0xb16 <ProcessRNDISControlMessage+0x1be>
     b14:	03 c1       	rjmp	.+518    	; 0xd1c <ProcessRNDISControlMessage+0x3c4>
     b16:	4f 30       	cpi	r20, 0x0F	; 15
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	58 07       	cpc	r21, r24
     b1c:	81 e0       	ldi	r24, 0x01	; 1
     b1e:	68 07       	cpc	r22, r24
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	78 07       	cpc	r23, r24
     b24:	08 f0       	brcs	.+2      	; 0xb28 <ProcessRNDISControlMessage+0x1d0>
     b26:	64 c0       	rjmp	.+200    	; 0xbf0 <ProcessRNDISControlMessage+0x298>
     b28:	46 30       	cpi	r20, 0x06	; 6
     b2a:	21 e0       	ldi	r18, 0x01	; 1
     b2c:	52 07       	cpc	r21, r18
     b2e:	21 e0       	ldi	r18, 0x01	; 1
     b30:	62 07       	cpc	r22, r18
     b32:	20 e0       	ldi	r18, 0x00	; 0
     b34:	72 07       	cpc	r23, r18
     b36:	09 f4       	brne	.+2      	; 0xb3a <ProcessRNDISControlMessage+0x1e2>
     b38:	bf c0       	rjmp	.+382    	; 0xcb8 <ProcessRNDISControlMessage+0x360>
     b3a:	47 30       	cpi	r20, 0x07	; 7
     b3c:	81 e0       	ldi	r24, 0x01	; 1
     b3e:	58 07       	cpc	r21, r24
     b40:	81 e0       	ldi	r24, 0x01	; 1
     b42:	68 07       	cpc	r22, r24
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	78 07       	cpc	r23, r24
     b48:	28 f5       	brcc	.+74     	; 0xb94 <ProcessRNDISControlMessage+0x23c>
     b4a:	42 30       	cpi	r20, 0x02	; 2
     b4c:	21 e0       	ldi	r18, 0x01	; 1
     b4e:	52 07       	cpc	r21, r18
     b50:	21 e0       	ldi	r18, 0x01	; 1
     b52:	62 07       	cpc	r22, r18
     b54:	20 e0       	ldi	r18, 0x00	; 0
     b56:	72 07       	cpc	r23, r18
     b58:	09 f4       	brne	.+2      	; 0xb5c <ProcessRNDISControlMessage+0x204>
     b5a:	c6 c0       	rjmp	.+396    	; 0xce8 <ProcessRNDISControlMessage+0x390>
     b5c:	43 30       	cpi	r20, 0x03	; 3
     b5e:	81 e0       	ldi	r24, 0x01	; 1
     b60:	58 07       	cpc	r21, r24
     b62:	81 e0       	ldi	r24, 0x01	; 1
     b64:	68 07       	cpc	r22, r24
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	78 07       	cpc	r23, r24
     b6a:	50 f4       	brcc	.+20     	; 0xb80 <ProcessRNDISControlMessage+0x228>
     b6c:	41 30       	cpi	r20, 0x01	; 1
     b6e:	21 e0       	ldi	r18, 0x01	; 1
     b70:	52 07       	cpc	r21, r18
     b72:	21 e0       	ldi	r18, 0x01	; 1
     b74:	62 07       	cpc	r22, r18
     b76:	20 e0       	ldi	r18, 0x00	; 0
     b78:	72 07       	cpc	r23, r18
     b7a:	09 f0       	breq	.+2      	; 0xb7e <ProcessRNDISControlMessage+0x226>
     b7c:	ec c0       	rjmp	.+472    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     b7e:	8c c0       	rjmp	.+280    	; 0xc98 <ProcessRNDISControlMessage+0x340>
     b80:	45 30       	cpi	r20, 0x05	; 5
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	58 07       	cpc	r21, r24
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	68 07       	cpc	r22, r24
     b8a:	80 e0       	ldi	r24, 0x00	; 0
     b8c:	78 07       	cpc	r23, r24
     b8e:	08 f0       	brcs	.+2      	; 0xb92 <ProcessRNDISControlMessage+0x23a>
     b90:	e2 c0       	rjmp	.+452    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     b92:	aa c0       	rjmp	.+340    	; 0xce8 <ProcessRNDISControlMessage+0x390>
     b94:	4c 30       	cpi	r20, 0x0C	; 12
     b96:	21 e0       	ldi	r18, 0x01	; 1
     b98:	52 07       	cpc	r21, r18
     b9a:	21 e0       	ldi	r18, 0x01	; 1
     b9c:	62 07       	cpc	r22, r18
     b9e:	20 e0       	ldi	r18, 0x00	; 0
     ba0:	72 07       	cpc	r23, r18
     ba2:	98 f4       	brcc	.+38     	; 0xbca <ProcessRNDISControlMessage+0x272>
     ba4:	4a 30       	cpi	r20, 0x0A	; 10
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	58 07       	cpc	r21, r24
     baa:	81 e0       	ldi	r24, 0x01	; 1
     bac:	68 07       	cpc	r22, r24
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	78 07       	cpc	r23, r24
     bb2:	08 f0       	brcs	.+2      	; 0xbb6 <ProcessRNDISControlMessage+0x25e>
     bb4:	81 c0       	rjmp	.+258    	; 0xcb8 <ProcessRNDISControlMessage+0x360>
     bb6:	47 30       	cpi	r20, 0x07	; 7
     bb8:	21 e0       	ldi	r18, 0x01	; 1
     bba:	52 07       	cpc	r21, r18
     bbc:	21 e0       	ldi	r18, 0x01	; 1
     bbe:	62 07       	cpc	r22, r18
     bc0:	20 e0       	ldi	r18, 0x00	; 0
     bc2:	72 07       	cpc	r23, r18
     bc4:	09 f0       	breq	.+2      	; 0xbc8 <ProcessRNDISControlMessage+0x270>
     bc6:	c7 c0       	rjmp	.+398    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     bc8:	94 c0       	rjmp	.+296    	; 0xcf2 <ProcessRNDISControlMessage+0x39a>
     bca:	4c 30       	cpi	r20, 0x0C	; 12
     bcc:	81 e0       	ldi	r24, 0x01	; 1
     bce:	58 07       	cpc	r21, r24
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	68 07       	cpc	r22, r24
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	78 07       	cpc	r23, r24
     bd8:	09 f4       	brne	.+2      	; 0xbdc <ProcessRNDISControlMessage+0x284>
     bda:	69 c0       	rjmp	.+210    	; 0xcae <ProcessRNDISControlMessage+0x356>
     bdc:	4d 30       	cpi	r20, 0x0D	; 13
     bde:	21 e0       	ldi	r18, 0x01	; 1
     be0:	52 07       	cpc	r21, r18
     be2:	21 e0       	ldi	r18, 0x01	; 1
     be4:	62 07       	cpc	r22, r18
     be6:	20 e0       	ldi	r18, 0x00	; 0
     be8:	72 07       	cpc	r23, r18
     bea:	09 f0       	breq	.+2      	; 0xbee <ProcessRNDISControlMessage+0x296>
     bec:	b4 c0       	rjmp	.+360    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     bee:	71 c0       	rjmp	.+226    	; 0xcd2 <ProcessRNDISControlMessage+0x37a>
     bf0:	46 30       	cpi	r20, 0x06	; 6
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	58 07       	cpc	r21, r24
     bf6:	82 e0       	ldi	r24, 0x02	; 2
     bf8:	68 07       	cpc	r22, r24
     bfa:	80 e0       	ldi	r24, 0x00	; 0
     bfc:	78 07       	cpc	r23, r24
     bfe:	28 f5       	brcc	.+74     	; 0xc4a <ProcessRNDISControlMessage+0x2f2>
     c00:	41 30       	cpi	r20, 0x01	; 1
     c02:	21 e0       	ldi	r18, 0x01	; 1
     c04:	52 07       	cpc	r21, r18
     c06:	22 e0       	ldi	r18, 0x02	; 2
     c08:	62 07       	cpc	r22, r18
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	72 07       	cpc	r23, r18
     c0e:	08 f0       	brcs	.+2      	; 0xc12 <ProcessRNDISControlMessage+0x2ba>
     c10:	8e c0       	rjmp	.+284    	; 0xd2e <ProcessRNDISControlMessage+0x3d6>
     c12:	44 31       	cpi	r20, 0x14	; 20
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	58 07       	cpc	r21, r24
     c18:	81 e0       	ldi	r24, 0x01	; 1
     c1a:	68 07       	cpc	r22, r24
     c1c:	80 e0       	ldi	r24, 0x00	; 0
     c1e:	78 07       	cpc	r23, r24
     c20:	09 f4       	brne	.+2      	; 0xc24 <ProcessRNDISControlMessage+0x2cc>
     c22:	62 c0       	rjmp	.+196    	; 0xce8 <ProcessRNDISControlMessage+0x390>
     c24:	42 30       	cpi	r20, 0x02	; 2
     c26:	22 e0       	ldi	r18, 0x02	; 2
     c28:	52 07       	cpc	r21, r18
     c2a:	21 e0       	ldi	r18, 0x01	; 1
     c2c:	62 07       	cpc	r22, r18
     c2e:	20 e0       	ldi	r18, 0x00	; 0
     c30:	72 07       	cpc	r23, r18
     c32:	09 f4       	brne	.+2      	; 0xc36 <ProcessRNDISControlMessage+0x2de>
     c34:	59 c0       	rjmp	.+178    	; 0xce8 <ProcessRNDISControlMessage+0x390>
     c36:	41 31       	cpi	r20, 0x11	; 17
     c38:	81 e0       	ldi	r24, 0x01	; 1
     c3a:	58 07       	cpc	r21, r24
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	68 07       	cpc	r22, r24
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	78 07       	cpc	r23, r24
     c44:	09 f0       	breq	.+2      	; 0xc48 <ProcessRNDISControlMessage+0x2f0>
     c46:	87 c0       	rjmp	.+270    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     c48:	7b c0       	rjmp	.+246    	; 0xd40 <ProcessRNDISControlMessage+0x3e8>
     c4a:	44 30       	cpi	r20, 0x04	; 4
     c4c:	21 e0       	ldi	r18, 0x01	; 1
     c4e:	52 07       	cpc	r21, r18
     c50:	21 e0       	ldi	r18, 0x01	; 1
     c52:	62 07       	cpc	r22, r18
     c54:	21 e0       	ldi	r18, 0x01	; 1
     c56:	72 07       	cpc	r23, r18
     c58:	09 f4       	brne	.+2      	; 0xc5c <ProcessRNDISControlMessage+0x304>
     c5a:	5b c0       	rjmp	.+182    	; 0xd12 <ProcessRNDISControlMessage+0x3ba>
     c5c:	45 30       	cpi	r20, 0x05	; 5
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	58 07       	cpc	r21, r24
     c62:	81 e0       	ldi	r24, 0x01	; 1
     c64:	68 07       	cpc	r22, r24
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	78 07       	cpc	r23, r24
     c6a:	58 f4       	brcc	.+22     	; 0xc82 <ProcessRNDISControlMessage+0x32a>
     c6c:	41 50       	subi	r20, 0x01	; 1
     c6e:	51 40       	sbci	r21, 0x01	; 1
     c70:	61 40       	sbci	r22, 0x01	; 1
     c72:	71 40       	sbci	r23, 0x01	; 1
     c74:	42 30       	cpi	r20, 0x02	; 2
     c76:	51 05       	cpc	r21, r1
     c78:	61 05       	cpc	r22, r1
     c7a:	71 05       	cpc	r23, r1
     c7c:	08 f0       	brcs	.+2      	; 0xc80 <ProcessRNDISControlMessage+0x328>
     c7e:	6b c0       	rjmp	.+214    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     c80:	3d c0       	rjmp	.+122    	; 0xcfc <ProcessRNDISControlMessage+0x3a4>
     c82:	41 50       	subi	r20, 0x01	; 1
     c84:	51 40       	sbci	r21, 0x01	; 1
     c86:	62 40       	sbci	r22, 0x02	; 2
     c88:	71 40       	sbci	r23, 0x01	; 1
     c8a:	43 30       	cpi	r20, 0x03	; 3
     c8c:	51 05       	cpc	r21, r1
     c8e:	61 05       	cpc	r22, r1
     c90:	71 05       	cpc	r23, r1
     c92:	08 f0       	brcs	.+2      	; 0xc96 <ProcessRNDISControlMessage+0x33e>
     c94:	60 c0       	rjmp	.+192    	; 0xd56 <ProcessRNDISControlMessage+0x3fe>
     c96:	4b c0       	rjmp	.+150    	; 0xd2e <ProcessRNDISControlMessage+0x3d6>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
     c98:	cf 01       	movw	r24, r30
     c9a:	48 96       	adiw	r24, 0x18	; 24
     c9c:	60 e3       	ldi	r22, 0x30	; 48
     c9e:	71 e0       	ldi	r23, 0x01	; 1
     ca0:	4c e6       	ldi	r20, 0x6C	; 108
     ca2:	50 e0       	ldi	r21, 0x00	; 0
     ca4:	0e 94 2e 15 	call	0x2a5c	; 0x2a5c <memcpy_P>
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
     ca8:	4c e6       	ldi	r20, 0x6C	; 108
     caa:	50 e0       	ldi	r21, 0x00	; 0
     cac:	0b c1       	rjmp	.+534    	; 0xec4 <ProcessRNDISControlMessage+0x56c>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
     cae:	8f ef       	ldi	r24, 0xFF	; 255
     cb0:	9f ef       	ldi	r25, 0xFF	; 255
     cb2:	af ef       	ldi	r26, 0xFF	; 255
     cb4:	b0 e0       	ldi	r27, 0x00	; 0
     cb6:	48 c0       	rjmp	.+144    	; 0xd48 <ProcessRNDISControlMessage+0x3f0>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
     cb8:	8c ed       	ldi	r24, 0xDC	; 220
     cba:	95 e0       	ldi	r25, 0x05	; 5
     cbc:	a0 e0       	ldi	r26, 0x00	; 0
     cbe:	b0 e0       	ldi	r27, 0x00	; 0
     cc0:	80 93 21 0d 	sts	0x0D21, r24
     cc4:	90 93 22 0d 	sts	0x0D22, r25
     cc8:	a0 93 23 0d 	sts	0x0D23, r26
     ccc:	b0 93 24 0d 	sts	0x0D24, r27
     cd0:	3f c0       	rjmp	.+126    	; 0xd50 <ProcessRNDISControlMessage+0x3f8>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
     cd2:	cf 01       	movw	r24, r30
     cd4:	48 96       	adiw	r24, 0x18	; 24
     cd6:	6c e9       	ldi	r22, 0x9C	; 156
     cd8:	71 e0       	ldi	r23, 0x01	; 1
     cda:	43 e1       	ldi	r20, 0x13	; 19
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	0e 94 2e 15 	call	0x2a5c	; 0x2a5c <memcpy_P>
			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);
     ce2:	43 e1       	ldi	r20, 0x13	; 19
     ce4:	50 e0       	ldi	r21, 0x00	; 0
     ce6:	ee c0       	rjmp	.+476    	; 0xec4 <ProcessRNDISControlMessage+0x56c>
			return true;
		case OID_GEN_MEDIA_CONNECT_STATUS:
			*ResponseSize = sizeof(uint32_t);

			/* Always indicate that the adapter is connected to a network */
			*((uint32_t*)ResponseData) = REMOTE_NDIS_MEDIA_STATE_CONNECTED;
     ce8:	10 8e       	std	Z+24, r1	; 0x18
     cea:	11 8e       	std	Z+25, r1	; 0x19
     cec:	12 8e       	std	Z+26, r1	; 0x1a
     cee:	13 8e       	std	Z+27, r1	; 0x1b
     cf0:	2f c0       	rjmp	.+94     	; 0xd50 <ProcessRNDISControlMessage+0x3f8>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
     cf2:	80 ea       	ldi	r24, 0xA0	; 160
     cf4:	96 e8       	ldi	r25, 0x86	; 134
     cf6:	a1 e0       	ldi	r26, 0x01	; 1
     cf8:	b0 e0       	ldi	r27, 0x00	; 0
     cfa:	26 c0       	rjmp	.+76     	; 0xd48 <ProcessRNDISControlMessage+0x3f0>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
     cfc:	cf 01       	movw	r24, r30
     cfe:	48 96       	adiw	r24, 0x18	; 24
     d00:	6f ea       	ldi	r22, 0xAF	; 175
     d02:	71 e0       	ldi	r23, 0x01	; 1
     d04:	46 e0       	ldi	r20, 0x06	; 6
     d06:	50 e0       	ldi	r21, 0x00	; 0
     d08:	0e 94 2e 15 	call	0x2a5c	; 0x2a5c <memcpy_P>
			*((uint32_t*)ResponseData) = 100000;

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
     d0c:	46 e0       	ldi	r20, 0x06	; 6
     d0e:	50 e0       	ldi	r21, 0x00	; 0
     d10:	d9 c0       	rjmp	.+434    	; 0xec4 <ProcessRNDISControlMessage+0x56c>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
     d12:	81 e0       	ldi	r24, 0x01	; 1
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	a0 e0       	ldi	r26, 0x00	; 0
     d18:	b0 e0       	ldi	r27, 0x00	; 0
     d1a:	16 c0       	rjmp	.+44     	; 0xd48 <ProcessRNDISControlMessage+0x3f0>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
     d1c:	80 91 46 01 	lds	r24, 0x0146
     d20:	90 91 47 01 	lds	r25, 0x0147
     d24:	a0 91 48 01 	lds	r26, 0x0148
     d28:	b0 91 49 01 	lds	r27, 0x0149
     d2c:	0d c0       	rjmp	.+26     	; 0xd48 <ProcessRNDISControlMessage+0x3f0>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
     d2e:	10 92 21 0d 	sts	0x0D21, r1
     d32:	10 92 22 0d 	sts	0x0D22, r1
     d36:	10 92 23 0d 	sts	0x0D23, r1
     d3a:	10 92 24 0d 	sts	0x0D24, r1
     d3e:	08 c0       	rjmp	.+16     	; 0xd50 <ProcessRNDISControlMessage+0x3f8>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
     d40:	80 e6       	ldi	r24, 0x60	; 96
     d42:	96 e0       	ldi	r25, 0x06	; 6
     d44:	a0 e0       	ldi	r26, 0x00	; 0
     d46:	b0 e0       	ldi	r27, 0x00	; 0
     d48:	80 8f       	std	Z+24, r24	; 0x18
     d4a:	91 8f       	std	Z+25, r25	; 0x19
     d4c:	a2 8f       	std	Z+26, r26	; 0x1a
     d4e:	b3 8f       	std	Z+27, r27	; 0x1b
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
     d50:	44 e0       	ldi	r20, 0x04	; 4
     d52:	50 e0       	ldi	r21, 0x00	; 0
     d54:	b7 c0       	rjmp	.+366    	; 0xec4 <ProcessRNDISControlMessage+0x56c>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
     d56:	8b eb       	ldi	r24, 0xBB	; 187
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	a0 e0       	ldi	r26, 0x00	; 0
     d5c:	b0 ec       	ldi	r27, 0xC0	; 192
     d5e:	80 93 15 0d 	sts	0x0D15, r24
     d62:	90 93 16 0d 	sts	0x0D16, r25
     d66:	a0 93 17 0d 	sts	0x0D17, r26
     d6a:	b0 93 18 0d 	sts	0x0D18, r27

				QUERY_Response->InformationBufferLength = 0;
     d6e:	10 92 19 0d 	sts	0x0D19, r1
     d72:	10 92 1a 0d 	sts	0x0D1A, r1
     d76:	10 92 1b 0d 	sts	0x0D1B, r1
     d7a:	10 92 1c 0d 	sts	0x0D1C, r1
				QUERY_Response->InformationBufferOffset = 0;
     d7e:	10 92 1d 0d 	sts	0x0D1D, r1
     d82:	10 92 1e 0d 	sts	0x0D1E, r1
     d86:	10 92 1f 0d 	sts	0x0D1F, r1
     d8a:	10 92 20 0d 	sts	0x0D20, r1
     d8e:	08 95       	ret

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
     d96:	80 91 15 0d 	lds	r24, 0x0D15
     d9a:	90 91 16 0d 	lds	r25, 0x0D16
     d9e:	a0 91 17 0d 	lds	r26, 0x0D17
     da2:	b0 91 18 0d 	lds	r27, 0x0D18

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
     da6:	45 e0       	ldi	r20, 0x05	; 5
     da8:	50 e0       	ldi	r21, 0x00	; 0
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	70 e8       	ldi	r23, 0x80	; 128
     dae:	40 93 09 0d 	sts	0x0D09, r20
     db2:	50 93 0a 0d 	sts	0x0D0A, r21
     db6:	60 93 0b 0d 	sts	0x0D0B, r22
     dba:	70 93 0c 0d 	sts	0x0D0C, r23
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
     dbe:	40 e1       	ldi	r20, 0x10	; 16
     dc0:	50 e0       	ldi	r21, 0x00	; 0
     dc2:	60 e0       	ldi	r22, 0x00	; 0
     dc4:	70 e0       	ldi	r23, 0x00	; 0
     dc6:	40 93 0d 0d 	sts	0x0D0D, r20
     dca:	50 93 0e 0d 	sts	0x0D0E, r21
     dce:	60 93 0f 0d 	sts	0x0D0F, r22
     dd2:	70 93 10 0d 	sts	0x0D10, r23
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];
     dd6:	40 91 1d 0d 	lds	r20, 0x0D1D
     dda:	50 91 1e 0d 	lds	r21, 0x0D1E
     dde:	60 91 1f 0d 	lds	r22, 0x0D1F
     de2:	70 91 20 0d 	lds	r23, 0x0D20
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
     de6:	8e 30       	cpi	r24, 0x0E	; 14
     de8:	e1 e0       	ldi	r30, 0x01	; 1
     dea:	9e 07       	cpc	r25, r30
     dec:	e1 e0       	ldi	r30, 0x01	; 1
     dee:	ae 07       	cpc	r26, r30
     df0:	e0 e0       	ldi	r30, 0x00	; 0
     df2:	be 07       	cpc	r27, r30
     df4:	51 f0       	breq	.+20     	; 0xe0a <ProcessRNDISControlMessage+0x4b2>
     df6:	83 30       	cpi	r24, 0x03	; 3
     df8:	f1 e0       	ldi	r31, 0x01	; 1
     dfa:	9f 07       	cpc	r25, r31
     dfc:	f1 e0       	ldi	r31, 0x01	; 1
     dfe:	af 07       	cpc	r26, r31
     e00:	f1 e0       	ldi	r31, 0x01	; 1
     e02:	bf 07       	cpc	r27, r31
     e04:	09 f0       	breq	.+2      	; 0xe08 <ProcessRNDISControlMessage+0x4b0>
     e06:	91 c0       	rjmp	.+290    	; 0xf2a <ProcessRNDISControlMessage+0x5d2>
     e08:	54 c0       	rjmp	.+168    	; 0xeb2 <ProcessRNDISControlMessage+0x55a>

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
     e0a:	48 5f       	subi	r20, 0xF8	; 248
     e0c:	5f 4f       	sbci	r21, 0xFF	; 255

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
     e0e:	47 5f       	subi	r20, 0xF7	; 247
     e10:	52 4f       	sbci	r21, 0xF2	; 242
     e12:	fa 01       	movw	r30, r20
     e14:	80 81       	ld	r24, Z
     e16:	91 81       	ldd	r25, Z+1	; 0x01
     e18:	a2 81       	ldd	r26, Z+2	; 0x02
     e1a:	b3 81       	ldd	r27, Z+3	; 0x03
     e1c:	80 93 46 01 	sts	0x0146, r24
     e20:	90 93 47 01 	sts	0x0147, r25
     e24:	a0 93 48 01 	sts	0x0148, r26
     e28:	b0 93 49 01 	sts	0x0149, r27

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
     e2c:	82 e0       	ldi	r24, 0x02	; 2
     e2e:	80 93 4a 01 	sts	0x014A, r24
     e32:	3f c0       	rjmp	.+126    	; 0xeb2 <ProcessRNDISControlMessage+0x55a>

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
     e3a:	86 e0       	ldi	r24, 0x06	; 6
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	a0 e0       	ldi	r26, 0x00	; 0
     e40:	b0 e8       	ldi	r27, 0x80	; 128
     e42:	80 93 09 0d 	sts	0x0D09, r24
     e46:	90 93 0a 0d 	sts	0x0D0A, r25
     e4a:	a0 93 0b 0d 	sts	0x0D0B, r26
     e4e:	b0 93 0c 0d 	sts	0x0D0C, r27
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
     e52:	80 e1       	ldi	r24, 0x10	; 16
     e54:	90 e0       	ldi	r25, 0x00	; 0
     e56:	a0 e0       	ldi	r26, 0x00	; 0
     e58:	b0 e0       	ldi	r27, 0x00	; 0
     e5a:	80 93 0d 0d 	sts	0x0D0D, r24
     e5e:	90 93 0e 0d 	sts	0x0D0E, r25
     e62:	a0 93 0f 0d 	sts	0x0D0F, r26
     e66:	b0 93 10 0d 	sts	0x0D10, r27
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
     e6a:	10 92 11 0d 	sts	0x0D11, r1
     e6e:	10 92 12 0d 	sts	0x0D12, r1
     e72:	10 92 13 0d 	sts	0x0D13, r1
     e76:	10 92 14 0d 	sts	0x0D14, r1
     e7a:	1b c0       	rjmp	.+54     	; 0xeb2 <ProcessRNDISControlMessage+0x55a>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
     e82:	88 e0       	ldi	r24, 0x08	; 8
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	a0 e0       	ldi	r26, 0x00	; 0
     e88:	b0 e8       	ldi	r27, 0x80	; 128
     e8a:	80 93 09 0d 	sts	0x0D09, r24
     e8e:	90 93 0a 0d 	sts	0x0D0A, r25
     e92:	a0 93 0b 0d 	sts	0x0D0B, r26
     e96:	b0 93 0c 0d 	sts	0x0D0C, r27
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
     e9a:	80 e1       	ldi	r24, 0x10	; 16
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	a0 e0       	ldi	r26, 0x00	; 0
     ea0:	b0 e0       	ldi	r27, 0x00	; 0
     ea2:	80 93 0d 0d 	sts	0x0D0D, r24
     ea6:	90 93 0e 0d 	sts	0x0D0E, r25
     eaa:	a0 93 0f 0d 	sts	0x0D0F, r26
     eae:	b0 93 10 0d 	sts	0x0D10, r27
			KEEPALIVE_Response->RequestId       = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
     eb2:	10 92 15 0d 	sts	0x0D15, r1
     eb6:	10 92 16 0d 	sts	0x0D16, r1
     eba:	10 92 17 0d 	sts	0x0D17, r1
     ebe:	10 92 18 0d 	sts	0x0D18, r1

			break;
     ec2:	08 95       	ret
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
     ec4:	10 92 15 0d 	sts	0x0D15, r1
     ec8:	10 92 16 0d 	sts	0x0D16, r1
     ecc:	10 92 17 0d 	sts	0x0D17, r1
     ed0:	10 92 18 0d 	sts	0x0D18, r1
				QUERY_Response->MessageLength          += ResponseSize;
     ed4:	60 e0       	ldi	r22, 0x00	; 0
     ed6:	70 e0       	ldi	r23, 0x00	; 0
     ed8:	80 91 0d 0d 	lds	r24, 0x0D0D
     edc:	90 91 0e 0d 	lds	r25, 0x0D0E
     ee0:	a0 91 0f 0d 	lds	r26, 0x0D0F
     ee4:	b0 91 10 0d 	lds	r27, 0x0D10
     ee8:	84 0f       	add	r24, r20
     eea:	95 1f       	adc	r25, r21
     eec:	a6 1f       	adc	r26, r22
     eee:	b7 1f       	adc	r27, r23
     ef0:	80 93 0d 0d 	sts	0x0D0D, r24
     ef4:	90 93 0e 0d 	sts	0x0D0E, r25
     ef8:	a0 93 0f 0d 	sts	0x0D0F, r26
     efc:	b0 93 10 0d 	sts	0x0D10, r27

				QUERY_Response->InformationBufferLength = ResponseSize;
     f00:	40 93 19 0d 	sts	0x0D19, r20
     f04:	50 93 1a 0d 	sts	0x0D1A, r21
     f08:	60 93 1b 0d 	sts	0x0D1B, r22
     f0c:	70 93 1c 0d 	sts	0x0D1C, r23
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
     f10:	80 e1       	ldi	r24, 0x10	; 16
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	a0 e0       	ldi	r26, 0x00	; 0
     f16:	b0 e0       	ldi	r27, 0x00	; 0
     f18:	80 93 1d 0d 	sts	0x0D1D, r24
     f1c:	90 93 1e 0d 	sts	0x0D1E, r25
     f20:	a0 93 1f 0d 	sts	0x0D1F, r26
     f24:	b0 93 20 0d 	sts	0x0D20, r27
     f28:	08 95       	ret
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
     f2a:	8b eb       	ldi	r24, 0xBB	; 187
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	a0 e0       	ldi	r26, 0x00	; 0
     f30:	b0 ec       	ldi	r27, 0xC0	; 192
     f32:	80 93 15 0d 	sts	0x0D15, r24
     f36:	90 93 16 0d 	sts	0x0D16, r25
     f3a:	a0 93 17 0d 	sts	0x0D17, r26
     f3e:	b0 93 18 0d 	sts	0x0D18, r27
     f42:	08 95       	ret

00000f44 <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     f44:	ef 92       	push	r14
     f46:	ff 92       	push	r15
     f48:	0f 93       	push	r16
     f4a:	1f 93       	push	r17
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	8c 01       	movw	r16, r24
     f52:	7b 01       	movw	r14, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     f54:	fd dc       	rcall	.-1542   	; 0x950 <DecodeICMPHeader>
     f56:	f8 01       	movw	r30, r16

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     f58:	80 81       	ld	r24, Z
     f5a:	88 30       	cpi	r24, 0x08	; 8
     f5c:	51 f5       	brne	.+84     	; 0xfb2 <ICMP_ProcessICMPPacket+0x6e>
     f5e:	f7 01       	movw	r30, r14
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     f60:	10 82       	st	Z, r1
     f62:	11 82       	std	Z+1, r1	; 0x01
		ICMPHeaderOUT->Code     = 0;
     f64:	13 82       	std	Z+3, r1	; 0x03
		ICMPHeaderOUT->Checksum = 0;
     f66:	12 82       	std	Z+2, r1	; 0x02
     f68:	f8 01       	movw	r30, r16
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     f6a:	84 81       	ldd	r24, Z+4	; 0x04
     f6c:	95 81       	ldd	r25, Z+5	; 0x05
     f6e:	f7 01       	movw	r30, r14
     f70:	95 83       	std	Z+5, r25	; 0x05
     f72:	84 83       	std	Z+4, r24	; 0x04
     f74:	f8 01       	movw	r30, r16
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     f76:	86 81       	ldd	r24, Z+6	; 0x06
     f78:	97 81       	ldd	r25, Z+7	; 0x07
     f7a:	f7 01       	movw	r30, r14
     f7c:	97 83       	std	Z+7, r25	; 0x07
     f7e:	86 83       	std	Z+6, r24	; 0x06
     f80:	c0 91 29 07 	lds	r28, 0x0729

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     f84:	d0 91 2a 07 	lds	r29, 0x072A
     f88:	cb 5b       	subi	r28, 0xBB	; 187
     f8a:	de 4f       	sbci	r29, 0xFE	; 254
     f8c:	c0 1b       	sub	r28, r16
     f8e:	d1 0b       	sbc	r29, r17
     f90:	b8 01       	movw	r22, r16

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     f92:	68 5f       	subi	r22, 0xF8	; 248
     f94:	7f 4f       	sbci	r23, 0xFF	; 255
     f96:	c7 01       	movw	r24, r14
     f98:	08 96       	adiw	r24, 0x08	; 8
     f9a:	ae 01       	movw	r20, r28
     f9c:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <memmove>
     fa0:	28 96       	adiw	r28, 0x08	; 8
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     fa2:	c7 01       	movw	r24, r14
     fa4:	be 01       	movw	r22, r28
     fa6:	9f dc       	rcall	.-1730   	; 0x8e6 <Ethernet_Checksum16>
     fa8:	f7 01       	movw	r30, r14
     faa:	93 83       	std	Z+3, r25	; 0x03
     fac:	82 83       	std	Z+2, r24	; 0x02
     fae:	ce 01       	movw	r24, r28
     fb0:	02 c0       	rjmp	.+4      	; 0xfb6 <ICMP_ProcessICMPPacket+0x72>

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     fb2:	80 e0       	ldi	r24, 0x00	; 0
     fb4:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
     fb6:	df 91       	pop	r29
     fb8:	cf 91       	pop	r28
}
     fba:	1f 91       	pop	r17
     fbc:	0f 91       	pop	r16
     fbe:	ff 90       	pop	r15
     fc0:	ef 90       	pop	r14
     fc2:	08 95       	ret

00000fc4 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     fc4:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     fc6:	69 2f       	mov	r22, r25
     fc8:	78 2f       	mov	r23, r24
     fca:	83 2f       	mov	r24, r19
     fcc:	92 2f       	mov	r25, r18
     fce:	08 95       	ret

00000fd0 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     fd0:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     fd2:	89 2f       	mov	r24, r25
     fd4:	92 2f       	mov	r25, r18
     fd6:	08 95       	ret

00000fd8 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     fd8:	af 92       	push	r10
     fda:	bf 92       	push	r11
     fdc:	cf 92       	push	r12
     fde:	df 92       	push	r13
     fe0:	ef 92       	push	r14
     fe2:	ff 92       	push	r15
     fe4:	0f 93       	push	r16
     fe6:	1f 93       	push	r17
     fe8:	cf 93       	push	r28
     fea:	df 93       	push	r29
     fec:	5c 01       	movw	r10, r24
     fee:	fb 01       	movw	r30, r22
     ff0:	ea 01       	movw	r28, r20
     ff2:	89 01       	movw	r16, r18

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     ff4:	c2 80       	ldd	r12, Z+2	; 0x02
     ff6:	d3 80       	ldd	r13, Z+3	; 0x03
     ff8:	ee 24       	eor	r14, r14
     ffa:	ff 24       	eor	r15, r15
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     ffc:	80 81       	ld	r24, Z
     ffe:	91 81       	ldd	r25, Z+1	; 0x01
    1000:	a0 e0       	ldi	r26, 0x00	; 0
    1002:	b0 e0       	ldi	r27, 0x00	; 0
	Checksum += ((uint16_t*)SourceAddress)[1];
    1004:	c8 0e       	add	r12, r24
    1006:	d9 1e       	adc	r13, r25
    1008:	ea 1e       	adc	r14, r26
    100a:	fb 1e       	adc	r15, r27
	Checksum += ((uint16_t*)DestinationAddress)[0];
    100c:	88 81       	ld	r24, Y
    100e:	99 81       	ldd	r25, Y+1	; 0x01
    1010:	a0 e0       	ldi	r26, 0x00	; 0
    1012:	b0 e0       	ldi	r27, 0x00	; 0
    1014:	c8 0e       	add	r12, r24
    1016:	d9 1e       	adc	r13, r25
    1018:	ea 1e       	adc	r14, r26
    101a:	fb 1e       	adc	r15, r27
	Checksum += ((uint16_t*)DestinationAddress)[1];
    101c:	8a 81       	ldd	r24, Y+2	; 0x02
    101e:	9b 81       	ldd	r25, Y+3	; 0x03
    1020:	a0 e0       	ldi	r26, 0x00	; 0
    1022:	b0 e0       	ldi	r27, 0x00	; 0
    1024:	c8 0e       	add	r12, r24
    1026:	d9 1e       	adc	r13, r25
    1028:	ea 1e       	adc	r14, r26
    102a:	fb 1e       	adc	r15, r27
	Checksum += SwapEndian_16(PROTOCOL_TCP);
    102c:	86 e0       	ldi	r24, 0x06	; 6
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	cf df       	rcall	.-98     	; 0xfd0 <SwapEndian_16>
    1032:	a0 e0       	ldi	r26, 0x00	; 0
    1034:	b0 e0       	ldi	r27, 0x00	; 0
    1036:	c8 0e       	add	r12, r24
    1038:	d9 1e       	adc	r13, r25
    103a:	ea 1e       	adc	r14, r26
    103c:	fb 1e       	adc	r15, r27
    103e:	c8 01       	movw	r24, r16
	Checksum += SwapEndian_16(TCPOutSize);
    1040:	c7 df       	rcall	.-114    	; 0xfd0 <SwapEndian_16>
    1042:	ac 01       	movw	r20, r24
    1044:	60 e0       	ldi	r22, 0x00	; 0
    1046:	70 e0       	ldi	r23, 0x00	; 0
    1048:	4c 0d       	add	r20, r12
    104a:	5d 1d       	adc	r21, r13
    104c:	6e 1d       	adc	r22, r14
    104e:	7f 1d       	adc	r23, r15
    1050:	e8 01       	movw	r28, r16
    1052:	d6 95       	lsr	r29

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
    1054:	c7 95       	ror	r28
    1056:	f5 01       	movw	r30, r10
    1058:	20 e0       	ldi	r18, 0x00	; 0
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	0a c0       	rjmp	.+20     	; 0x1072 <TCP_Checksum16+0x9a>
    105e:	81 91       	ld	r24, Z+
    1060:	91 91       	ld	r25, Z+
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
    1062:	a0 e0       	ldi	r26, 0x00	; 0
    1064:	b0 e0       	ldi	r27, 0x00	; 0
    1066:	48 0f       	add	r20, r24
    1068:	59 1f       	adc	r21, r25
    106a:	6a 1f       	adc	r22, r26
    106c:	7b 1f       	adc	r23, r27
    106e:	2f 5f       	subi	r18, 0xFF	; 255
    1070:	3f 4f       	sbci	r19, 0xFF	; 255
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
    1072:	2c 17       	cp	r18, r28
    1074:	3d 07       	cpc	r19, r29
    1076:	99 f7       	brne	.-26     	; 0x105e <TCP_Checksum16+0x86>
    1078:	00 ff       	sbrs	r16, 0
    107a:	16 c0       	rjmp	.+44     	; 0x10a8 <TCP_Checksum16+0xd0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
    107c:	f9 01       	movw	r30, r18
    107e:	ee 0f       	add	r30, r30
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
    1080:	ff 1f       	adc	r31, r31
    1082:	ea 0d       	add	r30, r10
    1084:	fb 1d       	adc	r31, r11
    1086:	80 81       	ld	r24, Z
    1088:	48 0f       	add	r20, r24
    108a:	51 1d       	adc	r21, r1
    108c:	61 1d       	adc	r22, r1
    108e:	71 1d       	adc	r23, r1
    1090:	0b c0       	rjmp	.+22     	; 0x10a8 <TCP_Checksum16+0xd0>
    1092:	db 01       	movw	r26, r22
    1094:	ca 01       	movw	r24, r20

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
    1096:	a0 70       	andi	r26, 0x00	; 0
    1098:	b0 70       	andi	r27, 0x00	; 0
    109a:	ab 01       	movw	r20, r22
    109c:	66 27       	eor	r22, r22
    109e:	77 27       	eor	r23, r23
    10a0:	48 0f       	add	r20, r24
    10a2:	59 1f       	adc	r21, r25
    10a4:	6a 1f       	adc	r22, r26
    10a6:	7b 1f       	adc	r23, r27
    10a8:	db 01       	movw	r26, r22
    10aa:	ca 01       	movw	r24, r20
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
    10ac:	80 70       	andi	r24, 0x00	; 0
    10ae:	90 70       	andi	r25, 0x00	; 0
    10b0:	00 97       	sbiw	r24, 0x00	; 0
    10b2:	a1 05       	cpc	r26, r1
    10b4:	b1 05       	cpc	r27, r1
    10b6:	69 f7       	brne	.-38     	; 0x1092 <TCP_Checksum16+0xba>
    10b8:	ca 01       	movw	r24, r20
    10ba:	80 95       	com	r24
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
    10bc:	90 95       	com	r25
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
}
    10c2:	1f 91       	pop	r17
    10c4:	0f 91       	pop	r16
    10c6:	ff 90       	pop	r15
    10c8:	ef 90       	pop	r14
    10ca:	df 90       	pop	r13
    10cc:	cf 90       	pop	r12
    10ce:	bf 90       	pop	r11
    10d0:	af 90       	pop	r10
    10d2:	08 95       	ret

000010d4 <TCP_Task>:
    10d4:	6f 92       	push	r6
    10d6:	7f 92       	push	r7
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    10d8:	8f 92       	push	r8
    10da:	9f 92       	push	r9
    10dc:	af 92       	push	r10
    10de:	bf 92       	push	r11
    10e0:	cf 92       	push	r12
    10e2:	df 92       	push	r13
    10e4:	ef 92       	push	r14
    10e6:	ff 92       	push	r15
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    10f0:	0d e8       	ldi	r16, 0x8D	; 141
    10f2:	1d e0       	ldi	r17, 0x0D	; 13
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    10f4:	c0 e0       	ldi	r28, 0x00	; 0
    10f6:	d0 e0       	ldi	r29, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    10f8:	86 e1       	ldi	r24, 0x16	; 22
    10fa:	c8 2e       	mov	r12, r24
    10fc:	82 e0       	ldi	r24, 0x02	; 2
    10fe:	d8 2e       	mov	r13, r24
    1100:	1b c0       	rjmp	.+54     	; 0x1138 <TCP_Task+0x64>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1102:	80 91 d1 13 	lds	r24, 0x13D1
    1106:	81 30       	cpi	r24, 0x01	; 1
    1108:	89 f4       	brne	.+34     	; 0x112c <TCP_Task+0x58>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    110a:	cc 9d       	mul	r28, r12
    110c:	c0 01       	movw	r24, r0
    110e:	cd 9d       	mul	r28, r13
    1110:	90 0d       	add	r25, r0
    1112:	dc 9d       	mul	r29, r12
    1114:	90 0d       	add	r25, r0
    1116:	11 24       	eor	r1, r1
    1118:	bc 01       	movw	r22, r24
    111a:	63 56       	subi	r22, 0x63	; 99
    111c:	72 4f       	sbci	r23, 0xF2	; 242
    111e:	e0 91 d2 13 	lds	r30, 0x13D2
    1122:	f0 91 d3 13 	lds	r31, 0x13D3
    1126:	83 57       	subi	r24, 0x73	; 115
    1128:	92 4f       	sbci	r25, 0xF2	; 242
    112a:	09 95       	icall
    112c:	21 96       	adiw	r28, 0x01	; 1
    112e:	0a 5e       	subi	r16, 0xEA	; 234
    1130:	1d 4f       	sbci	r17, 0xFD	; 253
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1132:	c3 30       	cpi	r28, 0x03	; 3
    1134:	d1 05       	cpc	r29, r1
    1136:	59 f0       	breq	.+22     	; 0x114e <TCP_Task+0x7a>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1138:	80 91 cf 13 	lds	r24, 0x13CF
    113c:	90 91 d0 13 	lds	r25, 0x13D0
    1140:	f8 01       	movw	r30, r16
    1142:	20 81       	ld	r18, Z
    1144:	31 81       	ldd	r19, Z+1	; 0x01
    1146:	82 17       	cp	r24, r18
    1148:	93 07       	cpc	r25, r19
    114a:	81 f7       	brne	.-32     	; 0x112c <TCP_Task+0x58>
    114c:	da cf       	rjmp	.-76     	; 0x1102 <TCP_Task+0x2e>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    114e:	80 91 07 0d 	lds	r24, 0x0D07
    1152:	90 91 08 0d 	lds	r25, 0x0D08
    1156:	00 97       	sbiw	r24, 0x00	; 0
    1158:	09 f0       	breq	.+2      	; 0x115c <TCP_Task+0x88>
    115a:	fd c0       	rjmp	.+506    	; 0x1356 <TCP_Task+0x282>
    115c:	e0 ea       	ldi	r30, 0xA0	; 160
    115e:	ff e0       	ldi	r31, 0x0F	; 15
    1160:	66 24       	eor	r6, r6
    1162:	77 24       	eor	r7, r7

/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
    1164:	df 01       	movw	r26, r30
    1166:	11 97       	sbiw	r26, 0x01	; 1

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    1168:	8c 91       	ld	r24, X
    116a:	88 23       	and	r24, r24
    116c:	09 f4       	brne	.+2      	; 0x1170 <TCP_Task+0x9c>
    116e:	e9 c0       	rjmp	.+466    	; 0x1342 <TCP_Task+0x26e>
    1170:	80 81       	ld	r24, Z
    1172:	88 23       	and	r24, r24
    1174:	09 f4       	brne	.+2      	; 0x1178 <TCP_Task+0xa4>
    1176:	e5 c0       	rjmp	.+458    	; 0x1342 <TCP_Task+0x26e>
			                                                                             sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    1178:	86 e1       	ldi	r24, 0x16	; 22
    117a:	92 e0       	ldi	r25, 0x02	; 2
    117c:	68 9e       	mul	r6, r24
    117e:	50 01       	movw	r10, r0
    1180:	69 9e       	mul	r6, r25
    1182:	b0 0c       	add	r11, r0
    1184:	78 9e       	mul	r7, r24
    1186:	b0 0c       	add	r11, r0
    1188:	11 24       	eor	r1, r1
    118a:	e5 01       	movw	r28, r10
    118c:	c3 57       	subi	r28, 0x73	; 115
    118e:	d2 4f       	sbci	r29, 0xF2	; 242
    1190:	88 88       	ldd	r8, Y+16	; 0x10
    1192:	99 88       	ldd	r9, Y+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    1194:	88 81       	ld	r24, Y
    1196:	99 81       	ldd	r25, Y+1	; 0x01
    1198:	90 93 4e 07 	sts	0x074E, r25
    119c:	80 93 4d 07 	sts	0x074D, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    11a0:	8a 81       	ldd	r24, Y+2	; 0x02
    11a2:	9b 81       	ldd	r25, Y+3	; 0x03
    11a4:	90 93 50 07 	sts	0x0750, r25
    11a8:	80 93 4f 07 	sts	0x074F, r24
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    11ac:	cc 84       	ldd	r12, Y+12	; 0x0c
    11ae:	dd 84       	ldd	r13, Y+13	; 0x0d
    11b0:	ee 84       	ldd	r14, Y+14	; 0x0e
    11b2:	ff 84       	ldd	r15, Y+15	; 0x0f
    11b4:	c7 01       	movw	r24, r14
    11b6:	b6 01       	movw	r22, r12
    11b8:	05 df       	rcall	.-502    	; 0xfc4 <SwapEndian_32>
    11ba:	dc 01       	movw	r26, r24
    11bc:	cb 01       	movw	r24, r22
    11be:	80 93 51 07 	sts	0x0751, r24
    11c2:	90 93 52 07 	sts	0x0752, r25
    11c6:	a0 93 53 07 	sts	0x0753, r26
    11ca:	b0 93 54 07 	sts	0x0754, r27
    11ce:	68 85       	ldd	r22, Y+8	; 0x08
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    11d0:	79 85       	ldd	r23, Y+9	; 0x09
    11d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    11d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    11d6:	f6 de       	rcall	.-532    	; 0xfc4 <SwapEndian_32>
    11d8:	dc 01       	movw	r26, r24
    11da:	cb 01       	movw	r24, r22
    11dc:	80 93 55 07 	sts	0x0755, r24
    11e0:	90 93 56 07 	sts	0x0756, r25
    11e4:	a0 93 57 07 	sts	0x0757, r26
    11e8:	b0 93 58 07 	sts	0x0758, r27
    11ec:	00 91 59 07 	lds	r16, 0x0759
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    11f0:	0f 70       	andi	r16, 0x0F	; 15
    11f2:	00 65       	ori	r16, 0x50	; 80
    11f4:	80 e0       	ldi	r24, 0x00	; 0
    11f6:	92 e0       	ldi	r25, 0x02	; 2
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    11f8:	eb de       	rcall	.-554    	; 0xfd0 <SwapEndian_16>
    11fa:	90 93 5c 07 	sts	0x075C, r25
    11fe:	80 93 5b 07 	sts	0x075B, r24
    1202:	80 e1       	ldi	r24, 0x10	; 16
    1204:	80 93 5a 07 	sts	0x075A, r24

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    1208:	10 92 60 07 	sts	0x0760, r1
    120c:	10 92 5f 07 	sts	0x075F, r1
			TCPHeaderOUT->UrgentPointer        = 0;
    1210:	10 92 5e 07 	sts	0x075E, r1
    1214:	10 92 5d 07 	sts	0x075D, r1
			TCPHeaderOUT->Checksum             = 0;
    1218:	00 7f       	andi	r16, 0xF0	; 240
    121a:	00 93 59 07 	sts	0x0759, r16
			TCPHeaderOUT->Reserved             = 0;
    121e:	01 e6       	ldi	r16, 0x61	; 97
    1220:	17 e0       	ldi	r17, 0x07	; 7
    1222:	b5 01       	movw	r22, r10

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    1224:	61 56       	subi	r22, 0x61	; 97
    1226:	72 4f       	sbci	r23, 0xF2	; 242
    1228:	c8 01       	movw	r24, r16
    122a:	a4 01       	movw	r20, r8
    122c:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <memcpy>
    1230:	c4 01       	movw	r24, r8
    1232:	a0 e0       	ldi	r26, 0x00	; 0
    1234:	b0 e0       	ldi	r27, 0x00	; 0

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    1236:	8c 0d       	add	r24, r12
    1238:	9d 1d       	adc	r25, r13
    123a:	ae 1d       	adc	r26, r14
    123c:	bf 1d       	adc	r27, r15
    123e:	8c 87       	std	Y+12, r24	; 0x0c
    1240:	9d 87       	std	Y+13, r25	; 0x0d
    1242:	ae 87       	std	Y+14, r26	; 0x0e
    1244:	bf 87       	std	Y+15, r27	; 0x0f
    1246:	a5 01       	movw	r20, r10
    1248:	4f 56       	subi	r20, 0x6F	; 111
    124a:	52 4f       	sbci	r21, 0xF2	; 242

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
    124c:	94 01       	movw	r18, r8
    124e:	2c 5e       	subi	r18, 0xEC	; 236
    1250:	3f 4f       	sbci	r19, 0xFF	; 255

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
    1252:	c8 01       	movw	r24, r16
    1254:	44 97       	sbiw	r24, 0x14	; 20
    1256:	66 e1       	ldi	r22, 0x16	; 22
    1258:	71 e0       	ldi	r23, 0x01	; 1
    125a:	be de       	rcall	.-644    	; 0xfd8 <TCP_Checksum16>
    125c:	90 93 5e 07 	sts	0x075E, r25
    1260:	80 93 5d 07 	sts	0x075D, r24
    1264:	c4 01       	movw	r24, r8
    1266:	88 96       	adiw	r24, 0x28	; 40
    1268:	b3 de       	rcall	.-666    	; 0xfd0 <SwapEndian_16>
    126a:	90 93 3c 07 	sts	0x073C, r25
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    126e:	80 93 3b 07 	sts	0x073B, r24
    1272:	10 92 3a 07 	sts	0x073A, r1
    1276:	85 e4       	ldi	r24, 0x45	; 69
    1278:	80 93 39 07 	sts	0x0739, r24
			IPHeaderOUT->TypeOfService      = 0;
    127c:	10 92 3f 07 	sts	0x073F, r1
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    1280:	10 92 40 07 	sts	0x0740, r1
    1284:	10 92 3e 07 	sts	0x073E, r1
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    1288:	10 92 3d 07 	sts	0x073D, r1
    128c:	10 92 44 07 	sts	0x0744, r1
			IPHeaderOUT->Identification     = 0;
    1290:	10 92 43 07 	sts	0x0743, r1
    1294:	86 e0       	ldi	r24, 0x06	; 6
			IPHeaderOUT->HeaderChecksum     = 0;
    1296:	80 93 42 07 	sts	0x0742, r24
    129a:	80 e8       	ldi	r24, 0x80	; 128
    129c:	80 93 41 07 	sts	0x0741, r24
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    12a0:	80 91 16 01 	lds	r24, 0x0116
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    12a4:	90 91 17 01 	lds	r25, 0x0117
    12a8:	a0 91 18 01 	lds	r26, 0x0118
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    12ac:	b0 91 19 01 	lds	r27, 0x0119
    12b0:	80 93 45 07 	sts	0x0745, r24
    12b4:	90 93 46 07 	sts	0x0746, r25
    12b8:	a0 93 47 07 	sts	0x0747, r26
    12bc:	b0 93 48 07 	sts	0x0748, r27
    12c0:	8c 81       	ldd	r24, Y+4	; 0x04
    12c2:	9d 81       	ldd	r25, Y+5	; 0x05
    12c4:	ae 81       	ldd	r26, Y+6	; 0x06
    12c6:	bf 81       	ldd	r27, Y+7	; 0x07
    12c8:	80 93 49 07 	sts	0x0749, r24
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    12cc:	90 93 4a 07 	sts	0x074A, r25
    12d0:	a0 93 4b 07 	sts	0x074B, r26
    12d4:	b0 93 4c 07 	sts	0x074C, r27
    12d8:	c8 01       	movw	r24, r16
    12da:	88 97       	sbiw	r24, 0x28	; 40
    12dc:	64 e1       	ldi	r22, 0x14	; 20
    12de:	70 e0       	ldi	r23, 0x00	; 0
    12e0:	02 db       	rcall	.-2556   	; 0x8e6 <Ethernet_Checksum16>

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    12e2:	90 93 44 07 	sts	0x0744, r25
    12e6:	80 93 43 07 	sts	0x0743, r24
    12ea:	d8 01       	movw	r26, r16
    12ec:	d0 97       	sbiw	r26, 0x30	; 48
    12ee:	ea e1       	ldi	r30, 0x1A	; 26
    12f0:	f1 e0       	ldi	r31, 0x01	; 1
    12f2:	86 e0       	ldi	r24, 0x06	; 6
    12f4:	01 90       	ld	r0, Z+

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    12f6:	0d 92       	st	X+, r0
    12f8:	81 50       	subi	r24, 0x01	; 1
    12fa:	e1 f7       	brne	.-8      	; 0x12f4 <TCP_Task+0x220>
    12fc:	ab e2       	ldi	r26, 0x2B	; 43
    12fe:	b7 e0       	ldi	r27, 0x07	; 7
    1300:	e2 e2       	ldi	r30, 0x22	; 34
    1302:	f1 e0       	ldi	r31, 0x01	; 1
    1304:	86 e0       	ldi	r24, 0x06	; 6
    1306:	01 90       	ld	r0, Z+
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    1308:	0d 92       	st	X+, r0
    130a:	81 50       	subi	r24, 0x01	; 1
    130c:	e1 f7       	brne	.-8      	; 0x1306 <TCP_Task+0x232>
    130e:	80 e0       	ldi	r24, 0x00	; 0
    1310:	98 e0       	ldi	r25, 0x08	; 8
    1312:	5e de       	rcall	.-836    	; 0xfd0 <SwapEndian_16>
    1314:	90 93 38 07 	sts	0x0738, r25
    1318:	80 93 37 07 	sts	0x0737, r24
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    131c:	c4 01       	movw	r24, r8
    131e:	c6 96       	adiw	r24, 0x36	; 54
    1320:	90 93 08 0d 	sts	0x0D08, r25
    1324:	80 93 07 0d 	sts	0x0D07, r24
    1328:	86 e1       	ldi	r24, 0x16	; 22

			PacketSize += sizeof(Ethernet_Frame_Header_t);
    132a:	92 e0       	ldi	r25, 0x02	; 2
    132c:	68 9e       	mul	r6, r24

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
    132e:	f0 01       	movw	r30, r0
    1330:	69 9e       	mul	r6, r25
    1332:	f0 0d       	add	r31, r0
    1334:	78 9e       	mul	r7, r24

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    1336:	f0 0d       	add	r31, r0
    1338:	11 24       	eor	r1, r1
    133a:	e0 56       	subi	r30, 0x60	; 96
    133c:	f0 4f       	sbci	r31, 0xF0	; 240
    133e:	10 82       	st	Z, r1
    1340:	0a c0       	rjmp	.+20     	; 0x1356 <TCP_Task+0x282>
    1342:	08 94       	sec
    1344:	61 1c       	adc	r6, r1
    1346:	71 1c       	adc	r7, r1
    1348:	ea 5e       	subi	r30, 0xEA	; 234
    134a:	fd 4f       	sbci	r31, 0xFD	; 253
    134c:	83 e0       	ldi	r24, 0x03	; 3

			break;
    134e:	68 16       	cp	r6, r24
    1350:	71 04       	cpc	r7, r1
    1352:	09 f0       	breq	.+2      	; 0x1356 <TCP_Task+0x282>
    1354:	07 cf       	rjmp	.-498    	; 0x1164 <TCP_Task+0x90>
    1356:	df 91       	pop	r29
    1358:	cf 91       	pop	r28
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    135a:	1f 91       	pop	r17
    135c:	0f 91       	pop	r16
    135e:	ff 90       	pop	r15
    1360:	ef 90       	pop	r14
    1362:	df 90       	pop	r13
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
    1364:	cf 90       	pop	r12
    1366:	bf 90       	pop	r11
    1368:	af 90       	pop	r10
    136a:	9f 90       	pop	r9
    136c:	8f 90       	pop	r8
    136e:	7f 90       	pop	r7
    1370:	6f 90       	pop	r6
    1372:	08 95       	ret

00001374 <TCP_Init>:
    1374:	10 92 d1 13 	sts	0x13D1, r1
    1378:	8a e0       	ldi	r24, 0x0A	; 10
    137a:	80 93 a2 0f 	sts	0x0FA2, r24
    137e:	80 93 b8 11 	sts	0x11B8, r24
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
    1382:	80 93 ce 13 	sts	0x13CE, r24
}
    1386:	08 95       	ret

00001388 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
    1388:	20 91 cf 13 	lds	r18, 0x13CF
    138c:	30 91 d0 13 	lds	r19, 0x13D0
    1390:	28 17       	cp	r18, r24
    1392:	39 07       	cpc	r19, r25
    1394:	51 f0       	breq	.+20     	; 0x13aa <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
    1396:	61 30       	cpi	r22, 0x01	; 1
    1398:	71 f4       	brne	.+28     	; 0x13b6 <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
    139a:	20 91 d1 13 	lds	r18, 0x13D1
    139e:	22 23       	and	r18, r18
    13a0:	61 f4       	brne	.+24     	; 0x13ba <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
    13a2:	90 93 d0 13 	sts	0x13D0, r25
    13a6:	80 93 cf 13 	sts	0x13CF, r24
				PortStateTable[PTableEntry].State = State;
    13aa:	60 93 d1 13 	sts	0x13D1, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
    13ae:	50 93 d3 13 	sts	0x13D3, r21
    13b2:	40 93 d2 13 	sts	0x13D2, r20
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
    13ba:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
    13bc:	08 95       	ret

000013be <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
    13be:	20 91 cf 13 	lds	r18, 0x13CF
    13c2:	30 91 d0 13 	lds	r19, 0x13D0
    13c6:	28 17       	cp	r18, r24
    13c8:	39 07       	cpc	r19, r25
    13ca:	19 f4       	brne	.+6      	; 0x13d2 <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
    13cc:	80 91 d1 13 	lds	r24, 0x13D1
    13d0:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
    13d2:	80 e0       	ldi	r24, 0x00	; 0
}
    13d4:	08 95       	ret

000013d6 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
    13d6:	4f 92       	push	r4
    13d8:	5f 92       	push	r5
    13da:	6f 92       	push	r6
    13dc:	7f 92       	push	r7
    13de:	8f 92       	push	r8
    13e0:	9f 92       	push	r9
    13e2:	af 92       	push	r10
    13e4:	bf 92       	push	r11
    13e6:	df 92       	push	r13
    13e8:	ef 92       	push	r14
    13ea:	ff 92       	push	r15
    13ec:	0f 93       	push	r16
    13ee:	1f 93       	push	r17
    13f0:	cf 93       	push	r28
    13f2:	df 93       	push	r29
    13f4:	5c 01       	movw	r10, r24
    13f6:	4b 01       	movw	r8, r22
    13f8:	3a 01       	movw	r6, r20
    13fa:	d2 2e       	mov	r13, r18
			ConnectionStateTable[CSTableEntry].State         = State;
			return true;
		}
	}

	return false;
    13fc:	cd e8       	ldi	r28, 0x8D	; 141
    13fe:	dd e0       	ldi	r29, 0x0D	; 13
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
    1400:	00 e0       	ldi	r16, 0x00	; 0
    1402:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1404:	26 e1       	ldi	r18, 0x16	; 22
    1406:	42 2e       	mov	r4, r18
    1408:	22 e0       	ldi	r18, 0x02	; 2
    140a:	52 2e       	mov	r5, r18
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    140c:	88 81       	ld	r24, Y
    140e:	99 81       	ldd	r25, Y+1	; 0x01
    1410:	8a 15       	cp	r24, r10
    1412:	9b 05       	cpc	r25, r11
    1414:	d1 f4       	brne	.+52     	; 0x144a <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1416:	04 9d       	mul	r16, r4
    1418:	70 01       	movw	r14, r0
    141a:	05 9d       	mul	r16, r5
    141c:	f0 0c       	add	r15, r0
    141e:	14 9d       	mul	r17, r4
    1420:	f0 0c       	add	r15, r0
    1422:	11 24       	eor	r1, r1
    1424:	c7 01       	movw	r24, r14
    1426:	8f 56       	subi	r24, 0x6F	; 111
    1428:	92 4f       	sbci	r25, 0xF2	; 242
    142a:	b4 01       	movw	r22, r8
    142c:	44 e0       	ldi	r20, 0x04	; 4
    142e:	50 e0       	ldi	r21, 0x00	; 0
    1430:	0e 94 56 15 	call	0x2aac	; 0x2aac <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1434:	00 97       	sbiw	r24, 0x00	; 0
    1436:	49 f4       	brne	.+18     	; 0x144a <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1438:	8a 81       	ldd	r24, Y+2	; 0x02
    143a:	9b 81       	ldd	r25, Y+3	; 0x03
    143c:	86 15       	cp	r24, r6
    143e:	97 05       	cpc	r25, r7
    1440:	21 f4       	brne	.+8      	; 0x144a <TCP_SetConnectionState+0x74>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
    1442:	f7 01       	movw	r30, r14
    1444:	ee 55       	subi	r30, 0x5E	; 94
    1446:	f0 4f       	sbci	r31, 0xF0	; 240
    1448:	33 c0       	rjmp	.+102    	; 0x14b0 <TCP_SetConnectionState+0xda>
			return true;
    144a:	0f 5f       	subi	r16, 0xFF	; 255
    144c:	1f 4f       	sbci	r17, 0xFF	; 255
    144e:	ca 5e       	subi	r28, 0xEA	; 234
    1450:	dd 4f       	sbci	r29, 0xFD	; 253
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1452:	03 30       	cpi	r16, 0x03	; 3
    1454:	11 05       	cpc	r17, r1
    1456:	d1 f6       	brne	.-76     	; 0x140c <TCP_SetConnectionState+0x36>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
    1458:	80 91 a2 0f 	lds	r24, 0x0FA2
    145c:	8a 30       	cpi	r24, 0x0A	; 10
    145e:	51 f0       	breq	.+20     	; 0x1474 <TCP_SetConnectionState+0x9e>
    1460:	80 91 b8 11 	lds	r24, 0x11B8
    1464:	8a 30       	cpi	r24, 0x0A	; 10
    1466:	41 f0       	breq	.+16     	; 0x1478 <TCP_SetConnectionState+0xa2>
    1468:	80 91 ce 13 	lds	r24, 0x13CE
    146c:	8a 30       	cpi	r24, 0x0A	; 10
    146e:	19 f5       	brne	.+70     	; 0x14b6 <TCP_SetConnectionState+0xe0>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1470:	82 e0       	ldi	r24, 0x02	; 2
    1472:	03 c0       	rjmp	.+6      	; 0x147a <TCP_SetConnectionState+0xa4>
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
    1474:	80 e0       	ldi	r24, 0x00	; 0
    1476:	01 c0       	rjmp	.+2      	; 0x147a <TCP_SetConnectionState+0xa4>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1478:	81 e0       	ldi	r24, 0x01	; 1
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
    147a:	90 e0       	ldi	r25, 0x00	; 0
    147c:	26 e1       	ldi	r18, 0x16	; 22
    147e:	32 e0       	ldi	r19, 0x02	; 2
    1480:	82 9f       	mul	r24, r18
    1482:	f0 01       	movw	r30, r0
    1484:	83 9f       	mul	r24, r19
    1486:	f0 0d       	add	r31, r0
    1488:	92 9f       	mul	r25, r18
    148a:	f0 0d       	add	r31, r0
    148c:	11 24       	eor	r1, r1
    148e:	e3 57       	subi	r30, 0x73	; 115
    1490:	f2 4f       	sbci	r31, 0xF2	; 242
    1492:	b1 82       	std	Z+1, r11	; 0x01
    1494:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
    1496:	e4 01       	movw	r28, r8
    1498:	88 81       	ld	r24, Y
    149a:	99 81       	ldd	r25, Y+1	; 0x01
    149c:	aa 81       	ldd	r26, Y+2	; 0x02
    149e:	bb 81       	ldd	r27, Y+3	; 0x03
    14a0:	84 83       	std	Z+4, r24	; 0x04
    14a2:	95 83       	std	Z+5, r25	; 0x05
    14a4:	a6 83       	std	Z+6, r26	; 0x06
    14a6:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
    14a8:	73 82       	std	Z+3, r7	; 0x03
    14aa:	62 82       	std	Z+2, r6	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
    14ac:	eb 5e       	subi	r30, 0xEB	; 235
    14ae:	fd 4f       	sbci	r31, 0xFD	; 253
    14b0:	d0 82       	st	Z, r13
			return true;
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	01 c0       	rjmp	.+2      	; 0x14b8 <TCP_SetConnectionState+0xe2>
		}
	}

	return false;
    14b6:	80 e0       	ldi	r24, 0x00	; 0
}
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	df 90       	pop	r13
    14c6:	bf 90       	pop	r11
    14c8:	af 90       	pop	r10
    14ca:	9f 90       	pop	r9
    14cc:	8f 90       	pop	r8
    14ce:	7f 90       	pop	r7
    14d0:	6f 90       	pop	r6
    14d2:	5f 90       	pop	r5
    14d4:	4f 90       	pop	r4
    14d6:	08 95       	ret

000014d8 <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
    14d8:	6f 92       	push	r6
    14da:	7f 92       	push	r7
    14dc:	8f 92       	push	r8
    14de:	9f 92       	push	r9
    14e0:	af 92       	push	r10
    14e2:	bf 92       	push	r11
    14e4:	cf 92       	push	r12
    14e6:	df 92       	push	r13
    14e8:	ef 92       	push	r14
    14ea:	ff 92       	push	r15
    14ec:	0f 93       	push	r16
    14ee:	1f 93       	push	r17
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	6c 01       	movw	r12, r24
    14f6:	5b 01       	movw	r10, r22
    14f8:	4a 01       	movw	r8, r20
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
    14fa:	cd e8       	ldi	r28, 0x8D	; 141
    14fc:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
    14fe:	00 e0       	ldi	r16, 0x00	; 0
    1500:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1502:	36 e1       	ldi	r19, 0x16	; 22
    1504:	63 2e       	mov	r6, r19
    1506:	32 e0       	ldi	r19, 0x02	; 2
    1508:	73 2e       	mov	r7, r19
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    150a:	88 81       	ld	r24, Y
    150c:	99 81       	ldd	r25, Y+1	; 0x01
    150e:	8c 15       	cp	r24, r12
    1510:	9d 05       	cpc	r25, r13
    1512:	d9 f4       	brne	.+54     	; 0x154a <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1514:	06 9d       	mul	r16, r6
    1516:	70 01       	movw	r14, r0
    1518:	07 9d       	mul	r16, r7
    151a:	f0 0c       	add	r15, r0
    151c:	16 9d       	mul	r17, r6
    151e:	f0 0c       	add	r15, r0
    1520:	11 24       	eor	r1, r1
    1522:	c7 01       	movw	r24, r14
    1524:	8f 56       	subi	r24, 0x6F	; 111
    1526:	92 4f       	sbci	r25, 0xF2	; 242
    1528:	b5 01       	movw	r22, r10
    152a:	44 e0       	ldi	r20, 0x04	; 4
    152c:	50 e0       	ldi	r21, 0x00	; 0
    152e:	0e 94 56 15 	call	0x2aac	; 0x2aac <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1532:	00 97       	sbiw	r24, 0x00	; 0
    1534:	51 f4       	brne	.+20     	; 0x154a <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1536:	8a 81       	ldd	r24, Y+2	; 0x02
    1538:	9b 81       	ldd	r25, Y+3	; 0x03
    153a:	88 15       	cp	r24, r8
    153c:	99 05       	cpc	r25, r9
    153e:	29 f4       	brne	.+10     	; 0x154a <TCP_GetConnectionState+0x72>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
    1540:	f7 01       	movw	r30, r14
    1542:	ee 55       	subi	r30, 0x5E	; 94
    1544:	f0 4f       	sbci	r31, 0xF0	; 240
    1546:	80 81       	ld	r24, Z
    1548:	08 c0       	rjmp	.+16     	; 0x155a <TCP_GetConnectionState+0x82>
    154a:	0f 5f       	subi	r16, 0xFF	; 255
    154c:	1f 4f       	sbci	r17, 0xFF	; 255
    154e:	ca 5e       	subi	r28, 0xEA	; 234
    1550:	dd 4f       	sbci	r29, 0xFD	; 253
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1552:	03 30       	cpi	r16, 0x03	; 3
    1554:	11 05       	cpc	r17, r1
    1556:	c9 f6       	brne	.-78     	; 0x150a <TCP_GetConnectionState+0x32>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
    1558:	8a e0       	ldi	r24, 0x0A	; 10
}
    155a:	df 91       	pop	r29
    155c:	cf 91       	pop	r28
    155e:	1f 91       	pop	r17
    1560:	0f 91       	pop	r16
    1562:	ff 90       	pop	r15
    1564:	ef 90       	pop	r14
    1566:	df 90       	pop	r13
    1568:	cf 90       	pop	r12
    156a:	bf 90       	pop	r11
    156c:	af 90       	pop	r10
    156e:	9f 90       	pop	r9
    1570:	8f 90       	pop	r8
    1572:	7f 90       	pop	r7
    1574:	6f 90       	pop	r6
    1576:	08 95       	ret

00001578 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
    1578:	6f 92       	push	r6
    157a:	7f 92       	push	r7
    157c:	8f 92       	push	r8
    157e:	9f 92       	push	r9
    1580:	af 92       	push	r10
    1582:	bf 92       	push	r11
    1584:	cf 92       	push	r12
    1586:	df 92       	push	r13
    1588:	ef 92       	push	r14
    158a:	ff 92       	push	r15
    158c:	0f 93       	push	r16
    158e:	1f 93       	push	r17
    1590:	cf 93       	push	r28
    1592:	df 93       	push	r29
    1594:	6c 01       	movw	r12, r24
    1596:	5b 01       	movw	r10, r22
    1598:	4a 01       	movw	r8, r20
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
    159a:	cd e8       	ldi	r28, 0x8D	; 141
    159c:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
    159e:	00 e0       	ldi	r16, 0x00	; 0
    15a0:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    15a2:	e6 e1       	ldi	r30, 0x16	; 22
    15a4:	6e 2e       	mov	r6, r30
    15a6:	e2 e0       	ldi	r30, 0x02	; 2
    15a8:	7e 2e       	mov	r7, r30
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    15aa:	88 81       	ld	r24, Y
    15ac:	99 81       	ldd	r25, Y+1	; 0x01
    15ae:	8c 15       	cp	r24, r12
    15b0:	9d 05       	cpc	r25, r13
    15b2:	d1 f4       	brne	.+52     	; 0x15e8 <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    15b4:	06 9d       	mul	r16, r6
    15b6:	70 01       	movw	r14, r0
    15b8:	07 9d       	mul	r16, r7
    15ba:	f0 0c       	add	r15, r0
    15bc:	16 9d       	mul	r17, r6
    15be:	f0 0c       	add	r15, r0
    15c0:	11 24       	eor	r1, r1
    15c2:	c7 01       	movw	r24, r14
    15c4:	8f 56       	subi	r24, 0x6F	; 111
    15c6:	92 4f       	sbci	r25, 0xF2	; 242
    15c8:	b5 01       	movw	r22, r10
    15ca:	44 e0       	ldi	r20, 0x04	; 4
    15cc:	50 e0       	ldi	r21, 0x00	; 0
    15ce:	0e 94 56 15 	call	0x2aac	; 0x2aac <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    15d2:	00 97       	sbiw	r24, 0x00	; 0
    15d4:	49 f4       	brne	.+18     	; 0x15e8 <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    15d6:	8a 81       	ldd	r24, Y+2	; 0x02
    15d8:	9b 81       	ldd	r25, Y+3	; 0x03
    15da:	88 15       	cp	r24, r8
    15dc:	99 05       	cpc	r25, r9
    15de:	21 f4       	brne	.+8      	; 0x15e8 <TCP_GetConnectionInfo+0x70>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
    15e0:	c7 01       	movw	r24, r14
    15e2:	8b 56       	subi	r24, 0x6B	; 107
    15e4:	92 4f       	sbci	r25, 0xF2	; 242
    15e6:	09 c0       	rjmp	.+18     	; 0x15fa <TCP_GetConnectionInfo+0x82>
    15e8:	0f 5f       	subi	r16, 0xFF	; 255
    15ea:	1f 4f       	sbci	r17, 0xFF	; 255
    15ec:	ca 5e       	subi	r28, 0xEA	; 234
    15ee:	dd 4f       	sbci	r29, 0xFD	; 253
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    15f0:	03 30       	cpi	r16, 0x03	; 3
    15f2:	11 05       	cpc	r17, r1
    15f4:	d1 f6       	brne	.-76     	; 0x15aa <TCP_GetConnectionInfo+0x32>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	90 e0       	ldi	r25, 0x00	; 0
}
    15fa:	df 91       	pop	r29
    15fc:	cf 91       	pop	r28
    15fe:	1f 91       	pop	r17
    1600:	0f 91       	pop	r16
    1602:	ff 90       	pop	r15
    1604:	ef 90       	pop	r14
    1606:	df 90       	pop	r13
    1608:	cf 90       	pop	r12
    160a:	bf 90       	pop	r11
    160c:	af 90       	pop	r10
    160e:	9f 90       	pop	r9
    1610:	8f 90       	pop	r8
    1612:	7f 90       	pop	r7
    1614:	6f 90       	pop	r6
    1616:	08 95       	ret

00001618 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
    1618:	6f 92       	push	r6
    161a:	7f 92       	push	r7
    161c:	8f 92       	push	r8
    161e:	9f 92       	push	r9
    1620:	af 92       	push	r10
    1622:	bf 92       	push	r11
    1624:	cf 92       	push	r12
    1626:	df 92       	push	r13
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	3c 01       	movw	r6, r24
    1636:	5b 01       	movw	r10, r22
    1638:	4a 01       	movw	r8, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
    163a:	cb 01       	movw	r24, r22
    163c:	8a d9       	rcall	.-3308   	; 0x952 <DecodeTCPHeader>
    163e:	d5 01       	movw	r26, r10

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
    1640:	12 96       	adiw	r26, 0x02	; 2
    1642:	cd 91       	ld	r28, X+
    1644:	dc 91       	ld	r29, X
    1646:	13 97       	sbiw	r26, 0x03	; 3
    1648:	ce 01       	movw	r24, r28
    164a:	b9 de       	rcall	.-654    	; 0x13be <TCP_GetPortState>
    164c:	81 30       	cpi	r24, 0x01	; 1
    164e:	09 f0       	breq	.+2      	; 0x1652 <TCP_ProcessTCPPacket+0x3a>
    1650:	8e c1       	rjmp	.+796    	; 0x196e <TCP_ProcessTCPPacket+0x356>
    1652:	f5 01       	movw	r30, r10
    1654:	85 85       	ldd	r24, Z+13	; 0x0d
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
    1656:	81 ff       	sbrs	r24, 1
    1658:	08 c0       	rjmp	.+16     	; 0x166a <TCP_ProcessTCPPacket+0x52>
    165a:	b3 01       	movw	r22, r6
    165c:	64 5f       	subi	r22, 0xF4	; 244
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
    165e:	7f 4f       	sbci	r23, 0xFF	; 255
    1660:	40 81       	ld	r20, Z
    1662:	51 81       	ldd	r21, Z+1	; 0x01
    1664:	ce 01       	movw	r24, r28
    1666:	20 e0       	ldi	r18, 0x00	; 0
    1668:	b6 de       	rcall	.-660    	; 0x13d6 <TCP_SetConnectionState>
    166a:	d5 01       	movw	r26, r10
    166c:	1d 96       	adiw	r26, 0x0d	; 13
    166e:	cc 91       	ld	r28, X

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
    1670:	1d 97       	sbiw	r26, 0x0d	; 13
    1672:	12 96       	adiw	r26, 0x02	; 2
    1674:	0d 91       	ld	r16, X+
    1676:	1c 91       	ld	r17, X
    1678:	13 97       	sbiw	r26, 0x03	; 3
    167a:	5c e0       	ldi	r21, 0x0C	; 12
    167c:	c5 2e       	mov	r12, r21
    167e:	d1 2c       	mov	r13, r1
    1680:	c6 0c       	add	r12, r6
    1682:	d7 1c       	adc	r13, r7
    1684:	ed 90       	ld	r14, X+
    1686:	fc 90       	ld	r15, X
    1688:	11 97       	sbiw	r26, 0x01	; 1
    168a:	c8 01       	movw	r24, r16
    168c:	b6 01       	movw	r22, r12
    168e:	a7 01       	movw	r20, r14
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1690:	c2 ff       	sbrs	r28, 2
    1692:	07 c0       	rjmp	.+14     	; 0x16a2 <TCP_ProcessTCPPacket+0x8a>
    1694:	2a e0       	ldi	r18, 0x0A	; 10
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
    1696:	9f de       	rcall	.-706    	; 0x13d6 <TCP_SetConnectionState>
    1698:	88 23       	and	r24, r24
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    169a:	09 f4       	brne	.+2      	; 0x169e <TCP_ProcessTCPPacket+0x86>
    169c:	96 c1       	rjmp	.+812    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    169e:	84 e1       	ldi	r24, 0x14	; 20
    16a0:	11 c1       	rjmp	.+546    	; 0x18c4 <TCP_ProcessTCPPacket+0x2ac>
    16a2:	1a df       	rcall	.-460    	; 0x14d8 <TCP_GetConnectionState>
    16a4:	84 30       	cpi	r24, 0x04	; 4
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    16a6:	09 f4       	brne	.+2      	; 0x16aa <TCP_ProcessTCPPacket+0x92>
    16a8:	25 c1       	rjmp	.+586    	; 0x18f4 <TCP_ProcessTCPPacket+0x2dc>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
    16aa:	85 30       	cpi	r24, 0x05	; 5
    16ac:	48 f4       	brcc	.+18     	; 0x16c0 <TCP_ProcessTCPPacket+0xa8>
    16ae:	82 30       	cpi	r24, 0x02	; 2
    16b0:	09 f4       	brne	.+2      	; 0x16b4 <TCP_ProcessTCPPacket+0x9c>
    16b2:	41 c0       	rjmp	.+130    	; 0x1736 <TCP_ProcessTCPPacket+0x11e>
    16b4:	83 30       	cpi	r24, 0x03	; 3
    16b6:	08 f0       	brcs	.+2      	; 0x16ba <TCP_ProcessTCPPacket+0xa2>
    16b8:	5e c0       	rjmp	.+188    	; 0x1776 <TCP_ProcessTCPPacket+0x15e>
    16ba:	88 23       	and	r24, r24
    16bc:	59 f0       	breq	.+22     	; 0x16d4 <TCP_ProcessTCPPacket+0xbc>
    16be:	85 c1       	rjmp	.+778    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    16c0:	86 30       	cpi	r24, 0x06	; 6
    16c2:	09 f4       	brne	.+2      	; 0x16c6 <TCP_ProcessTCPPacket+0xae>
    16c4:	4c c1       	rjmp	.+664    	; 0x195e <TCP_ProcessTCPPacket+0x346>
    16c6:	86 30       	cpi	r24, 0x06	; 6
    16c8:	08 f4       	brcc	.+2      	; 0x16cc <TCP_ProcessTCPPacket+0xb4>
    16ca:	1e c1       	rjmp	.+572    	; 0x1908 <TCP_ProcessTCPPacket+0x2f0>
    16cc:	87 30       	cpi	r24, 0x07	; 7
    16ce:	09 f0       	breq	.+2      	; 0x16d2 <TCP_ProcessTCPPacket+0xba>
    16d0:	7c c1       	rjmp	.+760    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    16d2:	fb c0       	rjmp	.+502    	; 0x18ca <TCP_ProcessTCPPacket+0x2b2>
    16d4:	c2 30       	cpi	r28, 0x02	; 2
    16d6:	09 f0       	breq	.+2      	; 0x16da <TCP_ProcessTCPPacket+0xc2>
    16d8:	78 c1       	rjmp	.+752    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    16da:	c8 01       	movw	r24, r16
    16dc:	b6 01       	movw	r22, r12
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
    16de:	a7 01       	movw	r20, r14
    16e0:	22 e0       	ldi	r18, 0x02	; 2
    16e2:	79 de       	rcall	.-782    	; 0x13d6 <TCP_SetConnectionState>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    16e4:	88 23       	and	r24, r24
    16e6:	29 f1       	breq	.+74     	; 0x1732 <TCP_ProcessTCPPacket+0x11a>
    16e8:	82 e1       	ldi	r24, 0x12	; 18
    16ea:	d4 01       	movw	r26, r8
    16ec:	1d 96       	adiw	r26, 0x0d	; 13
    16ee:	8c 93       	st	X, r24
    16f0:	f5 01       	movw	r30, r10
    16f2:	40 81       	ld	r20, Z
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    16f4:	51 81       	ldd	r21, Z+1	; 0x01
    16f6:	82 81       	ldd	r24, Z+2	; 0x02
    16f8:	93 81       	ldd	r25, Z+3	; 0x03
    16fa:	b6 01       	movw	r22, r12

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    16fc:	3d df       	rcall	.-390    	; 0x1578 <TCP_GetConnectionInfo>
    16fe:	ec 01       	movw	r28, r24
    1700:	d5 01       	movw	r26, r10
    1702:	14 96       	adiw	r26, 0x04	; 4
    1704:	6d 91       	ld	r22, X+
    1706:	7d 91       	ld	r23, X+
    1708:	8d 91       	ld	r24, X+
    170a:	9c 91       	ld	r25, X
    170c:	17 97       	sbiw	r26, 0x07	; 7

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    170e:	5a dc       	rcall	.-1868   	; 0xfc4 <SwapEndian_32>
    1710:	dc 01       	movw	r26, r24
    1712:	cb 01       	movw	r24, r22
    1714:	01 96       	adiw	r24, 0x01	; 1
    1716:	a1 1d       	adc	r26, r1
    1718:	b1 1d       	adc	r27, r1
    171a:	88 83       	st	Y, r24
    171c:	99 83       	std	Y+1, r25	; 0x01
    171e:	aa 83       	std	Y+2, r26	; 0x02
    1720:	bb 83       	std	Y+3, r27	; 0x03
    1722:	1c 82       	std	Y+4, r1	; 0x04
    1724:	1d 82       	std	Y+5, r1	; 0x05
    1726:	1e 82       	std	Y+6, r1	; 0x06
    1728:	1f 82       	std	Y+7, r1	; 0x07
    172a:	c4 5f       	subi	r28, 0xF4	; 244
    172c:	dd 4f       	sbci	r29, 0xFD	; 253
    172e:	18 82       	st	Y, r1
    1730:	5d c1       	rjmp	.+698    	; 0x19ec <TCP_ProcessTCPPacket+0x3d4>
							ConnectionInfo->SequenceNumberOut = 0;
    1732:	84 e0       	ldi	r24, 0x04	; 4
    1734:	c7 c0       	rjmp	.+398    	; 0x18c4 <TCP_ProcessTCPPacket+0x2ac>
    1736:	c0 31       	cpi	r28, 0x10	; 16
    1738:	09 f0       	breq	.+2      	; 0x173c <TCP_ProcessTCPPacket+0x124>
							ConnectionInfo->Buffer.InUse      = false;
    173a:	47 c1       	rjmp	.+654    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    173c:	c8 01       	movw	r24, r16
    173e:	b6 01       	movw	r22, r12
    1740:	a7 01       	movw	r20, r14
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    1742:	23 e0       	ldi	r18, 0x03	; 3
    1744:	48 de       	rcall	.-880    	; 0x13d6 <TCP_SetConnectionState>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1746:	d5 01       	movw	r26, r10
    1748:	4d 91       	ld	r20, X+
    174a:	5c 91       	ld	r21, X
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    174c:	11 97       	sbiw	r26, 0x01	; 1
    174e:	12 96       	adiw	r26, 0x02	; 2
    1750:	8d 91       	ld	r24, X+
    1752:	9c 91       	ld	r25, X
    1754:	13 97       	sbiw	r26, 0x03	; 3
    1756:	b6 01       	movw	r22, r12
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1758:	0f df       	rcall	.-482    	; 0x1578 <TCP_GetConnectionInfo>
    175a:	fc 01       	movw	r30, r24
    175c:	44 81       	ldd	r20, Z+4	; 0x04
    175e:	55 81       	ldd	r21, Z+5	; 0x05
    1760:	66 81       	ldd	r22, Z+6	; 0x06
    1762:	77 81       	ldd	r23, Z+7	; 0x07
    1764:	4f 5f       	subi	r20, 0xFF	; 255
    1766:	5f 4f       	sbci	r21, 0xFF	; 255
    1768:	6f 4f       	sbci	r22, 0xFF	; 255
    176a:	7f 4f       	sbci	r23, 0xFF	; 255
    176c:	44 83       	std	Z+4, r20	; 0x04
    176e:	55 83       	std	Z+5, r21	; 0x05
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    1770:	66 83       	std	Z+6, r22	; 0x06
    1772:	77 83       	std	Z+7, r23	; 0x07
    1774:	2a c1       	rjmp	.+596    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    1776:	c1 31       	cpi	r28, 0x11	; 17
    1778:	61 f5       	brne	.+88     	; 0x17d2 <TCP_ProcessTCPPacket+0x1ba>
    177a:	f4 01       	movw	r30, r8
    177c:	c5 87       	std	Z+13, r28	; 0x0d
    177e:	d5 01       	movw	r26, r10
    1780:	4d 91       	ld	r20, X+
    1782:	5c 91       	ld	r21, X
    1784:	11 97       	sbiw	r26, 0x01	; 1
    1786:	12 96       	adiw	r26, 0x02	; 2
    1788:	8d 91       	ld	r24, X+
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    178a:	9c 91       	ld	r25, X
    178c:	13 97       	sbiw	r26, 0x03	; 3
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    178e:	b6 01       	movw	r22, r12
    1790:	26 e0       	ldi	r18, 0x06	; 6
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1792:	21 de       	rcall	.-958    	; 0x13d6 <TCP_SetConnectionState>
    1794:	f5 01       	movw	r30, r10
    1796:	40 81       	ld	r20, Z
    1798:	51 81       	ldd	r21, Z+1	; 0x01
    179a:	82 81       	ldd	r24, Z+2	; 0x02
    179c:	93 81       	ldd	r25, Z+3	; 0x03
    179e:	b6 01       	movw	r22, r12
    17a0:	eb de       	rcall	.-554    	; 0x1578 <TCP_GetConnectionInfo>
    17a2:	fc 01       	movw	r30, r24
    17a4:	80 81       	ld	r24, Z
    17a6:	91 81       	ldd	r25, Z+1	; 0x01
    17a8:	a2 81       	ldd	r26, Z+2	; 0x02
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17aa:	b3 81       	ldd	r27, Z+3	; 0x03
    17ac:	01 96       	adiw	r24, 0x01	; 1
    17ae:	a1 1d       	adc	r26, r1
    17b0:	b1 1d       	adc	r27, r1
    17b2:	80 83       	st	Z, r24
    17b4:	91 83       	std	Z+1, r25	; 0x01
    17b6:	a2 83       	std	Z+2, r26	; 0x02
    17b8:	b3 83       	std	Z+3, r27	; 0x03
    17ba:	84 81       	ldd	r24, Z+4	; 0x04
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    17bc:	95 81       	ldd	r25, Z+5	; 0x05
    17be:	a6 81       	ldd	r26, Z+6	; 0x06
    17c0:	b7 81       	ldd	r27, Z+7	; 0x07
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	a1 1d       	adc	r26, r1
    17c6:	b1 1d       	adc	r27, r1
    17c8:	84 83       	std	Z+4, r24	; 0x04
    17ca:	95 83       	std	Z+5, r25	; 0x05
    17cc:	a6 83       	std	Z+6, r26	; 0x06
    17ce:	b7 83       	std	Z+7, r27	; 0x07
    17d0:	0d c1       	rjmp	.+538    	; 0x19ec <TCP_ProcessTCPPacket+0x3d4>
						ConnectionInfo->SequenceNumberOut++;
    17d2:	c0 31       	cpi	r28, 0x10	; 16
    17d4:	19 f0       	breq	.+6      	; 0x17dc <TCP_ProcessTCPPacket+0x1c4>
    17d6:	c8 31       	cpi	r28, 0x18	; 24
    17d8:	09 f0       	breq	.+2      	; 0x17dc <TCP_ProcessTCPPacket+0x1c4>
    17da:	f7 c0       	rjmp	.+494    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    17dc:	c8 01       	movw	r24, r16
    17de:	b6 01       	movw	r22, r12
    17e0:	a7 01       	movw	r20, r14
    17e2:	ca de       	rcall	.-620    	; 0x1578 <TCP_GetConnectionInfo>
    17e4:	ec 01       	movw	r28, r24
    17e6:	dc 01       	movw	r26, r24
    17e8:	a4 5f       	subi	r26, 0xF4	; 244
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    17ea:	bd 4f       	sbci	r27, 0xFD	; 253
    17ec:	2c 91       	ld	r18, X
    17ee:	86 5f       	subi	r24, 0xF6	; 246
    17f0:	9d 4f       	sbci	r25, 0xFD	; 253
    17f2:	22 23       	and	r18, r18
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17f4:	61 f4       	brne	.+24     	; 0x180e <TCP_ProcessTCPPacket+0x1f6>
    17f6:	fe 01       	movw	r30, r28
    17f8:	e5 5f       	subi	r30, 0xF5	; 245
    17fa:	fd 4f       	sbci	r31, 0xFD	; 253
    17fc:	20 81       	ld	r18, Z
    17fe:	22 23       	and	r18, r18
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    1800:	31 f4       	brne	.+12     	; 0x180e <TCP_ProcessTCPPacket+0x1f6>
    1802:	fc 01       	movw	r30, r24
    1804:	10 82       	st	Z, r1
    1806:	21 e0       	ldi	r18, 0x01	; 1
    1808:	2c 93       	st	X, r18
    180a:	19 86       	std	Y+9, r1	; 0x09
    180c:	18 86       	std	Y+8, r1	; 0x08
    180e:	dc 01       	movw	r26, r24
    1810:	8c 91       	ld	r24, X
    1812:	88 23       	and	r24, r24
    1814:	09 f0       	breq	.+2      	; 0x1818 <TCP_ProcessTCPPacket+0x200>
    1816:	d6 c0       	rjmp	.+428    	; 0x19c4 <TCP_ProcessTCPPacket+0x3ac>
    1818:	c8 84       	ldd	r12, Y+8	; 0x08
    181a:	d9 84       	ldd	r13, Y+9	; 0x09
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    181c:	b0 e0       	ldi	r27, 0x00	; 0
    181e:	cb 16       	cp	r12, r27
							ConnectionInfo->Buffer.InUse     = true;
    1820:	b2 e0       	ldi	r27, 0x02	; 2
    1822:	db 06       	cpc	r13, r27
							ConnectionInfo->Buffer.Length    = 0;
    1824:	09 f4       	brne	.+2      	; 0x1828 <TCP_ProcessTCPPacket+0x210>
    1826:	ce c0       	rjmp	.+412    	; 0x19c4 <TCP_ProcessTCPPacket+0x3ac>
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    1828:	f5 01       	movw	r30, r10
    182a:	04 85       	ldd	r16, Z+12	; 0x0c
    182c:	02 95       	swap	r16
    182e:	0f 70       	andi	r16, 0x0F	; 15
    1830:	10 e0       	ldi	r17, 0x00	; 0
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
    1832:	00 0f       	add	r16, r16
    1834:	11 1f       	adc	r17, r17
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    1836:	00 0f       	add	r16, r16
    1838:	11 1f       	adc	r17, r17
    183a:	d3 01       	movw	r26, r6
    183c:	12 96       	adiw	r26, 0x02	; 2
    183e:	8d 91       	ld	r24, X+
    1840:	9c 91       	ld	r25, X
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    1842:	13 97       	sbiw	r26, 0x03	; 3
    1844:	c5 db       	rcall	.-2166   	; 0xfd0 <SwapEndian_16>
    1846:	f3 01       	movw	r30, r6
    1848:	20 81       	ld	r18, Z
    184a:	2f 70       	andi	r18, 0x0F	; 15
    184c:	30 e0       	ldi	r19, 0x00	; 0
    184e:	22 0f       	add	r18, r18
    1850:	33 1f       	adc	r19, r19
    1852:	22 0f       	add	r18, r18
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1854:	33 1f       	adc	r19, r19
    1856:	7c 01       	movw	r14, r24
    1858:	e2 1a       	sub	r14, r18
    185a:	f3 0a       	sbc	r15, r19
    185c:	e0 1a       	sub	r14, r16
    185e:	f1 0a       	sbc	r15, r17
    1860:	c6 01       	movw	r24, r12

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1862:	0a 96       	adiw	r24, 0x0a	; 10
    1864:	8c 0f       	add	r24, r28
    1866:	9d 1f       	adc	r25, r29
    1868:	b5 01       	movw	r22, r10
    186a:	60 0f       	add	r22, r16
    186c:	71 1f       	adc	r23, r17
    186e:	a7 01       	movw	r20, r14
    1870:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <memcpy>
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1874:	a7 01       	movw	r20, r14
    1876:	60 e0       	ldi	r22, 0x00	; 0
    1878:	70 e0       	ldi	r23, 0x00	; 0
    187a:	88 81       	ld	r24, Y

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    187c:	99 81       	ldd	r25, Y+1	; 0x01
    187e:	aa 81       	ldd	r26, Y+2	; 0x02
    1880:	bb 81       	ldd	r27, Y+3	; 0x03
    1882:	84 0f       	add	r24, r20
    1884:	95 1f       	adc	r25, r21
    1886:	a6 1f       	adc	r26, r22
    1888:	b7 1f       	adc	r27, r23
    188a:	88 83       	st	Y, r24
    188c:	99 83       	std	Y+1, r25	; 0x01
    188e:	aa 83       	std	Y+2, r26	; 0x02
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1890:	bb 83       	std	Y+3, r27	; 0x03
    1892:	88 85       	ldd	r24, Y+8	; 0x08
    1894:	99 85       	ldd	r25, Y+9	; 0x09
    1896:	8e 0d       	add	r24, r14
    1898:	9f 1d       	adc	r25, r15
    189a:	99 87       	std	Y+9, r25	; 0x09
    189c:	88 87       	std	Y+8, r24	; 0x08
    189e:	f2 e0       	ldi	r31, 0x02	; 2
    18a0:	80 30       	cpi	r24, 0x00	; 0
    18a2:	9f 07       	cpc	r25, r31
    18a4:	31 f0       	breq	.+12     	; 0x18b2 <TCP_ProcessTCPPacket+0x29a>
    18a6:	d5 01       	movw	r26, r10
    18a8:	1d 96       	adiw	r26, 0x0d	; 13
    18aa:	8c 91       	ld	r24, X
    18ac:	1d 97       	sbiw	r26, 0x0d	; 13
							ConnectionInfo->Buffer.Length    += DataLength;
    18ae:	83 ff       	sbrs	r24, 3
    18b0:	8c c0       	rjmp	.+280    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    18b2:	fe 01       	movw	r30, r28
    18b4:	e4 5f       	subi	r30, 0xF4	; 244
    18b6:	fd 4f       	sbci	r31, 0xFD	; 253
    18b8:	10 82       	st	Z, r1

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    18ba:	c5 5f       	subi	r28, 0xF5	; 245
    18bc:	dd 4f       	sbci	r29, 0xFD	; 253
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	88 83       	st	Y, r24
    18c2:	80 e1       	ldi	r24, 0x10	; 16
    18c4:	f4 01       	movw	r30, r8
    18c6:	85 87       	std	Z+13, r24	; 0x0d
    18c8:	91 c0       	rjmp	.+290    	; 0x19ec <TCP_ProcessTCPPacket+0x3d4>
    18ca:	c8 01       	movw	r24, r16
    18cc:	b6 01       	movw	r22, r12
							{
								ConnectionInfo->Buffer.InUse = false;
    18ce:	a7 01       	movw	r20, r14
    18d0:	53 de       	rcall	.-858    	; 0x1578 <TCP_GetConnectionInfo>
    18d2:	21 e1       	ldi	r18, 0x11	; 17
    18d4:	d4 01       	movw	r26, r8
								ConnectionInfo->Buffer.Ready = true;
    18d6:	1d 96       	adiw	r26, 0x0d	; 13
    18d8:	2c 93       	st	X, r18
    18da:	1d 97       	sbiw	r26, 0x0d	; 13
    18dc:	fc 01       	movw	r30, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    18de:	e4 5f       	subi	r30, 0xF4	; 244
    18e0:	fd 4f       	sbci	r31, 0xFD	; 253
    18e2:	10 82       	st	Z, r1
    18e4:	f5 01       	movw	r30, r10
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    18e6:	40 81       	ld	r20, Z
    18e8:	51 81       	ldd	r21, Z+1	; 0x01
    18ea:	82 81       	ldd	r24, Z+2	; 0x02
    18ec:	93 81       	ldd	r25, Z+3	; 0x03
    18ee:	b6 01       	movw	r22, r12
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    18f0:	24 e0       	ldi	r18, 0x04	; 4
    18f2:	33 c0       	rjmp	.+102    	; 0x195a <TCP_ProcessTCPPacket+0x342>
    18f4:	c1 31       	cpi	r28, 0x11	; 17
    18f6:	59 f0       	breq	.+22     	; 0x190e <TCP_ProcessTCPPacket+0x2f6>
    18f8:	c0 31       	cpi	r28, 0x10	; 16
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    18fa:	09 f0       	breq	.+2      	; 0x18fe <TCP_ProcessTCPPacket+0x2e6>
    18fc:	66 c0       	rjmp	.+204    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    18fe:	c8 01       	movw	r24, r16
    1900:	b6 01       	movw	r22, r12

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1902:	a7 01       	movw	r20, r14
    1904:	25 e0       	ldi	r18, 0x05	; 5
    1906:	31 c0       	rjmp	.+98     	; 0x196a <TCP_ProcessTCPPacket+0x352>
    1908:	c1 31       	cpi	r28, 0x11	; 17
    190a:	09 f0       	breq	.+2      	; 0x190e <TCP_ProcessTCPPacket+0x2f6>
    190c:	5e c0       	rjmp	.+188    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    190e:	c8 01       	movw	r24, r16
    1910:	b6 01       	movw	r22, r12
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1912:	a7 01       	movw	r20, r14
    1914:	31 de       	rcall	.-926    	; 0x1578 <TCP_GetConnectionInfo>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1916:	fc 01       	movw	r30, r24
    1918:	80 e1       	ldi	r24, 0x10	; 16
    191a:	d4 01       	movw	r26, r8
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    191c:	1d 96       	adiw	r26, 0x0d	; 13
    191e:	8c 93       	st	X, r24
    1920:	80 81       	ld	r24, Z
    1922:	91 81       	ldd	r25, Z+1	; 0x01
    1924:	a2 81       	ldd	r26, Z+2	; 0x02
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1926:	b3 81       	ldd	r27, Z+3	; 0x03
    1928:	01 96       	adiw	r24, 0x01	; 1
    192a:	a1 1d       	adc	r26, r1
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    192c:	b1 1d       	adc	r27, r1
    192e:	80 83       	st	Z, r24
    1930:	91 83       	std	Z+1, r25	; 0x01
    1932:	a2 83       	std	Z+2, r26	; 0x02
    1934:	b3 83       	std	Z+3, r27	; 0x03
    1936:	84 81       	ldd	r24, Z+4	; 0x04
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1938:	95 81       	ldd	r25, Z+5	; 0x05
    193a:	a6 81       	ldd	r26, Z+6	; 0x06
    193c:	b7 81       	ldd	r27, Z+7	; 0x07
    193e:	01 96       	adiw	r24, 0x01	; 1
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1940:	a1 1d       	adc	r26, r1
    1942:	b1 1d       	adc	r27, r1
    1944:	84 83       	std	Z+4, r24	; 0x04
    1946:	95 83       	std	Z+5, r25	; 0x05
    1948:	a6 83       	std	Z+6, r26	; 0x06
    194a:	b7 83       	std	Z+7, r27	; 0x07
    194c:	f5 01       	movw	r30, r10
    194e:	40 81       	ld	r20, Z
    1950:	51 81       	ldd	r21, Z+1	; 0x01
    1952:	82 81       	ldd	r24, Z+2	; 0x02
    1954:	93 81       	ldd	r25, Z+3	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1956:	b6 01       	movw	r22, r12
    1958:	2a e0       	ldi	r18, 0x0A	; 10
    195a:	3d dd       	rcall	.-1414   	; 0x13d6 <TCP_SetConnectionState>
    195c:	47 c0       	rjmp	.+142    	; 0x19ec <TCP_ProcessTCPPacket+0x3d4>
    195e:	c0 31       	cpi	r28, 0x10	; 16
    1960:	a1 f5       	brne	.+104    	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    1962:	c8 01       	movw	r24, r16
    1964:	b6 01       	movw	r22, r12
    1966:	a7 01       	movw	r20, r14
    1968:	2a e0       	ldi	r18, 0x0A	; 10
    196a:	35 dd       	rcall	.-1430   	; 0x13d6 <TCP_SetConnectionState>

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    196c:	2e c0       	rjmp	.+92     	; 0x19ca <TCP_ProcessTCPPacket+0x3b2>
    196e:	84 e1       	ldi	r24, 0x14	; 20
    1970:	d4 01       	movw	r26, r8
    1972:	1d 96       	adiw	r26, 0x0d	; 13
    1974:	8c 93       	st	X, r24
    1976:	1d 97       	sbiw	r26, 0x0d	; 13
    1978:	39 c0       	rjmp	.+114    	; 0x19ec <TCP_ProcessTCPPacket+0x3d4>
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	92 e0       	ldi	r25, 0x02	; 2
    197e:	09 c0       	rjmp	.+18     	; 0x1992 <TCP_ProcessTCPPacket+0x37a>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1980:	d8 01       	movw	r26, r16
    1982:	18 96       	adiw	r26, 0x08	; 8
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1984:	2d 91       	ld	r18, X+
    1986:	3c 91       	ld	r19, X
    1988:	19 97       	sbiw	r26, 0x09	; 9
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	92 e0       	ldi	r25, 0x02	; 2
    198e:	82 1b       	sub	r24, r18
    1990:	93 0b       	sbc	r25, r19
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1992:	1e db       	rcall	.-2500   	; 0xfd0 <SwapEndian_16>
    1994:	f4 01       	movw	r30, r8
    1996:	97 87       	std	Z+15, r25	; 0x0f
    1998:	86 87       	std	Z+14, r24	; 0x0e
    199a:	13 8a       	std	Z+19, r1	; 0x13
    199c:	12 8a       	std	Z+18, r1	; 0x12
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    199e:	11 8a       	std	Z+17, r1	; 0x11
    19a0:	10 8a       	std	Z+16, r1	; 0x10
    19a2:	84 85       	ldd	r24, Z+12	; 0x0c
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    19a4:	80 7f       	andi	r24, 0xF0	; 240
    19a6:	84 87       	std	Z+12, r24	; 0x0c
    19a8:	b3 01       	movw	r22, r6
    19aa:	60 5f       	subi	r22, 0xF0	; 240
    19ac:	7f 4f       	sbci	r23, 0xFF	; 255
    19ae:	c4 01       	movw	r24, r8
    19b0:	a7 01       	movw	r20, r14
    19b2:	24 e1       	ldi	r18, 0x14	; 20
    19b4:	30 e0       	ldi	r19, 0x00	; 0
    19b6:	10 db       	rcall	.-2528   	; 0xfd8 <TCP_Checksum16>
    19b8:	f4 01       	movw	r30, r8
    19ba:	91 8b       	std	Z+17, r25	; 0x11
    19bc:	80 8b       	std	Z+16, r24	; 0x10
    19be:	84 e1       	ldi	r24, 0x14	; 20

		TCPHeaderOUT->UrgentPointer        = 0;
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	05 c0       	rjmp	.+10     	; 0x19ce <TCP_ProcessTCPPacket+0x3b6>
		TCPHeaderOUT->Checksum             = 0;
    19c4:	8f ef       	ldi	r24, 0xFF	; 255
    19c6:	9f ef       	ldi	r25, 0xFF	; 255
		TCPHeaderOUT->Reserved             = 0;
    19c8:	02 c0       	rjmp	.+4      	; 0x19ce <TCP_ProcessTCPPacket+0x3b6>
    19ca:	80 e0       	ldi	r24, 0x00	; 0
    19cc:	90 e0       	ldi	r25, 0x00	; 0

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    19ce:	df 91       	pop	r29
    19d0:	cf 91       	pop	r28
    19d2:	1f 91       	pop	r17
    19d4:	0f 91       	pop	r16
    19d6:	ff 90       	pop	r15
    19d8:	ef 90       	pop	r14
    19da:	df 90       	pop	r13
    19dc:	cf 90       	pop	r12
    19de:	bf 90       	pop	r11
    19e0:	af 90       	pop	r10
    19e2:	9f 90       	pop	r9
    19e4:	8f 90       	pop	r8
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    19e6:	7f 90       	pop	r7
    19e8:	6f 90       	pop	r6
    19ea:	08 95       	ret
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    19ec:	d5 01       	movw	r26, r10
    19ee:	12 96       	adiw	r26, 0x02	; 2
    19f0:	cd 91       	ld	r28, X+
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    19f2:	dc 91       	ld	r29, X
    19f4:	13 97       	sbiw	r26, 0x03	; 3
}
    19f6:	fc e0       	ldi	r31, 0x0C	; 12
    19f8:	ef 2e       	mov	r14, r31
    19fa:	f1 2c       	mov	r15, r1
    19fc:	e6 0c       	add	r14, r6
    19fe:	f7 1c       	adc	r15, r7
    1a00:	4d 91       	ld	r20, X+
    1a02:	5c 91       	ld	r21, X
    1a04:	ce 01       	movw	r24, r28
    1a06:	b7 01       	movw	r22, r14
    1a08:	b7 dd       	rcall	.-1170   	; 0x1578 <TCP_GetConnectionInfo>
    1a0a:	8c 01       	movw	r16, r24
    1a0c:	f4 01       	movw	r30, r8
    1a0e:	d1 83       	std	Z+1, r29	; 0x01
    1a10:	c0 83       	st	Z, r28
    1a12:	d5 01       	movw	r26, r10
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1a14:	8d 91       	ld	r24, X+
    1a16:	9c 91       	ld	r25, X
    1a18:	93 83       	std	Z+3, r25	; 0x03
    1a1a:	82 83       	std	Z+2, r24	; 0x02
    1a1c:	f8 01       	movw	r30, r16
    1a1e:	64 81       	ldd	r22, Z+4	; 0x04
    1a20:	75 81       	ldd	r23, Z+5	; 0x05
    1a22:	86 81       	ldd	r24, Z+6	; 0x06
    1a24:	97 81       	ldd	r25, Z+7	; 0x07
    1a26:	ce da       	rcall	.-2660   	; 0xfc4 <SwapEndian_32>
    1a28:	dc 01       	movw	r26, r24
    1a2a:	cb 01       	movw	r24, r22
    1a2c:	f4 01       	movw	r30, r8
    1a2e:	84 83       	std	Z+4, r24	; 0x04
    1a30:	95 83       	std	Z+5, r25	; 0x05
    1a32:	a6 83       	std	Z+6, r26	; 0x06
    1a34:	b7 83       	std	Z+7, r27	; 0x07
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1a36:	d8 01       	movw	r26, r16
    1a38:	6d 91       	ld	r22, X+
    1a3a:	7d 91       	ld	r23, X+
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1a3c:	8d 91       	ld	r24, X+
    1a3e:	9c 91       	ld	r25, X
    1a40:	c1 da       	rcall	.-2686   	; 0xfc4 <SwapEndian_32>
    1a42:	dc 01       	movw	r26, r24
    1a44:	cb 01       	movw	r24, r22
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1a46:	f4 01       	movw	r30, r8
    1a48:	80 87       	std	Z+8, r24	; 0x08
    1a4a:	91 87       	std	Z+9, r25	; 0x09
    1a4c:	a2 87       	std	Z+10, r26	; 0x0a
    1a4e:	b3 87       	std	Z+11, r27	; 0x0b
    1a50:	84 85       	ldd	r24, Z+12	; 0x0c
    1a52:	8f 70       	andi	r24, 0x0F	; 15
    1a54:	80 65       	ori	r24, 0x50	; 80
    1a56:	84 87       	std	Z+12, r24	; 0x0c
    1a58:	f8 01       	movw	r30, r16
    1a5a:	e4 5f       	subi	r30, 0xF4	; 244
    1a5c:	fd 4f       	sbci	r31, 0xFD	; 253
    1a5e:	80 81       	ld	r24, Z
    1a60:	88 23       	and	r24, r24
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    1a62:	09 f4       	brne	.+2      	; 0x1a66 <TCP_ProcessTCPPacket+0x44e>
    1a64:	8a cf       	rjmp	.-236    	; 0x197a <TCP_ProcessTCPPacket+0x362>
    1a66:	8c cf       	rjmp	.-232    	; 0x1980 <TCP_ProcessTCPPacket+0x368>

00001a68 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    1a68:	ef 92       	push	r14
    1a6a:	ff 92       	push	r15
    1a6c:	0f 93       	push	r16
    1a6e:	1f 93       	push	r17
    1a70:	cf 93       	push	r28
    1a72:	df 93       	push	r29
    1a74:	7c 01       	movw	r14, r24
    1a76:	8b 01       	movw	r16, r22
    1a78:	ea 01       	movw	r28, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1a7a:	cb 01       	movw	r24, r22
    1a7c:	0e 94 aa 04 	call	0x954	; 0x954 <DecodeUDPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1a80:	f8 01       	movw	r30, r16
    1a82:	82 81       	ldd	r24, Z+2	; 0x02
    1a84:	93 81       	ldd	r25, Z+3	; 0x03

				Temp = Data.Bytes[0];
    1a86:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1a88:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1a8a:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1a8c:	83 34       	cpi	r24, 0x43	; 67
    1a8e:	91 05       	cpc	r25, r1
    1a90:	d1 f4       	brne	.+52     	; 0x1ac6 <UDP_ProcessUDPPacket+0x5e>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1a92:	b8 01       	movw	r22, r16
    1a94:	68 5f       	subi	r22, 0xF8	; 248
    1a96:	7f 4f       	sbci	r23, 0xFF	; 255
    1a98:	ae 01       	movw	r20, r28
    1a9a:	48 5f       	subi	r20, 0xF8	; 248
    1a9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1a9e:	c7 01       	movw	r24, r14
    1aa0:	1b d0       	rcall	.+54     	; 0x1ad8 <DHCP_ProcessDHCPPacket>
    1aa2:	18 16       	cp	r1, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1aa4:	19 06       	cpc	r1, r25
    1aa6:	7c f4       	brge	.+30     	; 0x1ac6 <UDP_ProcessUDPPacket+0x5e>
    1aa8:	f8 01       	movw	r30, r16
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1aaa:	22 81       	ldd	r18, Z+2	; 0x02
    1aac:	33 81       	ldd	r19, Z+3	; 0x03
    1aae:	39 83       	std	Y+1, r19	; 0x01
    1ab0:	28 83       	st	Y, r18
    1ab2:	20 81       	ld	r18, Z
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1ab4:	31 81       	ldd	r19, Z+1	; 0x01
    1ab6:	3b 83       	std	Y+3, r19	; 0x03
    1ab8:	2a 83       	std	Y+2, r18	; 0x02
    1aba:	1f 82       	std	Y+7, r1	; 0x07
		UDPHeaderOUT->Checksum        = 0;
    1abc:	1e 82       	std	Y+6, r1	; 0x06
    1abe:	08 96       	adiw	r24, 0x08	; 8
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1ac0:	9c 83       	std	Y+4, r25	; 0x04
    1ac2:	8d 83       	std	Y+5, r24	; 0x05
    1ac4:	02 c0       	rjmp	.+4      	; 0x1aca <UDP_ProcessUDPPacket+0x62>

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
	}

	return NO_RESPONSE;
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	df 91       	pop	r29
}
    1acc:	cf 91       	pop	r28
    1ace:	1f 91       	pop	r17
    1ad0:	0f 91       	pop	r16
    1ad2:	ff 90       	pop	r15
    1ad4:	ef 90       	pop	r14
    1ad6:	08 95       	ret

00001ad8 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1ad8:	8f 92       	push	r8
    1ada:	9f 92       	push	r9
    1adc:	af 92       	push	r10
    1ade:	bf 92       	push	r11
    1ae0:	cf 92       	push	r12
    1ae2:	df 92       	push	r13
    1ae4:	ef 92       	push	r14
    1ae6:	ff 92       	push	r15
    1ae8:	0f 93       	push	r16
    1aea:	1f 93       	push	r17
    1aec:	cf 93       	push	r28
    1aee:	df 93       	push	r29
    1af0:	6c 01       	movw	r12, r24
    1af2:	8b 01       	movw	r16, r22
    1af4:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    1af6:	20 ef       	ldi	r18, 0xF0	; 240
    1af8:	e2 2e       	mov	r14, r18
    1afa:	f1 2c       	mov	r15, r1
    1afc:	e6 0e       	add	r14, r22
    1afe:	f7 1e       	adc	r15, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1b00:	cb 01       	movw	r24, r22
    1b02:	0e 94 ab 04 	call	0x956	; 0x956 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    1b06:	80 ef       	ldi	r24, 0xF0	; 240
    1b08:	fe 01       	movw	r30, r28
    1b0a:	11 92       	st	Z+, r1
    1b0c:	8a 95       	dec	r24
    1b0e:	e9 f7       	brne	.-6      	; 0x1b0a <DHCP_ProcessDHCPPacket+0x32>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1b10:	f8 01       	movw	r30, r16
    1b12:	81 81       	ldd	r24, Z+1	; 0x01
    1b14:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1b16:	82 e0       	ldi	r24, 0x02	; 2
    1b18:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    1b1a:	82 81       	ldd	r24, Z+2	; 0x02
    1b1c:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    1b1e:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    1b20:	84 81       	ldd	r24, Z+4	; 0x04
    1b22:	95 81       	ldd	r25, Z+5	; 0x05
    1b24:	a6 81       	ldd	r26, Z+6	; 0x06
    1b26:	b7 81       	ldd	r27, Z+7	; 0x07
    1b28:	8c 83       	std	Y+4, r24	; 0x04
    1b2a:	9d 83       	std	Y+5, r25	; 0x05
    1b2c:	ae 83       	std	Y+6, r26	; 0x06
    1b2e:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    1b30:	19 86       	std	Y+9, r1	; 0x09
    1b32:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    1b34:	82 85       	ldd	r24, Z+10	; 0x0a
    1b36:	93 85       	ldd	r25, Z+11	; 0x0b
    1b38:	9b 87       	std	Y+11, r25	; 0x0b
    1b3a:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    1b3c:	80 90 08 01 	lds	r8, 0x0108
    1b40:	90 90 09 01 	lds	r9, 0x0109
    1b44:	a0 90 0a 01 	lds	r10, 0x010A
    1b48:	b0 90 0b 01 	lds	r11, 0x010B
    1b4c:	88 8a       	std	Y+16, r8	; 0x10
    1b4e:	99 8a       	std	Y+17, r9	; 0x11
    1b50:	aa 8a       	std	Y+18, r10	; 0x12
    1b52:	bb 8a       	std	Y+19, r11	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    1b54:	b8 01       	movw	r22, r16
    1b56:	64 5e       	subi	r22, 0xE4	; 228
    1b58:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5a:	ce 01       	movw	r24, r28
    1b5c:	4c 96       	adiw	r24, 0x1c	; 28
    1b5e:	46 e0       	ldi	r20, 0x06	; 6
    1b60:	50 e0       	ldi	r21, 0x00	; 0
    1b62:	ba d7       	rcall	.+3956   	; 0x2ad8 <memmove>
    1b64:	fe 01       	movw	r30, r28
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1b66:	e4 51       	subi	r30, 0x14	; 20
    1b68:	ff 4f       	sbci	r31, 0xFF	; 255
    1b6a:	83 e6       	ldi	r24, 0x63	; 99
    1b6c:	92 e8       	ldi	r25, 0x82	; 130
    1b6e:	a3 e5       	ldi	r26, 0x53	; 83
    1b70:	b3 e6       	ldi	r27, 0x63	; 99
    1b72:	80 83       	st	Z, r24
    1b74:	91 83       	std	Z+1, r25	; 0x01
    1b76:	a2 83       	std	Z+2, r26	; 0x02
    1b78:	b3 83       	std	Z+3, r27	; 0x03
    1b7a:	f6 01       	movw	r30, r12

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1b7c:	84 86       	std	Z+12, r8	; 0x0c
    1b7e:	95 86       	std	Z+13, r9	; 0x0d
    1b80:	a6 86       	std	Z+14, r10	; 0x0e
    1b82:	b7 86       	std	Z+15, r11	; 0x0f
    1b84:	80 91 16 01 	lds	r24, 0x0116
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1b88:	90 91 17 01 	lds	r25, 0x0117
    1b8c:	a0 91 18 01 	lds	r26, 0x0118
    1b90:	b0 91 19 01 	lds	r27, 0x0119
    1b94:	80 8b       	std	Z+16, r24	; 0x10
    1b96:	91 8b       	std	Z+17, r25	; 0x11
    1b98:	a2 8b       	std	Z+18, r26	; 0x12
    1b9a:	b3 8b       	std	Z+19, r27	; 0x13
    1b9c:	63 c0       	rjmp	.+198    	; 0x1c64 <DHCP_ProcessDHCPPacket+0x18c>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1b9e:	85 33       	cpi	r24, 0x35	; 53
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1ba0:	09 f0       	breq	.+2      	; 0x1ba4 <DHCP_ProcessDHCPPacket+0xcc>
    1ba2:	55 c0       	rjmp	.+170    	; 0x1c4e <DHCP_ProcessDHCPPacket+0x176>
    1ba4:	f7 01       	movw	r30, r14
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1ba6:	82 81       	ldd	r24, Z+2	; 0x02
    1ba8:	81 30       	cpi	r24, 0x01	; 1
    1baa:	19 f0       	breq	.+6      	; 0x1bb2 <DHCP_ProcessDHCPPacket+0xda>
    1bac:	83 30       	cpi	r24, 0x03	; 3
    1bae:	09 f0       	breq	.+2      	; 0x1bb2 <DHCP_ProcessDHCPPacket+0xda>
    1bb0:	50 c0       	rjmp	.+160    	; 0x1c52 <DHCP_ProcessDHCPPacket+0x17a>
    1bb2:	fe 01       	movw	r30, r28
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1bb4:	e0 51       	subi	r30, 0x10	; 16
    1bb6:	ff 4f       	sbci	r31, 0xFF	; 255
    1bb8:	85 e3       	ldi	r24, 0x35	; 53
    1bba:	80 83       	st	Z, r24
    1bbc:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 1;
    1bbe:	ef 50       	subi	r30, 0x0F	; 15
    1bc0:	ff 4f       	sbci	r31, 0xFF	; 255
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	80 83       	st	Z, r24
    1bc6:	f7 01       	movw	r30, r14
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1bc8:	82 81       	ldd	r24, Z+2	; 0x02
    1bca:	81 30       	cpi	r24, 0x01	; 1
    1bcc:	11 f4       	brne	.+4      	; 0x1bd2 <DHCP_ProcessDHCPPacket+0xfa>
    1bce:	82 e0       	ldi	r24, 0x02	; 2
    1bd0:	01 c0       	rjmp	.+2      	; 0x1bd4 <DHCP_ProcessDHCPPacket+0xfc>
    1bd2:	85 e0       	ldi	r24, 0x05	; 5
    1bd4:	fe 01       	movw	r30, r28
    1bd6:	ee 50       	subi	r30, 0x0E	; 14
    1bd8:	ff 4f       	sbci	r31, 0xFF	; 255
    1bda:	80 83       	st	Z, r24
    1bdc:	fe 01       	movw	r30, r28
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1bde:	ed 50       	subi	r30, 0x0D	; 13
    1be0:	ff 4f       	sbci	r31, 0xFF	; 255
    1be2:	81 e0       	ldi	r24, 0x01	; 1
    1be4:	80 83       	st	Z, r24
    1be6:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 4;
    1be8:	ec 50       	subi	r30, 0x0C	; 12
    1bea:	ff 4f       	sbci	r31, 0xFF	; 255
    1bec:	84 e0       	ldi	r24, 0x04	; 4
    1bee:	80 83       	st	Z, r24
    1bf0:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1bf2:	eb 50       	subi	r30, 0x0B	; 11
    1bf4:	ff 4f       	sbci	r31, 0xFF	; 255
    1bf6:	2f ef       	ldi	r18, 0xFF	; 255
    1bf8:	20 83       	st	Z, r18
    1bfa:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1bfc:	ea 50       	subi	r30, 0x0A	; 10
    1bfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1c00:	20 83       	st	Z, r18
    1c02:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1c04:	e9 50       	subi	r30, 0x09	; 9
    1c06:	ff 4f       	sbci	r31, 0xFF	; 255
    1c08:	20 83       	st	Z, r18
    1c0a:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0x00;
    1c0c:	e8 50       	subi	r30, 0x08	; 8
    1c0e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c10:	10 82       	st	Z, r1
    1c12:	fe 01       	movw	r30, r28

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1c14:	e7 50       	subi	r30, 0x07	; 7
    1c16:	ff 4f       	sbci	r31, 0xFF	; 255
    1c18:	96 e3       	ldi	r25, 0x36	; 54
    1c1a:	90 83       	st	Z, r25
    1c1c:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    1c1e:	e6 50       	subi	r30, 0x06	; 6
    1c20:	ff 4f       	sbci	r31, 0xFF	; 255
    1c22:	80 83       	st	Z, r24
    1c24:	fe 01       	movw	r30, r28
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    1c26:	e5 50       	subi	r30, 0x05	; 5
    1c28:	ff 4f       	sbci	r31, 0xFF	; 255
    1c2a:	80 91 16 01 	lds	r24, 0x0116
    1c2e:	90 91 17 01 	lds	r25, 0x0117
    1c32:	a0 91 18 01 	lds	r26, 0x0118
    1c36:	b0 91 19 01 	lds	r27, 0x0119
    1c3a:	80 83       	st	Z, r24
    1c3c:	91 83       	std	Z+1, r25	; 0x01
    1c3e:	a2 83       	std	Z+2, r26	; 0x02
    1c40:	b3 83       	std	Z+3, r27	; 0x03
    1c42:	c1 50       	subi	r28, 0x01	; 1
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1c44:	df 4f       	sbci	r29, 0xFF	; 255
    1c46:	28 83       	st	Y, r18
    1c48:	80 e0       	ldi	r24, 0x00	; 0

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    1c4a:	91 e0       	ldi	r25, 0x01	; 1
    1c4c:	12 c0       	rjmp	.+36     	; 0x1c72 <DHCP_ProcessDHCPPacket+0x19a>
    1c4e:	88 23       	and	r24, r24
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    1c50:	29 f0       	breq	.+10     	; 0x1c5c <DHCP_ProcessDHCPPacket+0x184>
    1c52:	f7 01       	movw	r30, r14
    1c54:	81 81       	ldd	r24, Z+1	; 0x01
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	02 96       	adiw	r24, 0x02	; 2
    1c5a:	02 c0       	rjmp	.+4      	; 0x1c60 <DHCP_ProcessDHCPPacket+0x188>
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	e8 0e       	add	r14, r24
    1c62:	f9 1e       	adc	r15, r25
    1c64:	f7 01       	movw	r30, r14
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1c66:	80 81       	ld	r24, Z
    1c68:	8f 3f       	cpi	r24, 0xFF	; 255
    1c6a:	09 f0       	breq	.+2      	; 0x1c6e <DHCP_ProcessDHCPPacket+0x196>
    1c6c:	98 cf       	rjmp	.-208    	; 0x1b9e <DHCP_ProcessDHCPPacket+0xc6>
    1c6e:	80 e0       	ldi	r24, 0x00	; 0

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	df 91       	pop	r29
}
    1c74:	cf 91       	pop	r28
    1c76:	1f 91       	pop	r17
    1c78:	0f 91       	pop	r16
    1c7a:	ff 90       	pop	r15
    1c7c:	ef 90       	pop	r14
    1c7e:	df 90       	pop	r13
    1c80:	cf 90       	pop	r12
    1c82:	bf 90       	pop	r11
    1c84:	af 90       	pop	r10
    1c86:	9f 90       	pop	r9
    1c88:	8f 90       	pop	r8
    1c8a:	08 95       	ret

00001c8c <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1c8c:	0f 93       	push	r16
    1c8e:	1f 93       	push	r17
    1c90:	cf 93       	push	r28
    1c92:	df 93       	push	r29
    1c94:	ec 01       	movw	r28, r24
    1c96:	8b 01       	movw	r16, r22
	DecodeARPHeader(InDataStart);
    1c98:	0e 94 a6 04 	call	0x94c	; 0x94c <DecodeARPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1c9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c9e:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1ca0:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1ca2:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1ca4:	92 2f       	mov	r25, r18

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1ca6:	28 e0       	ldi	r18, 0x08	; 8
    1ca8:	80 30       	cpi	r24, 0x00	; 0
    1caa:	92 07       	cpc	r25, r18
    1cac:	09 f0       	breq	.+2      	; 0x1cb0 <ARP_ProcessARPPacket+0x24>
    1cae:	57 c0       	rjmp	.+174    	; 0x1d5e <ARP_ProcessARPPacket+0xd2>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1cb0:	8e 81       	ldd	r24, Y+6	; 0x06
    1cb2:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1cb4:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1cb6:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1cb8:	92 2f       	mov	r25, r18
    1cba:	81 30       	cpi	r24, 0x01	; 1
    1cbc:	91 05       	cpc	r25, r1
    1cbe:	09 f0       	breq	.+2      	; 0x1cc2 <ARP_ProcessARPPacket+0x36>
    1cc0:	4e c0       	rjmp	.+156    	; 0x1d5e <ARP_ProcessARPPacket+0xd2>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1cc2:	ce 01       	movw	r24, r28
    1cc4:	48 96       	adiw	r24, 0x18	; 24
    1cc6:	66 e1       	ldi	r22, 0x16	; 22
    1cc8:	71 e0       	ldi	r23, 0x01	; 1
    1cca:	44 e0       	ldi	r20, 0x04	; 4
    1ccc:	50 e0       	ldi	r21, 0x00	; 0
    1cce:	ee d6       	rcall	.+3548   	; 0x2aac <memcmp>
    1cd0:	00 97       	sbiw	r24, 0x00	; 0
    1cd2:	49 f0       	breq	.+18     	; 0x1ce6 <ARP_ProcessARPPacket+0x5a>
    1cd4:	ce 01       	movw	r24, r28
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    1cd6:	42 96       	adiw	r24, 0x12	; 18
    1cd8:	6a e1       	ldi	r22, 0x1A	; 26
    1cda:	71 e0       	ldi	r23, 0x01	; 1
    1cdc:	46 e0       	ldi	r20, 0x06	; 6
    1cde:	50 e0       	ldi	r21, 0x00	; 0
    1ce0:	e5 d6       	rcall	.+3530   	; 0x2aac <memcmp>
    1ce2:	00 97       	sbiw	r24, 0x00	; 0
    1ce4:	e1 f5       	brne	.+120    	; 0x1d5e <ARP_ProcessARPPacket+0xd2>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1ce6:	88 81       	ld	r24, Y
    1ce8:	99 81       	ldd	r25, Y+1	; 0x01
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1cea:	f8 01       	movw	r30, r16
    1cec:	91 83       	std	Z+1, r25	; 0x01
    1cee:	80 83       	st	Z, r24
    1cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf2:	9b 81       	ldd	r25, Y+3	; 0x03
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1cf4:	93 83       	std	Z+3, r25	; 0x03
    1cf6:	82 83       	std	Z+2, r24	; 0x02
    1cf8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cfa:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1cfc:	8d 81       	ldd	r24, Y+5	; 0x05
    1cfe:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1d00:	80 e0       	ldi	r24, 0x00	; 0
    1d02:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1d04:	97 83       	std	Z+7, r25	; 0x07
    1d06:	86 83       	std	Z+6, r24	; 0x06
    1d08:	d8 01       	movw	r26, r16
    1d0a:	52 96       	adiw	r26, 0x12	; 18

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    1d0c:	fe 01       	movw	r30, r28
    1d0e:	38 96       	adiw	r30, 0x08	; 8
    1d10:	86 e0       	ldi	r24, 0x06	; 6
    1d12:	01 90       	ld	r0, Z+
    1d14:	0d 92       	st	X+, r0
    1d16:	81 50       	subi	r24, 0x01	; 1
    1d18:	e1 f7       	brne	.-8      	; 0x1d12 <ARP_ProcessARPPacket+0x86>
    1d1a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d1c:	9f 85       	ldd	r25, Y+15	; 0x0f
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1d1e:	a8 89       	ldd	r26, Y+16	; 0x10
    1d20:	b9 89       	ldd	r27, Y+17	; 0x11
    1d22:	f8 01       	movw	r30, r16
    1d24:	80 8f       	std	Z+24, r24	; 0x18
    1d26:	91 8f       	std	Z+25, r25	; 0x19
    1d28:	a2 8f       	std	Z+26, r26	; 0x1a
    1d2a:	b3 8f       	std	Z+27, r27	; 0x1b
    1d2c:	d8 01       	movw	r26, r16
    1d2e:	18 96       	adiw	r26, 0x08	; 8

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1d30:	ea e1       	ldi	r30, 0x1A	; 26
    1d32:	f1 e0       	ldi	r31, 0x01	; 1
    1d34:	86 e0       	ldi	r24, 0x06	; 6
    1d36:	01 90       	ld	r0, Z+
    1d38:	0d 92       	st	X+, r0
    1d3a:	81 50       	subi	r24, 0x01	; 1
    1d3c:	e1 f7       	brne	.-8      	; 0x1d36 <ARP_ProcessARPPacket+0xaa>
    1d3e:	80 91 16 01 	lds	r24, 0x0116
			ARPHeaderOUT->SPA = ServerIPAddress;
    1d42:	90 91 17 01 	lds	r25, 0x0117
    1d46:	a0 91 18 01 	lds	r26, 0x0118
    1d4a:	b0 91 19 01 	lds	r27, 0x0119
    1d4e:	f8 01       	movw	r30, r16
    1d50:	86 87       	std	Z+14, r24	; 0x0e
    1d52:	97 87       	std	Z+15, r25	; 0x0f
    1d54:	a0 8b       	std	Z+16, r26	; 0x10
    1d56:	b1 8b       	std	Z+17, r27	; 0x11
    1d58:	8c e1       	ldi	r24, 0x1C	; 28
    1d5a:	90 e0       	ldi	r25, 0x00	; 0

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1d5c:	02 c0       	rjmp	.+4      	; 0x1d62 <ARP_ProcessARPPacket+0xd6>
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
    1d60:	90 e0       	ldi	r25, 0x00	; 0
		}
	}

	return NO_RESPONSE;
    1d62:	df 91       	pop	r29
    1d64:	cf 91       	pop	r28
}
    1d66:	1f 91       	pop	r17
    1d68:	0f 91       	pop	r16
    1d6a:	08 95       	ret

00001d6c <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    1d6c:	df 92       	push	r13
    1d6e:	ef 92       	push	r14
    1d70:	ff 92       	push	r15
    1d72:	0f 93       	push	r16
    1d74:	1f 93       	push	r17
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	7c 01       	movw	r14, r24
    1d7c:	8b 01       	movw	r16, r22
	DecodeIPHeader(InDataStart);
    1d7e:	0e 94 a7 04 	call	0x94e	; 0x94e <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1d82:	f7 01       	movw	r30, r14
    1d84:	d0 80       	ld	r13, Z
    1d86:	ff e0       	ldi	r31, 0x0F	; 15
    1d88:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1d8a:	e7 01       	movw	r28, r14
    1d8c:	60 96       	adiw	r28, 0x10	; 16
    1d8e:	ce 01       	movw	r24, r28
    1d90:	66 e1       	ldi	r22, 0x16	; 22
    1d92:	71 e0       	ldi	r23, 0x01	; 1
    1d94:	44 e0       	ldi	r20, 0x04	; 4
    1d96:	50 e0       	ldi	r21, 0x00	; 0
    1d98:	89 d6       	rcall	.+3346   	; 0x2aac <memcmp>
    1d9a:	00 97       	sbiw	r24, 0x00	; 0
    1d9c:	49 f0       	breq	.+18     	; 0x1db0 <IP_ProcessIPPacket+0x44>
    1d9e:	ce 01       	movw	r24, r28
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    1da0:	6c e0       	ldi	r22, 0x0C	; 12
    1da2:	71 e0       	ldi	r23, 0x01	; 1
    1da4:	44 e0       	ldi	r20, 0x04	; 4
    1da6:	50 e0       	ldi	r21, 0x00	; 0
    1da8:	81 d6       	rcall	.+3330   	; 0x2aac <memcmp>
    1daa:	00 97       	sbiw	r24, 0x00	; 0
    1dac:	09 f0       	breq	.+2      	; 0x1db0 <IP_ProcessIPPacket+0x44>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1dae:	5c c0       	rjmp	.+184    	; 0x1e68 <IP_ProcessIPPacket+0xfc>
    1db0:	6d 2d       	mov	r22, r13
    1db2:	70 e0       	ldi	r23, 0x00	; 0

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1db4:	66 0f       	add	r22, r22
    1db6:	77 1f       	adc	r23, r23
    1db8:	66 0f       	add	r22, r22
    1dba:	77 1f       	adc	r23, r23
    1dbc:	f7 01       	movw	r30, r14
    1dbe:	81 85       	ldd	r24, Z+9	; 0x09
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1dc0:	86 30       	cpi	r24, 0x06	; 6
    1dc2:	71 f0       	breq	.+28     	; 0x1de0 <IP_ProcessIPPacket+0x74>
    1dc4:	81 31       	cpi	r24, 0x11	; 17
    1dc6:	a1 f0       	breq	.+40     	; 0x1df0 <IP_ProcessIPPacket+0x84>
    1dc8:	81 30       	cpi	r24, 0x01	; 1
    1dca:	09 f0       	breq	.+2      	; 0x1dce <IP_ProcessIPPacket+0x62>
    1dcc:	4d c0       	rjmp	.+154    	; 0x1e68 <IP_ProcessIPPacket+0xfc>
    1dce:	98 01       	movw	r18, r16
    1dd0:	2c 5e       	subi	r18, 0xEC	; 236
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    1dd4:	c7 01       	movw	r24, r14
    1dd6:	86 0f       	add	r24, r22
    1dd8:	97 1f       	adc	r25, r23
    1dda:	b9 01       	movw	r22, r18
    1ddc:	b3 d8       	rcall	.-3738   	; 0xf44 <ICMP_ProcessICMPPacket>
    1dde:	0f c0       	rjmp	.+30     	; 0x1dfe <IP_ProcessIPPacket+0x92>
    1de0:	6e 0d       	add	r22, r14
    1de2:	7f 1d       	adc	r23, r15
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    1de4:	a8 01       	movw	r20, r16
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1de6:	4c 5e       	subi	r20, 0xEC	; 236
    1de8:	5f 4f       	sbci	r21, 0xFF	; 255
    1dea:	c7 01       	movw	r24, r14
    1dec:	15 dc       	rcall	.-2006   	; 0x1618 <TCP_ProcessTCPPacket>
    1dee:	07 c0       	rjmp	.+14     	; 0x1dfe <IP_ProcessIPPacket+0x92>
    1df0:	6e 0d       	add	r22, r14
    1df2:	7f 1d       	adc	r23, r15
    1df4:	a8 01       	movw	r20, r16
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    1df6:	4c 5e       	subi	r20, 0xEC	; 236
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1df8:	5f 4f       	sbci	r21, 0xFF	; 255
    1dfa:	c7 01       	movw	r24, r14
    1dfc:	35 de       	rcall	.-918    	; 0x1a68 <UDP_ProcessUDPPacket>
    1dfe:	18 16       	cp	r1, r24
    1e00:	19 06       	cpc	r1, r25
    1e02:	a4 f5       	brge	.+104    	; 0x1e6c <IP_ProcessIPPacket+0x100>
    1e04:	ec 01       	movw	r28, r24
    1e06:	64 96       	adiw	r28, 0x14	; 20
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1e08:	f8 01       	movw	r30, r16
    1e0a:	d2 83       	std	Z+2, r29	; 0x02
    1e0c:	c3 83       	std	Z+3, r28	; 0x03
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1e0e:	11 82       	std	Z+1, r1	; 0x01
    1e10:	85 e4       	ldi	r24, 0x45	; 69
    1e12:	80 83       	st	Z, r24
    1e14:	16 82       	std	Z+6, r1	; 0x06
    1e16:	17 82       	std	Z+7, r1	; 0x07
		IPHeaderOUT->TypeOfService      = 0;
    1e18:	15 82       	std	Z+5, r1	; 0x05
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1e1a:	14 82       	std	Z+4, r1	; 0x04
    1e1c:	13 86       	std	Z+11, r1	; 0x0b
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1e1e:	12 86       	std	Z+10, r1	; 0x0a
    1e20:	f7 01       	movw	r30, r14
		IPHeaderOUT->Identification     = 0;
    1e22:	81 85       	ldd	r24, Z+9	; 0x09
    1e24:	f8 01       	movw	r30, r16
		IPHeaderOUT->HeaderChecksum     = 0;
    1e26:	81 87       	std	Z+9, r24	; 0x09
    1e28:	80 e8       	ldi	r24, 0x80	; 128
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1e2a:	80 87       	std	Z+8, r24	; 0x08
    1e2c:	f7 01       	movw	r30, r14
    1e2e:	80 89       	ldd	r24, Z+16	; 0x10
    1e30:	91 89       	ldd	r25, Z+17	; 0x11
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1e32:	a2 89       	ldd	r26, Z+18	; 0x12
    1e34:	b3 89       	ldd	r27, Z+19	; 0x13
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1e36:	f8 01       	movw	r30, r16
    1e38:	84 87       	std	Z+12, r24	; 0x0c
    1e3a:	95 87       	std	Z+13, r25	; 0x0d
    1e3c:	a6 87       	std	Z+14, r26	; 0x0e
    1e3e:	b7 87       	std	Z+15, r27	; 0x0f
    1e40:	f7 01       	movw	r30, r14
    1e42:	84 85       	ldd	r24, Z+12	; 0x0c
    1e44:	95 85       	ldd	r25, Z+13	; 0x0d
    1e46:	a6 85       	ldd	r26, Z+14	; 0x0e
    1e48:	b7 85       	ldd	r27, Z+15	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1e4a:	f8 01       	movw	r30, r16
    1e4c:	80 8b       	std	Z+16, r24	; 0x10
    1e4e:	91 8b       	std	Z+17, r25	; 0x11
    1e50:	a2 8b       	std	Z+18, r26	; 0x12
    1e52:	b3 8b       	std	Z+19, r27	; 0x13
    1e54:	c8 01       	movw	r24, r16
    1e56:	64 e1       	ldi	r22, 0x14	; 20
    1e58:	70 e0       	ldi	r23, 0x00	; 0
    1e5a:	0e 94 73 04 	call	0x8e6	; 0x8e6 <Ethernet_Checksum16>

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1e5e:	f8 01       	movw	r30, r16
    1e60:	93 87       	std	Z+11, r25	; 0x0b
    1e62:	82 87       	std	Z+10, r24	; 0x0a
    1e64:	ce 01       	movw	r24, r28
    1e66:	02 c0       	rjmp	.+4      	; 0x1e6c <IP_ProcessIPPacket+0x100>
    1e68:	80 e0       	ldi	r24, 0x00	; 0
    1e6a:	90 e0       	ldi	r25, 0x00	; 0
    1e6c:	df 91       	pop	r29

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1e6e:	cf 91       	pop	r28
    1e70:	1f 91       	pop	r17
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    1e72:	0f 91       	pop	r16
    1e74:	ff 90       	pop	r15
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    1e76:	ef 90       	pop	r14
    1e78:	df 90       	pop	r13
    1e7a:	08 95       	ret

00001e7c <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1e7c:	db 01       	movw	r26, r22
    1e7e:	0d 90       	ld	r0, X+
    1e80:	00 20       	and	r0, r0
    1e82:	e9 f7       	brne	.-6      	; 0x1e7e <IsHTTPCommand+0x2>
    1e84:	ad 01       	movw	r20, r26
    1e86:	41 50       	subi	r20, 0x01	; 1
    1e88:	50 40       	sbci	r21, 0x00	; 0
    1e8a:	46 1b       	sub	r20, r22
    1e8c:	57 0b       	sbc	r21, r23
    1e8e:	35 d6       	rcall	.+3178   	; 0x2afa <strncmp>
    1e90:	9c 01       	movw	r18, r24
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	21 15       	cp	r18, r1
    1e96:	31 05       	cpc	r19, r1
    1e98:	09 f0       	breq	.+2      	; 0x1e9c <IsHTTPCommand+0x20>
    1e9a:	80 e0       	ldi	r24, 0x00	; 0
    1e9c:	08 95       	ret

00001e9e <Webserver_ApplicationCallback>:
}
    1e9e:	af 92       	push	r10
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1ea0:	bf 92       	push	r11
    1ea2:	cf 92       	push	r12
    1ea4:	df 92       	push	r13
    1ea6:	ef 92       	push	r14
    1ea8:	ff 92       	push	r15
    1eaa:	0f 93       	push	r16
    1eac:	1f 93       	push	r17
    1eae:	cf 93       	push	r28
    1eb0:	df 93       	push	r29
    1eb2:	5c 01       	movw	r10, r24
    1eb4:	7b 01       	movw	r14, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1eb6:	8b 01       	movw	r16, r22
    1eb8:	0e 5f       	subi	r16, 0xFE	; 254
    1eba:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1ebc:	23 e0       	ldi	r18, 0x03	; 3
    1ebe:	c2 2e       	mov	r12, r18
    1ec0:	22 e0       	ldi	r18, 0x02	; 2
    1ec2:	d2 2e       	mov	r13, r18
    1ec4:	c6 0e       	add	r12, r22
    1ec6:	d7 1e       	adc	r13, r23
    1ec8:	d6 01       	movw	r26, r12
    1eca:	8c 91       	ld	r24, X
    1ecc:	88 23       	and	r24, r24
    1ece:	09 f4       	brne	.+2      	; 0x1ed2 <Webserver_ApplicationCallback+0x34>
    1ed0:	62 c0       	rjmp	.+196    	; 0x1f96 <Webserver_ApplicationCallback+0xf8>
    1ed2:	eb 01       	movw	r28, r22
    1ed4:	ce 5f       	subi	r28, 0xFE	; 254
    1ed6:	dd 4f       	sbci	r29, 0xFD	; 253
    1ed8:	88 81       	ld	r24, Y
    1eda:	88 23       	and	r24, r24
    1edc:	09 f0       	breq	.+2      	; 0x1ee0 <Webserver_ApplicationCallback+0x42>
    1ede:	9a c0       	rjmp	.+308    	; 0x2014 <Webserver_ApplicationCallback+0x176>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1ee0:	c8 01       	movw	r24, r16
    1ee2:	68 e2       	ldi	r22, 0x28	; 40
    1ee4:	71 e0       	ldi	r23, 0x01	; 1
    1ee6:	ca df       	rcall	.-108    	; 0x1e7c <IsHTTPCommand>
    1ee8:	88 23       	and	r24, r24
    1eea:	f9 f0       	breq	.+62     	; 0x1f2a <Webserver_ApplicationCallback+0x8c>
    1eec:	c8 01       	movw	r24, r16
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1eee:	6c e2       	ldi	r22, 0x2C	; 44
    1ef0:	71 e0       	ldi	r23, 0x01	; 1
    1ef2:	c4 df       	rcall	.-120    	; 0x1e7c <IsHTTPCommand>
    1ef4:	88 23       	and	r24, r24
    1ef6:	49 f1       	breq	.+82     	; 0x1f4a <Webserver_ApplicationCallback+0xac>
    1ef8:	10 92 4c 01 	sts	0x014C, r1
			{
				PageBlock = 0;
    1efc:	c8 01       	movw	r24, r16
    1efe:	67 ee       	ldi	r22, 0xE7	; 231

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1f00:	73 e0       	ldi	r23, 0x03	; 3
    1f02:	b5 d5       	rcall	.+2922   	; 0x2a6e <strcpy_P>
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	88 83       	st	Y, r24
    1f08:	f8 01       	movw	r30, r16

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1f0a:	01 90       	ld	r0, Z+
    1f0c:	00 20       	and	r0, r0
    1f0e:	e9 f7       	brne	.-6      	; 0x1f0a <Webserver_ApplicationCallback+0x6c>
    1f10:	31 97       	sbiw	r30, 0x01	; 1
    1f12:	e0 1b       	sub	r30, r16
    1f14:	f1 0b       	sbc	r31, r17
    1f16:	d7 01       	movw	r26, r14
    1f18:	11 96       	adiw	r26, 0x01	; 1
    1f1a:	fc 93       	st	X, r31
    1f1c:	ee 93       	st	-X, r30
    1f1e:	f6 01       	movw	r30, r12
    1f20:	80 83       	st	Z, r24
    1f22:	f7 01       	movw	r30, r14
    1f24:	ec 5f       	subi	r30, 0xFC	; 252
    1f26:	fd 4f       	sbci	r31, 0xFD	; 253

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1f28:	74 c0       	rjmp	.+232    	; 0x2012 <Webserver_ApplicationCallback+0x174>
    1f2a:	c8 01       	movw	r24, r16
    1f2c:	63 e3       	ldi	r22, 0x33	; 51
    1f2e:	71 e0       	ldi	r23, 0x01	; 1

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1f30:	a5 df       	rcall	.-182    	; 0x1e7c <IsHTTPCommand>
    1f32:	88 23       	and	r24, r24
    1f34:	f1 f0       	breq	.+60     	; 0x1f72 <Webserver_ApplicationCallback+0xd4>
    1f36:	c8 01       	movw	r24, r16
    1f38:	68 e3       	ldi	r22, 0x38	; 56
    1f3a:	71 e0       	ldi	r23, 0x01	; 1
    1f3c:	9f df       	rcall	.-194    	; 0x1e7c <IsHTTPCommand>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1f3e:	88 23       	and	r24, r24
    1f40:	21 f0       	breq	.+8      	; 0x1f4a <Webserver_ApplicationCallback+0xac>
    1f42:	c8 01       	movw	r24, r16
    1f44:	67 ee       	ldi	r22, 0xE7	; 231
    1f46:	73 e0       	ldi	r23, 0x03	; 3
    1f48:	03 c0       	rjmp	.+6      	; 0x1f50 <Webserver_ApplicationCallback+0xb2>
    1f4a:	c8 01       	movw	r24, r16
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1f4c:	65 ea       	ldi	r22, 0xA5	; 165
    1f4e:	73 e0       	ldi	r23, 0x03	; 3
    1f50:	8e d5       	rcall	.+2844   	; 0x2a6e <strcpy_P>
    1f52:	81 e0       	ldi	r24, 0x01	; 1
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1f54:	88 83       	st	Y, r24
    1f56:	f8 01       	movw	r30, r16
    1f58:	01 90       	ld	r0, Z+
    1f5a:	00 20       	and	r0, r0
    1f5c:	e9 f7       	brne	.-6      	; 0x1f58 <Webserver_ApplicationCallback+0xba>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1f5e:	31 97       	sbiw	r30, 0x01	; 1
    1f60:	e0 1b       	sub	r30, r16
    1f62:	f1 0b       	sbc	r31, r17
    1f64:	d7 01       	movw	r26, r14
    1f66:	11 96       	adiw	r26, 0x01	; 1
    1f68:	fc 93       	st	X, r31
    1f6a:	ee 93       	st	-X, r30
    1f6c:	f6 01       	movw	r30, r12
    1f6e:	80 83       	st	Z, r24
    1f70:	4c c0       	rjmp	.+152    	; 0x200a <Webserver_ApplicationCallback+0x16c>
    1f72:	c8 01       	movw	r24, r16
    1f74:	60 e4       	ldi	r22, 0x40	; 64
    1f76:	71 e0       	ldi	r23, 0x01	; 1
    1f78:	81 df       	rcall	.-254    	; 0x1e7c <IsHTTPCommand>
    1f7a:	88 23       	and	r24, r24
    1f7c:	29 f0       	breq	.+10     	; 0x1f88 <Webserver_ApplicationCallback+0xea>
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	88 83       	st	Y, r24
    1f82:	d6 01       	movw	r26, r12
    1f84:	8c 93       	st	X, r24
    1f86:	41 c0       	rjmp	.+130    	; 0x200a <Webserver_ApplicationCallback+0x16c>
    1f88:	f6 01       	movw	r30, r12
    1f8a:	10 82       	st	Z, r1
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1f8c:	d7 01       	movw	r26, r14
    1f8e:	11 96       	adiw	r26, 0x01	; 1
    1f90:	1c 92       	st	X, r1
    1f92:	1e 92       	st	-X, r1
    1f94:	3f c0       	rjmp	.+126    	; 0x2014 <Webserver_ApplicationCallback+0x176>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1f96:	fb 01       	movw	r30, r22
    1f98:	ec 5f       	subi	r30, 0xFC	; 252
    1f9a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f9c:	80 81       	ld	r24, Z
    1f9e:	88 23       	and	r24, r24
    1fa0:	c9 f1       	breq	.+114    	; 0x2014 <Webserver_ApplicationCallback+0x176>
    1fa2:	fb 01       	movw	r30, r22
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1fa4:	ee 5f       	subi	r30, 0xFE	; 254
    1fa6:	fd 4f       	sbci	r31, 0xFD	; 253
    1fa8:	80 81       	ld	r24, Z
    1faa:	88 23       	and	r24, r24
    1fac:	99 f1       	breq	.+102    	; 0x2014 <Webserver_ApplicationCallback+0x176>
    1fae:	c0 91 4c 01 	lds	r28, 0x014C
    1fb2:	d0 e0       	ldi	r29, 0x00	; 0
    1fb4:	d6 95       	lsr	r29
    1fb6:	dc 2f       	mov	r29, r28
    1fb8:	cc 27       	eor	r28, r28
    1fba:	d7 95       	ror	r29
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1fbc:	c7 95       	ror	r28
    1fbe:	cb 54       	subi	r28, 0x4B	; 75
    1fc0:	de 4f       	sbci	r29, 0xFE	; 254
    1fc2:	ce 01       	movw	r24, r28
    1fc4:	5b d5       	rcall	.+2742   	; 0x2a7c <__strlen_P>
    1fc6:	6c 01       	movw	r12, r24
    1fc8:	81 38       	cpi	r24, 0x81	; 129
    1fca:	91 05       	cpc	r25, r1
    1fcc:	18 f0       	brcs	.+6      	; 0x1fd4 <Webserver_ApplicationCallback+0x136>
    1fce:	80 e8       	ldi	r24, 0x80	; 128


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    1fd0:	c8 2e       	mov	r12, r24
    1fd2:	d1 2c       	mov	r13, r1
    1fd4:	c8 01       	movw	r24, r16
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = MIN(RemLength, HTTP_REPLY_BLOCK_SIZE);
    1fd6:	be 01       	movw	r22, r28
    1fd8:	a6 01       	movw	r20, r12
    1fda:	59 d5       	rcall	.+2738   	; 0x2a8e <strncpy_P>
    1fdc:	f7 01       	movw	r30, r14
    1fde:	ee 5f       	subi	r30, 0xFE	; 254
    1fe0:	fd 4f       	sbci	r31, 0xFD	; 253
    1fe2:	81 e0       	ldi	r24, 0x01	; 1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1fe4:	80 83       	st	Z, r24
    1fe6:	f7 01       	movw	r30, r14
    1fe8:	d1 82       	std	Z+1, r13	; 0x01
    1fea:	c0 82       	st	Z, r12
    1fec:	ed 5f       	subi	r30, 0xFD	; 253

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1fee:	fd 4f       	sbci	r31, 0xFD	; 253
    1ff0:	80 83       	st	Z, r24
    1ff2:	80 91 4c 01 	lds	r24, 0x014C
    1ff6:	98 2f       	mov	r25, r24
    1ff8:	9f 5f       	subi	r25, 0xFF	; 255
    1ffa:	90 93 4c 01 	sts	0x014C, r25
    1ffe:	83 30       	cpi	r24, 0x03	; 3
    2000:	49 f4       	brne	.+18     	; 0x2014 <Webserver_ApplicationCallback+0x176>
    2002:	f7 01       	movw	r30, r14

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    2004:	ec 5f       	subi	r30, 0xFC	; 252
    2006:	fd 4f       	sbci	r31, 0xFD	; 253
    2008:	10 82       	st	Z, r1
    200a:	f5 01       	movw	r30, r10
    200c:	eb 5e       	subi	r30, 0xEB	; 235
    200e:	fd 4f       	sbci	r31, 0xFD	; 253
    2010:	87 e0       	ldi	r24, 0x07	; 7
    2012:	80 83       	st	Z, r24
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    2014:	df 91       	pop	r29
    2016:	cf 91       	pop	r28
    2018:	1f 91       	pop	r17
    201a:	0f 91       	pop	r16

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    201c:	ff 90       	pop	r15
    201e:	ef 90       	pop	r14
    2020:	df 90       	pop	r13
    2022:	cf 90       	pop	r12
    2024:	bf 90       	pop	r11
		}
	}
}
    2026:	af 90       	pop	r10
    2028:	08 95       	ret

0000202a <Webserver_Init>:
    202a:	80 e0       	ldi	r24, 0x00	; 0
    202c:	90 e5       	ldi	r25, 0x50	; 80
    202e:	61 e0       	ldi	r22, 0x01	; 1
    2030:	4f e4       	ldi	r20, 0x4F	; 79
    2032:	5f e0       	ldi	r21, 0x0F	; 15
    2034:	a9 c9       	rjmp	.-3246   	; 0x1388 <TCP_SetPortState>

00002036 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2036:	af 92       	push	r10
    2038:	bf 92       	push	r11
    203a:	cf 92       	push	r12
    203c:	df 92       	push	r13
    203e:	ef 92       	push	r14
    2040:	ff 92       	push	r15
    2042:	1f 93       	push	r17
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	ec 01       	movw	r28, r24
    204a:	7b 01       	movw	r14, r22
    204c:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    204e:	eb d1       	rcall	.+982    	; 0x2426 <Endpoint_WaitUntilReady>
    2050:	18 2f       	mov	r17, r24
    2052:	88 23       	and	r24, r24
    2054:	a9 f5       	brne	.+106    	; 0x20c0 <Endpoint_Write_Stream_LE+0x8a>
    2056:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2058:	d1 04       	cpc	r13, r1
    205a:	39 f0       	breq	.+14     	; 0x206a <Endpoint_Write_Stream_LE+0x34>
    205c:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    205e:	20 81       	ld	r18, Z
    2060:	31 81       	ldd	r19, Z+1	; 0x01
    2062:	e2 1a       	sub	r14, r18
    2064:	f3 0a       	sbc	r15, r19
    2066:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2068:	d3 1f       	adc	r29, r19
    206a:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    206c:	bb 24       	eor	r11, r11
    206e:	23 c0       	rjmp	.+70     	; 0x20b6 <Endpoint_Write_Stream_LE+0x80>
    2070:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2074:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2076:	16 c0       	rjmp	.+44     	; 0x20a4 <Endpoint_Write_Stream_LE+0x6e>
    2078:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    207c:	8e 77       	andi	r24, 0x7E	; 126
    207e:	80 93 e8 00 	sts	0x00E8, r24
    2082:	98 d4       	rcall	.+2352   	; 0x29b4 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2084:	c1 14       	cp	r12, r1
    2086:	d1 04       	cpc	r13, r1
			#endif

			if (BytesProcessed != NULL)
    2088:	49 f0       	breq	.+18     	; 0x209c <Endpoint_Write_Stream_LE+0x66>
    208a:	f6 01       	movw	r30, r12
    208c:	80 81       	ld	r24, Z
			{
				*BytesProcessed += BytesInTransfer;
    208e:	91 81       	ldd	r25, Z+1	; 0x01
    2090:	8a 0d       	add	r24, r10
    2092:	9b 1d       	adc	r25, r11
    2094:	91 83       	std	Z+1, r25	; 0x01
    2096:	80 83       	st	Z, r24
    2098:	15 e0       	ldi	r17, 0x05	; 5
    209a:	12 c0       	rjmp	.+36     	; 0x20c0 <Endpoint_Write_Stream_LE+0x8a>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    209c:	c4 d1       	rcall	.+904    	; 0x2426 <Endpoint_WaitUntilReady>
    209e:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    20a0:	51 f0       	breq	.+20     	; 0x20b6 <Endpoint_Write_Stream_LE+0x80>
    20a2:	0d c0       	rjmp	.+26     	; 0x20be <Endpoint_Write_Stream_LE+0x88>
    20a4:	89 91       	ld	r24, Y+
    20a6:	80 93 f1 00 	sts	0x00F1, r24
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    20aa:	08 94       	sec
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    20ac:	e1 08       	sbc	r14, r1
    20ae:	f1 08       	sbc	r15, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    20b0:	08 94       	sec
    20b2:	a1 1c       	adc	r10, r1
    20b4:	b1 1c       	adc	r11, r1
			BytesInTransfer++;
    20b6:	e1 14       	cp	r14, r1
    20b8:	f1 04       	cpc	r15, r1
    20ba:	d1 f6       	brne	.-76     	; 0x2070 <Endpoint_Write_Stream_LE+0x3a>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    20bc:	01 c0       	rjmp	.+2      	; 0x20c0 <Endpoint_Write_Stream_LE+0x8a>
    20be:	18 2f       	mov	r17, r24
    20c0:	81 2f       	mov	r24, r17
    20c2:	df 91       	pop	r29
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    20c4:	cf 91       	pop	r28
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    20c6:	1f 91       	pop	r17
    20c8:	ff 90       	pop	r15
    20ca:	ef 90       	pop	r14
    20cc:	df 90       	pop	r13
    20ce:	cf 90       	pop	r12
    20d0:	bf 90       	pop	r11
    20d2:	af 90       	pop	r10
    20d4:	08 95       	ret

000020d6 <Endpoint_Read_Stream_LE>:
    20d6:	af 92       	push	r10
    20d8:	bf 92       	push	r11
    20da:	cf 92       	push	r12
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    20dc:	df 92       	push	r13
    20de:	ef 92       	push	r14
    20e0:	ff 92       	push	r15
    20e2:	1f 93       	push	r17
    20e4:	cf 93       	push	r28
    20e6:	df 93       	push	r29
    20e8:	ec 01       	movw	r28, r24
    20ea:	7b 01       	movw	r14, r22
    20ec:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    20ee:	9b d1       	rcall	.+822    	; 0x2426 <Endpoint_WaitUntilReady>
    20f0:	18 2f       	mov	r17, r24
    20f2:	88 23       	and	r24, r24
    20f4:	a9 f5       	brne	.+106    	; 0x2160 <__stack+0x61>
    20f6:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    20f8:	d1 04       	cpc	r13, r1
    20fa:	39 f0       	breq	.+14     	; 0x210a <__stack+0xb>
    20fc:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    20fe:	20 81       	ld	r18, Z
    2100:	31 81       	ldd	r19, Z+1	; 0x01
    2102:	e2 1a       	sub	r14, r18
    2104:	f3 0a       	sbc	r15, r19
    2106:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2108:	d3 1f       	adc	r29, r19
    210a:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    210c:	bb 24       	eor	r11, r11
    210e:	23 c0       	rjmp	.+70     	; 0x2156 <__stack+0x57>
    2110:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2114:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2116:	16 c0       	rjmp	.+44     	; 0x2144 <__stack+0x45>
    2118:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    211c:	8b 77       	andi	r24, 0x7B	; 123
    211e:	80 93 e8 00 	sts	0x00E8, r24
    2122:	48 d4       	rcall	.+2192   	; 0x29b4 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2124:	c1 14       	cp	r12, r1
    2126:	d1 04       	cpc	r13, r1
			#endif

			if (BytesProcessed != NULL)
    2128:	49 f0       	breq	.+18     	; 0x213c <__stack+0x3d>
    212a:	f6 01       	movw	r30, r12
    212c:	80 81       	ld	r24, Z
			{
				*BytesProcessed += BytesInTransfer;
    212e:	91 81       	ldd	r25, Z+1	; 0x01
    2130:	8a 0d       	add	r24, r10
    2132:	9b 1d       	adc	r25, r11
    2134:	91 83       	std	Z+1, r25	; 0x01
    2136:	80 83       	st	Z, r24
    2138:	15 e0       	ldi	r17, 0x05	; 5
    213a:	12 c0       	rjmp	.+36     	; 0x2160 <__stack+0x61>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    213c:	74 d1       	rcall	.+744    	; 0x2426 <Endpoint_WaitUntilReady>
    213e:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2140:	51 f0       	breq	.+20     	; 0x2156 <__stack+0x57>
    2142:	0d c0       	rjmp	.+26     	; 0x215e <__stack+0x5f>
    2144:	80 91 f1 00 	lds	r24, 0x00F1
    2148:	89 93       	st	Y+, r24
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    214a:	08 94       	sec
    214c:	e1 08       	sbc	r14, r1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    214e:	f1 08       	sbc	r15, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2150:	08 94       	sec
    2152:	a1 1c       	adc	r10, r1
    2154:	b1 1c       	adc	r11, r1
			BytesInTransfer++;
    2156:	e1 14       	cp	r14, r1
    2158:	f1 04       	cpc	r15, r1
    215a:	d1 f6       	brne	.-76     	; 0x2110 <__stack+0x11>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    215c:	01 c0       	rjmp	.+2      	; 0x2160 <__stack+0x61>
    215e:	18 2f       	mov	r17, r24
    2160:	81 2f       	mov	r24, r17
    2162:	df 91       	pop	r29
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2164:	cf 91       	pop	r28
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2166:	1f 91       	pop	r17
    2168:	ff 90       	pop	r15
    216a:	ef 90       	pop	r14
    216c:	df 90       	pop	r13
    216e:	cf 90       	pop	r12
    2170:	bf 90       	pop	r11
    2172:	af 90       	pop	r10
    2174:	08 95       	ret

00002176 <Endpoint_Write_Control_Stream_LE>:
    2176:	20 91 df 13 	lds	r18, 0x13DF
    217a:	30 91 e0 13 	lds	r19, 0x13E0
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    217e:	26 17       	cp	r18, r22
    2180:	37 07       	cpc	r19, r23
    2182:	20 f4       	brcc	.+8      	; 0x218c <Endpoint_Write_Control_Stream_LE+0x16>
    2184:	b9 01       	movw	r22, r18
    2186:	fc 01       	movw	r30, r24
    2188:	20 e0       	ldi	r18, 0x00	; 0
    218a:	37 c0       	rjmp	.+110    	; 0x21fa <Endpoint_Write_Control_Stream_LE+0x84>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    218c:	61 15       	cp	r22, r1
    218e:	71 05       	cpc	r23, r1
    2190:	d1 f7       	brne	.-12     	; 0x2186 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2192:	20 91 e8 00 	lds	r18, 0x00E8
    2196:	2e 77       	andi	r18, 0x7E	; 126
    2198:	20 93 e8 00 	sts	0x00E8, r18
    219c:	f4 cf       	rjmp	.-24     	; 0x2186 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    219e:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    21a2:	88 23       	and	r24, r24
    21a4:	09 f4       	brne	.+2      	; 0x21a8 <Endpoint_Write_Control_Stream_LE+0x32>
    21a6:	3f c0       	rjmp	.+126    	; 0x2226 <Endpoint_Write_Control_Stream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    21a8:	85 30       	cpi	r24, 0x05	; 5
    21aa:	c9 f1       	breq	.+114    	; 0x221e <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    21ac:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    21b0:	83 fd       	sbrc	r24, 3
    21b2:	37 c0       	rjmp	.+110    	; 0x2222 <Endpoint_Write_Control_Stream_LE+0xac>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    21b4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    21b8:	82 fd       	sbrc	r24, 2
    21ba:	2b c0       	rjmp	.+86     	; 0x2212 <Endpoint_Write_Control_Stream_LE+0x9c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    21bc:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    21c0:	80 ff       	sbrs	r24, 0
    21c2:	1b c0       	rjmp	.+54     	; 0x21fa <Endpoint_Write_Control_Stream_LE+0x84>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    21c4:	80 91 f2 00 	lds	r24, 0x00F2
    21c8:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    21cc:	06 c0       	rjmp	.+12     	; 0x21da <Endpoint_Write_Control_Stream_LE+0x64>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    21ce:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    21d0:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    21d4:	61 50       	subi	r22, 0x01	; 1
    21d6:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    21d8:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    21da:	61 15       	cp	r22, r1
    21dc:	71 05       	cpc	r23, r1
    21de:	19 f0       	breq	.+6      	; 0x21e6 <Endpoint_Write_Control_Stream_LE+0x70>
    21e0:	88 30       	cpi	r24, 0x08	; 8
    21e2:	91 05       	cpc	r25, r1
    21e4:	a0 f3       	brcs	.-24     	; 0x21ce <Endpoint_Write_Control_Stream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    21e6:	21 e0       	ldi	r18, 0x01	; 1
    21e8:	88 30       	cpi	r24, 0x08	; 8
    21ea:	91 05       	cpc	r25, r1
    21ec:	09 f0       	breq	.+2      	; 0x21f0 <Endpoint_Write_Control_Stream_LE+0x7a>
    21ee:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    21f0:	80 91 e8 00 	lds	r24, 0x00E8
    21f4:	8e 77       	andi	r24, 0x7E	; 126
    21f6:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    21fa:	61 15       	cp	r22, r1
    21fc:	71 05       	cpc	r23, r1
    21fe:	79 f6       	brne	.-98     	; 0x219e <Endpoint_Write_Control_Stream_LE+0x28>
    2200:	22 23       	and	r18, r18
    2202:	69 f6       	brne	.-102    	; 0x219e <Endpoint_Write_Control_Stream_LE+0x28>
    2204:	06 c0       	rjmp	.+12     	; 0x2212 <Endpoint_Write_Control_Stream_LE+0x9c>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2206:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    220a:	88 23       	and	r24, r24
    220c:	61 f0       	breq	.+24     	; 0x2226 <Endpoint_Write_Control_Stream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    220e:	85 30       	cpi	r24, 0x05	; 5
    2210:	61 f0       	breq	.+24     	; 0x222a <Endpoint_Write_Control_Stream_LE+0xb4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2212:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2216:	82 ff       	sbrs	r24, 2
    2218:	f6 cf       	rjmp	.-20     	; 0x2206 <Endpoint_Write_Control_Stream_LE+0x90>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    221a:	80 e0       	ldi	r24, 0x00	; 0
    221c:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    221e:	83 e0       	ldi	r24, 0x03	; 3
    2220:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2222:	81 e0       	ldi	r24, 0x01	; 1
    2224:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2226:	82 e0       	ldi	r24, 0x02	; 2
    2228:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    222a:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    222c:	08 95       	ret

0000222e <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    222e:	61 15       	cp	r22, r1
    2230:	71 05       	cpc	r23, r1
    2232:	29 f4       	brne	.+10     	; 0x223e <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2234:	20 91 e8 00 	lds	r18, 0x00E8
    2238:	2b 77       	andi	r18, 0x7B	; 123
    223a:	20 93 e8 00 	sts	0x00E8, r18

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    223e:	38 2f       	mov	r19, r24
    2240:	29 2f       	mov	r18, r25
    2242:	26 c0       	rjmp	.+76     	; 0x2290 <Endpoint_Read_Control_Stream_LE+0x62>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2244:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2248:	88 23       	and	r24, r24
    224a:	b1 f1       	breq	.+108    	; 0x22b8 <Endpoint_Read_Control_Stream_LE+0x8a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    224c:	85 30       	cpi	r24, 0x05	; 5
    224e:	81 f1       	breq	.+96     	; 0x22b0 <Endpoint_Read_Control_Stream_LE+0x82>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2250:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2254:	83 fd       	sbrc	r24, 3
    2256:	2e c0       	rjmp	.+92     	; 0x22b4 <Endpoint_Read_Control_Stream_LE+0x86>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2258:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    225c:	82 ff       	sbrs	r24, 2
    225e:	f2 cf       	rjmp	.-28     	; 0x2244 <Endpoint_Read_Control_Stream_LE+0x16>
    2260:	e3 2f       	mov	r30, r19
    2262:	f2 2f       	mov	r31, r18
    2264:	08 c0       	rjmp	.+16     	; 0x2276 <Endpoint_Read_Control_Stream_LE+0x48>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2266:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    226a:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    226c:	3e 2f       	mov	r19, r30
    226e:	2f 2f       	mov	r18, r31
				Length--;
    2270:	61 50       	subi	r22, 0x01	; 1
    2272:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2274:	41 f0       	breq	.+16     	; 0x2286 <Endpoint_Read_Control_Stream_LE+0x58>
    2276:	3e 2f       	mov	r19, r30
    2278:	2f 2f       	mov	r18, r31
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    227a:	80 91 f2 00 	lds	r24, 0x00F2
    227e:	90 91 f3 00 	lds	r25, 0x00F3
    2282:	00 97       	sbiw	r24, 0x00	; 0
    2284:	81 f7       	brne	.-32     	; 0x2266 <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2286:	80 91 e8 00 	lds	r24, 0x00E8
    228a:	8b 77       	andi	r24, 0x7B	; 123
    228c:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    2290:	61 15       	cp	r22, r1
    2292:	71 05       	cpc	r23, r1
    2294:	b9 f6       	brne	.-82     	; 0x2244 <Endpoint_Read_Control_Stream_LE+0x16>
    2296:	06 c0       	rjmp	.+12     	; 0x22a4 <Endpoint_Read_Control_Stream_LE+0x76>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2298:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    229c:	88 23       	and	r24, r24
    229e:	61 f0       	breq	.+24     	; 0x22b8 <Endpoint_Read_Control_Stream_LE+0x8a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    22a0:	85 30       	cpi	r24, 0x05	; 5
    22a2:	61 f0       	breq	.+24     	; 0x22bc <Endpoint_Read_Control_Stream_LE+0x8e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    22a4:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    22a8:	80 ff       	sbrs	r24, 0
    22aa:	f6 cf       	rjmp	.-20     	; 0x2298 <Endpoint_Read_Control_Stream_LE+0x6a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    22ac:	80 e0       	ldi	r24, 0x00	; 0
    22ae:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    22b0:	83 e0       	ldi	r24, 0x03	; 3
    22b2:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    22b8:	82 e0       	ldi	r24, 0x02	; 2
    22ba:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    22bc:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    22be:	08 95       	ret

000022c0 <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    22c0:	20 91 df 13 	lds	r18, 0x13DF
    22c4:	30 91 e0 13 	lds	r19, 0x13E0
    22c8:	26 17       	cp	r18, r22
    22ca:	37 07       	cpc	r19, r23
    22cc:	20 f4       	brcc	.+8      	; 0x22d6 <Endpoint_Write_Control_PStream_LE+0x16>
    22ce:	b9 01       	movw	r22, r18
    22d0:	fc 01       	movw	r30, r24
    22d2:	20 e0       	ldi	r18, 0x00	; 0
    22d4:	38 c0       	rjmp	.+112    	; 0x2346 <Endpoint_Write_Control_PStream_LE+0x86>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    22d6:	61 15       	cp	r22, r1
    22d8:	71 05       	cpc	r23, r1
    22da:	d1 f7       	brne	.-12     	; 0x22d0 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    22dc:	20 91 e8 00 	lds	r18, 0x00E8
    22e0:	2e 77       	andi	r18, 0x7E	; 126
    22e2:	20 93 e8 00 	sts	0x00E8, r18
    22e6:	f4 cf       	rjmp	.-24     	; 0x22d0 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    22e8:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    22ec:	88 23       	and	r24, r24
    22ee:	09 f4       	brne	.+2      	; 0x22f2 <Endpoint_Write_Control_PStream_LE+0x32>
    22f0:	40 c0       	rjmp	.+128    	; 0x2372 <Endpoint_Write_Control_PStream_LE+0xb2>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    22f2:	85 30       	cpi	r24, 0x05	; 5
    22f4:	d1 f1       	breq	.+116    	; 0x236a <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    22f6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    22fa:	83 fd       	sbrc	r24, 3
    22fc:	38 c0       	rjmp	.+112    	; 0x236e <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    22fe:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2302:	82 fd       	sbrc	r24, 2
    2304:	2c c0       	rjmp	.+88     	; 0x235e <Endpoint_Write_Control_PStream_LE+0x9e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2306:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    230a:	80 ff       	sbrs	r24, 0
    230c:	1c c0       	rjmp	.+56     	; 0x2346 <Endpoint_Write_Control_PStream_LE+0x86>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    230e:	80 91 f2 00 	lds	r24, 0x00F2
    2312:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    2316:	07 c0       	rjmp	.+14     	; 0x2326 <Endpoint_Write_Control_PStream_LE+0x66>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2318:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    231a:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    231e:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    2320:	61 50       	subi	r22, 0x01	; 1
    2322:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    2324:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    2326:	61 15       	cp	r22, r1
    2328:	71 05       	cpc	r23, r1
    232a:	19 f0       	breq	.+6      	; 0x2332 <Endpoint_Write_Control_PStream_LE+0x72>
    232c:	88 30       	cpi	r24, 0x08	; 8
    232e:	91 05       	cpc	r25, r1
    2330:	98 f3       	brcs	.-26     	; 0x2318 <Endpoint_Write_Control_PStream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2332:	21 e0       	ldi	r18, 0x01	; 1
    2334:	88 30       	cpi	r24, 0x08	; 8
    2336:	91 05       	cpc	r25, r1
    2338:	09 f0       	breq	.+2      	; 0x233c <Endpoint_Write_Control_PStream_LE+0x7c>
    233a:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    233c:	80 91 e8 00 	lds	r24, 0x00E8
    2340:	8e 77       	andi	r24, 0x7E	; 126
    2342:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2346:	61 15       	cp	r22, r1
    2348:	71 05       	cpc	r23, r1
    234a:	71 f6       	brne	.-100    	; 0x22e8 <Endpoint_Write_Control_PStream_LE+0x28>
    234c:	22 23       	and	r18, r18
    234e:	61 f6       	brne	.-104    	; 0x22e8 <Endpoint_Write_Control_PStream_LE+0x28>
    2350:	06 c0       	rjmp	.+12     	; 0x235e <Endpoint_Write_Control_PStream_LE+0x9e>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2352:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2356:	88 23       	and	r24, r24
    2358:	61 f0       	breq	.+24     	; 0x2372 <Endpoint_Write_Control_PStream_LE+0xb2>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    235a:	85 30       	cpi	r24, 0x05	; 5
    235c:	61 f0       	breq	.+24     	; 0x2376 <Endpoint_Write_Control_PStream_LE+0xb6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    235e:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2362:	82 ff       	sbrs	r24, 2
    2364:	f6 cf       	rjmp	.-20     	; 0x2352 <Endpoint_Write_Control_PStream_LE+0x92>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    2366:	80 e0       	ldi	r24, 0x00	; 0
    2368:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    236a:	83 e0       	ldi	r24, 0x03	; 3
    236c:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2372:	82 e0       	ldi	r24, 0x02	; 2
    2374:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2376:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2378:	08 95       	ret

0000237a <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    237a:	98 2f       	mov	r25, r24
    237c:	2a c0       	rjmp	.+84     	; 0x23d2 <Endpoint_ConfigureEndpoint_Prv+0x58>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    237e:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    2382:	98 17       	cp	r25, r24
    2384:	39 f0       	breq	.+14     	; 0x2394 <Endpoint_ConfigureEndpoint_Prv+0x1a>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    2386:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    238a:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    238e:	50 91 f0 00 	lds	r21, 0x00F0
    2392:	03 c0       	rjmp	.+6      	; 0x239a <Endpoint_ConfigureEndpoint_Prv+0x20>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    2394:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    2396:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    2398:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    239a:	21 ff       	sbrs	r18, 1
    239c:	19 c0       	rjmp	.+50     	; 0x23d0 <Endpoint_ConfigureEndpoint_Prv+0x56>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    239e:	30 91 eb 00 	lds	r19, 0x00EB
    23a2:	3e 7f       	andi	r19, 0xFE	; 254
    23a4:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    23a8:	30 91 ed 00 	lds	r19, 0x00ED
    23ac:	3d 7f       	andi	r19, 0xFD	; 253
    23ae:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    23b2:	30 91 eb 00 	lds	r19, 0x00EB
    23b6:	31 60       	ori	r19, 0x01	; 1
    23b8:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    23bc:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    23c0:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    23c4:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    23c8:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    23cc:	27 ff       	sbrs	r18, 7
    23ce:	08 c0       	rjmp	.+16     	; 0x23e0 <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    23d0:	9f 5f       	subi	r25, 0xFF	; 255
    23d2:	97 30       	cpi	r25, 0x07	; 7
    23d4:	a0 f2       	brcs	.-88     	; 0x237e <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    23d6:	8f 70       	andi	r24, 0x0F	; 15
    23d8:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    23dc:	81 e0       	ldi	r24, 0x01	; 1
    23de:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    23e0:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    23e2:	08 95       	ret

000023e4 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    23e4:	80 91 d9 13 	lds	r24, 0x13D9
    23e8:	87 ff       	sbrs	r24, 7
    23ea:	13 c0       	rjmp	.+38     	; 0x2412 <Endpoint_ClearStatusStage+0x2e>
    23ec:	04 c0       	rjmp	.+8      	; 0x23f6 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    23ee:	80 91 d8 13 	lds	r24, 0x13D8
    23f2:	88 23       	and	r24, r24
    23f4:	b9 f0       	breq	.+46     	; 0x2424 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    23f6:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    23fa:	82 ff       	sbrs	r24, 2
    23fc:	f8 cf       	rjmp	.-16     	; 0x23ee <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    23fe:	80 91 e8 00 	lds	r24, 0x00E8
    2402:	8b 77       	andi	r24, 0x7B	; 123
    2404:	80 93 e8 00 	sts	0x00E8, r24
    2408:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    240a:	80 91 d8 13 	lds	r24, 0x13D8
    240e:	88 23       	and	r24, r24
    2410:	49 f0       	breq	.+18     	; 0x2424 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2412:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    2416:	80 ff       	sbrs	r24, 0
    2418:	f8 cf       	rjmp	.-16     	; 0x240a <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    241a:	80 91 e8 00 	lds	r24, 0x00E8
    241e:	8e 77       	andi	r24, 0x7E	; 126
    2420:	80 93 e8 00 	sts	0x00E8, r24
    2424:	08 95       	ret

00002426 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    2426:	80 91 e4 00 	lds	r24, 0x00E4
    242a:	90 91 e5 00 	lds	r25, 0x00E5
    242e:	45 e6       	ldi	r20, 0x65	; 101
    2430:	01 c0       	rjmp	.+2      	; 0x2434 <Endpoint_WaitUntilReady+0xe>
    2432:	c9 01       	movw	r24, r18
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    2434:	20 91 ec 00 	lds	r18, 0x00EC
    2438:	20 ff       	sbrs	r18, 0
    243a:	23 c0       	rjmp	.+70     	; 0x2482 <Endpoint_WaitUntilReady+0x5c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    243c:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    2440:	20 fd       	sbrc	r18, 0
    2442:	15 c0       	rjmp	.+42     	; 0x246e <Endpoint_WaitUntilReady+0x48>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2444:	20 91 d8 13 	lds	r18, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2448:	22 23       	and	r18, r18
    244a:	99 f0       	breq	.+38     	; 0x2472 <Endpoint_WaitUntilReady+0x4c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    244c:	25 30       	cpi	r18, 0x05	; 5
    244e:	99 f0       	breq	.+38     	; 0x2476 <Endpoint_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2450:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    2454:	25 fd       	sbrc	r18, 5
    2456:	11 c0       	rjmp	.+34     	; 0x247a <Endpoint_WaitUntilReady+0x54>
    2458:	20 91 e4 00 	lds	r18, 0x00E4
    245c:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    2460:	28 17       	cp	r18, r24
    2462:	39 07       	cpc	r19, r25
    2464:	39 f3       	breq	.-50     	; 0x2434 <Endpoint_WaitUntilReady+0xe>
    2466:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    2468:	21 f7       	brne	.-56     	; 0x2432 <Endpoint_WaitUntilReady+0xc>
			  return ENDPOINT_READYWAIT_Timeout;
    246a:	84 e0       	ldi	r24, 0x04	; 4
    246c:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    246e:	80 e0       	ldi	r24, 0x00	; 0
    2470:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    2472:	82 e0       	ldi	r24, 0x02	; 2
    2474:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    2476:	83 e0       	ldi	r24, 0x03	; 3
    2478:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    247a:	81 e0       	ldi	r24, 0x01	; 1
    247c:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    247e:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    2480:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2482:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    2486:	22 ff       	sbrs	r18, 2
    2488:	dd cf       	rjmp	.-70     	; 0x2444 <Endpoint_WaitUntilReady+0x1e>
    248a:	f9 cf       	rjmp	.-14     	; 0x247e <Endpoint_WaitUntilReady+0x58>

0000248c <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    248c:	0f 93       	push	r16
    248e:	1f 93       	push	r17
    2490:	cf 93       	push	r28
    2492:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    2494:	4e d0       	rcall	.+156    	; 0x2532 <USB_INT_DisableAllInterrupts>
    2496:	55 d0       	rcall	.+170    	; 0x2542 <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2498:	c8 ed       	ldi	r28, 0xD8	; 216
    249a:	d0 e0       	ldi	r29, 0x00	; 0
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    249c:	88 81       	ld	r24, Y
    249e:	8f 77       	andi	r24, 0x7F	; 127
    24a0:	88 83       	st	Y, r24
    24a2:	88 81       	ld	r24, Y
    24a4:	80 68       	ori	r24, 0x80	; 128
				USBCON |=  (1 << USBE);
    24a6:	88 83       	st	Y, r24
    24a8:	88 81       	ld	r24, Y
    24aa:	8f 7d       	andi	r24, 0xDF	; 223
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    24ac:	88 83       	st	Y, r24
    24ae:	e7 ed       	ldi	r30, 0xD7	; 215
    24b0:	f0 e0       	ldi	r31, 0x00	; 0

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    24b2:	80 81       	ld	r24, Z
    24b4:	80 68       	ori	r24, 0x80	; 128
    24b6:	80 83       	st	Z, r24
    24b8:	19 bc       	out	0x29, r1	; 41
    24ba:	10 92 d8 13 	sts	0x13D8, r1
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    24be:	10 92 d4 13 	sts	0x13D4, r1
	USB_Device_ConfigurationNumber  = 0;
    24c2:	10 92 d6 13 	sts	0x13D6, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    24c6:	10 92 d5 13 	sts	0x13D5, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    24ca:	00 ee       	ldi	r16, 0xE0	; 224
    24cc:	10 e0       	ldi	r17, 0x00	; 0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    24ce:	f8 01       	movw	r30, r16
    24d0:	80 81       	ld	r24, Z
    24d2:	8b 7f       	andi	r24, 0xFB	; 251
    24d4:	80 83       	st	Z, r24
    24d6:	88 81       	ld	r24, Y
    24d8:	81 60       	ori	r24, 0x01	; 1
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    24da:	88 83       	st	Y, r24
    24dc:	80 e0       	ldi	r24, 0x00	; 0
    24de:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    24e0:	42 e0       	ldi	r20, 0x02	; 2
    24e2:	4b df       	rcall	.-362    	; 0x237a <Endpoint_ConfigureEndpoint_Prv>
    24e4:	e1 ee       	ldi	r30, 0xE1	; 225
    24e6:	f0 e0       	ldi	r31, 0x00	; 0
    24e8:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    24ea:	8e 7f       	andi	r24, 0xFE	; 254
    24ec:	80 83       	st	Z, r24
    24ee:	e2 ee       	ldi	r30, 0xE2	; 226
    24f0:	f0 e0       	ldi	r31, 0x00	; 0
    24f2:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    24f4:	81 60       	ori	r24, 0x01	; 1
    24f6:	80 83       	st	Z, r24
    24f8:	80 81       	ld	r24, Z
    24fa:	88 60       	ori	r24, 0x08	; 8
    24fc:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    24fe:	f8 01       	movw	r30, r16
    2500:	80 81       	ld	r24, Z
    2502:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    2504:	80 83       	st	Z, r24
    2506:	88 81       	ld	r24, Y
    2508:	80 61       	ori	r24, 0x10	; 16
    250a:	88 83       	st	Y, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    250c:	df 91       	pop	r29
    250e:	cf 91       	pop	r28
    2510:	1f 91       	pop	r17
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    2512:	0f 91       	pop	r16
    2514:	08 95       	ret

00002516 <USB_Init>:
    2516:	e8 ed       	ldi	r30, 0xD8	; 216
    2518:	f0 e0       	ldi	r31, 0x00	; 0
    251a:	80 81       	ld	r24, Z
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    251c:	8f 7e       	andi	r24, 0xEF	; 239
    251e:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    2520:	e7 ed       	ldi	r30, 0xD7	; 215
    2522:	f0 e0       	ldi	r31, 0x00	; 0
    2524:	80 81       	ld	r24, Z
    2526:	81 60       	ori	r24, 0x01	; 1
    2528:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	80 93 d7 13 	sts	0x13D7, r24

	USB_ResetInterface();
    2530:	ad cf       	rjmp	.-166    	; 0x248c <USB_ResetInterface>

00002532 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    2532:	e8 ed       	ldi	r30, 0xD8	; 216
    2534:	f0 e0       	ldi	r31, 0x00	; 0
    2536:	80 81       	ld	r24, Z
    2538:	8c 7f       	andi	r24, 0xFC	; 252
    253a:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    253c:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    2540:	08 95       	ret

00002542 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    2542:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    2546:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    254a:	08 95       	ret

0000254c <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    254c:	1f 92       	push	r1
    254e:	0f 92       	push	r0
    2550:	0f b6       	in	r0, 0x3f	; 63
    2552:	0f 92       	push	r0
    2554:	0b b6       	in	r0, 0x3b	; 59
    2556:	0f 92       	push	r0
    2558:	11 24       	eor	r1, r1
    255a:	2f 93       	push	r18
    255c:	3f 93       	push	r19
    255e:	4f 93       	push	r20
    2560:	5f 93       	push	r21
    2562:	6f 93       	push	r22
    2564:	7f 93       	push	r23
    2566:	8f 93       	push	r24
    2568:	9f 93       	push	r25
    256a:	af 93       	push	r26
    256c:	bf 93       	push	r27
    256e:	ef 93       	push	r30
    2570:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    2572:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    2576:	82 ff       	sbrs	r24, 2
    2578:	0a c0       	rjmp	.+20     	; 0x258e <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    257a:	80 91 e2 00 	lds	r24, 0x00E2
    257e:	82 ff       	sbrs	r24, 2
    2580:	06 c0       	rjmp	.+12     	; 0x258e <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    2582:	80 91 e1 00 	lds	r24, 0x00E1
    2586:	8b 7f       	andi	r24, 0xFB	; 251
    2588:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    258c:	12 d2       	rcall	.+1060   	; 0x29b2 <USB_Event_Stub>
    258e:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    2592:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    2594:	1f c0       	rjmp	.+62     	; 0x25d4 <__vector_10+0x88>
    2596:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    259a:	80 ff       	sbrs	r24, 0
    259c:	1b c0       	rjmp	.+54     	; 0x25d4 <__vector_10+0x88>
    259e:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    25a2:	8e 7f       	andi	r24, 0xFE	; 254
    25a4:	80 93 da 00 	sts	0x00DA, r24
    25a8:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    25ac:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    25ae:	0d c0       	rjmp	.+26     	; 0x25ca <__vector_10+0x7e>
    25b0:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    25b2:	89 bd       	out	0x29, r24	; 41
    25b4:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    25b6:	89 bd       	out	0x29, r24	; 41
    25b8:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    25ba:	00 fe       	sbrs	r0, 0
    25bc:	fd cf       	rjmp	.-6      	; 0x25b8 <__vector_10+0x6c>
    25be:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    25c0:	80 93 d8 13 	sts	0x13D8, r24
    25c4:	0e 94 72 02 	call	0x4e4	; 0x4e4 <EVENT_USB_Device_Connect>
			EVENT_USB_Device_Connect();
    25c8:	05 c0       	rjmp	.+10     	; 0x25d4 <__vector_10+0x88>
    25ca:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    25cc:	10 92 d8 13 	sts	0x13D8, r1
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    25d0:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Device_Disconnect>
			EVENT_USB_Device_Disconnect();
    25d4:	80 91 e1 00 	lds	r24, 0x00E1
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    25d8:	80 ff       	sbrs	r24, 0
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    25da:	18 c0       	rjmp	.+48     	; 0x260c <__vector_10+0xc0>
    25dc:	80 91 e2 00 	lds	r24, 0x00E2
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    25e0:	80 ff       	sbrs	r24, 0
    25e2:	14 c0       	rjmp	.+40     	; 0x260c <__vector_10+0xc0>
    25e4:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    25e8:	8e 7f       	andi	r24, 0xFE	; 254
    25ea:	80 93 e2 00 	sts	0x00E2, r24
    25ee:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    25f2:	80 61       	ori	r24, 0x10	; 16
    25f4:	80 93 e2 00 	sts	0x00E2, r24
    25f8:	80 91 d8 00 	lds	r24, 0x00D8
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    25fc:	80 62       	ori	r24, 0x20	; 32
    25fe:	80 93 d8 00 	sts	0x00D8, r24
    2602:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2604:	85 e0       	ldi	r24, 0x05	; 5

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    2606:	80 93 d8 13 	sts	0x13D8, r24
    260a:	d3 d1       	rcall	.+934    	; 0x29b2 <USB_Event_Stub>
		EVENT_USB_Device_Suspend();
    260c:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    2610:	84 ff       	sbrs	r24, 4
    2612:	2d c0       	rjmp	.+90     	; 0x266e <__vector_10+0x122>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    2614:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    2618:	84 ff       	sbrs	r24, 4
    261a:	29 c0       	rjmp	.+82     	; 0x266e <__vector_10+0x122>
    261c:	8c e0       	ldi	r24, 0x0C	; 12
    261e:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2620:	8e e0       	ldi	r24, 0x0E	; 14
    2622:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2624:	09 b4       	in	r0, 0x29	; 41
    2626:	00 fe       	sbrs	r0, 0
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    2628:	fd cf       	rjmp	.-6      	; 0x2624 <__vector_10+0xd8>
    262a:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    262e:	8f 7d       	andi	r24, 0xDF	; 223
    2630:	80 93 d8 00 	sts	0x00D8, r24
    2634:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    2638:	8f 7e       	andi	r24, 0xEF	; 239
    263a:	80 93 e1 00 	sts	0x00E1, r24
    263e:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    2642:	8f 7e       	andi	r24, 0xEF	; 239
    2644:	80 93 e2 00 	sts	0x00E2, r24
    2648:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    264c:	81 60       	ori	r24, 0x01	; 1
    264e:	80 93 e2 00 	sts	0x00E2, r24
    2652:	80 91 d4 13 	lds	r24, 0x13D4
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    2656:	88 23       	and	r24, r24
    2658:	21 f4       	brne	.+8      	; 0x2662 <__vector_10+0x116>
    265a:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    265e:	87 ff       	sbrs	r24, 7
    2660:	02 c0       	rjmp	.+4      	; 0x2666 <__vector_10+0x11a>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2662:	84 e0       	ldi	r24, 0x04	; 4
    2664:	01 c0       	rjmp	.+2      	; 0x2668 <__vector_10+0x11c>
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	80 93 d8 13 	sts	0x13D8, r24
    266c:	a2 d1       	rcall	.+836    	; 0x29b2 <USB_Event_Stub>
    266e:	80 91 e1 00 	lds	r24, 0x00E1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    2672:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    2674:	22 c0       	rjmp	.+68     	; 0x26ba <__vector_10+0x16e>
    2676:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    267a:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    267c:	1e c0       	rjmp	.+60     	; 0x26ba <__vector_10+0x16e>
    267e:	80 91 e1 00 	lds	r24, 0x00E1
    2682:	87 7f       	andi	r24, 0xF7	; 247
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    2684:	80 93 e1 00 	sts	0x00E1, r24
    2688:	82 e0       	ldi	r24, 0x02	; 2
    268a:	80 93 d8 13 	sts	0x13D8, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    268e:	10 92 d4 13 	sts	0x13D4, r1
    2692:	80 91 e1 00 	lds	r24, 0x00E1
		USB_Device_ConfigurationNumber = 0;
    2696:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2698:	80 93 e1 00 	sts	0x00E1, r24
    269c:	80 91 e2 00 	lds	r24, 0x00E2
    26a0:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    26a2:	80 93 e2 00 	sts	0x00E2, r24
    26a6:	80 91 e2 00 	lds	r24, 0x00E2
    26aa:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    26ac:	80 93 e2 00 	sts	0x00E2, r24
    26b0:	80 e0       	ldi	r24, 0x00	; 0
    26b2:	60 e0       	ldi	r22, 0x00	; 0
    26b4:	42 e0       	ldi	r20, 0x02	; 2
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    26b6:	61 de       	rcall	.-830    	; 0x237a <Endpoint_ConfigureEndpoint_Prv>
    26b8:	7c d1       	rcall	.+760    	; 0x29b2 <USB_Event_Stub>
    26ba:	ff 91       	pop	r31
    26bc:	ef 91       	pop	r30
    26be:	bf 91       	pop	r27

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    26c0:	af 91       	pop	r26
    26c2:	9f 91       	pop	r25
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    26c4:	8f 91       	pop	r24
    26c6:	7f 91       	pop	r23
    26c8:	6f 91       	pop	r22
    26ca:	5f 91       	pop	r21
    26cc:	4f 91       	pop	r20
    26ce:	3f 91       	pop	r19
    26d0:	2f 91       	pop	r18
    26d2:	0f 90       	pop	r0
    26d4:	0b be       	out	0x3b, r0	; 59
    26d6:	0f 90       	pop	r0
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	0f 90       	pop	r0
    26dc:	1f 90       	pop	r1
    26de:	18 95       	reti

000026e0 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	ac 97       	sbiw	r28, 0x2c	; 44
    26ec:	0f b6       	in	r0, 0x3f	; 63
    26ee:	f8 94       	cli
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	0f be       	out	0x3f, r0	; 63
    26f4:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    26f6:	80 e0       	ldi	r24, 0x00	; 0
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    26f8:	e9 ed       	ldi	r30, 0xD9	; 217
    26fa:	f3 e1       	ldi	r31, 0x13	; 19
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    26fc:	90 91 f1 00 	lds	r25, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    2700:	91 93       	st	Z+, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    2702:	8f 5f       	subi	r24, 0xFF	; 255
    2704:	88 30       	cpi	r24, 0x08	; 8
    2706:	d1 f7       	brne	.-12     	; 0x26fc <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    2708:	0e 94 9c 02 	call	0x538	; 0x538 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    270c:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    2710:	83 ff       	sbrs	r24, 3
    2712:	37 c1       	rjmp	.+622    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2714:	80 91 d9 13 	lds	r24, 0x13D9

		switch (USB_ControlRequest.bRequest)
    2718:	20 91 da 13 	lds	r18, 0x13DA
    271c:	25 30       	cpi	r18, 0x05	; 5
    271e:	09 f4       	brne	.+2      	; 0x2722 <USB_Device_ProcessControlRequest+0x42>
    2720:	84 c0       	rjmp	.+264    	; 0x282a <USB_Device_ProcessControlRequest+0x14a>
    2722:	26 30       	cpi	r18, 0x06	; 6
    2724:	40 f4       	brcc	.+16     	; 0x2736 <USB_Device_ProcessControlRequest+0x56>
    2726:	21 30       	cpi	r18, 0x01	; 1
    2728:	a1 f1       	breq	.+104    	; 0x2792 <USB_Device_ProcessControlRequest+0xb2>
    272a:	21 30       	cpi	r18, 0x01	; 1
    272c:	70 f0       	brcs	.+28     	; 0x274a <USB_Device_ProcessControlRequest+0x6a>
    272e:	23 30       	cpi	r18, 0x03	; 3
    2730:	09 f0       	breq	.+2      	; 0x2734 <USB_Device_ProcessControlRequest+0x54>
    2732:	27 c1       	rjmp	.+590    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2734:	2e c0       	rjmp	.+92     	; 0x2792 <USB_Device_ProcessControlRequest+0xb2>
    2736:	28 30       	cpi	r18, 0x08	; 8
    2738:	09 f4       	brne	.+2      	; 0x273c <USB_Device_ProcessControlRequest+0x5c>
    273a:	f4 c0       	rjmp	.+488    	; 0x2924 <USB_Device_ProcessControlRequest+0x244>
    273c:	29 30       	cpi	r18, 0x09	; 9
    273e:	09 f4       	brne	.+2      	; 0x2742 <USB_Device_ProcessControlRequest+0x62>
    2740:	03 c1       	rjmp	.+518    	; 0x2948 <USB_Device_ProcessControlRequest+0x268>
    2742:	26 30       	cpi	r18, 0x06	; 6
    2744:	09 f0       	breq	.+2      	; 0x2748 <USB_Device_ProcessControlRequest+0x68>
    2746:	1d c1       	rjmp	.+570    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2748:	93 c0       	rjmp	.+294    	; 0x2870 <USB_Device_ProcessControlRequest+0x190>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    274a:	80 38       	cpi	r24, 0x80	; 128
    274c:	21 f0       	breq	.+8      	; 0x2756 <USB_Device_ProcessControlRequest+0x76>
    274e:	82 38       	cpi	r24, 0x82	; 130
    2750:	09 f0       	breq	.+2      	; 0x2754 <USB_Device_ProcessControlRequest+0x74>
    2752:	17 c1       	rjmp	.+558    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2754:	08 c0       	rjmp	.+16     	; 0x2766 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    2756:	80 91 d5 13 	lds	r24, 0x13D5
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    275a:	90 91 d6 13 	lds	r25, 0x13D6
    275e:	99 23       	and	r25, r25
    2760:	71 f0       	breq	.+28     	; 0x277e <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2762:	82 60       	ori	r24, 0x02	; 2
    2764:	0c c0       	rjmp	.+24     	; 0x277e <USB_Device_ProcessControlRequest+0x9e>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2766:	80 91 dd 13 	lds	r24, 0x13DD
    276a:	8f 70       	andi	r24, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    276c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2770:	90 91 eb 00 	lds	r25, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2774:	81 e0       	ldi	r24, 0x01	; 1
    2776:	95 ff       	sbrs	r25, 5
    2778:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    277a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    277e:	90 91 e8 00 	lds	r25, 0x00E8
    2782:	97 7f       	andi	r25, 0xF7	; 247
    2784:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2788:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    278c:	10 92 f1 00 	sts	0x00F1, r1
    2790:	d4 c0       	rjmp	.+424    	; 0x293a <USB_Device_ProcessControlRequest+0x25a>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2792:	88 23       	and	r24, r24
    2794:	19 f0       	breq	.+6      	; 0x279c <USB_Device_ProcessControlRequest+0xbc>
    2796:	82 30       	cpi	r24, 0x02	; 2
    2798:	09 f0       	breq	.+2      	; 0x279c <USB_Device_ProcessControlRequest+0xbc>
    279a:	f3 c0       	rjmp	.+486    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	8f 71       	andi	r24, 0x1F	; 31
    27a0:	90 70       	andi	r25, 0x00	; 0
    27a2:	00 97       	sbiw	r24, 0x00	; 0
    27a4:	29 f0       	breq	.+10     	; 0x27b0 <USB_Device_ProcessControlRequest+0xd0>
    27a6:	82 30       	cpi	r24, 0x02	; 2
    27a8:	91 05       	cpc	r25, r1
    27aa:	09 f0       	breq	.+2      	; 0x27ae <USB_Device_ProcessControlRequest+0xce>
    27ac:	ea c0       	rjmp	.+468    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    27ae:	0b c0       	rjmp	.+22     	; 0x27c6 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    27b0:	80 91 db 13 	lds	r24, 0x13DB
    27b4:	81 30       	cpi	r24, 0x01	; 1
    27b6:	09 f0       	breq	.+2      	; 0x27ba <USB_Device_ProcessControlRequest+0xda>
    27b8:	e4 c0       	rjmp	.+456    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    27ba:	23 30       	cpi	r18, 0x03	; 3
    27bc:	09 f0       	breq	.+2      	; 0x27c0 <USB_Device_ProcessControlRequest+0xe0>
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	80 93 d6 13 	sts	0x13D6, r24
    27c4:	2c c0       	rjmp	.+88     	; 0x281e <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    27c6:	80 91 db 13 	lds	r24, 0x13DB
    27ca:	88 23       	and	r24, r24
    27cc:	41 f5       	brne	.+80     	; 0x281e <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    27ce:	20 91 dd 13 	lds	r18, 0x13DD
    27d2:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    27d4:	09 f4       	brne	.+2      	; 0x27d8 <USB_Device_ProcessControlRequest+0xf8>
    27d6:	d5 c0       	rjmp	.+426    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    27d8:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    27dc:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    27e0:	80 ff       	sbrs	r24, 0
    27e2:	1d c0       	rjmp	.+58     	; 0x281e <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    27e4:	80 91 da 13 	lds	r24, 0x13DA
    27e8:	83 30       	cpi	r24, 0x03	; 3
    27ea:	21 f4       	brne	.+8      	; 0x27f4 <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    27ec:	80 91 eb 00 	lds	r24, 0x00EB
    27f0:	80 62       	ori	r24, 0x20	; 32
    27f2:	13 c0       	rjmp	.+38     	; 0x281a <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    27f4:	80 91 eb 00 	lds	r24, 0x00EB
    27f8:	80 61       	ori	r24, 0x10	; 16
    27fa:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    27fe:	81 e0       	ldi	r24, 0x01	; 1
    2800:	90 e0       	ldi	r25, 0x00	; 0
    2802:	02 c0       	rjmp	.+4      	; 0x2808 <USB_Device_ProcessControlRequest+0x128>
    2804:	88 0f       	add	r24, r24
    2806:	99 1f       	adc	r25, r25
    2808:	2a 95       	dec	r18
    280a:	e2 f7       	brpl	.-8      	; 0x2804 <USB_Device_ProcessControlRequest+0x124>
    280c:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    2810:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2814:	80 91 eb 00 	lds	r24, 0x00EB
    2818:	88 60       	ori	r24, 0x08	; 8
    281a:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    281e:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2822:	80 91 e8 00 	lds	r24, 0x00E8
    2826:	87 7f       	andi	r24, 0xF7	; 247
    2828:	8b c0       	rjmp	.+278    	; 0x2940 <USB_Device_ProcessControlRequest+0x260>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    282a:	88 23       	and	r24, r24
    282c:	09 f0       	breq	.+2      	; 0x2830 <USB_Device_ProcessControlRequest+0x150>
    282e:	a9 c0       	rjmp	.+338    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2830:	10 91 db 13 	lds	r17, 0x13DB
    2834:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2836:	80 91 e3 00 	lds	r24, 0x00E3
    283a:	80 78       	andi	r24, 0x80	; 128
    283c:	81 2b       	or	r24, r17
    283e:	80 93 e3 00 	sts	0x00E3, r24
    2842:	80 91 e8 00 	lds	r24, 0x00E8
    2846:	87 7f       	andi	r24, 0xF7	; 247
    2848:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    284c:	cb dd       	rcall	.-1130   	; 0x23e4 <Endpoint_ClearStatusStage>
    284e:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2852:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    2854:	fc cf       	rjmp	.-8      	; 0x284e <USB_Device_ProcessControlRequest+0x16e>
    2856:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;
				
				UDADDR |= (1 << ADDEN);
    285a:	80 68       	ori	r24, 0x80	; 128
    285c:	80 93 e3 00 	sts	0x00E3, r24
    2860:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2862:	11 f0       	breq	.+4      	; 0x2868 <USB_Device_ProcessControlRequest+0x188>
    2864:	83 e0       	ldi	r24, 0x03	; 3
    2866:	01 c0       	rjmp	.+2      	; 0x286a <USB_Device_ProcessControlRequest+0x18a>
    2868:	82 e0       	ldi	r24, 0x02	; 2
    286a:	80 93 d8 13 	sts	0x13D8, r24
    286e:	89 c0       	rjmp	.+274    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2870:	80 58       	subi	r24, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2872:	82 30       	cpi	r24, 0x02	; 2
    2874:	08 f0       	brcs	.+2      	; 0x2878 <USB_Device_ProcessControlRequest+0x198>
    2876:	85 c0       	rjmp	.+266    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2878:	80 91 db 13 	lds	r24, 0x13DB
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    287c:	90 91 dc 13 	lds	r25, 0x13DC
    2880:	23 e0       	ldi	r18, 0x03	; 3
    2882:	8c 3d       	cpi	r24, 0xDC	; 220
    2884:	92 07       	cpc	r25, r18
    2886:	a9 f5       	brne	.+106    	; 0x28f2 <USB_Device_ProcessControlRequest+0x212>
    2888:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    288a:	8c 83       	std	Y+4, r24	; 0x04
    288c:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    288e:	8b 83       	std	Y+3, r24	; 0x03
    2890:	5f b7       	in	r21, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2892:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2894:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    2896:	13 96       	adiw	r26, 0x03	; 3
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	90 e0       	ldi	r25, 0x00	; 0
    289c:	4e e0       	ldi	r20, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    289e:	61 e2       	ldi	r22, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    28a0:	e4 2f       	mov	r30, r20
    28a2:	f0 e0       	ldi	r31, 0x00	; 0
    28a4:	60 93 57 00 	sts	0x0057, r22
    28a8:	e4 91       	lpm	r30, Z
    28aa:	80 ff       	sbrs	r24, 0

					if (SerialCharNum & 0x01)
    28ac:	03 c0       	rjmp	.+6      	; 0x28b4 <USB_Device_ProcessControlRequest+0x1d4>
    28ae:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    28b0:	ef 70       	andi	r30, 0x0F	; 15
    28b2:	4f 5f       	subi	r20, 0xFF	; 255
						SigReadAddress++;
    28b4:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    28b6:	2e 2f       	mov	r18, r30
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    28bc:	18 f0       	brcs	.+6      	; 0x28c4 <USB_Device_ProcessControlRequest+0x1e4>
    28be:	29 5c       	subi	r18, 0xC9	; 201
    28c0:	3f 4f       	sbci	r19, 0xFF	; 255
    28c2:	02 c0       	rjmp	.+4      	; 0x28c8 <USB_Device_ProcessControlRequest+0x1e8>
    28c4:	20 5d       	subi	r18, 0xD0	; 208
    28c6:	3f 4f       	sbci	r19, 0xFF	; 255
    28c8:	13 96       	adiw	r26, 0x03	; 3
    28ca:	3c 93       	st	X, r19
    28cc:	2e 93       	st	-X, r18
    28ce:	12 97       	sbiw	r26, 0x02	; 2
    28d0:	01 96       	adiw	r24, 0x01	; 1
    28d2:	12 96       	adiw	r26, 0x02	; 2
    28d4:	84 31       	cpi	r24, 0x14	; 20
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    28d6:	91 05       	cpc	r25, r1
    28d8:	19 f7       	brne	.-58     	; 0x28a0 <USB_Device_ProcessControlRequest+0x1c0>
    28da:	5f bf       	out	0x3f, r21	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    28dc:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    28e0:	87 7f       	andi	r24, 0xF7	; 247
    28e2:	80 93 e8 00 	sts	0x00E8, r24
    28e6:	ce 01       	movw	r24, r28

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    28e8:	03 96       	adiw	r24, 0x03	; 3
    28ea:	6a e2       	ldi	r22, 0x2A	; 42
    28ec:	70 e0       	ldi	r23, 0x00	; 0
    28ee:	43 dc       	rcall	.-1914   	; 0x2176 <Endpoint_Write_Control_Stream_LE>
    28f0:	13 c0       	rjmp	.+38     	; 0x2918 <USB_Device_ProcessControlRequest+0x238>
    28f2:	60 91 dd 13 	lds	r22, 0x13DD
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    28f6:	ae 01       	movw	r20, r28
    28f8:	4f 5f       	subi	r20, 0xFF	; 255
    28fa:	5f 4f       	sbci	r21, 0xFF	; 255
    28fc:	0e 94 db 03 	call	0x7b6	; 0x7b6 <CALLBACK_USB_GetDescriptor>
    2900:	bc 01       	movw	r22, r24
    2902:	00 97       	sbiw	r24, 0x00	; 0
    2904:	09 f4       	brne	.+2      	; 0x2908 <USB_Device_ProcessControlRequest+0x228>
    2906:	3d c0       	rjmp	.+122    	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2908:	80 91 e8 00 	lds	r24, 0x00E8
    290c:	87 7f       	andi	r24, 0xF7	; 247
    290e:	80 93 e8 00 	sts	0x00E8, r24
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	9a 81       	ldd	r25, Y+2	; 0x02
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2916:	d4 dc       	rcall	.-1624   	; 0x22c0 <Endpoint_Write_Control_PStream_LE>
    2918:	80 91 e8 00 	lds	r24, 0x00E8
    291c:	8b 77       	andi	r24, 0x7B	; 123
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    291e:	80 93 e8 00 	sts	0x00E8, r24
    2922:	2f c0       	rjmp	.+94     	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2924:	80 38       	cpi	r24, 0x80	; 128
    2926:	69 f5       	brne	.+90     	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2928:	80 91 e8 00 	lds	r24, 0x00E8
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    292c:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    292e:	80 93 e8 00 	sts	0x00E8, r24
    2932:	80 91 d4 13 	lds	r24, 0x13D4
    2936:	80 93 f1 00 	sts	0x00F1, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    293a:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    293e:	8e 77       	andi	r24, 0x7E	; 126
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2940:	80 93 e8 00 	sts	0x00E8, r24
    2944:	4f dd       	rcall	.-1378   	; 0x23e4 <Endpoint_ClearStatusStage>
    2946:	1d c0       	rjmp	.+58     	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    2948:	88 23       	and	r24, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    294a:	d9 f4       	brne	.+54     	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
    294c:	90 91 db 13 	lds	r25, 0x13DB
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2950:	92 30       	cpi	r25, 0x02	; 2
    2952:	b8 f4       	brcc	.+46     	; 0x2982 <USB_Device_ProcessControlRequest+0x2a2>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2954:	80 91 e8 00 	lds	r24, 0x00E8
    2958:	87 7f       	andi	r24, 0xF7	; 247
    295a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    295e:	90 93 d4 13 	sts	0x13D4, r25
    2962:	40 dd       	rcall	.-1408   	; 0x23e4 <Endpoint_ClearStatusStage>
    2964:	80 91 d4 13 	lds	r24, 0x13D4
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2968:	88 23       	and	r24, r24

	Endpoint_ClearStatusStage();
    296a:	21 f4       	brne	.+8      	; 0x2974 <USB_Device_ProcessControlRequest+0x294>
    296c:	80 91 e3 00 	lds	r24, 0x00E3

	if (USB_Device_ConfigurationNumber)
    2970:	87 ff       	sbrs	r24, 7
    2972:	02 c0       	rjmp	.+4      	; 0x2978 <USB_Device_ProcessControlRequest+0x298>
    2974:	84 e0       	ldi	r24, 0x04	; 4
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2976:	01 c0       	rjmp	.+2      	; 0x297a <USB_Device_ProcessControlRequest+0x29a>
    2978:	81 e0       	ldi	r24, 0x01	; 1
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    297a:	80 93 d8 13 	sts	0x13D8, r24
    297e:	0e 94 76 02 	call	0x4ec	; 0x4ec <EVENT_USB_Device_ConfigurationChanged>
    2982:	80 91 e8 00 	lds	r24, 0x00E8
    2986:	83 ff       	sbrs	r24, 3

	EVENT_USB_Device_ConfigurationChanged();
    2988:	0a c0       	rjmp	.+20     	; 0x299e <USB_Device_ProcessControlRequest+0x2be>
    298a:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    298e:	87 7f       	andi	r24, 0xF7	; 247
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2990:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2994:	80 91 eb 00 	lds	r24, 0x00EB
    2998:	80 62       	ori	r24, 0x20	; 32
    299a:	80 93 eb 00 	sts	0x00EB, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    299e:	ac 96       	adiw	r28, 0x2c	; 44
    29a0:	0f b6       	in	r0, 0x3f	; 63
    29a2:	f8 94       	cli
    29a4:	de bf       	out	0x3e, r29	; 62
    29a6:	0f be       	out	0x3f, r0	; 63
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    29a8:	cd bf       	out	0x3d, r28	; 61
    29aa:	df 91       	pop	r29
    29ac:	cf 91       	pop	r28
    29ae:	1f 91       	pop	r17
    29b0:	08 95       	ret

000029b2 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    29b2:	08 95       	ret

000029b4 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    29b4:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    29b6:	80 91 d8 13 	lds	r24, 0x13D8
    29ba:	88 23       	and	r24, r24
    29bc:	a9 f0       	breq	.+42     	; 0x29e8 <USB_USBTask+0x34>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    29be:	80 91 e9 00 	lds	r24, 0x00E9
    29c2:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    29c4:	90 91 ec 00 	lds	r25, 0x00EC
    29c8:	90 ff       	sbrs	r25, 0
    29ca:	02 c0       	rjmp	.+4      	; 0x29d0 <USB_USBTask+0x1c>
    29cc:	c0 e8       	ldi	r28, 0x80	; 128
    29ce:	01 c0       	rjmp	.+2      	; 0x29d2 <USB_USBTask+0x1e>
    29d0:	c0 e0       	ldi	r28, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    29d2:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    29d4:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    29d8:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    29dc:	83 ff       	sbrs	r24, 3
    29de:	01 c0       	rjmp	.+2      	; 0x29e2 <USB_USBTask+0x2e>
	  USB_Device_ProcessControlRequest();
    29e0:	7f de       	rcall	.-770    	; 0x26e0 <USB_Device_ProcessControlRequest>
    29e2:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    29e4:	c0 93 e9 00 	sts	0x00E9, r28
    29e8:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    29ea:	08 95       	ret

000029ec <Serial_putchar>:
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    29ec:	90 91 c8 00 	lds	r25, 0x00C8
    29f0:	95 ff       	sbrs	r25, 5
    29f2:	fc cf       	rjmp	.-8      	; 0x29ec <Serial_putchar>
				UDR1 = DataByte;
    29f4:	80 93 ce 00 	sts	0x00CE, r24
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    29f8:	80 e0       	ldi	r24, 0x00	; 0
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	08 95       	ret

000029fe <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    29fe:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2a02:	87 ff       	sbrs	r24, 7
    2a04:	08 c0       	rjmp	.+16     	; 0x2a16 <Serial_getchar+0x18>
    2a06:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2a0a:	87 ff       	sbrs	r24, 7
    2a0c:	07 c0       	rjmp	.+14     	; 0x2a1c <Serial_getchar+0x1e>
				  return -1;

				return UDR1;
    2a0e:	80 91 ce 00 	lds	r24, 0x00CE
    2a12:	90 e0       	ldi	r25, 0x00	; 0
    2a14:	08 95       	ret
	  return _FDEV_EOF;
    2a16:	8e ef       	ldi	r24, 0xFE	; 254
    2a18:	9f ef       	ldi	r25, 0xFF	; 255
    2a1a:	08 95       	ret
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2a1c:	8f ef       	ldi	r24, 0xFF	; 255
    2a1e:	9f ef       	ldi	r25, 0xFF	; 255

	return Serial_ReceiveByte();
}
    2a20:	08 95       	ret

00002a22 <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*((uint8_t*)Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    2a22:	fc 01       	movw	r30, r24
	if (!(Stream))
    2a24:	00 97       	sbiw	r24, 0x00	; 0
    2a26:	51 f4       	brne	.+20     	; 0x2a3c <Serial_CreateStream+0x1a>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    2a28:	e1 ee       	ldi	r30, 0xE1	; 225
    2a2a:	f3 e1       	ldi	r31, 0x13	; 19
    2a2c:	f0 93 f0 13 	sts	0x13F0, r31
    2a30:	e0 93 ef 13 	sts	0x13EF, r30
		stdout = Stream;
    2a34:	f0 93 f2 13 	sts	0x13F2, r31
    2a38:	e0 93 f1 13 	sts	0x13F1, r30
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    2a3c:	8e e0       	ldi	r24, 0x0E	; 14
    2a3e:	df 01       	movw	r26, r30
    2a40:	1d 92       	st	X+, r1
    2a42:	8a 95       	dec	r24
    2a44:	e9 f7       	brne	.-6      	; 0x2a40 <Serial_CreateStream+0x1e>
    2a46:	83 e0       	ldi	r24, 0x03	; 3
    2a48:	83 83       	std	Z+3, r24	; 0x03
    2a4a:	86 ef       	ldi	r24, 0xF6	; 246
    2a4c:	94 e1       	ldi	r25, 0x14	; 20
    2a4e:	91 87       	std	Z+9, r25	; 0x09
    2a50:	80 87       	std	Z+8, r24	; 0x08
    2a52:	8f ef       	ldi	r24, 0xFF	; 255
    2a54:	94 e1       	ldi	r25, 0x14	; 20
    2a56:	93 87       	std	Z+11, r25	; 0x0b
    2a58:	82 87       	std	Z+10, r24	; 0x0a
}
    2a5a:	08 95       	ret

00002a5c <memcpy_P>:
    2a5c:	fb 01       	movw	r30, r22
    2a5e:	dc 01       	movw	r26, r24
    2a60:	02 c0       	rjmp	.+4      	; 0x2a66 <memcpy_P+0xa>
    2a62:	05 90       	lpm	r0, Z+
    2a64:	0d 92       	st	X+, r0
    2a66:	41 50       	subi	r20, 0x01	; 1
    2a68:	50 40       	sbci	r21, 0x00	; 0
    2a6a:	d8 f7       	brcc	.-10     	; 0x2a62 <memcpy_P+0x6>
    2a6c:	08 95       	ret

00002a6e <strcpy_P>:
    2a6e:	fb 01       	movw	r30, r22
    2a70:	dc 01       	movw	r26, r24
    2a72:	05 90       	lpm	r0, Z+
    2a74:	0d 92       	st	X+, r0
    2a76:	00 20       	and	r0, r0
    2a78:	e1 f7       	brne	.-8      	; 0x2a72 <strcpy_P+0x4>
    2a7a:	08 95       	ret

00002a7c <__strlen_P>:
    2a7c:	fc 01       	movw	r30, r24
    2a7e:	05 90       	lpm	r0, Z+
    2a80:	00 20       	and	r0, r0
    2a82:	e9 f7       	brne	.-6      	; 0x2a7e <__strlen_P+0x2>
    2a84:	80 95       	com	r24
    2a86:	90 95       	com	r25
    2a88:	8e 0f       	add	r24, r30
    2a8a:	9f 1f       	adc	r25, r31
    2a8c:	08 95       	ret

00002a8e <strncpy_P>:
    2a8e:	fb 01       	movw	r30, r22
    2a90:	dc 01       	movw	r26, r24
    2a92:	41 50       	subi	r20, 0x01	; 1
    2a94:	50 40       	sbci	r21, 0x00	; 0
    2a96:	48 f0       	brcs	.+18     	; 0x2aaa <strncpy_P+0x1c>
    2a98:	05 90       	lpm	r0, Z+
    2a9a:	0d 92       	st	X+, r0
    2a9c:	00 20       	and	r0, r0
    2a9e:	c9 f7       	brne	.-14     	; 0x2a92 <strncpy_P+0x4>
    2aa0:	01 c0       	rjmp	.+2      	; 0x2aa4 <strncpy_P+0x16>
    2aa2:	1d 92       	st	X+, r1
    2aa4:	41 50       	subi	r20, 0x01	; 1
    2aa6:	50 40       	sbci	r21, 0x00	; 0
    2aa8:	e0 f7       	brcc	.-8      	; 0x2aa2 <strncpy_P+0x14>
    2aaa:	08 95       	ret

00002aac <memcmp>:
    2aac:	fb 01       	movw	r30, r22
    2aae:	dc 01       	movw	r26, r24
    2ab0:	04 c0       	rjmp	.+8      	; 0x2aba <memcmp+0xe>
    2ab2:	8d 91       	ld	r24, X+
    2ab4:	01 90       	ld	r0, Z+
    2ab6:	80 19       	sub	r24, r0
    2ab8:	21 f4       	brne	.+8      	; 0x2ac2 <memcmp+0x16>
    2aba:	41 50       	subi	r20, 0x01	; 1
    2abc:	50 40       	sbci	r21, 0x00	; 0
    2abe:	c8 f7       	brcc	.-14     	; 0x2ab2 <memcmp+0x6>
    2ac0:	88 1b       	sub	r24, r24
    2ac2:	99 0b       	sbc	r25, r25
    2ac4:	08 95       	ret

00002ac6 <memcpy>:
    2ac6:	fb 01       	movw	r30, r22
    2ac8:	dc 01       	movw	r26, r24
    2aca:	02 c0       	rjmp	.+4      	; 0x2ad0 <memcpy+0xa>
    2acc:	01 90       	ld	r0, Z+
    2ace:	0d 92       	st	X+, r0
    2ad0:	41 50       	subi	r20, 0x01	; 1
    2ad2:	50 40       	sbci	r21, 0x00	; 0
    2ad4:	d8 f7       	brcc	.-10     	; 0x2acc <memcpy+0x6>
    2ad6:	08 95       	ret

00002ad8 <memmove>:
    2ad8:	68 17       	cp	r22, r24
    2ada:	79 07       	cpc	r23, r25
    2adc:	68 f4       	brcc	.+26     	; 0x2af8 <memmove+0x20>
    2ade:	fb 01       	movw	r30, r22
    2ae0:	dc 01       	movw	r26, r24
    2ae2:	e4 0f       	add	r30, r20
    2ae4:	f5 1f       	adc	r31, r21
    2ae6:	a4 0f       	add	r26, r20
    2ae8:	b5 1f       	adc	r27, r21
    2aea:	02 c0       	rjmp	.+4      	; 0x2af0 <memmove+0x18>
    2aec:	02 90       	ld	r0, -Z
    2aee:	0e 92       	st	-X, r0
    2af0:	41 50       	subi	r20, 0x01	; 1
    2af2:	50 40       	sbci	r21, 0x00	; 0
    2af4:	d8 f7       	brcc	.-10     	; 0x2aec <memmove+0x14>
    2af6:	08 95       	ret
    2af8:	e6 cf       	rjmp	.-52     	; 0x2ac6 <memcpy>

00002afa <strncmp>:
    2afa:	fb 01       	movw	r30, r22
    2afc:	dc 01       	movw	r26, r24
    2afe:	41 50       	subi	r20, 0x01	; 1
    2b00:	50 40       	sbci	r21, 0x00	; 0
    2b02:	30 f0       	brcs	.+12     	; 0x2b10 <strncmp+0x16>
    2b04:	8d 91       	ld	r24, X+
    2b06:	01 90       	ld	r0, Z+
    2b08:	80 19       	sub	r24, r0
    2b0a:	19 f4       	brne	.+6      	; 0x2b12 <strncmp+0x18>
    2b0c:	00 20       	and	r0, r0
    2b0e:	b9 f7       	brne	.-18     	; 0x2afe <strncmp+0x4>
    2b10:	88 1b       	sub	r24, r24
    2b12:	99 0b       	sbc	r25, r25
    2b14:	08 95       	ret

00002b16 <_exit>:
    2b16:	f8 94       	cli

00002b18 <__stop_program>:
    2b18:	ff cf       	rjmp	.-2      	; 0x2b18 <__stop_program>
