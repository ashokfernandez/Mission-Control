
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000102  00800100  00002b8e  00002c22  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b8e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  00800202  00800202  00002d24  2**0
                  ALLOC
  3 .stab         00000df8  00000000  00000000  00002d24  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000480  00000000  00000000  00003b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000006e8  00000000  00000000  00003fa0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b08a  00000000  00000000  00004688  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002fe7  00000000  00000000  0000f712  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005163  00000000  00000000  000126f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000131c  00000000  00000000  0001785c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000044aa  00000000  00000000  00018b78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006c0b  00000000  00000000  0001d022  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000898  00000000  00000000  00023c2d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
       2:	00 00       	nop
       4:	2d c2       	rjmp	.+1114   	; 0x460 <__bad_interrupt>
       6:	00 00       	nop
       8:	2b c2       	rjmp	.+1110   	; 0x460 <__bad_interrupt>
       a:	00 00       	nop
       c:	29 c2       	rjmp	.+1106   	; 0x460 <__bad_interrupt>
       e:	00 00       	nop
      10:	27 c2       	rjmp	.+1102   	; 0x460 <__bad_interrupt>
      12:	00 00       	nop
      14:	25 c2       	rjmp	.+1098   	; 0x460 <__bad_interrupt>
      16:	00 00       	nop
      18:	23 c2       	rjmp	.+1094   	; 0x460 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	21 c2       	rjmp	.+1090   	; 0x460 <__bad_interrupt>
      1e:	00 00       	nop
      20:	1f c2       	rjmp	.+1086   	; 0x460 <__bad_interrupt>
      22:	00 00       	nop
      24:	1d c2       	rjmp	.+1082   	; 0x460 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 bd 0e 	jmp	0x1d7a	; 0x1d7a <__vector_10>
      2c:	19 c2       	rjmp	.+1074   	; 0x460 <__bad_interrupt>
      2e:	00 00       	nop
      30:	17 c2       	rjmp	.+1070   	; 0x460 <__bad_interrupt>
      32:	00 00       	nop
      34:	15 c2       	rjmp	.+1066   	; 0x460 <__bad_interrupt>
      36:	00 00       	nop
      38:	13 c2       	rjmp	.+1062   	; 0x460 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	11 c2       	rjmp	.+1058   	; 0x460 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0f c2       	rjmp	.+1054   	; 0x460 <__bad_interrupt>
      42:	00 00       	nop
      44:	0d c2       	rjmp	.+1050   	; 0x460 <__bad_interrupt>
      46:	00 00       	nop
      48:	0b c2       	rjmp	.+1046   	; 0x460 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	09 c2       	rjmp	.+1042   	; 0x460 <__bad_interrupt>
      4e:	00 00       	nop
      50:	07 c2       	rjmp	.+1038   	; 0x460 <__bad_interrupt>
      52:	00 00       	nop
      54:	05 c2       	rjmp	.+1034   	; 0x460 <__bad_interrupt>
      56:	00 00       	nop
      58:	03 c2       	rjmp	.+1030   	; 0x460 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	01 c2       	rjmp	.+1026   	; 0x460 <__bad_interrupt>
      5e:	00 00       	nop
      60:	ff c1       	rjmp	.+1022   	; 0x460 <__bad_interrupt>
      62:	00 00       	nop
      64:	fd c1       	rjmp	.+1018   	; 0x460 <__bad_interrupt>
      66:	00 00       	nop
      68:	fb c1       	rjmp	.+1014   	; 0x460 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f9 c1       	rjmp	.+1010   	; 0x460 <__bad_interrupt>
      6e:	00 00       	nop
      70:	f7 c1       	rjmp	.+1006   	; 0x460 <__bad_interrupt>
      72:	00 00       	nop
      74:	f5 c1       	rjmp	.+1002   	; 0x460 <__bad_interrupt>
      76:	00 00       	nop
      78:	f3 c1       	rjmp	.+998    	; 0x460 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f1 c1       	rjmp	.+994    	; 0x460 <__bad_interrupt>
      7e:	00 00       	nop
      80:	ef c1       	rjmp	.+990    	; 0x460 <__bad_interrupt>
      82:	00 00       	nop
      84:	ed c1       	rjmp	.+986    	; 0x460 <__bad_interrupt>
      86:	00 00       	nop
      88:	eb c1       	rjmp	.+982    	; 0x460 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e9 c1       	rjmp	.+978    	; 0x460 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e7 c1       	rjmp	.+974    	; 0x460 <__bad_interrupt>
      92:	00 00       	nop
      94:	e5 c1       	rjmp	.+970    	; 0x460 <__bad_interrupt>
      96:	00 00       	nop

00000098 <ProductString>:
      98:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
      a8:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
      b8:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000c2 <ManufacturerString>:
      c2:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      d2:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000dc <LanguageString>:
      dc:	04 03 09 04                                         ....

000000e0 <ConfigurationDescriptor>:
      e0:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      f0:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
     100:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     110:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

0000011e <DeviceDescriptor>:
     11e:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
     12e:	00 01                                               ..

00000130 <HTTPPage>:
     130:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     140:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     150:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     160:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     170:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     180:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     190:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     1a0:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     1b0:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     1c0:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     1d0:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     1e0:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     1f0:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     200:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     210:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     220:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     230:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     240:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     250:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     260:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     270:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     280:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     290:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     2a0:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     2b0:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     2c0:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     2d0:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     2e0:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     2f0:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     300:	3c 2f 69 3e 31 33 30 33 30 33 09 09 3c 2f 70 3e     </i>130303..</p>
     310:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

00000320 <HTTP404Header>:
     320:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     330:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     340:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     350:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     360:	0a 00                                               ..

00000362 <HTTP200Header>:
     362:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     372:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     382:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     392:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     3a2:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     3b2:	0a 0d 0a 00                                         ....

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	12 e0       	ldi	r17, 0x02	; 2
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	ee e8       	ldi	r30, 0x8E	; 142
     436:	fb e2       	ldi	r31, 0x2B	; 43
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	a2 30       	cpi	r26, 0x02	; 2
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>
     448:	1b be       	out	0x3b, r1	; 59

0000044a <__do_clear_bss>:
     44a:	14 e1       	ldi	r17, 0x14	; 20
     44c:	a2 e0       	ldi	r26, 0x02	; 2
     44e:	b2 e0       	ldi	r27, 0x02	; 2
     450:	01 c0       	rjmp	.+2      	; 0x454 <.do_clear_bss_start>

00000452 <.do_clear_bss_loop>:
     452:	1d 92       	st	X+, r1

00000454 <.do_clear_bss_start>:
     454:	a7 32       	cpi	r26, 0x27	; 39
     456:	b1 07       	cpc	r27, r17
     458:	e1 f7       	brne	.-8      	; 0x452 <.do_clear_bss_loop>
     45a:	37 d0       	rcall	.+110    	; 0x4ca <main>
     45c:	0c 94 c5 15 	jmp	0x2b8a	; 0x2b8a <_exit>

00000460 <__bad_interrupt>:
     460:	cf cd       	rjmp	.-1122   	; 0x0 <__vectors>

00000462 <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     462:	9b b1       	in	r25, 0x0b	; 11
     464:	9f 70       	andi	r25, 0x0F	; 15
     466:	98 2b       	or	r25, r24
     468:	9b b9       	out	0x0b, r25	; 11
			}
     46a:	08 95       	ret

0000046c <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     46c:	84 b7       	in	r24, 0x34	; 52
     46e:	87 7f       	andi	r24, 0xF7	; 247
     470:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     472:	28 e1       	ldi	r18, 0x18	; 24
     474:	0f b6       	in	r0, 0x3f	; 63
     476:	f8 94       	cli
     478:	20 93 60 00 	sts	0x0060, r18
     47c:	10 92 60 00 	sts	0x0060, r1
     480:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	80 e8       	ldi	r24, 0x80	; 128
     486:	0f b6       	in	r0, 0x3f	; 63
     488:	f8 94       	cli
     48a:	80 93 61 00 	sts	0x0061, r24
     48e:	90 93 61 00 	sts	0x0061, r25
     492:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     494:	8a b1       	in	r24, 0x0a	; 10
     496:	80 6f       	ori	r24, 0xF0	; 240
     498:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     49a:	8b b1       	in	r24, 0x0b	; 11
     49c:	8f 70       	andi	r24, 0x0F	; 15
     49e:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4a0:	83 e3       	ldi	r24, 0x33	; 51
     4a2:	90 e0       	ldi	r25, 0x00	; 0
     4a4:	90 93 cd 00 	sts	0x00CD, r25
     4a8:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4ac:	86 e0       	ldi	r24, 0x06	; 6
     4ae:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4b2:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4b6:	20 93 c9 00 	sts	0x00C9, r18

				DDRD  |= (1 << 3);
     4ba:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4bc:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4be:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <USB_Init>

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
     4c2:	80 e0       	ldi	r24, 0x00	; 0
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	0c 94 4b 15 	jmp	0x2a96	; 0x2a96 <Serial_CreateStream>

000004ca <main>:
}
     4ca:	d0 df       	rcall	.-96     	; 0x46c <SetupHardware>
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     4cc:	24 d3       	rcall	.+1608   	; 0xb16 <TCP_Init>

	TCP_Init();
     4ce:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <Webserver_Init>
	Webserver_Init();
     4d2:	80 e1       	ldi	r24, 0x10	; 16
     4d4:	c6 df       	rcall	.-116    	; 0x462 <LEDs_SetAllLEDs>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     4d6:	78 94       	sei
     4d8:	88 e1       	ldi	r24, 0x18	; 24
     4da:	91 e0       	ldi	r25, 0x01	; 1
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     4dc:	0e 94 48 14 	call	0x2890	; 0x2890 <RNDIS_Device_IsPacketReceived>
	GlobalInterruptEnable();

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     4e0:	88 23       	and	r24, r24
     4e2:	11 f1       	breq	.+68     	; 0x528 <main+0x5e>
     4e4:	80 e2       	ldi	r24, 0x20	; 32
     4e6:	bd df       	rcall	.-134    	; 0x462 <LEDs_SetAllLEDs>
     4e8:	88 e1       	ldi	r24, 0x18	; 24
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     4ea:	91 e0       	ldi	r25, 0x01	; 1
     4ec:	62 e0       	ldi	r22, 0x02	; 2
     4ee:	72 e0       	ldi	r23, 0x02	; 2

			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     4f0:	4e ed       	ldi	r20, 0xDE	; 222
     4f2:	57 e0       	ldi	r21, 0x07	; 7
     4f4:	0e 94 60 14 	call	0x28c0	; 0x28c0 <RNDIS_Device_ReadPacket>
     4f8:	82 e0       	ldi	r24, 0x02	; 2
     4fa:	92 e0       	ldi	r25, 0x02	; 2
     4fc:	60 ee       	ldi	r22, 0xE0	; 224
     4fe:	77 e0       	ldi	r23, 0x07	; 7
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     500:	5d d0       	rcall	.+186    	; 0x5bc <Ethernet_ProcessPacket>
     502:	40 91 bc 0d 	lds	r20, 0x0DBC
     506:	50 91 bd 0d 	lds	r21, 0x0DBD
     50a:	41 15       	cp	r20, r1

			if (FrameOUT.FrameLength)
     50c:	51 05       	cpc	r21, r1
     50e:	51 f0       	breq	.+20     	; 0x524 <main+0x5a>
     510:	88 e1       	ldi	r24, 0x18	; 24
     512:	91 e0       	ldi	r25, 0x01	; 1
     514:	60 ee       	ldi	r22, 0xE0	; 224
     516:	77 e0       	ldi	r23, 0x07	; 7
     518:	0e 94 c0 14 	call	0x2980	; 0x2980 <RNDIS_Device_SendPacket>
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);
     51c:	10 92 bd 0d 	sts	0x0DBD, r1
     520:	10 92 bc 0d 	sts	0x0DBC, r1
     524:	80 e6       	ldi	r24, 0x60	; 96
				FrameOUT.FrameLength = 0;
     526:	9d df       	rcall	.-198    	; 0x462 <LEDs_SetAllLEDs>
     528:	88 e1       	ldi	r24, 0x18	; 24
     52a:	91 e0       	ldi	r25, 0x01	; 1
     52c:	60 ee       	ldi	r22, 0xE0	; 224
			}

			LEDs_SetAllLEDs(LEDMASK_USB_READY);
     52e:	77 e0       	ldi	r23, 0x07	; 7
     530:	b8 d1       	rcall	.+880    	; 0x8a2 <TCP_TCPTask>
     532:	88 e1       	ldi	r24, 0x18	; 24
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     534:	91 e0       	ldi	r25, 0x01	; 1
     536:	0e 94 04 14 	call	0x2808	; 0x2808 <RNDIS_Device_USBTask>
     53a:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <USB_USBTask>
     53e:	cc cf       	rjmp	.-104    	; 0x4d8 <main+0xe>

00000540 <EVENT_USB_Device_Connect>:

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     540:	80 ea       	ldi	r24, 0xA0	; 160
     542:	8f cf       	rjmp	.-226    	; 0x462 <LEDs_SetAllLEDs>

00000544 <EVENT_USB_Device_Disconnect>:
     544:	80 e1       	ldi	r24, 0x10	; 16
     546:	8d cf       	rjmp	.-230    	; 0x462 <LEDs_SetAllLEDs>

00000548 <EVENT_USB_Device_ConfigurationChanged>:
		USB_USBTask();
     548:	88 e1       	ldi	r24, 0x18	; 24
     54a:	91 e0       	ldi	r25, 0x01	; 1
	}
     54c:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <RNDIS_Device_ConfigureEndpoints>
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     550:	88 23       	and	r24, r24
     552:	11 f0       	breq	.+4      	; 0x558 <EVENT_USB_Device_ConfigurationChanged+0x10>
     554:	80 e6       	ldi	r24, 0x60	; 96
     556:	01 c0       	rjmp	.+2      	; 0x55a <EVENT_USB_Device_ConfigurationChanged+0x12>
     558:	80 e9       	ldi	r24, 0x90	; 144
     55a:	83 cf       	rjmp	.-250    	; 0x462 <LEDs_SetAllLEDs>

0000055c <EVENT_USB_Device_ControlRequest>:
     55c:	88 e1       	ldi	r24, 0x18	; 24
}
     55e:	91 e0       	ldi	r25, 0x01	; 1

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     560:	0c 94 0d 11 	jmp	0x221a	; 0x221a <RNDIS_Device_ProcessControlRequest>

00000564 <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     564:	92 30       	cpi	r25, 0x02	; 2
     566:	29 f0       	breq	.+10     	; 0x572 <CALLBACK_USB_GetDescriptor+0xe>
     568:	93 30       	cpi	r25, 0x03	; 3
     56a:	41 f0       	breq	.+16     	; 0x57c <CALLBACK_USB_GetDescriptor+0x18>
     56c:	91 30       	cpi	r25, 0x01	; 1
     56e:	e9 f4       	brne	.+58     	; 0x5aa <CALLBACK_USB_GetDescriptor+0x46>
     570:	17 c0       	rjmp	.+46     	; 0x5a0 <CALLBACK_USB_GetDescriptor+0x3c>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     572:	8e e3       	ldi	r24, 0x3E	; 62
     574:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     576:	e0 ee       	ldi	r30, 0xE0	; 224
     578:	f0 e0       	ldi	r31, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     57a:	1b c0       	rjmp	.+54     	; 0x5b2 <CALLBACK_USB_GetDescriptor+0x4e>
		case DTYPE_String:
			switch (DescriptorNumber)
     57c:	81 30       	cpi	r24, 0x01	; 1
     57e:	41 f0       	breq	.+16     	; 0x590 <CALLBACK_USB_GetDescriptor+0x2c>
     580:	81 30       	cpi	r24, 0x01	; 1
     582:	18 f0       	brcs	.+6      	; 0x58a <CALLBACK_USB_GetDescriptor+0x26>
     584:	82 30       	cpi	r24, 0x02	; 2
     586:	89 f4       	brne	.+34     	; 0x5aa <CALLBACK_USB_GetDescriptor+0x46>
     588:	06 c0       	rjmp	.+12     	; 0x596 <CALLBACK_USB_GetDescriptor+0x32>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     58a:	ec ed       	ldi	r30, 0xDC	; 220
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	05 c0       	rjmp	.+10     	; 0x59a <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     590:	e2 ec       	ldi	r30, 0xC2	; 194
     592:	f0 e0       	ldi	r31, 0x00	; 0
     594:	02 c0       	rjmp	.+4      	; 0x59a <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     596:	e8 e9       	ldi	r30, 0x98	; 152
     598:	f0 e0       	ldi	r31, 0x00	; 0
     59a:	84 91       	lpm	r24, Z
     59c:	90 e0       	ldi	r25, 0x00	; 0
					break;
     59e:	09 c0       	rjmp	.+18     	; 0x5b2 <CALLBACK_USB_GetDescriptor+0x4e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     5a0:	82 e1       	ldi	r24, 0x12	; 18
     5a2:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     5a4:	ee e1       	ldi	r30, 0x1E	; 30
     5a6:	f1 e0       	ldi	r31, 0x01	; 1
     5a8:	04 c0       	rjmp	.+8      	; 0x5b2 <CALLBACK_USB_GetDescriptor+0x4e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     5aa:	80 e0       	ldi	r24, 0x00	; 0
     5ac:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     5ae:	e0 e0       	ldi	r30, 0x00	; 0
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     5b2:	da 01       	movw	r26, r20
     5b4:	11 96       	adiw	r26, 0x01	; 1
     5b6:	fc 93       	st	X, r31
     5b8:	ee 93       	st	-X, r30
	return Size;
}
     5ba:	08 95       	ret

000005bc <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     5bc:	0f 93       	push	r16
     5be:	1f 93       	push	r17
     5c0:	cf 93       	push	r28
     5c2:	df 93       	push	r29
     5c4:	ec 01       	movw	r28, r24
     5c6:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     5c8:	9a d0       	rcall	.+308    	; 0x6fe <DecodeEthernetFrameHeader>
     5ca:	ce 01       	movw	r24, r28
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     5cc:	68 ec       	ldi	r22, 0xC8	; 200
     5ce:	71 e0       	ldi	r23, 0x01	; 1
     5d0:	46 e0       	ldi	r20, 0x06	; 6
     5d2:	50 e0       	ldi	r21, 0x00	; 0
     5d4:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
     5d8:	00 97       	sbiw	r24, 0x00	; 0
     5da:	51 f0       	breq	.+20     	; 0x5f0 <Ethernet_ProcessPacket+0x34>
     5dc:	ce 01       	movw	r24, r28
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     5de:	6e eb       	ldi	r22, 0xBE	; 190
     5e0:	71 e0       	ldi	r23, 0x01	; 1
     5e2:	46 e0       	ldi	r20, 0x06	; 6
     5e4:	50 e0       	ldi	r21, 0x00	; 0
     5e6:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
     5ea:	00 97       	sbiw	r24, 0x00	; 0
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <Ethernet_ProcessPacket+0x34>
     5ee:	4c c0       	rjmp	.+152    	; 0x688 <Ethernet_ProcessPacket+0xcc>
     5f0:	fe 01       	movw	r30, r28
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
     5f2:	e4 52       	subi	r30, 0x24	; 36
     5f4:	fa 4f       	sbci	r31, 0xFA	; 250
     5f6:	80 81       	ld	r24, Z
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     5f8:	91 81       	ldd	r25, Z+1	; 0x01
     5fa:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
     5fc:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
     5fe:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
     600:	26 e0       	ldi	r18, 0x06	; 6

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     602:	81 30       	cpi	r24, 0x01	; 1
     604:	92 07       	cpc	r25, r18
     606:	08 f4       	brcc	.+2      	; 0x60a <Ethernet_ProcessPacket+0x4e>
     608:	3f c0       	rjmp	.+126    	; 0x688 <Ethernet_ProcessPacket+0xcc>
     60a:	8c 85       	ldd	r24, Y+12	; 0x0c
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     60c:	9d 85       	ldd	r25, Y+13	; 0x0d
     60e:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
     610:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
     612:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
     614:	e8 e0       	ldi	r30, 0x08	; 8
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     616:	80 30       	cpi	r24, 0x00	; 0
     618:	9e 07       	cpc	r25, r30
     61a:	59 f0       	breq	.+22     	; 0x632 <Ethernet_ProcessPacket+0x76>
     61c:	f8 e0       	ldi	r31, 0x08	; 8
     61e:	86 30       	cpi	r24, 0x06	; 6
     620:	9f 07       	cpc	r25, r31
     622:	91 f5       	brne	.+100    	; 0x688 <Ethernet_ProcessPacket+0xcc>
     624:	b8 01       	movw	r22, r16
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     626:	62 5f       	subi	r22, 0xF2	; 242
     628:	7f 4f       	sbci	r23, 0xFF	; 255
     62a:	ce 01       	movw	r24, r28
     62c:	0e 96       	adiw	r24, 0x0e	; 14
     62e:	fe d6       	rcall	.+3580   	; 0x142c <ARP_ProcessARPPacket>
     630:	08 c0       	rjmp	.+16     	; 0x642 <Ethernet_ProcessPacket+0x86>
     632:	be 01       	movw	r22, r28
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     634:	62 5f       	subi	r22, 0xF2	; 242
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     636:	7f 4f       	sbci	r23, 0xFF	; 255
     638:	a8 01       	movw	r20, r16
     63a:	42 5f       	subi	r20, 0xF2	; 242
     63c:	5f 4f       	sbci	r21, 0xFF	; 255
     63e:	ce 01       	movw	r24, r28
     640:	66 d7       	rcall	.+3788   	; 0x150e <IP_ProcessIPPacket>
     642:	18 16       	cp	r1, r24
     644:	19 06       	cpc	r1, r25
     646:	e4 f4       	brge	.+56     	; 0x680 <Ethernet_ProcessPacket+0xc4>
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     648:	f8 01       	movw	r30, r16
     64a:	36 96       	adiw	r30, 0x06	; 6
     64c:	a8 ec       	ldi	r26, 0xC8	; 200
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     64e:	b1 e0       	ldi	r27, 0x01	; 1
     650:	26 e0       	ldi	r18, 0x06	; 6
     652:	0d 90       	ld	r0, X+
     654:	01 92       	st	Z+, r0
     656:	21 50       	subi	r18, 0x01	; 1
     658:	e1 f7       	brne	.-8      	; 0x652 <Ethernet_ProcessPacket+0x96>
     65a:	d8 01       	movw	r26, r16
     65c:	fe 01       	movw	r30, r28
     65e:	36 96       	adiw	r30, 0x06	; 6
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     660:	26 e0       	ldi	r18, 0x06	; 6
     662:	01 90       	ld	r0, Z+
     664:	0d 92       	st	X+, r0
     666:	21 50       	subi	r18, 0x01	; 1
     668:	e1 f7       	brne	.-8      	; 0x662 <Ethernet_ProcessPacket+0xa6>
     66a:	2c 85       	ldd	r18, Y+12	; 0x0c
     66c:	3d 85       	ldd	r19, Y+13	; 0x0d
     66e:	f8 01       	movw	r30, r16
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     670:	35 87       	std	Z+13, r19	; 0x0d
     672:	24 87       	std	Z+12, r18	; 0x0c
     674:	e4 52       	subi	r30, 0x24	; 36
     676:	fa 4f       	sbci	r31, 0xFA	; 250
     678:	0e 96       	adiw	r24, 0x0e	; 14

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     67a:	91 83       	std	Z+1, r25	; 0x01
     67c:	80 83       	st	Z, r24
     67e:	04 c0       	rjmp	.+8      	; 0x688 <Ethernet_ProcessPacket+0xcc>
     680:	ff ef       	ldi	r31, 0xFF	; 255
     682:	8f 3f       	cpi	r24, 0xFF	; 255
     684:	9f 07       	cpc	r25, r31
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     686:	21 f0       	breq	.+8      	; 0x690 <Ethernet_ProcessPacket+0xd4>
     688:	c4 52       	subi	r28, 0x24	; 36
     68a:	da 4f       	sbci	r29, 0xFA	; 250
     68c:	19 82       	std	Y+1, r1	; 0x01
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     68e:	18 82       	st	Y, r1
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	1f 91       	pop	r17
	}
}
     696:	0f 91       	pop	r16
     698:	08 95       	ret

0000069a <Ethernet_Checksum16>:
     69a:	cf 93       	push	r28
     69c:	df 93       	push	r29
     69e:	9b 01       	movw	r18, r22
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6a0:	36 95       	lsr	r19
     6a2:	27 95       	ror	r18
     6a4:	ec 01       	movw	r28, r24
     6a6:	e0 e0       	ldi	r30, 0x00	; 0
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     6aa:	40 e0       	ldi	r20, 0x00	; 0
     6ac:	50 e0       	ldi	r21, 0x00	; 0
     6ae:	ba 01       	movw	r22, r20

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6b0:	09 c0       	rjmp	.+18     	; 0x6c4 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     6b2:	89 91       	ld	r24, Y+
     6b4:	99 91       	ld	r25, Y+
     6b6:	a0 e0       	ldi	r26, 0x00	; 0
     6b8:	b0 e0       	ldi	r27, 0x00	; 0
     6ba:	48 0f       	add	r20, r24
     6bc:	59 1f       	adc	r21, r25
     6be:	6a 1f       	adc	r22, r26
     6c0:	7b 1f       	adc	r23, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6c2:	31 96       	adiw	r30, 0x01	; 1
     6c4:	e2 17       	cp	r30, r18
     6c6:	f3 07       	cpc	r31, r19
     6c8:	a1 f7       	brne	.-24     	; 0x6b2 <Ethernet_Checksum16+0x18>
     6ca:	0b c0       	rjmp	.+22     	; 0x6e2 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     6cc:	db 01       	movw	r26, r22
     6ce:	ca 01       	movw	r24, r20
     6d0:	a0 70       	andi	r26, 0x00	; 0
     6d2:	b0 70       	andi	r27, 0x00	; 0
     6d4:	ab 01       	movw	r20, r22
     6d6:	66 27       	eor	r22, r22
     6d8:	77 27       	eor	r23, r23
     6da:	48 0f       	add	r20, r24
     6dc:	59 1f       	adc	r21, r25
     6de:	6a 1f       	adc	r22, r26
     6e0:	7b 1f       	adc	r23, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     6e2:	db 01       	movw	r26, r22
     6e4:	ca 01       	movw	r24, r20
     6e6:	80 70       	andi	r24, 0x00	; 0
     6e8:	90 70       	andi	r25, 0x00	; 0
     6ea:	00 97       	sbiw	r24, 0x00	; 0
     6ec:	a1 05       	cpc	r26, r1
     6ee:	b1 05       	cpc	r27, r1
     6f0:	69 f7       	brne	.-38     	; 0x6cc <Ethernet_Checksum16+0x32>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     6f2:	ca 01       	movw	r24, r20
     6f4:	80 95       	com	r24
     6f6:	90 95       	com	r25
}
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	08 95       	ret

000006fe <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     6fe:	08 95       	ret

00000700 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     700:	08 95       	ret

00000702 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     702:	08 95       	ret

00000704 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     704:	08 95       	ret

00000706 <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     706:	08 95       	ret

00000708 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     708:	08 95       	ret

0000070a <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     70a:	08 95       	ret

0000070c <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     70c:	cf 92       	push	r12
     70e:	df 92       	push	r13
     710:	ef 92       	push	r14
     712:	ff 92       	push	r15
     714:	0f 93       	push	r16
     716:	1f 93       	push	r17
     718:	cf 93       	push	r28
     71a:	df 93       	push	r29
     71c:	6c 01       	movw	r12, r24
     71e:	eb 01       	movw	r28, r22
     720:	7a 01       	movw	r14, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     722:	cb 01       	movw	r24, r22
     724:	ef df       	rcall	.-34     	; 0x704 <DecodeICMPHeader>
     726:	88 81       	ld	r24, Y

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     728:	88 30       	cpi	r24, 0x08	; 8
     72a:	41 f5       	brne	.+80     	; 0x77c <ICMP_ProcessICMPPacket+0x70>
     72c:	f7 01       	movw	r30, r14
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     72e:	10 82       	st	Z, r1
     730:	11 82       	std	Z+1, r1	; 0x01
		ICMPHeaderOUT->Code     = 0;
     732:	13 82       	std	Z+3, r1	; 0x03
		ICMPHeaderOUT->Checksum = 0;
     734:	12 82       	std	Z+2, r1	; 0x02
     736:	8c 81       	ldd	r24, Y+4	; 0x04
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     738:	9d 81       	ldd	r25, Y+5	; 0x05
     73a:	95 83       	std	Z+5, r25	; 0x05
     73c:	84 83       	std	Z+4, r24	; 0x04
     73e:	8e 81       	ldd	r24, Y+6	; 0x06
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     740:	9f 81       	ldd	r25, Y+7	; 0x07
     742:	97 83       	std	Z+7, r25	; 0x07
     744:	86 83       	std	Z+6, r24	; 0x06
     746:	f6 01       	movw	r30, r12

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     748:	e4 52       	subi	r30, 0x24	; 36
     74a:	fa 4f       	sbci	r31, 0xFA	; 250
     74c:	00 81       	ld	r16, Z
     74e:	11 81       	ldd	r17, Z+1	; 0x01
     750:	0c 0d       	add	r16, r12
     752:	1d 1d       	adc	r17, r13
     754:	0c 1b       	sub	r16, r28
     756:	1d 0b       	sbc	r17, r29
     758:	be 01       	movw	r22, r28

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     75a:	68 5f       	subi	r22, 0xF8	; 248
     75c:	7f 4f       	sbci	r23, 0xFF	; 255
     75e:	a8 01       	movw	r20, r16
		ICMPHeaderOUT->Code     = 0;
		ICMPHeaderOUT->Checksum = 0;
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     760:	48 50       	subi	r20, 0x08	; 8
     762:	50 40       	sbci	r21, 0x00	; 0
     764:	c7 01       	movw	r24, r14

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     766:	08 96       	adiw	r24, 0x08	; 8
     768:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <memmove>
     76c:	c7 01       	movw	r24, r14
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     76e:	b8 01       	movw	r22, r16
     770:	94 df       	rcall	.-216    	; 0x69a <Ethernet_Checksum16>
     772:	f7 01       	movw	r30, r14
     774:	93 83       	std	Z+3, r25	; 0x03
     776:	82 83       	std	Z+2, r24	; 0x02
     778:	c8 01       	movw	r24, r16
     77a:	02 c0       	rjmp	.+4      	; 0x780 <ICMP_ProcessICMPPacket+0x74>

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     77c:	80 e0       	ldi	r24, 0x00	; 0
     77e:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
}
     784:	1f 91       	pop	r17
     786:	0f 91       	pop	r16
     788:	ff 90       	pop	r15
     78a:	ef 90       	pop	r14
     78c:	df 90       	pop	r13
     78e:	cf 90       	pop	r12
     790:	08 95       	ret

00000792 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     792:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     794:	69 2f       	mov	r22, r25
     796:	78 2f       	mov	r23, r24
     798:	83 2f       	mov	r24, r19
     79a:	92 2f       	mov	r25, r18
     79c:	08 95       	ret

0000079e <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     79e:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     7a0:	89 2f       	mov	r24, r25
     7a2:	92 2f       	mov	r25, r18
     7a4:	08 95       	ret

000007a6 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     7a6:	af 92       	push	r10
     7a8:	bf 92       	push	r11
     7aa:	cf 92       	push	r12
     7ac:	df 92       	push	r13
     7ae:	ef 92       	push	r14
     7b0:	ff 92       	push	r15
     7b2:	0f 93       	push	r16
     7b4:	1f 93       	push	r17
     7b6:	cf 93       	push	r28
     7b8:	df 93       	push	r29
     7ba:	5c 01       	movw	r10, r24
     7bc:	fb 01       	movw	r30, r22
     7be:	ea 01       	movw	r28, r20
     7c0:	89 01       	movw	r16, r18

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     7c2:	c2 80       	ldd	r12, Z+2	; 0x02
     7c4:	d3 80       	ldd	r13, Z+3	; 0x03
     7c6:	ee 24       	eor	r14, r14
     7c8:	ff 24       	eor	r15, r15
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     7ca:	80 81       	ld	r24, Z
     7cc:	91 81       	ldd	r25, Z+1	; 0x01
     7ce:	a0 e0       	ldi	r26, 0x00	; 0
     7d0:	b0 e0       	ldi	r27, 0x00	; 0
	Checksum += ((uint16_t*)SourceAddress)[1];
     7d2:	c8 0e       	add	r12, r24
     7d4:	d9 1e       	adc	r13, r25
     7d6:	ea 1e       	adc	r14, r26
     7d8:	fb 1e       	adc	r15, r27
	Checksum += ((uint16_t*)DestinationAddress)[0];
     7da:	88 81       	ld	r24, Y
     7dc:	99 81       	ldd	r25, Y+1	; 0x01
     7de:	a0 e0       	ldi	r26, 0x00	; 0
     7e0:	b0 e0       	ldi	r27, 0x00	; 0
     7e2:	c8 0e       	add	r12, r24
     7e4:	d9 1e       	adc	r13, r25
     7e6:	ea 1e       	adc	r14, r26
     7e8:	fb 1e       	adc	r15, r27
	Checksum += ((uint16_t*)DestinationAddress)[1];
     7ea:	8a 81       	ldd	r24, Y+2	; 0x02
     7ec:	9b 81       	ldd	r25, Y+3	; 0x03
     7ee:	a0 e0       	ldi	r26, 0x00	; 0
     7f0:	b0 e0       	ldi	r27, 0x00	; 0
     7f2:	c8 0e       	add	r12, r24
     7f4:	d9 1e       	adc	r13, r25
     7f6:	ea 1e       	adc	r14, r26
     7f8:	fb 1e       	adc	r15, r27
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     7fa:	86 e0       	ldi	r24, 0x06	; 6
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	cf df       	rcall	.-98     	; 0x79e <SwapEndian_16>
     800:	a0 e0       	ldi	r26, 0x00	; 0
     802:	b0 e0       	ldi	r27, 0x00	; 0
     804:	c8 0e       	add	r12, r24
     806:	d9 1e       	adc	r13, r25
     808:	ea 1e       	adc	r14, r26
     80a:	fb 1e       	adc	r15, r27
     80c:	c8 01       	movw	r24, r16
	Checksum += SwapEndian_16(TCPOutSize);
     80e:	c7 df       	rcall	.-114    	; 0x79e <SwapEndian_16>
     810:	ac 01       	movw	r20, r24
     812:	60 e0       	ldi	r22, 0x00	; 0
     814:	70 e0       	ldi	r23, 0x00	; 0
     816:	4c 0d       	add	r20, r12
     818:	5d 1d       	adc	r21, r13
     81a:	6e 1d       	adc	r22, r14
     81c:	7f 1d       	adc	r23, r15
     81e:	e8 01       	movw	r28, r16
     820:	d6 95       	lsr	r29

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     822:	c7 95       	ror	r28
     824:	f5 01       	movw	r30, r10
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	0a c0       	rjmp	.+20     	; 0x840 <TCP_Checksum16+0x9a>
     82c:	81 91       	ld	r24, Z+
     82e:	91 91       	ld	r25, Z+
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     830:	a0 e0       	ldi	r26, 0x00	; 0
     832:	b0 e0       	ldi	r27, 0x00	; 0
     834:	48 0f       	add	r20, r24
     836:	59 1f       	adc	r21, r25
     838:	6a 1f       	adc	r22, r26
     83a:	7b 1f       	adc	r23, r27
     83c:	2f 5f       	subi	r18, 0xFF	; 255
     83e:	3f 4f       	sbci	r19, 0xFF	; 255
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     840:	2c 17       	cp	r18, r28
     842:	3d 07       	cpc	r19, r29
     844:	99 f7       	brne	.-26     	; 0x82c <TCP_Checksum16+0x86>
     846:	00 ff       	sbrs	r16, 0
     848:	16 c0       	rjmp	.+44     	; 0x876 <TCP_Checksum16+0xd0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     84a:	f9 01       	movw	r30, r18
     84c:	ee 0f       	add	r30, r30
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     84e:	ff 1f       	adc	r31, r31
     850:	ea 0d       	add	r30, r10
     852:	fb 1d       	adc	r31, r11
     854:	80 81       	ld	r24, Z
     856:	48 0f       	add	r20, r24
     858:	51 1d       	adc	r21, r1
     85a:	61 1d       	adc	r22, r1
     85c:	71 1d       	adc	r23, r1
     85e:	0b c0       	rjmp	.+22     	; 0x876 <TCP_Checksum16+0xd0>
     860:	db 01       	movw	r26, r22
     862:	ca 01       	movw	r24, r20

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     864:	a0 70       	andi	r26, 0x00	; 0
     866:	b0 70       	andi	r27, 0x00	; 0
     868:	ab 01       	movw	r20, r22
     86a:	66 27       	eor	r22, r22
     86c:	77 27       	eor	r23, r23
     86e:	48 0f       	add	r20, r24
     870:	59 1f       	adc	r21, r25
     872:	6a 1f       	adc	r22, r26
     874:	7b 1f       	adc	r23, r27
     876:	db 01       	movw	r26, r22
     878:	ca 01       	movw	r24, r20
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     87a:	80 70       	andi	r24, 0x00	; 0
     87c:	90 70       	andi	r25, 0x00	; 0
     87e:	00 97       	sbiw	r24, 0x00	; 0
     880:	a1 05       	cpc	r26, r1
     882:	b1 05       	cpc	r27, r1
     884:	69 f7       	brne	.-38     	; 0x860 <TCP_Checksum16+0xba>
     886:	ca 01       	movw	r24, r20
     888:	80 95       	com	r24
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     88a:	90 95       	com	r25
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
}
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	ff 90       	pop	r15
     896:	ef 90       	pop	r14
     898:	df 90       	pop	r13
     89a:	cf 90       	pop	r12
     89c:	bf 90       	pop	r11
     89e:	af 90       	pop	r10
     8a0:	08 95       	ret

000008a2 <TCP_TCPTask>:
     8a2:	8f 92       	push	r8
     8a4:	9f 92       	push	r9
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     8a6:	af 92       	push	r10
     8a8:	bf 92       	push	r11
     8aa:	cf 92       	push	r12
     8ac:	df 92       	push	r13
     8ae:	ef 92       	push	r14
     8b0:	ff 92       	push	r15
     8b2:	0f 93       	push	r16
     8b4:	1f 93       	push	r17
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	0f 92       	push	r0
     8bc:	cd b7       	in	r28, 0x3d	; 61
     8be:	de b7       	in	r29, 0x3e	; 62
     8c0:	4b 01       	movw	r8, r22
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     8c2:	8f eb       	ldi	r24, 0xBF	; 191
     8c4:	e8 2e       	mov	r14, r24
     8c6:	8d e0       	ldi	r24, 0x0D	; 13
     8c8:	f8 2e       	mov	r15, r24
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     8ca:	00 e0       	ldi	r16, 0x00	; 0
     8cc:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     8ce:	96 e1       	ldi	r25, 0x16	; 22
     8d0:	c9 2e       	mov	r12, r25
     8d2:	92 e0       	ldi	r25, 0x02	; 2
     8d4:	d9 2e       	mov	r13, r25
     8d6:	1e c0       	rjmp	.+60     	; 0x914 <TCP_TCPTask+0x72>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     8d8:	80 91 03 14 	lds	r24, 0x1403
     8dc:	81 30       	cpi	r24, 0x01	; 1
     8de:	89 f4       	brne	.+34     	; 0x902 <TCP_TCPTask+0x60>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     8e0:	0c 9d       	mul	r16, r12
     8e2:	c0 01       	movw	r24, r0
     8e4:	0d 9d       	mul	r16, r13
     8e6:	90 0d       	add	r25, r0
     8e8:	1c 9d       	mul	r17, r12
     8ea:	90 0d       	add	r25, r0
     8ec:	11 24       	eor	r1, r1
     8ee:	bc 01       	movw	r22, r24
     8f0:	61 53       	subi	r22, 0x31	; 49
     8f2:	72 4f       	sbci	r23, 0xF2	; 242
     8f4:	e0 91 04 14 	lds	r30, 0x1404
     8f8:	f0 91 05 14 	lds	r31, 0x1405
     8fc:	81 54       	subi	r24, 0x41	; 65
     8fe:	92 4f       	sbci	r25, 0xF2	; 242
     900:	09 95       	icall
     902:	0f 5f       	subi	r16, 0xFF	; 255
     904:	1f 4f       	sbci	r17, 0xFF	; 255
     906:	86 e1       	ldi	r24, 0x16	; 22
     908:	92 e0       	ldi	r25, 0x02	; 2
     90a:	e8 0e       	add	r14, r24
     90c:	f9 1e       	adc	r15, r25
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     90e:	03 30       	cpi	r16, 0x03	; 3
     910:	11 05       	cpc	r17, r1
     912:	59 f0       	breq	.+22     	; 0x92a <TCP_TCPTask+0x88>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     914:	80 91 01 14 	lds	r24, 0x1401
     918:	90 91 02 14 	lds	r25, 0x1402
     91c:	f7 01       	movw	r30, r14
     91e:	20 81       	ld	r18, Z
     920:	31 81       	ldd	r19, Z+1	; 0x01
     922:	82 17       	cp	r24, r18
     924:	93 07       	cpc	r25, r19
     926:	69 f7       	brne	.-38     	; 0x902 <TCP_TCPTask+0x60>
     928:	d7 cf       	rjmp	.-82     	; 0x8d8 <TCP_TCPTask+0x36>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     92a:	f4 01       	movw	r30, r8
     92c:	e4 52       	subi	r30, 0x24	; 36
     92e:	fa 4f       	sbci	r31, 0xFA	; 250
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	09 f0       	breq	.+2      	; 0x93a <TCP_TCPTask+0x98>
     938:	e0 c0       	rjmp	.+448    	; 0xafa <TCP_TCPTask+0x258>
     93a:	e2 ed       	ldi	r30, 0xD2	; 210
     93c:	ff e0       	ldi	r31, 0x0F	; 15
     93e:	aa 24       	eor	r10, r10
     940:	bb 24       	eor	r11, r11

/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
     942:	df 01       	movw	r26, r30
     944:	11 97       	sbiw	r26, 0x01	; 1

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     946:	8c 91       	ld	r24, X
     948:	88 23       	and	r24, r24
     94a:	09 f4       	brne	.+2      	; 0x94e <TCP_TCPTask+0xac>
     94c:	cc c0       	rjmp	.+408    	; 0xae6 <TCP_TCPTask+0x244>
     94e:	80 81       	ld	r24, Z
     950:	88 23       	and	r24, r24
     952:	09 f4       	brne	.+2      	; 0x956 <TCP_TCPTask+0xb4>
     954:	c8 c0       	rjmp	.+400    	; 0xae6 <TCP_TCPTask+0x244>
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
     956:	86 e1       	ldi	r24, 0x16	; 22
     958:	92 e0       	ldi	r25, 0x02	; 2
     95a:	a8 9e       	mul	r10, r24
     95c:	60 01       	movw	r12, r0
     95e:	a9 9e       	mul	r10, r25
     960:	d0 0c       	add	r13, r0
     962:	b8 9e       	mul	r11, r24
     964:	d0 0c       	add	r13, r0
     966:	11 24       	eor	r1, r1
     968:	86 01       	movw	r16, r12
     96a:	01 54       	subi	r16, 0x41	; 65
     96c:	12 4f       	sbci	r17, 0xF2	; 242
     96e:	f8 01       	movw	r30, r16
     970:	e0 88       	ldd	r14, Z+16	; 0x10
     972:	f1 88       	ldd	r15, Z+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
     974:	80 81       	ld	r24, Z
     976:	91 81       	ldd	r25, Z+1	; 0x01
     978:	f4 01       	movw	r30, r8
     97a:	93 a3       	lds	r25, 0x53
     97c:	82 a3       	lds	r24, 0x52
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
     97e:	f8 01       	movw	r30, r16
     980:	82 81       	ldd	r24, Z+2	; 0x02
     982:	93 81       	ldd	r25, Z+3	; 0x03
     984:	f4 01       	movw	r30, r8
     986:	95 a3       	lds	r25, 0x55
     988:	84 a3       	lds	r24, 0x54
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
     98a:	f8 01       	movw	r30, r16
     98c:	64 85       	ldd	r22, Z+12	; 0x0c
     98e:	75 85       	ldd	r23, Z+13	; 0x0d
     990:	86 85       	ldd	r24, Z+14	; 0x0e
     992:	97 85       	ldd	r25, Z+15	; 0x0f
     994:	fe de       	rcall	.-516    	; 0x792 <SwapEndian_32>
     996:	dc 01       	movw	r26, r24
     998:	cb 01       	movw	r24, r22
     99a:	f4 01       	movw	r30, r8
     99c:	86 a3       	lds	r24, 0x56
     99e:	97 a3       	lds	r25, 0x57
     9a0:	a0 a7       	lds	r26, 0x70
     9a2:	b1 a7       	lds	r27, 0x71
     9a4:	f8 01       	movw	r30, r16
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
     9a6:	60 85       	ldd	r22, Z+8	; 0x08
     9a8:	71 85       	ldd	r23, Z+9	; 0x09
     9aa:	82 85       	ldd	r24, Z+10	; 0x0a
     9ac:	93 85       	ldd	r25, Z+11	; 0x0b
     9ae:	f1 de       	rcall	.-542    	; 0x792 <SwapEndian_32>
     9b0:	dc 01       	movw	r26, r24
     9b2:	cb 01       	movw	r24, r22
     9b4:	f4 01       	movw	r30, r8
     9b6:	82 a7       	lds	r24, 0x72
     9b8:	93 a7       	lds	r25, 0x73
     9ba:	a4 a7       	lds	r26, 0x74
     9bc:	b5 a7       	lds	r27, 0x75
     9be:	26 a5       	lds	r18, 0x66
     9c0:	2f 70       	andi	r18, 0x0F	; 15
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
     9c2:	20 65       	ori	r18, 0x50	; 80
     9c4:	26 a7       	lds	r18, 0x76
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	92 e0       	ldi	r25, 0x02	; 2
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
     9ca:	29 83       	std	Y+1, r18	; 0x01
     9cc:	e8 de       	rcall	.-560    	; 0x79e <SwapEndian_16>
     9ce:	f4 01       	movw	r30, r8
     9d0:	91 ab       	sts	0x51, r25
     9d2:	80 ab       	sts	0x50, r24
     9d4:	80 e1       	ldi	r24, 0x10	; 16
     9d6:	87 a7       	lds	r24, 0x77
     9d8:	15 aa       	sts	0x95, r17

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
     9da:	14 aa       	sts	0x94, r17
     9dc:	13 aa       	sts	0x93, r17
			TCPHeaderOUT->UrgentPointer        = 0;
     9de:	12 aa       	sts	0x92, r17
     9e0:	29 81       	ldd	r18, Y+1	; 0x01
			TCPHeaderOUT->Checksum             = 0;
     9e2:	20 7f       	andi	r18, 0xF0	; 240
     9e4:	26 a7       	lds	r18, 0x76
			TCPHeaderOUT->Reserved             = 0;
     9e6:	c4 01       	movw	r24, r8
     9e8:	c6 96       	adiw	r24, 0x36	; 54
     9ea:	b6 01       	movw	r22, r12
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
     9ec:	6f 52       	subi	r22, 0x2F	; 47
     9ee:	72 4f       	sbci	r23, 0xF2	; 242
			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
			TCPHeaderOUT->UrgentPointer        = 0;
			TCPHeaderOUT->Checksum             = 0;
			TCPHeaderOUT->Reserved             = 0;

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
     9f0:	a7 01       	movw	r20, r14
     9f2:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <memcpy>
     9f6:	c7 01       	movw	r24, r14
     9f8:	a0 e0       	ldi	r26, 0x00	; 0
     9fa:	b0 e0       	ldi	r27, 0x00	; 0

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
     9fc:	f8 01       	movw	r30, r16
     9fe:	44 85       	ldd	r20, Z+12	; 0x0c
     a00:	55 85       	ldd	r21, Z+13	; 0x0d
     a02:	66 85       	ldd	r22, Z+14	; 0x0e
     a04:	77 85       	ldd	r23, Z+15	; 0x0f
     a06:	84 0f       	add	r24, r20
     a08:	95 1f       	adc	r25, r21
     a0a:	a6 1f       	adc	r26, r22
     a0c:	b7 1f       	adc	r27, r23
     a0e:	84 87       	std	Z+12, r24	; 0x0c
     a10:	95 87       	std	Z+13, r25	; 0x0d
     a12:	a6 87       	std	Z+14, r26	; 0x0e
     a14:	b7 87       	std	Z+15, r27	; 0x0f
     a16:	a6 01       	movw	r20, r12
     a18:	4d 53       	subi	r20, 0x3D	; 61
     a1a:	52 4f       	sbci	r21, 0xF2	; 242

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
     a1c:	97 01       	movw	r18, r14
     a1e:	2c 5e       	subi	r18, 0xEC	; 236
     a20:	3f 4f       	sbci	r19, 0xFF	; 255

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
     a22:	c4 01       	movw	r24, r8
     a24:	82 96       	adiw	r24, 0x22	; 34
     a26:	64 ec       	ldi	r22, 0xC4	; 196
     a28:	71 e0       	ldi	r23, 0x01	; 1
     a2a:	bd de       	rcall	.-646    	; 0x7a6 <TCP_Checksum16>
     a2c:	f4 01       	movw	r30, r8
     a2e:	93 ab       	sts	0x53, r25
     a30:	82 ab       	sts	0x52, r24
     a32:	c7 01       	movw	r24, r14
     a34:	88 96       	adiw	r24, 0x28	; 40
     a36:	b3 de       	rcall	.-666    	; 0x79e <SwapEndian_16>
     a38:	f4 01       	movw	r30, r8
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
     a3a:	91 8b       	std	Z+17, r25	; 0x11
     a3c:	80 8b       	std	Z+16, r24	; 0x10
     a3e:	17 86       	std	Z+15, r1	; 0x0f
     a40:	85 e4       	ldi	r24, 0x45	; 69
     a42:	86 87       	std	Z+14, r24	; 0x0e
     a44:	14 8a       	std	Z+20, r1	; 0x14
     a46:	15 8a       	std	Z+21, r1	; 0x15
			IPHeaderOUT->TypeOfService      = 0;
     a48:	13 8a       	std	Z+19, r1	; 0x13
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
     a4a:	12 8a       	std	Z+18, r1	; 0x12
     a4c:	11 8e       	std	Z+25, r1	; 0x19
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
     a4e:	10 8e       	std	Z+24, r1	; 0x18
     a50:	86 e0       	ldi	r24, 0x06	; 6
			IPHeaderOUT->Identification     = 0;
     a52:	87 8b       	std	Z+23, r24	; 0x17
     a54:	80 e8       	ldi	r24, 0x80	; 128
			IPHeaderOUT->HeaderChecksum     = 0;
     a56:	86 8b       	std	Z+22, r24	; 0x16
     a58:	80 91 c4 01 	lds	r24, 0x01C4
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
     a5c:	90 91 c5 01 	lds	r25, 0x01C5
			IPHeaderOUT->TTL                = DEFAULT_TTL;
     a60:	a0 91 c6 01 	lds	r26, 0x01C6
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
     a64:	b0 91 c7 01 	lds	r27, 0x01C7
     a68:	82 8f       	std	Z+26, r24	; 0x1a
     a6a:	93 8f       	std	Z+27, r25	; 0x1b
     a6c:	a4 8f       	std	Z+28, r26	; 0x1c
     a6e:	b5 8f       	std	Z+29, r27	; 0x1d
     a70:	f8 01       	movw	r30, r16
     a72:	84 81       	ldd	r24, Z+4	; 0x04
     a74:	95 81       	ldd	r25, Z+5	; 0x05
     a76:	a6 81       	ldd	r26, Z+6	; 0x06
     a78:	b7 81       	ldd	r27, Z+7	; 0x07
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
     a7a:	f4 01       	movw	r30, r8
     a7c:	86 8f       	std	Z+30, r24	; 0x1e
     a7e:	97 8f       	std	Z+31, r25	; 0x1f
     a80:	a0 a3       	lds	r26, 0x50
     a82:	b1 a3       	lds	r27, 0x51
     a84:	c4 01       	movw	r24, r8
     a86:	0e 96       	adiw	r24, 0x0e	; 14
     a88:	64 e1       	ldi	r22, 0x14	; 20
     a8a:	70 e0       	ldi	r23, 0x00	; 0
     a8c:	06 de       	rcall	.-1012   	; 0x69a <Ethernet_Checksum16>

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     a8e:	f4 01       	movw	r30, r8
     a90:	91 8f       	std	Z+25, r25	; 0x19
     a92:	80 8f       	std	Z+24, r24	; 0x18
     a94:	36 96       	adiw	r30, 0x06	; 6
     a96:	a8 ec       	ldi	r26, 0xC8	; 200
     a98:	b1 e0       	ldi	r27, 0x01	; 1
     a9a:	86 e0       	ldi	r24, 0x06	; 6
     a9c:	0d 90       	ld	r0, X+
     a9e:	01 92       	st	Z+, r0

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     aa0:	81 50       	subi	r24, 0x01	; 1
     aa2:	e1 f7       	brne	.-8      	; 0xa9c <TCP_TCPTask+0x1fa>
     aa4:	f4 01       	movw	r30, r8
     aa6:	ae ec       	ldi	r26, 0xCE	; 206
     aa8:	b1 e0       	ldi	r27, 0x01	; 1
     aaa:	86 e0       	ldi	r24, 0x06	; 6
     aac:	0d 90       	ld	r0, X+
     aae:	01 92       	st	Z+, r0
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
     ab0:	81 50       	subi	r24, 0x01	; 1
     ab2:	e1 f7       	brne	.-8      	; 0xaac <TCP_TCPTask+0x20a>
     ab4:	80 e0       	ldi	r24, 0x00	; 0
     ab6:	98 e0       	ldi	r25, 0x08	; 8
     ab8:	72 de       	rcall	.-796    	; 0x79e <SwapEndian_16>
     aba:	f4 01       	movw	r30, r8
     abc:	95 87       	std	Z+13, r25	; 0x0d
     abe:	84 87       	std	Z+12, r24	; 0x0c
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
     ac0:	e4 52       	subi	r30, 0x24	; 36
     ac2:	fa 4f       	sbci	r31, 0xFA	; 250
     ac4:	c7 01       	movw	r24, r14
     ac6:	c6 96       	adiw	r24, 0x36	; 54
     ac8:	91 83       	std	Z+1, r25	; 0x01
     aca:	80 83       	st	Z, r24
     acc:	86 e1       	ldi	r24, 0x16	; 22

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     ace:	92 e0       	ldi	r25, 0x02	; 2
     ad0:	a8 9e       	mul	r10, r24
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);

			PacketSize += sizeof(Ethernet_Frame_Header_t);
     ad2:	f0 01       	movw	r30, r0
     ad4:	a9 9e       	mul	r10, r25

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     ad6:	f0 0d       	add	r31, r0
     ad8:	b8 9e       	mul	r11, r24

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
     ada:	f0 0d       	add	r31, r0
     adc:	11 24       	eor	r1, r1
     ade:	ee 52       	subi	r30, 0x2E	; 46
     ae0:	f0 4f       	sbci	r31, 0xF0	; 240
     ae2:	10 82       	st	Z, r1
     ae4:	0a c0       	rjmp	.+20     	; 0xafa <TCP_TCPTask+0x258>
     ae6:	08 94       	sec
     ae8:	a1 1c       	adc	r10, r1
     aea:	b1 1c       	adc	r11, r1
     aec:	ea 5e       	subi	r30, 0xEA	; 234
     aee:	fd 4f       	sbci	r31, 0xFD	; 253
     af0:	83 e0       	ldi	r24, 0x03	; 3

			break;
     af2:	a8 16       	cp	r10, r24
     af4:	b1 04       	cpc	r11, r1
     af6:	09 f0       	breq	.+2      	; 0xafa <TCP_TCPTask+0x258>
     af8:	24 cf       	rjmp	.-440    	; 0x942 <TCP_TCPTask+0xa0>
     afa:	0f 90       	pop	r0
     afc:	df 91       	pop	r29
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     afe:	cf 91       	pop	r28
     b00:	1f 91       	pop	r17
     b02:	0f 91       	pop	r16
     b04:	ff 90       	pop	r15
     b06:	ef 90       	pop	r14
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
     b08:	df 90       	pop	r13
     b0a:	cf 90       	pop	r12
     b0c:	bf 90       	pop	r11
     b0e:	af 90       	pop	r10
     b10:	9f 90       	pop	r9
     b12:	8f 90       	pop	r8
     b14:	08 95       	ret

00000b16 <TCP_Init>:
     b16:	10 92 03 14 	sts	0x1403, r1
     b1a:	8a e0       	ldi	r24, 0x0A	; 10
     b1c:	80 93 d4 0f 	sts	0x0FD4, r24
     b20:	80 93 ea 11 	sts	0x11EA, r24
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     b24:	80 93 00 14 	sts	0x1400, r24
}
     b28:	08 95       	ret

00000b2a <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     b2a:	20 91 01 14 	lds	r18, 0x1401
     b2e:	30 91 02 14 	lds	r19, 0x1402
     b32:	28 17       	cp	r18, r24
     b34:	39 07       	cpc	r19, r25
     b36:	51 f0       	breq	.+20     	; 0xb4c <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     b38:	61 30       	cpi	r22, 0x01	; 1
     b3a:	71 f4       	brne	.+28     	; 0xb58 <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     b3c:	20 91 03 14 	lds	r18, 0x1403
     b40:	22 23       	and	r18, r18
     b42:	61 f4       	brne	.+24     	; 0xb5c <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
     b44:	90 93 02 14 	sts	0x1402, r25
     b48:	80 93 01 14 	sts	0x1401, r24
				PortStateTable[PTableEntry].State = State;
     b4c:	60 93 03 14 	sts	0x1403, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     b50:	50 93 05 14 	sts	0x1405, r21
     b54:	40 93 04 14 	sts	0x1404, r20
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
     b5c:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     b5e:	08 95       	ret

00000b60 <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     b60:	20 91 01 14 	lds	r18, 0x1401
     b64:	30 91 02 14 	lds	r19, 0x1402
     b68:	28 17       	cp	r18, r24
     b6a:	39 07       	cpc	r19, r25
     b6c:	19 f4       	brne	.+6      	; 0xb74 <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
     b6e:	80 91 03 14 	lds	r24, 0x1403
     b72:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
     b74:	80 e0       	ldi	r24, 0x00	; 0
}
     b76:	08 95       	ret

00000b78 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     b78:	4f 92       	push	r4
     b7a:	5f 92       	push	r5
     b7c:	6f 92       	push	r6
     b7e:	7f 92       	push	r7
     b80:	8f 92       	push	r8
     b82:	9f 92       	push	r9
     b84:	af 92       	push	r10
     b86:	bf 92       	push	r11
     b88:	df 92       	push	r13
     b8a:	ef 92       	push	r14
     b8c:	ff 92       	push	r15
     b8e:	0f 93       	push	r16
     b90:	1f 93       	push	r17
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
     b96:	5c 01       	movw	r10, r24
     b98:	4b 01       	movw	r8, r22
     b9a:	3a 01       	movw	r6, r20
     b9c:	d2 2e       	mov	r13, r18
			ConnectionStateTable[CSTableEntry].State         = State;
			return true;
		}
	}

	return false;
     b9e:	cf eb       	ldi	r28, 0xBF	; 191
     ba0:	dd e0       	ldi	r29, 0x0D	; 13
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     ba2:	00 e0       	ldi	r16, 0x00	; 0
     ba4:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     ba6:	26 e1       	ldi	r18, 0x16	; 22
     ba8:	42 2e       	mov	r4, r18
     baa:	22 e0       	ldi	r18, 0x02	; 2
     bac:	52 2e       	mov	r5, r18
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     bae:	88 81       	ld	r24, Y
     bb0:	99 81       	ldd	r25, Y+1	; 0x01
     bb2:	8a 15       	cp	r24, r10
     bb4:	9b 05       	cpc	r25, r11
     bb6:	d1 f4       	brne	.+52     	; 0xbec <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     bb8:	04 9d       	mul	r16, r4
     bba:	70 01       	movw	r14, r0
     bbc:	05 9d       	mul	r16, r5
     bbe:	f0 0c       	add	r15, r0
     bc0:	14 9d       	mul	r17, r4
     bc2:	f0 0c       	add	r15, r0
     bc4:	11 24       	eor	r1, r1
     bc6:	c7 01       	movw	r24, r14
     bc8:	8d 53       	subi	r24, 0x3D	; 61
     bca:	92 4f       	sbci	r25, 0xF2	; 242
     bcc:	b4 01       	movw	r22, r8
     bce:	44 e0       	ldi	r20, 0x04	; 4
     bd0:	50 e0       	ldi	r21, 0x00	; 0
     bd2:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     bd6:	00 97       	sbiw	r24, 0x00	; 0
     bd8:	49 f4       	brne	.+18     	; 0xbec <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     bda:	8a 81       	ldd	r24, Y+2	; 0x02
     bdc:	9b 81       	ldd	r25, Y+3	; 0x03
     bde:	86 15       	cp	r24, r6
     be0:	97 05       	cpc	r25, r7
     be2:	21 f4       	brne	.+8      	; 0xbec <TCP_SetConnectionState+0x74>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     be4:	f7 01       	movw	r30, r14
     be6:	ec 52       	subi	r30, 0x2C	; 44
     be8:	f0 4f       	sbci	r31, 0xF0	; 240
     bea:	33 c0       	rjmp	.+102    	; 0xc52 <TCP_SetConnectionState+0xda>
			return true;
     bec:	0f 5f       	subi	r16, 0xFF	; 255
     bee:	1f 4f       	sbci	r17, 0xFF	; 255
     bf0:	ca 5e       	subi	r28, 0xEA	; 234
     bf2:	dd 4f       	sbci	r29, 0xFD	; 253
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bf4:	03 30       	cpi	r16, 0x03	; 3
     bf6:	11 05       	cpc	r17, r1
     bf8:	d1 f6       	brne	.-76     	; 0xbae <TCP_SetConnectionState+0x36>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     bfa:	80 91 d4 0f 	lds	r24, 0x0FD4
     bfe:	8a 30       	cpi	r24, 0x0A	; 10
     c00:	51 f0       	breq	.+20     	; 0xc16 <TCP_SetConnectionState+0x9e>
     c02:	80 91 ea 11 	lds	r24, 0x11EA
     c06:	8a 30       	cpi	r24, 0x0A	; 10
     c08:	41 f0       	breq	.+16     	; 0xc1a <TCP_SetConnectionState+0xa2>
     c0a:	80 91 00 14 	lds	r24, 0x1400
     c0e:	8a 30       	cpi	r24, 0x0A	; 10
     c10:	19 f5       	brne	.+70     	; 0xc58 <TCP_SetConnectionState+0xe0>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c12:	82 e0       	ldi	r24, 0x02	; 2
     c14:	03 c0       	rjmp	.+6      	; 0xc1c <TCP_SetConnectionState+0xa4>
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     c16:	80 e0       	ldi	r24, 0x00	; 0
     c18:	01 c0       	rjmp	.+2      	; 0xc1c <TCP_SetConnectionState+0xa4>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c1a:	81 e0       	ldi	r24, 0x01	; 1
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	26 e1       	ldi	r18, 0x16	; 22
     c20:	32 e0       	ldi	r19, 0x02	; 2
     c22:	82 9f       	mul	r24, r18
     c24:	f0 01       	movw	r30, r0
     c26:	83 9f       	mul	r24, r19
     c28:	f0 0d       	add	r31, r0
     c2a:	92 9f       	mul	r25, r18
     c2c:	f0 0d       	add	r31, r0
     c2e:	11 24       	eor	r1, r1
     c30:	e1 54       	subi	r30, 0x41	; 65
     c32:	f2 4f       	sbci	r31, 0xF2	; 242
     c34:	b1 82       	std	Z+1, r11	; 0x01
     c36:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
     c38:	e4 01       	movw	r28, r8
     c3a:	88 81       	ld	r24, Y
     c3c:	99 81       	ldd	r25, Y+1	; 0x01
     c3e:	aa 81       	ldd	r26, Y+2	; 0x02
     c40:	bb 81       	ldd	r27, Y+3	; 0x03
     c42:	84 83       	std	Z+4, r24	; 0x04
     c44:	95 83       	std	Z+5, r25	; 0x05
     c46:	a6 83       	std	Z+6, r26	; 0x06
     c48:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     c4a:	73 82       	std	Z+3, r7	; 0x03
     c4c:	62 82       	std	Z+2, r6	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
     c4e:	eb 5e       	subi	r30, 0xEB	; 235
     c50:	fd 4f       	sbci	r31, 0xFD	; 253
     c52:	d0 82       	st	Z, r13
			return true;
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	01 c0       	rjmp	.+2      	; 0xc5a <TCP_SetConnectionState+0xe2>
		}
	}

	return false;
     c58:	80 e0       	ldi	r24, 0x00	; 0
}
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	ff 90       	pop	r15
     c64:	ef 90       	pop	r14
     c66:	df 90       	pop	r13
     c68:	bf 90       	pop	r11
     c6a:	af 90       	pop	r10
     c6c:	9f 90       	pop	r9
     c6e:	8f 90       	pop	r8
     c70:	7f 90       	pop	r7
     c72:	6f 90       	pop	r6
     c74:	5f 90       	pop	r5
     c76:	4f 90       	pop	r4
     c78:	08 95       	ret

00000c7a <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
     c7a:	6f 92       	push	r6
     c7c:	7f 92       	push	r7
     c7e:	8f 92       	push	r8
     c80:	9f 92       	push	r9
     c82:	af 92       	push	r10
     c84:	bf 92       	push	r11
     c86:	cf 92       	push	r12
     c88:	df 92       	push	r13
     c8a:	ef 92       	push	r14
     c8c:	ff 92       	push	r15
     c8e:	0f 93       	push	r16
     c90:	1f 93       	push	r17
     c92:	cf 93       	push	r28
     c94:	df 93       	push	r29
     c96:	6c 01       	movw	r12, r24
     c98:	5b 01       	movw	r10, r22
     c9a:	4a 01       	movw	r8, r20
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     c9c:	cf eb       	ldi	r28, 0xBF	; 191
     c9e:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
     ca0:	00 e0       	ldi	r16, 0x00	; 0
     ca2:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     ca4:	36 e1       	ldi	r19, 0x16	; 22
     ca6:	63 2e       	mov	r6, r19
     ca8:	32 e0       	ldi	r19, 0x02	; 2
     caa:	73 2e       	mov	r7, r19
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     cac:	88 81       	ld	r24, Y
     cae:	99 81       	ldd	r25, Y+1	; 0x01
     cb0:	8c 15       	cp	r24, r12
     cb2:	9d 05       	cpc	r25, r13
     cb4:	d9 f4       	brne	.+54     	; 0xcec <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     cb6:	06 9d       	mul	r16, r6
     cb8:	70 01       	movw	r14, r0
     cba:	07 9d       	mul	r16, r7
     cbc:	f0 0c       	add	r15, r0
     cbe:	16 9d       	mul	r17, r6
     cc0:	f0 0c       	add	r15, r0
     cc2:	11 24       	eor	r1, r1
     cc4:	c7 01       	movw	r24, r14
     cc6:	8d 53       	subi	r24, 0x3D	; 61
     cc8:	92 4f       	sbci	r25, 0xF2	; 242
     cca:	b5 01       	movw	r22, r10
     ccc:	44 e0       	ldi	r20, 0x04	; 4
     cce:	50 e0       	ldi	r21, 0x00	; 0
     cd0:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     cd4:	00 97       	sbiw	r24, 0x00	; 0
     cd6:	51 f4       	brne	.+20     	; 0xcec <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     cd8:	8a 81       	ldd	r24, Y+2	; 0x02
     cda:	9b 81       	ldd	r25, Y+3	; 0x03
     cdc:	88 15       	cp	r24, r8
     cde:	99 05       	cpc	r25, r9
     ce0:	29 f4       	brne	.+10     	; 0xcec <TCP_GetConnectionState+0x72>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     ce2:	f7 01       	movw	r30, r14
     ce4:	ec 52       	subi	r30, 0x2C	; 44
     ce6:	f0 4f       	sbci	r31, 0xF0	; 240
     ce8:	80 81       	ld	r24, Z
     cea:	08 c0       	rjmp	.+16     	; 0xcfc <TCP_GetConnectionState+0x82>
     cec:	0f 5f       	subi	r16, 0xFF	; 255
     cee:	1f 4f       	sbci	r17, 0xFF	; 255
     cf0:	ca 5e       	subi	r28, 0xEA	; 234
     cf2:	dd 4f       	sbci	r29, 0xFD	; 253
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     cf4:	03 30       	cpi	r16, 0x03	; 3
     cf6:	11 05       	cpc	r17, r1
     cf8:	c9 f6       	brne	.-78     	; 0xcac <TCP_GetConnectionState+0x32>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     cfa:	8a e0       	ldi	r24, 0x0A	; 10
}
     cfc:	df 91       	pop	r29
     cfe:	cf 91       	pop	r28
     d00:	1f 91       	pop	r17
     d02:	0f 91       	pop	r16
     d04:	ff 90       	pop	r15
     d06:	ef 90       	pop	r14
     d08:	df 90       	pop	r13
     d0a:	cf 90       	pop	r12
     d0c:	bf 90       	pop	r11
     d0e:	af 90       	pop	r10
     d10:	9f 90       	pop	r9
     d12:	8f 90       	pop	r8
     d14:	7f 90       	pop	r7
     d16:	6f 90       	pop	r6
     d18:	08 95       	ret

00000d1a <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
     d1a:	6f 92       	push	r6
     d1c:	7f 92       	push	r7
     d1e:	8f 92       	push	r8
     d20:	9f 92       	push	r9
     d22:	af 92       	push	r10
     d24:	bf 92       	push	r11
     d26:	cf 92       	push	r12
     d28:	df 92       	push	r13
     d2a:	ef 92       	push	r14
     d2c:	ff 92       	push	r15
     d2e:	0f 93       	push	r16
     d30:	1f 93       	push	r17
     d32:	cf 93       	push	r28
     d34:	df 93       	push	r29
     d36:	6c 01       	movw	r12, r24
     d38:	5b 01       	movw	r10, r22
     d3a:	4a 01       	movw	r8, r20
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     d3c:	cf eb       	ldi	r28, 0xBF	; 191
     d3e:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
     d40:	00 e0       	ldi	r16, 0x00	; 0
     d42:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     d44:	e6 e1       	ldi	r30, 0x16	; 22
     d46:	6e 2e       	mov	r6, r30
     d48:	e2 e0       	ldi	r30, 0x02	; 2
     d4a:	7e 2e       	mov	r7, r30
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d4c:	88 81       	ld	r24, Y
     d4e:	99 81       	ldd	r25, Y+1	; 0x01
     d50:	8c 15       	cp	r24, r12
     d52:	9d 05       	cpc	r25, r13
     d54:	d1 f4       	brne	.+52     	; 0xd8a <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     d56:	06 9d       	mul	r16, r6
     d58:	70 01       	movw	r14, r0
     d5a:	07 9d       	mul	r16, r7
     d5c:	f0 0c       	add	r15, r0
     d5e:	16 9d       	mul	r17, r6
     d60:	f0 0c       	add	r15, r0
     d62:	11 24       	eor	r1, r1
     d64:	c7 01       	movw	r24, r14
     d66:	8d 53       	subi	r24, 0x3D	; 61
     d68:	92 4f       	sbci	r25, 0xF2	; 242
     d6a:	b5 01       	movw	r22, r10
     d6c:	44 e0       	ldi	r20, 0x04	; 4
     d6e:	50 e0       	ldi	r21, 0x00	; 0
     d70:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d74:	00 97       	sbiw	r24, 0x00	; 0
     d76:	49 f4       	brne	.+18     	; 0xd8a <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     d78:	8a 81       	ldd	r24, Y+2	; 0x02
     d7a:	9b 81       	ldd	r25, Y+3	; 0x03
     d7c:	88 15       	cp	r24, r8
     d7e:	99 05       	cpc	r25, r9
     d80:	21 f4       	brne	.+8      	; 0xd8a <TCP_GetConnectionInfo+0x70>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     d82:	c7 01       	movw	r24, r14
     d84:	89 53       	subi	r24, 0x39	; 57
     d86:	92 4f       	sbci	r25, 0xF2	; 242
     d88:	09 c0       	rjmp	.+18     	; 0xd9c <TCP_GetConnectionInfo+0x82>
     d8a:	0f 5f       	subi	r16, 0xFF	; 255
     d8c:	1f 4f       	sbci	r17, 0xFF	; 255
     d8e:	ca 5e       	subi	r28, 0xEA	; 234
     d90:	dd 4f       	sbci	r29, 0xFD	; 253
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d92:	03 30       	cpi	r16, 0x03	; 3
     d94:	11 05       	cpc	r17, r1
     d96:	d1 f6       	brne	.-76     	; 0xd4c <TCP_GetConnectionInfo+0x32>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     d98:	80 e0       	ldi	r24, 0x00	; 0
     d9a:	90 e0       	ldi	r25, 0x00	; 0
}
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	1f 91       	pop	r17
     da2:	0f 91       	pop	r16
     da4:	ff 90       	pop	r15
     da6:	ef 90       	pop	r14
     da8:	df 90       	pop	r13
     daa:	cf 90       	pop	r12
     dac:	bf 90       	pop	r11
     dae:	af 90       	pop	r10
     db0:	9f 90       	pop	r9
     db2:	8f 90       	pop	r8
     db4:	7f 90       	pop	r7
     db6:	6f 90       	pop	r6
     db8:	08 95       	ret

00000dba <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     dba:	6f 92       	push	r6
     dbc:	7f 92       	push	r7
     dbe:	8f 92       	push	r8
     dc0:	9f 92       	push	r9
     dc2:	af 92       	push	r10
     dc4:	bf 92       	push	r11
     dc6:	cf 92       	push	r12
     dc8:	df 92       	push	r13
     dca:	ef 92       	push	r14
     dcc:	ff 92       	push	r15
     dce:	0f 93       	push	r16
     dd0:	1f 93       	push	r17
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	3c 01       	movw	r6, r24
     dd8:	5b 01       	movw	r10, r22
     dda:	4a 01       	movw	r8, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     ddc:	cb 01       	movw	r24, r22
     dde:	93 dc       	rcall	.-1754   	; 0x706 <DecodeTCPHeader>
     de0:	d5 01       	movw	r26, r10

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     de2:	12 96       	adiw	r26, 0x02	; 2
     de4:	cd 91       	ld	r28, X+
     de6:	dc 91       	ld	r29, X
     de8:	13 97       	sbiw	r26, 0x03	; 3
     dea:	ce 01       	movw	r24, r28
     dec:	b9 de       	rcall	.-654    	; 0xb60 <TCP_GetPortState>
     dee:	81 30       	cpi	r24, 0x01	; 1
     df0:	09 f0       	breq	.+2      	; 0xdf4 <TCP_ProcessTCPPacket+0x3a>
     df2:	8e c1       	rjmp	.+796    	; 0x1110 <TCP_ProcessTCPPacket+0x356>
     df4:	f5 01       	movw	r30, r10
     df6:	85 85       	ldd	r24, Z+13	; 0x0d
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     df8:	81 ff       	sbrs	r24, 1
     dfa:	08 c0       	rjmp	.+16     	; 0xe0c <TCP_ProcessTCPPacket+0x52>
     dfc:	b3 01       	movw	r22, r6
     dfe:	64 5f       	subi	r22, 0xF4	; 244
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     e00:	7f 4f       	sbci	r23, 0xFF	; 255
     e02:	40 81       	ld	r20, Z
     e04:	51 81       	ldd	r21, Z+1	; 0x01
     e06:	ce 01       	movw	r24, r28
     e08:	20 e0       	ldi	r18, 0x00	; 0
     e0a:	b6 de       	rcall	.-660    	; 0xb78 <TCP_SetConnectionState>
     e0c:	d5 01       	movw	r26, r10
     e0e:	1d 96       	adiw	r26, 0x0d	; 13
     e10:	cc 91       	ld	r28, X

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     e12:	1d 97       	sbiw	r26, 0x0d	; 13
     e14:	12 96       	adiw	r26, 0x02	; 2
     e16:	0d 91       	ld	r16, X+
     e18:	1c 91       	ld	r17, X
     e1a:	13 97       	sbiw	r26, 0x03	; 3
     e1c:	5c e0       	ldi	r21, 0x0C	; 12
     e1e:	c5 2e       	mov	r12, r21
     e20:	d1 2c       	mov	r13, r1
     e22:	c6 0c       	add	r12, r6
     e24:	d7 1c       	adc	r13, r7
     e26:	ed 90       	ld	r14, X+
     e28:	fc 90       	ld	r15, X
     e2a:	11 97       	sbiw	r26, 0x01	; 1
     e2c:	c8 01       	movw	r24, r16
     e2e:	b6 01       	movw	r22, r12
     e30:	a7 01       	movw	r20, r14
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     e32:	c2 ff       	sbrs	r28, 2
     e34:	07 c0       	rjmp	.+14     	; 0xe44 <TCP_ProcessTCPPacket+0x8a>
     e36:	2a e0       	ldi	r18, 0x0A	; 10
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     e38:	9f de       	rcall	.-706    	; 0xb78 <TCP_SetConnectionState>
     e3a:	88 23       	and	r24, r24
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     e3c:	09 f4       	brne	.+2      	; 0xe40 <TCP_ProcessTCPPacket+0x86>
     e3e:	96 c1       	rjmp	.+812    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     e40:	84 e1       	ldi	r24, 0x14	; 20
     e42:	11 c1       	rjmp	.+546    	; 0x1066 <TCP_ProcessTCPPacket+0x2ac>
     e44:	1a df       	rcall	.-460    	; 0xc7a <TCP_GetConnectionState>
     e46:	84 30       	cpi	r24, 0x04	; 4
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     e48:	09 f4       	brne	.+2      	; 0xe4c <TCP_ProcessTCPPacket+0x92>
     e4a:	25 c1       	rjmp	.+586    	; 0x1096 <TCP_ProcessTCPPacket+0x2dc>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     e4c:	85 30       	cpi	r24, 0x05	; 5
     e4e:	48 f4       	brcc	.+18     	; 0xe62 <TCP_ProcessTCPPacket+0xa8>
     e50:	82 30       	cpi	r24, 0x02	; 2
     e52:	09 f4       	brne	.+2      	; 0xe56 <TCP_ProcessTCPPacket+0x9c>
     e54:	41 c0       	rjmp	.+130    	; 0xed8 <TCP_ProcessTCPPacket+0x11e>
     e56:	83 30       	cpi	r24, 0x03	; 3
     e58:	08 f0       	brcs	.+2      	; 0xe5c <TCP_ProcessTCPPacket+0xa2>
     e5a:	5e c0       	rjmp	.+188    	; 0xf18 <TCP_ProcessTCPPacket+0x15e>
     e5c:	88 23       	and	r24, r24
     e5e:	59 f0       	breq	.+22     	; 0xe76 <TCP_ProcessTCPPacket+0xbc>
     e60:	85 c1       	rjmp	.+778    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     e62:	86 30       	cpi	r24, 0x06	; 6
     e64:	09 f4       	brne	.+2      	; 0xe68 <TCP_ProcessTCPPacket+0xae>
     e66:	4c c1       	rjmp	.+664    	; 0x1100 <TCP_ProcessTCPPacket+0x346>
     e68:	86 30       	cpi	r24, 0x06	; 6
     e6a:	08 f4       	brcc	.+2      	; 0xe6e <TCP_ProcessTCPPacket+0xb4>
     e6c:	1e c1       	rjmp	.+572    	; 0x10aa <TCP_ProcessTCPPacket+0x2f0>
     e6e:	87 30       	cpi	r24, 0x07	; 7
     e70:	09 f0       	breq	.+2      	; 0xe74 <TCP_ProcessTCPPacket+0xba>
     e72:	7c c1       	rjmp	.+760    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     e74:	fb c0       	rjmp	.+502    	; 0x106c <TCP_ProcessTCPPacket+0x2b2>
     e76:	c2 30       	cpi	r28, 0x02	; 2
     e78:	09 f0       	breq	.+2      	; 0xe7c <TCP_ProcessTCPPacket+0xc2>
     e7a:	78 c1       	rjmp	.+752    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     e7c:	c8 01       	movw	r24, r16
     e7e:	b6 01       	movw	r22, r12
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     e80:	a7 01       	movw	r20, r14
     e82:	22 e0       	ldi	r18, 0x02	; 2
     e84:	79 de       	rcall	.-782    	; 0xb78 <TCP_SetConnectionState>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     e86:	88 23       	and	r24, r24
     e88:	29 f1       	breq	.+74     	; 0xed4 <TCP_ProcessTCPPacket+0x11a>
     e8a:	82 e1       	ldi	r24, 0x12	; 18
     e8c:	d4 01       	movw	r26, r8
     e8e:	1d 96       	adiw	r26, 0x0d	; 13
     e90:	8c 93       	st	X, r24
     e92:	f5 01       	movw	r30, r10
     e94:	40 81       	ld	r20, Z
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     e96:	51 81       	ldd	r21, Z+1	; 0x01
     e98:	82 81       	ldd	r24, Z+2	; 0x02
     e9a:	93 81       	ldd	r25, Z+3	; 0x03
     e9c:	b6 01       	movw	r22, r12

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     e9e:	3d df       	rcall	.-390    	; 0xd1a <TCP_GetConnectionInfo>
     ea0:	ec 01       	movw	r28, r24
     ea2:	d5 01       	movw	r26, r10
     ea4:	14 96       	adiw	r26, 0x04	; 4
     ea6:	6d 91       	ld	r22, X+
     ea8:	7d 91       	ld	r23, X+
     eaa:	8d 91       	ld	r24, X+
     eac:	9c 91       	ld	r25, X
     eae:	17 97       	sbiw	r26, 0x07	; 7

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     eb0:	70 dc       	rcall	.-1824   	; 0x792 <SwapEndian_32>
     eb2:	dc 01       	movw	r26, r24
     eb4:	cb 01       	movw	r24, r22
     eb6:	01 96       	adiw	r24, 0x01	; 1
     eb8:	a1 1d       	adc	r26, r1
     eba:	b1 1d       	adc	r27, r1
     ebc:	88 83       	st	Y, r24
     ebe:	99 83       	std	Y+1, r25	; 0x01
     ec0:	aa 83       	std	Y+2, r26	; 0x02
     ec2:	bb 83       	std	Y+3, r27	; 0x03
     ec4:	1c 82       	std	Y+4, r1	; 0x04
     ec6:	1d 82       	std	Y+5, r1	; 0x05
     ec8:	1e 82       	std	Y+6, r1	; 0x06
     eca:	1f 82       	std	Y+7, r1	; 0x07
     ecc:	c4 5f       	subi	r28, 0xF4	; 244
     ece:	dd 4f       	sbci	r29, 0xFD	; 253
     ed0:	18 82       	st	Y, r1
     ed2:	5d c1       	rjmp	.+698    	; 0x118e <TCP_ProcessTCPPacket+0x3d4>
							ConnectionInfo->SequenceNumberOut = 0;
     ed4:	84 e0       	ldi	r24, 0x04	; 4
     ed6:	c7 c0       	rjmp	.+398    	; 0x1066 <TCP_ProcessTCPPacket+0x2ac>
     ed8:	c0 31       	cpi	r28, 0x10	; 16
     eda:	09 f0       	breq	.+2      	; 0xede <TCP_ProcessTCPPacket+0x124>
							ConnectionInfo->Buffer.InUse      = false;
     edc:	47 c1       	rjmp	.+654    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     ede:	c8 01       	movw	r24, r16
     ee0:	b6 01       	movw	r22, r12
     ee2:	a7 01       	movw	r20, r14
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     ee4:	23 e0       	ldi	r18, 0x03	; 3
     ee6:	48 de       	rcall	.-880    	; 0xb78 <TCP_SetConnectionState>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     ee8:	d5 01       	movw	r26, r10
     eea:	4d 91       	ld	r20, X+
     eec:	5c 91       	ld	r21, X
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     eee:	11 97       	sbiw	r26, 0x01	; 1
     ef0:	12 96       	adiw	r26, 0x02	; 2
     ef2:	8d 91       	ld	r24, X+
     ef4:	9c 91       	ld	r25, X
     ef6:	13 97       	sbiw	r26, 0x03	; 3
     ef8:	b6 01       	movw	r22, r12
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     efa:	0f df       	rcall	.-482    	; 0xd1a <TCP_GetConnectionInfo>
     efc:	fc 01       	movw	r30, r24
     efe:	44 81       	ldd	r20, Z+4	; 0x04
     f00:	55 81       	ldd	r21, Z+5	; 0x05
     f02:	66 81       	ldd	r22, Z+6	; 0x06
     f04:	77 81       	ldd	r23, Z+7	; 0x07
     f06:	4f 5f       	subi	r20, 0xFF	; 255
     f08:	5f 4f       	sbci	r21, 0xFF	; 255
     f0a:	6f 4f       	sbci	r22, 0xFF	; 255
     f0c:	7f 4f       	sbci	r23, 0xFF	; 255
     f0e:	44 83       	std	Z+4, r20	; 0x04
     f10:	55 83       	std	Z+5, r21	; 0x05
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     f12:	66 83       	std	Z+6, r22	; 0x06
     f14:	77 83       	std	Z+7, r23	; 0x07
     f16:	2a c1       	rjmp	.+596    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     f18:	c1 31       	cpi	r28, 0x11	; 17
     f1a:	61 f5       	brne	.+88     	; 0xf74 <TCP_ProcessTCPPacket+0x1ba>
     f1c:	f4 01       	movw	r30, r8
     f1e:	c5 87       	std	Z+13, r28	; 0x0d
     f20:	d5 01       	movw	r26, r10
     f22:	4d 91       	ld	r20, X+
     f24:	5c 91       	ld	r21, X
     f26:	11 97       	sbiw	r26, 0x01	; 1
     f28:	12 96       	adiw	r26, 0x02	; 2
     f2a:	8d 91       	ld	r24, X+
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     f2c:	9c 91       	ld	r25, X
     f2e:	13 97       	sbiw	r26, 0x03	; 3
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     f30:	b6 01       	movw	r22, r12
     f32:	26 e0       	ldi	r18, 0x06	; 6
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f34:	21 de       	rcall	.-958    	; 0xb78 <TCP_SetConnectionState>
     f36:	f5 01       	movw	r30, r10
     f38:	40 81       	ld	r20, Z
     f3a:	51 81       	ldd	r21, Z+1	; 0x01
     f3c:	82 81       	ldd	r24, Z+2	; 0x02
     f3e:	93 81       	ldd	r25, Z+3	; 0x03
     f40:	b6 01       	movw	r22, r12
     f42:	eb de       	rcall	.-554    	; 0xd1a <TCP_GetConnectionInfo>
     f44:	fc 01       	movw	r30, r24
     f46:	80 81       	ld	r24, Z
     f48:	91 81       	ldd	r25, Z+1	; 0x01
     f4a:	a2 81       	ldd	r26, Z+2	; 0x02
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f4c:	b3 81       	ldd	r27, Z+3	; 0x03
     f4e:	01 96       	adiw	r24, 0x01	; 1
     f50:	a1 1d       	adc	r26, r1
     f52:	b1 1d       	adc	r27, r1
     f54:	80 83       	st	Z, r24
     f56:	91 83       	std	Z+1, r25	; 0x01
     f58:	a2 83       	std	Z+2, r26	; 0x02
     f5a:	b3 83       	std	Z+3, r27	; 0x03
     f5c:	84 81       	ldd	r24, Z+4	; 0x04
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     f5e:	95 81       	ldd	r25, Z+5	; 0x05
     f60:	a6 81       	ldd	r26, Z+6	; 0x06
     f62:	b7 81       	ldd	r27, Z+7	; 0x07
     f64:	01 96       	adiw	r24, 0x01	; 1
     f66:	a1 1d       	adc	r26, r1
     f68:	b1 1d       	adc	r27, r1
     f6a:	84 83       	std	Z+4, r24	; 0x04
     f6c:	95 83       	std	Z+5, r25	; 0x05
     f6e:	a6 83       	std	Z+6, r26	; 0x06
     f70:	b7 83       	std	Z+7, r27	; 0x07
     f72:	0d c1       	rjmp	.+538    	; 0x118e <TCP_ProcessTCPPacket+0x3d4>
						ConnectionInfo->SequenceNumberOut++;
     f74:	c0 31       	cpi	r28, 0x10	; 16
     f76:	19 f0       	breq	.+6      	; 0xf7e <TCP_ProcessTCPPacket+0x1c4>
     f78:	c8 31       	cpi	r28, 0x18	; 24
     f7a:	09 f0       	breq	.+2      	; 0xf7e <TCP_ProcessTCPPacket+0x1c4>
     f7c:	f7 c0       	rjmp	.+494    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
     f7e:	c8 01       	movw	r24, r16
     f80:	b6 01       	movw	r22, r12
     f82:	a7 01       	movw	r20, r14
     f84:	ca de       	rcall	.-620    	; 0xd1a <TCP_GetConnectionInfo>
     f86:	ec 01       	movw	r28, r24
     f88:	dc 01       	movw	r26, r24
     f8a:	a4 5f       	subi	r26, 0xF4	; 244
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     f8c:	bd 4f       	sbci	r27, 0xFD	; 253
     f8e:	2c 91       	ld	r18, X
     f90:	86 5f       	subi	r24, 0xF6	; 246
     f92:	9d 4f       	sbci	r25, 0xFD	; 253
     f94:	22 23       	and	r18, r18
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f96:	61 f4       	brne	.+24     	; 0xfb0 <TCP_ProcessTCPPacket+0x1f6>
     f98:	fe 01       	movw	r30, r28
     f9a:	e5 5f       	subi	r30, 0xF5	; 245
     f9c:	fd 4f       	sbci	r31, 0xFD	; 253
     f9e:	20 81       	ld	r18, Z
     fa0:	22 23       	and	r18, r18
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     fa2:	31 f4       	brne	.+12     	; 0xfb0 <TCP_ProcessTCPPacket+0x1f6>
     fa4:	fc 01       	movw	r30, r24
     fa6:	10 82       	st	Z, r1
     fa8:	21 e0       	ldi	r18, 0x01	; 1
     faa:	2c 93       	st	X, r18
     fac:	19 86       	std	Y+9, r1	; 0x09
     fae:	18 86       	std	Y+8, r1	; 0x08
     fb0:	dc 01       	movw	r26, r24
     fb2:	8c 91       	ld	r24, X
     fb4:	88 23       	and	r24, r24
     fb6:	09 f0       	breq	.+2      	; 0xfba <TCP_ProcessTCPPacket+0x200>
     fb8:	d6 c0       	rjmp	.+428    	; 0x1166 <TCP_ProcessTCPPacket+0x3ac>
     fba:	c8 84       	ldd	r12, Y+8	; 0x08
     fbc:	d9 84       	ldd	r13, Y+9	; 0x09
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     fbe:	b0 e0       	ldi	r27, 0x00	; 0
     fc0:	cb 16       	cp	r12, r27
							ConnectionInfo->Buffer.InUse     = true;
     fc2:	b2 e0       	ldi	r27, 0x02	; 2
     fc4:	db 06       	cpc	r13, r27
							ConnectionInfo->Buffer.Length    = 0;
     fc6:	09 f4       	brne	.+2      	; 0xfca <TCP_ProcessTCPPacket+0x210>
     fc8:	ce c0       	rjmp	.+412    	; 0x1166 <TCP_ProcessTCPPacket+0x3ac>
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     fca:	f5 01       	movw	r30, r10
     fcc:	04 85       	ldd	r16, Z+12	; 0x0c
     fce:	02 95       	swap	r16
     fd0:	0f 70       	andi	r16, 0x0F	; 15
     fd2:	10 e0       	ldi	r17, 0x00	; 0
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
     fd4:	00 0f       	add	r16, r16
     fd6:	11 1f       	adc	r17, r17
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     fd8:	00 0f       	add	r16, r16
     fda:	11 1f       	adc	r17, r17
     fdc:	d3 01       	movw	r26, r6
     fde:	12 96       	adiw	r26, 0x02	; 2
     fe0:	8d 91       	ld	r24, X+
     fe2:	9c 91       	ld	r25, X
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     fe4:	13 97       	sbiw	r26, 0x03	; 3
     fe6:	db db       	rcall	.-2122   	; 0x79e <SwapEndian_16>
     fe8:	f3 01       	movw	r30, r6
     fea:	20 81       	ld	r18, Z
     fec:	2f 70       	andi	r18, 0x0F	; 15
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	22 0f       	add	r18, r18
     ff2:	33 1f       	adc	r19, r19
     ff4:	22 0f       	add	r18, r18
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     ff6:	33 1f       	adc	r19, r19
     ff8:	7c 01       	movw	r14, r24
     ffa:	e2 1a       	sub	r14, r18
     ffc:	f3 0a       	sbc	r15, r19
     ffe:	e0 1a       	sub	r14, r16
    1000:	f1 0a       	sbc	r15, r17
    1002:	c6 01       	movw	r24, r12

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1004:	0a 96       	adiw	r24, 0x0a	; 10
    1006:	8c 0f       	add	r24, r28
    1008:	9d 1f       	adc	r25, r29
    100a:	b5 01       	movw	r22, r10
    100c:	60 0f       	add	r22, r16
    100e:	71 1f       	adc	r23, r17
    1010:	a7 01       	movw	r20, r14
    1012:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <memcpy>
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1016:	a7 01       	movw	r20, r14
    1018:	60 e0       	ldi	r22, 0x00	; 0
    101a:	70 e0       	ldi	r23, 0x00	; 0
    101c:	88 81       	ld	r24, Y

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    101e:	99 81       	ldd	r25, Y+1	; 0x01
    1020:	aa 81       	ldd	r26, Y+2	; 0x02
    1022:	bb 81       	ldd	r27, Y+3	; 0x03
    1024:	84 0f       	add	r24, r20
    1026:	95 1f       	adc	r25, r21
    1028:	a6 1f       	adc	r26, r22
    102a:	b7 1f       	adc	r27, r23
    102c:	88 83       	st	Y, r24
    102e:	99 83       	std	Y+1, r25	; 0x01
    1030:	aa 83       	std	Y+2, r26	; 0x02
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1032:	bb 83       	std	Y+3, r27	; 0x03
    1034:	88 85       	ldd	r24, Y+8	; 0x08
    1036:	99 85       	ldd	r25, Y+9	; 0x09
    1038:	8e 0d       	add	r24, r14
    103a:	9f 1d       	adc	r25, r15
    103c:	99 87       	std	Y+9, r25	; 0x09
    103e:	88 87       	std	Y+8, r24	; 0x08
    1040:	f2 e0       	ldi	r31, 0x02	; 2
    1042:	80 30       	cpi	r24, 0x00	; 0
    1044:	9f 07       	cpc	r25, r31
    1046:	31 f0       	breq	.+12     	; 0x1054 <TCP_ProcessTCPPacket+0x29a>
    1048:	d5 01       	movw	r26, r10
    104a:	1d 96       	adiw	r26, 0x0d	; 13
    104c:	8c 91       	ld	r24, X
    104e:	1d 97       	sbiw	r26, 0x0d	; 13
							ConnectionInfo->Buffer.Length    += DataLength;
    1050:	83 ff       	sbrs	r24, 3
    1052:	8c c0       	rjmp	.+280    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
    1054:	fe 01       	movw	r30, r28
    1056:	e4 5f       	subi	r30, 0xF4	; 244
    1058:	fd 4f       	sbci	r31, 0xFD	; 253
    105a:	10 82       	st	Z, r1

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    105c:	c5 5f       	subi	r28, 0xF5	; 245
    105e:	dd 4f       	sbci	r29, 0xFD	; 253
    1060:	81 e0       	ldi	r24, 0x01	; 1
    1062:	88 83       	st	Y, r24
    1064:	80 e1       	ldi	r24, 0x10	; 16
    1066:	f4 01       	movw	r30, r8
    1068:	85 87       	std	Z+13, r24	; 0x0d
    106a:	91 c0       	rjmp	.+290    	; 0x118e <TCP_ProcessTCPPacket+0x3d4>
    106c:	c8 01       	movw	r24, r16
    106e:	b6 01       	movw	r22, r12
							{
								ConnectionInfo->Buffer.InUse = false;
    1070:	a7 01       	movw	r20, r14
    1072:	53 de       	rcall	.-858    	; 0xd1a <TCP_GetConnectionInfo>
    1074:	21 e1       	ldi	r18, 0x11	; 17
    1076:	d4 01       	movw	r26, r8
								ConnectionInfo->Buffer.Ready = true;
    1078:	1d 96       	adiw	r26, 0x0d	; 13
    107a:	2c 93       	st	X, r18
    107c:	1d 97       	sbiw	r26, 0x0d	; 13
    107e:	fc 01       	movw	r30, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1080:	e4 5f       	subi	r30, 0xF4	; 244
    1082:	fd 4f       	sbci	r31, 0xFD	; 253
    1084:	10 82       	st	Z, r1
    1086:	f5 01       	movw	r30, r10
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1088:	40 81       	ld	r20, Z
    108a:	51 81       	ldd	r21, Z+1	; 0x01
    108c:	82 81       	ldd	r24, Z+2	; 0x02
    108e:	93 81       	ldd	r25, Z+3	; 0x03
    1090:	b6 01       	movw	r22, r12
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1092:	24 e0       	ldi	r18, 0x04	; 4
    1094:	33 c0       	rjmp	.+102    	; 0x10fc <TCP_ProcessTCPPacket+0x342>
    1096:	c1 31       	cpi	r28, 0x11	; 17
    1098:	59 f0       	breq	.+22     	; 0x10b0 <TCP_ProcessTCPPacket+0x2f6>
    109a:	c0 31       	cpi	r28, 0x10	; 16
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    109c:	09 f0       	breq	.+2      	; 0x10a0 <TCP_ProcessTCPPacket+0x2e6>
    109e:	66 c0       	rjmp	.+204    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
    10a0:	c8 01       	movw	r24, r16
    10a2:	b6 01       	movw	r22, r12

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    10a4:	a7 01       	movw	r20, r14
    10a6:	25 e0       	ldi	r18, 0x05	; 5
    10a8:	31 c0       	rjmp	.+98     	; 0x110c <TCP_ProcessTCPPacket+0x352>
    10aa:	c1 31       	cpi	r28, 0x11	; 17
    10ac:	09 f0       	breq	.+2      	; 0x10b0 <TCP_ProcessTCPPacket+0x2f6>
    10ae:	5e c0       	rjmp	.+188    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
    10b0:	c8 01       	movw	r24, r16
    10b2:	b6 01       	movw	r22, r12
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    10b4:	a7 01       	movw	r20, r14
    10b6:	31 de       	rcall	.-926    	; 0xd1a <TCP_GetConnectionInfo>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    10b8:	fc 01       	movw	r30, r24
    10ba:	80 e1       	ldi	r24, 0x10	; 16
    10bc:	d4 01       	movw	r26, r8
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    10be:	1d 96       	adiw	r26, 0x0d	; 13
    10c0:	8c 93       	st	X, r24
    10c2:	80 81       	ld	r24, Z
    10c4:	91 81       	ldd	r25, Z+1	; 0x01
    10c6:	a2 81       	ldd	r26, Z+2	; 0x02
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    10c8:	b3 81       	ldd	r27, Z+3	; 0x03
    10ca:	01 96       	adiw	r24, 0x01	; 1
    10cc:	a1 1d       	adc	r26, r1
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    10ce:	b1 1d       	adc	r27, r1
    10d0:	80 83       	st	Z, r24
    10d2:	91 83       	std	Z+1, r25	; 0x01
    10d4:	a2 83       	std	Z+2, r26	; 0x02
    10d6:	b3 83       	std	Z+3, r27	; 0x03
    10d8:	84 81       	ldd	r24, Z+4	; 0x04
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    10da:	95 81       	ldd	r25, Z+5	; 0x05
    10dc:	a6 81       	ldd	r26, Z+6	; 0x06
    10de:	b7 81       	ldd	r27, Z+7	; 0x07
    10e0:	01 96       	adiw	r24, 0x01	; 1
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    10e2:	a1 1d       	adc	r26, r1
    10e4:	b1 1d       	adc	r27, r1
    10e6:	84 83       	std	Z+4, r24	; 0x04
    10e8:	95 83       	std	Z+5, r25	; 0x05
    10ea:	a6 83       	std	Z+6, r26	; 0x06
    10ec:	b7 83       	std	Z+7, r27	; 0x07
    10ee:	f5 01       	movw	r30, r10
    10f0:	40 81       	ld	r20, Z
    10f2:	51 81       	ldd	r21, Z+1	; 0x01
    10f4:	82 81       	ldd	r24, Z+2	; 0x02
    10f6:	93 81       	ldd	r25, Z+3	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    10f8:	b6 01       	movw	r22, r12
    10fa:	2a e0       	ldi	r18, 0x0A	; 10
    10fc:	3d dd       	rcall	.-1414   	; 0xb78 <TCP_SetConnectionState>
    10fe:	47 c0       	rjmp	.+142    	; 0x118e <TCP_ProcessTCPPacket+0x3d4>
    1100:	c0 31       	cpi	r28, 0x10	; 16
    1102:	a1 f5       	brne	.+104    	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
    1104:	c8 01       	movw	r24, r16
    1106:	b6 01       	movw	r22, r12
    1108:	a7 01       	movw	r20, r14
    110a:	2a e0       	ldi	r18, 0x0A	; 10
    110c:	35 dd       	rcall	.-1430   	; 0xb78 <TCP_SetConnectionState>

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    110e:	2e c0       	rjmp	.+92     	; 0x116c <TCP_ProcessTCPPacket+0x3b2>
    1110:	84 e1       	ldi	r24, 0x14	; 20
    1112:	d4 01       	movw	r26, r8
    1114:	1d 96       	adiw	r26, 0x0d	; 13
    1116:	8c 93       	st	X, r24
    1118:	1d 97       	sbiw	r26, 0x0d	; 13
    111a:	39 c0       	rjmp	.+114    	; 0x118e <TCP_ProcessTCPPacket+0x3d4>
    111c:	80 e0       	ldi	r24, 0x00	; 0
    111e:	92 e0       	ldi	r25, 0x02	; 2
    1120:	09 c0       	rjmp	.+18     	; 0x1134 <TCP_ProcessTCPPacket+0x37a>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1122:	d8 01       	movw	r26, r16
    1124:	18 96       	adiw	r26, 0x08	; 8
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1126:	2d 91       	ld	r18, X+
    1128:	3c 91       	ld	r19, X
    112a:	19 97       	sbiw	r26, 0x09	; 9
    112c:	80 e0       	ldi	r24, 0x00	; 0
    112e:	92 e0       	ldi	r25, 0x02	; 2
    1130:	82 1b       	sub	r24, r18
    1132:	93 0b       	sbc	r25, r19
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1134:	34 db       	rcall	.-2456   	; 0x79e <SwapEndian_16>
    1136:	f4 01       	movw	r30, r8
    1138:	97 87       	std	Z+15, r25	; 0x0f
    113a:	86 87       	std	Z+14, r24	; 0x0e
    113c:	13 8a       	std	Z+19, r1	; 0x13
    113e:	12 8a       	std	Z+18, r1	; 0x12
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    1140:	11 8a       	std	Z+17, r1	; 0x11
    1142:	10 8a       	std	Z+16, r1	; 0x10
    1144:	84 85       	ldd	r24, Z+12	; 0x0c
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1146:	80 7f       	andi	r24, 0xF0	; 240
    1148:	84 87       	std	Z+12, r24	; 0x0c
    114a:	b3 01       	movw	r22, r6
    114c:	60 5f       	subi	r22, 0xF0	; 240
    114e:	7f 4f       	sbci	r23, 0xFF	; 255
    1150:	c4 01       	movw	r24, r8
    1152:	a7 01       	movw	r20, r14
    1154:	24 e1       	ldi	r18, 0x14	; 20
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	26 db       	rcall	.-2484   	; 0x7a6 <TCP_Checksum16>
    115a:	f4 01       	movw	r30, r8
    115c:	91 8b       	std	Z+17, r25	; 0x11
    115e:	80 8b       	std	Z+16, r24	; 0x10
    1160:	84 e1       	ldi	r24, 0x14	; 20

		TCPHeaderOUT->UrgentPointer        = 0;
    1162:	90 e0       	ldi	r25, 0x00	; 0
    1164:	05 c0       	rjmp	.+10     	; 0x1170 <TCP_ProcessTCPPacket+0x3b6>
		TCPHeaderOUT->Checksum             = 0;
    1166:	8f ef       	ldi	r24, 0xFF	; 255
    1168:	9f ef       	ldi	r25, 0xFF	; 255
		TCPHeaderOUT->Reserved             = 0;
    116a:	02 c0       	rjmp	.+4      	; 0x1170 <TCP_ProcessTCPPacket+0x3b6>
    116c:	80 e0       	ldi	r24, 0x00	; 0
    116e:	90 e0       	ldi	r25, 0x00	; 0

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    1170:	df 91       	pop	r29
    1172:	cf 91       	pop	r28
    1174:	1f 91       	pop	r17
    1176:	0f 91       	pop	r16
    1178:	ff 90       	pop	r15
    117a:	ef 90       	pop	r14
    117c:	df 90       	pop	r13
    117e:	cf 90       	pop	r12
    1180:	bf 90       	pop	r11
    1182:	af 90       	pop	r10
    1184:	9f 90       	pop	r9
    1186:	8f 90       	pop	r8
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1188:	7f 90       	pop	r7
    118a:	6f 90       	pop	r6
    118c:	08 95       	ret
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    118e:	d5 01       	movw	r26, r10
    1190:	12 96       	adiw	r26, 0x02	; 2
    1192:	cd 91       	ld	r28, X+
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    1194:	dc 91       	ld	r29, X
    1196:	13 97       	sbiw	r26, 0x03	; 3
}
    1198:	fc e0       	ldi	r31, 0x0C	; 12
    119a:	ef 2e       	mov	r14, r31
    119c:	f1 2c       	mov	r15, r1
    119e:	e6 0c       	add	r14, r6
    11a0:	f7 1c       	adc	r15, r7
    11a2:	4d 91       	ld	r20, X+
    11a4:	5c 91       	ld	r21, X
    11a6:	ce 01       	movw	r24, r28
    11a8:	b7 01       	movw	r22, r14
    11aa:	b7 dd       	rcall	.-1170   	; 0xd1a <TCP_GetConnectionInfo>
    11ac:	8c 01       	movw	r16, r24
    11ae:	f4 01       	movw	r30, r8
    11b0:	d1 83       	std	Z+1, r29	; 0x01
    11b2:	c0 83       	st	Z, r28
    11b4:	d5 01       	movw	r26, r10
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    11b6:	8d 91       	ld	r24, X+
    11b8:	9c 91       	ld	r25, X
    11ba:	93 83       	std	Z+3, r25	; 0x03
    11bc:	82 83       	std	Z+2, r24	; 0x02
    11be:	f8 01       	movw	r30, r16
    11c0:	64 81       	ldd	r22, Z+4	; 0x04
    11c2:	75 81       	ldd	r23, Z+5	; 0x05
    11c4:	86 81       	ldd	r24, Z+6	; 0x06
    11c6:	97 81       	ldd	r25, Z+7	; 0x07
    11c8:	e4 da       	rcall	.-2616   	; 0x792 <SwapEndian_32>
    11ca:	dc 01       	movw	r26, r24
    11cc:	cb 01       	movw	r24, r22
    11ce:	f4 01       	movw	r30, r8
    11d0:	84 83       	std	Z+4, r24	; 0x04
    11d2:	95 83       	std	Z+5, r25	; 0x05
    11d4:	a6 83       	std	Z+6, r26	; 0x06
    11d6:	b7 83       	std	Z+7, r27	; 0x07
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    11d8:	d8 01       	movw	r26, r16
    11da:	6d 91       	ld	r22, X+
    11dc:	7d 91       	ld	r23, X+
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    11de:	8d 91       	ld	r24, X+
    11e0:	9c 91       	ld	r25, X
    11e2:	d7 da       	rcall	.-2642   	; 0x792 <SwapEndian_32>
    11e4:	dc 01       	movw	r26, r24
    11e6:	cb 01       	movw	r24, r22
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    11e8:	f4 01       	movw	r30, r8
    11ea:	80 87       	std	Z+8, r24	; 0x08
    11ec:	91 87       	std	Z+9, r25	; 0x09
    11ee:	a2 87       	std	Z+10, r26	; 0x0a
    11f0:	b3 87       	std	Z+11, r27	; 0x0b
    11f2:	84 85       	ldd	r24, Z+12	; 0x0c
    11f4:	8f 70       	andi	r24, 0x0F	; 15
    11f6:	80 65       	ori	r24, 0x50	; 80
    11f8:	84 87       	std	Z+12, r24	; 0x0c
    11fa:	f8 01       	movw	r30, r16
    11fc:	e4 5f       	subi	r30, 0xF4	; 244
    11fe:	fd 4f       	sbci	r31, 0xFD	; 253
    1200:	80 81       	ld	r24, Z
    1202:	88 23       	and	r24, r24
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    1204:	09 f4       	brne	.+2      	; 0x1208 <TCP_ProcessTCPPacket+0x44e>
    1206:	8a cf       	rjmp	.-236    	; 0x111c <TCP_ProcessTCPPacket+0x362>
    1208:	8c cf       	rjmp	.-232    	; 0x1122 <TCP_ProcessTCPPacket+0x368>

0000120a <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    120a:	ef 92       	push	r14
    120c:	ff 92       	push	r15
    120e:	0f 93       	push	r16
    1210:	1f 93       	push	r17
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	7c 01       	movw	r14, r24
    1218:	8b 01       	movw	r16, r22
    121a:	ea 01       	movw	r28, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    121c:	cb 01       	movw	r24, r22
    121e:	74 da       	rcall	.-2840   	; 0x708 <DecodeUDPHeader>
    1220:	f8 01       	movw	r30, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1222:	82 81       	ldd	r24, Z+2	; 0x02
    1224:	93 81       	ldd	r25, Z+3	; 0x03
    1226:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
    1228:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
    122a:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
    122c:	83 34       	cpi	r24, 0x43	; 67

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    122e:	91 05       	cpc	r25, r1
    1230:	d1 f4       	brne	.+52     	; 0x1266 <UDP_ProcessUDPPacket+0x5c>
    1232:	b8 01       	movw	r22, r16
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1234:	68 5f       	subi	r22, 0xF8	; 248
    1236:	7f 4f       	sbci	r23, 0xFF	; 255
    1238:	ae 01       	movw	r20, r28
    123a:	48 5f       	subi	r20, 0xF8	; 248
    123c:	5f 4f       	sbci	r21, 0xFF	; 255
    123e:	c7 01       	movw	r24, r14
    1240:	1b d0       	rcall	.+54     	; 0x1278 <DHCP_ProcessDHCPPacket>
    1242:	18 16       	cp	r1, r24
    1244:	19 06       	cpc	r1, r25
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1246:	7c f4       	brge	.+30     	; 0x1266 <UDP_ProcessUDPPacket+0x5c>
    1248:	f8 01       	movw	r30, r16
    124a:	22 81       	ldd	r18, Z+2	; 0x02
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    124c:	33 81       	ldd	r19, Z+3	; 0x03
    124e:	39 83       	std	Y+1, r19	; 0x01
    1250:	28 83       	st	Y, r18
    1252:	20 81       	ld	r18, Z
    1254:	31 81       	ldd	r19, Z+1	; 0x01
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1256:	3b 83       	std	Y+3, r19	; 0x03
    1258:	2a 83       	std	Y+2, r18	; 0x02
    125a:	1f 82       	std	Y+7, r1	; 0x07
    125c:	1e 82       	std	Y+6, r1	; 0x06
		UDPHeaderOUT->Checksum        = 0;
    125e:	08 96       	adiw	r24, 0x08	; 8
    1260:	9c 83       	std	Y+4, r25	; 0x04
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1262:	8d 83       	std	Y+5, r24	; 0x05
    1264:	02 c0       	rjmp	.+4      	; 0x126a <UDP_ProcessUDPPacket+0x60>
    1266:	80 e0       	ldi	r24, 0x00	; 0

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1268:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
}
    126e:	1f 91       	pop	r17
    1270:	0f 91       	pop	r16
    1272:	ff 90       	pop	r15
    1274:	ef 90       	pop	r14
    1276:	08 95       	ret

00001278 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1278:	8f 92       	push	r8
    127a:	9f 92       	push	r9
    127c:	af 92       	push	r10
    127e:	bf 92       	push	r11
    1280:	cf 92       	push	r12
    1282:	df 92       	push	r13
    1284:	ef 92       	push	r14
    1286:	ff 92       	push	r15
    1288:	0f 93       	push	r16
    128a:	1f 93       	push	r17
    128c:	cf 93       	push	r28
    128e:	df 93       	push	r29
    1290:	6c 01       	movw	r12, r24
    1292:	8b 01       	movw	r16, r22
    1294:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    1296:	20 ef       	ldi	r18, 0xF0	; 240
    1298:	e2 2e       	mov	r14, r18
    129a:	f1 2c       	mov	r15, r1
    129c:	e6 0e       	add	r14, r22
    129e:	f7 1e       	adc	r15, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    12a0:	cb 01       	movw	r24, r22
    12a2:	33 da       	rcall	.-2970   	; 0x70a <DecodeDHCPHeader>
    12a4:	80 ef       	ldi	r24, 0xF0	; 240

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    12a6:	fe 01       	movw	r30, r28
    12a8:	11 92       	st	Z+, r1
    12aa:	8a 95       	dec	r24
    12ac:	e9 f7       	brne	.-6      	; 0x12a8 <DHCP_ProcessDHCPPacket+0x30>
    12ae:	f8 01       	movw	r30, r16

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    12b0:	81 81       	ldd	r24, Z+1	; 0x01
    12b2:	89 83       	std	Y+1, r24	; 0x01
    12b4:	82 e0       	ldi	r24, 0x02	; 2
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    12b6:	88 83       	st	Y, r24
    12b8:	82 81       	ldd	r24, Z+2	; 0x02
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    12ba:	8a 83       	std	Y+2, r24	; 0x02
    12bc:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->Hops                  = 0;
    12be:	84 81       	ldd	r24, Z+4	; 0x04
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    12c0:	95 81       	ldd	r25, Z+5	; 0x05
    12c2:	a6 81       	ldd	r26, Z+6	; 0x06
    12c4:	b7 81       	ldd	r27, Z+7	; 0x07
    12c6:	8c 83       	std	Y+4, r24	; 0x04
    12c8:	9d 83       	std	Y+5, r25	; 0x05
    12ca:	ae 83       	std	Y+6, r26	; 0x06
    12cc:	bf 83       	std	Y+7, r27	; 0x07
    12ce:	19 86       	std	Y+9, r1	; 0x09
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    12d0:	18 86       	std	Y+8, r1	; 0x08
    12d2:	82 85       	ldd	r24, Z+10	; 0x0a
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    12d4:	93 85       	ldd	r25, Z+11	; 0x0b
    12d6:	9b 87       	std	Y+11, r25	; 0x0b
    12d8:	8a 87       	std	Y+10, r24	; 0x0a
    12da:	80 90 b6 01 	lds	r8, 0x01B6
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    12de:	90 90 b7 01 	lds	r9, 0x01B7
    12e2:	a0 90 b8 01 	lds	r10, 0x01B8
    12e6:	b0 90 b9 01 	lds	r11, 0x01B9
    12ea:	88 8a       	std	Y+16, r8	; 0x10
    12ec:	99 8a       	std	Y+17, r9	; 0x11
    12ee:	aa 8a       	std	Y+18, r10	; 0x12
    12f0:	bb 8a       	std	Y+19, r11	; 0x13
    12f2:	b8 01       	movw	r22, r16
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    12f4:	64 5e       	subi	r22, 0xE4	; 228
    12f6:	7f 4f       	sbci	r23, 0xFF	; 255
    12f8:	ce 01       	movw	r24, r28
    12fa:	4c 96       	adiw	r24, 0x1c	; 28
    12fc:	46 e0       	ldi	r20, 0x06	; 6
    12fe:	50 e0       	ldi	r21, 0x00	; 0
    1300:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <memmove>
    1304:	fe 01       	movw	r30, r28
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1306:	e4 51       	subi	r30, 0x14	; 20
    1308:	ff 4f       	sbci	r31, 0xFF	; 255
    130a:	83 e6       	ldi	r24, 0x63	; 99
    130c:	92 e8       	ldi	r25, 0x82	; 130
    130e:	a3 e5       	ldi	r26, 0x53	; 83
    1310:	b3 e6       	ldi	r27, 0x63	; 99
    1312:	80 83       	st	Z, r24
    1314:	91 83       	std	Z+1, r25	; 0x01
    1316:	a2 83       	std	Z+2, r26	; 0x02
    1318:	b3 83       	std	Z+3, r27	; 0x03
    131a:	f6 01       	movw	r30, r12

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    131c:	84 86       	std	Z+12, r8	; 0x0c
    131e:	95 86       	std	Z+13, r9	; 0x0d
    1320:	a6 86       	std	Z+14, r10	; 0x0e
    1322:	b7 86       	std	Z+15, r11	; 0x0f
    1324:	80 91 c4 01 	lds	r24, 0x01C4
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1328:	90 91 c5 01 	lds	r25, 0x01C5
    132c:	a0 91 c6 01 	lds	r26, 0x01C6
    1330:	b0 91 c7 01 	lds	r27, 0x01C7
    1334:	80 8b       	std	Z+16, r24	; 0x10
    1336:	91 8b       	std	Z+17, r25	; 0x11
    1338:	a2 8b       	std	Z+18, r26	; 0x12
    133a:	b3 8b       	std	Z+19, r27	; 0x13
    133c:	63 c0       	rjmp	.+198    	; 0x1404 <DHCP_ProcessDHCPPacket+0x18c>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    133e:	85 33       	cpi	r24, 0x35	; 53
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1340:	09 f0       	breq	.+2      	; 0x1344 <DHCP_ProcessDHCPPacket+0xcc>
    1342:	55 c0       	rjmp	.+170    	; 0x13ee <DHCP_ProcessDHCPPacket+0x176>
    1344:	f7 01       	movw	r30, r14
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1346:	82 81       	ldd	r24, Z+2	; 0x02
    1348:	81 30       	cpi	r24, 0x01	; 1
    134a:	19 f0       	breq	.+6      	; 0x1352 <DHCP_ProcessDHCPPacket+0xda>
    134c:	83 30       	cpi	r24, 0x03	; 3
    134e:	09 f0       	breq	.+2      	; 0x1352 <DHCP_ProcessDHCPPacket+0xda>
    1350:	50 c0       	rjmp	.+160    	; 0x13f2 <DHCP_ProcessDHCPPacket+0x17a>
    1352:	fe 01       	movw	r30, r28
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1354:	e0 51       	subi	r30, 0x10	; 16
    1356:	ff 4f       	sbci	r31, 0xFF	; 255
    1358:	85 e3       	ldi	r24, 0x35	; 53
    135a:	80 83       	st	Z, r24
    135c:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 1;
    135e:	ef 50       	subi	r30, 0x0F	; 15
    1360:	ff 4f       	sbci	r31, 0xFF	; 255
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	80 83       	st	Z, r24
    1366:	f7 01       	movw	r30, r14
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1368:	82 81       	ldd	r24, Z+2	; 0x02
    136a:	81 30       	cpi	r24, 0x01	; 1
    136c:	11 f4       	brne	.+4      	; 0x1372 <DHCP_ProcessDHCPPacket+0xfa>
    136e:	82 e0       	ldi	r24, 0x02	; 2
    1370:	01 c0       	rjmp	.+2      	; 0x1374 <DHCP_ProcessDHCPPacket+0xfc>
    1372:	85 e0       	ldi	r24, 0x05	; 5
    1374:	fe 01       	movw	r30, r28
    1376:	ee 50       	subi	r30, 0x0E	; 14
    1378:	ff 4f       	sbci	r31, 0xFF	; 255
    137a:	80 83       	st	Z, r24
    137c:	fe 01       	movw	r30, r28
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    137e:	ed 50       	subi	r30, 0x0D	; 13
    1380:	ff 4f       	sbci	r31, 0xFF	; 255
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	80 83       	st	Z, r24
    1386:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 4;
    1388:	ec 50       	subi	r30, 0x0C	; 12
    138a:	ff 4f       	sbci	r31, 0xFF	; 255
    138c:	84 e0       	ldi	r24, 0x04	; 4
    138e:	80 83       	st	Z, r24
    1390:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1392:	eb 50       	subi	r30, 0x0B	; 11
    1394:	ff 4f       	sbci	r31, 0xFF	; 255
    1396:	2f ef       	ldi	r18, 0xFF	; 255
    1398:	20 83       	st	Z, r18
    139a:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    139c:	ea 50       	subi	r30, 0x0A	; 10
    139e:	ff 4f       	sbci	r31, 0xFF	; 255
    13a0:	20 83       	st	Z, r18
    13a2:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    13a4:	e9 50       	subi	r30, 0x09	; 9
    13a6:	ff 4f       	sbci	r31, 0xFF	; 255
    13a8:	20 83       	st	Z, r18
    13aa:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0x00;
    13ac:	e8 50       	subi	r30, 0x08	; 8
    13ae:	ff 4f       	sbci	r31, 0xFF	; 255
    13b0:	10 82       	st	Z, r1
    13b2:	fe 01       	movw	r30, r28

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    13b4:	e7 50       	subi	r30, 0x07	; 7
    13b6:	ff 4f       	sbci	r31, 0xFF	; 255
    13b8:	96 e3       	ldi	r25, 0x36	; 54
    13ba:	90 83       	st	Z, r25
    13bc:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    13be:	e6 50       	subi	r30, 0x06	; 6
    13c0:	ff 4f       	sbci	r31, 0xFF	; 255
    13c2:	80 83       	st	Z, r24
    13c4:	fe 01       	movw	r30, r28
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    13c6:	e5 50       	subi	r30, 0x05	; 5
    13c8:	ff 4f       	sbci	r31, 0xFF	; 255
    13ca:	80 91 c4 01 	lds	r24, 0x01C4
    13ce:	90 91 c5 01 	lds	r25, 0x01C5
    13d2:	a0 91 c6 01 	lds	r26, 0x01C6
    13d6:	b0 91 c7 01 	lds	r27, 0x01C7
    13da:	80 83       	st	Z, r24
    13dc:	91 83       	std	Z+1, r25	; 0x01
    13de:	a2 83       	std	Z+2, r26	; 0x02
    13e0:	b3 83       	std	Z+3, r27	; 0x03
    13e2:	c1 50       	subi	r28, 0x01	; 1
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    13e4:	df 4f       	sbci	r29, 0xFF	; 255
    13e6:	28 83       	st	Y, r18
    13e8:	80 e0       	ldi	r24, 0x00	; 0

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    13ea:	91 e0       	ldi	r25, 0x01	; 1
    13ec:	12 c0       	rjmp	.+36     	; 0x1412 <DHCP_ProcessDHCPPacket+0x19a>
    13ee:	88 23       	and	r24, r24
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    13f0:	29 f0       	breq	.+10     	; 0x13fc <DHCP_ProcessDHCPPacket+0x184>
    13f2:	f7 01       	movw	r30, r14
    13f4:	81 81       	ldd	r24, Z+1	; 0x01
    13f6:	90 e0       	ldi	r25, 0x00	; 0
    13f8:	02 96       	adiw	r24, 0x02	; 2
    13fa:	02 c0       	rjmp	.+4      	; 0x1400 <DHCP_ProcessDHCPPacket+0x188>
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	e8 0e       	add	r14, r24
    1402:	f9 1e       	adc	r15, r25
    1404:	f7 01       	movw	r30, r14
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1406:	80 81       	ld	r24, Z
    1408:	8f 3f       	cpi	r24, 0xFF	; 255
    140a:	09 f0       	breq	.+2      	; 0x140e <DHCP_ProcessDHCPPacket+0x196>
    140c:	98 cf       	rjmp	.-208    	; 0x133e <DHCP_ProcessDHCPPacket+0xc6>
    140e:	80 e0       	ldi	r24, 0x00	; 0

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	df 91       	pop	r29
}
    1414:	cf 91       	pop	r28
    1416:	1f 91       	pop	r17
    1418:	0f 91       	pop	r16
    141a:	ff 90       	pop	r15
    141c:	ef 90       	pop	r14
    141e:	df 90       	pop	r13
    1420:	cf 90       	pop	r12
    1422:	bf 90       	pop	r11
    1424:	af 90       	pop	r10
    1426:	9f 90       	pop	r9
    1428:	8f 90       	pop	r8
    142a:	08 95       	ret

0000142c <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    142c:	0f 93       	push	r16
    142e:	1f 93       	push	r17
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
    1434:	ec 01       	movw	r28, r24
    1436:	8b 01       	movw	r16, r22
	DecodeARPHeader(InDataStart);
    1438:	63 d9       	rcall	.-3386   	; 0x700 <DecodeARPHeader>
    143a:	8a 81       	ldd	r24, Y+2	; 0x02
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    143c:	9b 81       	ldd	r25, Y+3	; 0x03
    143e:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
    1440:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
    1442:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
    1444:	28 e0       	ldi	r18, 0x08	; 8

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1446:	80 30       	cpi	r24, 0x00	; 0
    1448:	92 07       	cpc	r25, r18
    144a:	09 f0       	breq	.+2      	; 0x144e <ARP_ProcessARPPacket+0x22>
    144c:	59 c0       	rjmp	.+178    	; 0x1500 <ARP_ProcessARPPacket+0xd4>
    144e:	8e 81       	ldd	r24, Y+6	; 0x06
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1450:	9f 81       	ldd	r25, Y+7	; 0x07
    1452:	28 2f       	mov	r18, r24

				Temp = Data.Bytes[0];
    1454:	89 2f       	mov	r24, r25
				Data.Bytes[0] = Data.Bytes[1];
    1456:	92 2f       	mov	r25, r18
				Data.Bytes[1] = Temp;
    1458:	81 30       	cpi	r24, 0x01	; 1
    145a:	91 05       	cpc	r25, r1
    145c:	09 f0       	breq	.+2      	; 0x1460 <ARP_ProcessARPPacket+0x34>
    145e:	50 c0       	rjmp	.+160    	; 0x1500 <ARP_ProcessARPPacket+0xd4>
    1460:	ce 01       	movw	r24, r28
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1462:	48 96       	adiw	r24, 0x18	; 24
    1464:	64 ec       	ldi	r22, 0xC4	; 196
    1466:	71 e0       	ldi	r23, 0x01	; 1
    1468:	44 e0       	ldi	r20, 0x04	; 4
    146a:	50 e0       	ldi	r21, 0x00	; 0
    146c:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
    1470:	00 97       	sbiw	r24, 0x00	; 0
    1472:	51 f0       	breq	.+20     	; 0x1488 <ARP_ProcessARPPacket+0x5c>
    1474:	ce 01       	movw	r24, r28
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    1476:	42 96       	adiw	r24, 0x12	; 18
    1478:	68 ec       	ldi	r22, 0xC8	; 200
    147a:	71 e0       	ldi	r23, 0x01	; 1
    147c:	46 e0       	ldi	r20, 0x06	; 6
    147e:	50 e0       	ldi	r21, 0x00	; 0
    1480:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
    1484:	00 97       	sbiw	r24, 0x00	; 0
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1486:	e1 f5       	brne	.+120    	; 0x1500 <ARP_ProcessARPPacket+0xd4>
    1488:	88 81       	ld	r24, Y
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    148a:	99 81       	ldd	r25, Y+1	; 0x01
    148c:	f8 01       	movw	r30, r16
    148e:	91 83       	std	Z+1, r25	; 0x01
    1490:	80 83       	st	Z, r24
    1492:	8a 81       	ldd	r24, Y+2	; 0x02
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1494:	9b 81       	ldd	r25, Y+3	; 0x03
    1496:	93 83       	std	Z+3, r25	; 0x03
    1498:	82 83       	std	Z+2, r24	; 0x02
    149a:	8c 81       	ldd	r24, Y+4	; 0x04
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    149c:	84 83       	std	Z+4, r24	; 0x04
    149e:	8d 81       	ldd	r24, Y+5	; 0x05
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    14a0:	85 83       	std	Z+5, r24	; 0x05
    14a2:	80 e0       	ldi	r24, 0x00	; 0
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    14a4:	92 e0       	ldi	r25, 0x02	; 2
    14a6:	97 83       	std	Z+7, r25	; 0x07
    14a8:	86 83       	std	Z+6, r24	; 0x06
    14aa:	d8 01       	movw	r26, r16

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    14ac:	52 96       	adiw	r26, 0x12	; 18
    14ae:	fe 01       	movw	r30, r28
    14b0:	38 96       	adiw	r30, 0x08	; 8
    14b2:	86 e0       	ldi	r24, 0x06	; 6
    14b4:	01 90       	ld	r0, Z+
    14b6:	0d 92       	st	X+, r0
    14b8:	81 50       	subi	r24, 0x01	; 1
    14ba:	e1 f7       	brne	.-8      	; 0x14b4 <ARP_ProcessARPPacket+0x88>
    14bc:	8e 85       	ldd	r24, Y+14	; 0x0e
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    14be:	9f 85       	ldd	r25, Y+15	; 0x0f
    14c0:	a8 89       	ldd	r26, Y+16	; 0x10
    14c2:	b9 89       	ldd	r27, Y+17	; 0x11
    14c4:	f8 01       	movw	r30, r16
    14c6:	80 8f       	std	Z+24, r24	; 0x18
    14c8:	91 8f       	std	Z+25, r25	; 0x19
    14ca:	a2 8f       	std	Z+26, r26	; 0x1a
    14cc:	b3 8f       	std	Z+27, r27	; 0x1b
    14ce:	d8 01       	movw	r26, r16

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    14d0:	18 96       	adiw	r26, 0x08	; 8
    14d2:	e8 ec       	ldi	r30, 0xC8	; 200
    14d4:	f1 e0       	ldi	r31, 0x01	; 1
    14d6:	86 e0       	ldi	r24, 0x06	; 6
    14d8:	01 90       	ld	r0, Z+
    14da:	0d 92       	st	X+, r0
    14dc:	81 50       	subi	r24, 0x01	; 1
    14de:	e1 f7       	brne	.-8      	; 0x14d8 <ARP_ProcessARPPacket+0xac>
    14e0:	80 91 c4 01 	lds	r24, 0x01C4
			ARPHeaderOUT->SPA = ServerIPAddress;
    14e4:	90 91 c5 01 	lds	r25, 0x01C5
    14e8:	a0 91 c6 01 	lds	r26, 0x01C6
    14ec:	b0 91 c7 01 	lds	r27, 0x01C7
    14f0:	f8 01       	movw	r30, r16
    14f2:	86 87       	std	Z+14, r24	; 0x0e
    14f4:	97 87       	std	Z+15, r25	; 0x0f
    14f6:	a0 8b       	std	Z+16, r26	; 0x10
    14f8:	b1 8b       	std	Z+17, r27	; 0x11
    14fa:	8c e1       	ldi	r24, 0x1C	; 28

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    14fc:	90 e0       	ldi	r25, 0x00	; 0
    14fe:	02 c0       	rjmp	.+4      	; 0x1504 <ARP_ProcessARPPacket+0xd8>
    1500:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return NO_RESPONSE;
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	df 91       	pop	r29
}
    1506:	cf 91       	pop	r28
    1508:	1f 91       	pop	r17
    150a:	0f 91       	pop	r16
    150c:	08 95       	ret

0000150e <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    150e:	af 92       	push	r10
    1510:	bf 92       	push	r11
    1512:	df 92       	push	r13
    1514:	ef 92       	push	r14
    1516:	ff 92       	push	r15
    1518:	0f 93       	push	r16
    151a:	1f 93       	push	r17
    151c:	cf 93       	push	r28
    151e:	df 93       	push	r29
    1520:	5c 01       	movw	r10, r24
    1522:	7b 01       	movw	r14, r22
    1524:	8a 01       	movw	r16, r20
	DecodeIPHeader(InDataStart);
    1526:	cb 01       	movw	r24, r22
    1528:	ec d8       	rcall	.-3624   	; 0x702 <DecodeIPHeader>
    152a:	f7 01       	movw	r30, r14

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    152c:	d0 80       	ld	r13, Z
    152e:	ff e0       	ldi	r31, 0x0F	; 15
    1530:	df 22       	and	r13, r31
    1532:	e7 01       	movw	r28, r14

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1534:	60 96       	adiw	r28, 0x10	; 16
    1536:	ce 01       	movw	r24, r28
    1538:	64 ec       	ldi	r22, 0xC4	; 196
    153a:	71 e0       	ldi	r23, 0x01	; 1
    153c:	44 e0       	ldi	r20, 0x04	; 4
    153e:	50 e0       	ldi	r21, 0x00	; 0
    1540:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
    1544:	00 97       	sbiw	r24, 0x00	; 0
    1546:	51 f0       	breq	.+20     	; 0x155c <IP_ProcessIPPacket+0x4e>
    1548:	ce 01       	movw	r24, r28
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    154a:	6a eb       	ldi	r22, 0xBA	; 186
    154c:	71 e0       	ldi	r23, 0x01	; 1
    154e:	44 e0       	ldi	r20, 0x04	; 4
    1550:	50 e0       	ldi	r21, 0x00	; 0
    1552:	0e 94 90 15 	call	0x2b20	; 0x2b20 <memcmp>
    1556:	00 97       	sbiw	r24, 0x00	; 0
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1558:	09 f0       	breq	.+2      	; 0x155c <IP_ProcessIPPacket+0x4e>
    155a:	5a c0       	rjmp	.+180    	; 0x1610 <IP_ProcessIPPacket+0x102>
    155c:	6d 2d       	mov	r22, r13

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    155e:	70 e0       	ldi	r23, 0x00	; 0
    1560:	66 0f       	add	r22, r22
    1562:	77 1f       	adc	r23, r23
    1564:	66 0f       	add	r22, r22
    1566:	77 1f       	adc	r23, r23
    1568:	f7 01       	movw	r30, r14
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    156a:	81 85       	ldd	r24, Z+9	; 0x09
    156c:	86 30       	cpi	r24, 0x06	; 6
    156e:	69 f0       	breq	.+26     	; 0x158a <IP_ProcessIPPacket+0x7c>
    1570:	81 31       	cpi	r24, 0x11	; 17
    1572:	99 f0       	breq	.+38     	; 0x159a <IP_ProcessIPPacket+0x8c>
    1574:	81 30       	cpi	r24, 0x01	; 1
    1576:	09 f0       	breq	.+2      	; 0x157a <IP_ProcessIPPacket+0x6c>
    1578:	4b c0       	rjmp	.+150    	; 0x1610 <IP_ProcessIPPacket+0x102>
    157a:	6e 0d       	add	r22, r14
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    157c:	7f 1d       	adc	r23, r15
    157e:	a8 01       	movw	r20, r16
    1580:	4c 5e       	subi	r20, 0xEC	; 236
    1582:	5f 4f       	sbci	r21, 0xFF	; 255
    1584:	c5 01       	movw	r24, r10
    1586:	c2 d8       	rcall	.-3708   	; 0x70c <ICMP_ProcessICMPPacket>
    1588:	0f c0       	rjmp	.+30     	; 0x15a8 <IP_ProcessIPPacket+0x9a>
    158a:	6e 0d       	add	r22, r14
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    158c:	7f 1d       	adc	r23, r15
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    158e:	a8 01       	movw	r20, r16
    1590:	4c 5e       	subi	r20, 0xEC	; 236
    1592:	5f 4f       	sbci	r21, 0xFF	; 255
    1594:	c7 01       	movw	r24, r14
    1596:	11 dc       	rcall	.-2014   	; 0xdba <TCP_ProcessTCPPacket>
    1598:	07 c0       	rjmp	.+14     	; 0x15a8 <IP_ProcessIPPacket+0x9a>
    159a:	6e 0d       	add	r22, r14
    159c:	7f 1d       	adc	r23, r15
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    159e:	a8 01       	movw	r20, r16
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    15a0:	4c 5e       	subi	r20, 0xEC	; 236
    15a2:	5f 4f       	sbci	r21, 0xFF	; 255
    15a4:	c7 01       	movw	r24, r14
    15a6:	31 de       	rcall	.-926    	; 0x120a <UDP_ProcessUDPPacket>
    15a8:	18 16       	cp	r1, r24
    15aa:	19 06       	cpc	r1, r25
    15ac:	9c f5       	brge	.+102    	; 0x1614 <IP_ProcessIPPacket+0x106>
    15ae:	ec 01       	movw	r28, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    15b0:	64 96       	adiw	r28, 0x14	; 20
    15b2:	f8 01       	movw	r30, r16
    15b4:	d2 83       	std	Z+2, r29	; 0x02
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    15b6:	c3 83       	std	Z+3, r28	; 0x03
    15b8:	11 82       	std	Z+1, r1	; 0x01
    15ba:	85 e4       	ldi	r24, 0x45	; 69
    15bc:	80 83       	st	Z, r24
    15be:	16 82       	std	Z+6, r1	; 0x06
		IPHeaderOUT->TypeOfService      = 0;
    15c0:	17 82       	std	Z+7, r1	; 0x07
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    15c2:	15 82       	std	Z+5, r1	; 0x05
    15c4:	14 82       	std	Z+4, r1	; 0x04
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    15c6:	13 86       	std	Z+11, r1	; 0x0b
    15c8:	12 86       	std	Z+10, r1	; 0x0a
		IPHeaderOUT->Identification     = 0;
    15ca:	f7 01       	movw	r30, r14
    15cc:	81 85       	ldd	r24, Z+9	; 0x09
		IPHeaderOUT->HeaderChecksum     = 0;
    15ce:	f8 01       	movw	r30, r16
    15d0:	81 87       	std	Z+9, r24	; 0x09
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    15d2:	80 e8       	ldi	r24, 0x80	; 128
    15d4:	80 87       	std	Z+8, r24	; 0x08
    15d6:	f7 01       	movw	r30, r14
    15d8:	80 89       	ldd	r24, Z+16	; 0x10
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    15da:	91 89       	ldd	r25, Z+17	; 0x11
    15dc:	a2 89       	ldd	r26, Z+18	; 0x12
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    15de:	b3 89       	ldd	r27, Z+19	; 0x13
    15e0:	f8 01       	movw	r30, r16
    15e2:	84 87       	std	Z+12, r24	; 0x0c
    15e4:	95 87       	std	Z+13, r25	; 0x0d
    15e6:	a6 87       	std	Z+14, r26	; 0x0e
    15e8:	b7 87       	std	Z+15, r27	; 0x0f
    15ea:	f7 01       	movw	r30, r14
    15ec:	84 85       	ldd	r24, Z+12	; 0x0c
    15ee:	95 85       	ldd	r25, Z+13	; 0x0d
    15f0:	a6 85       	ldd	r26, Z+14	; 0x0e
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    15f2:	b7 85       	ldd	r27, Z+15	; 0x0f
    15f4:	f8 01       	movw	r30, r16
    15f6:	80 8b       	std	Z+16, r24	; 0x10
    15f8:	91 8b       	std	Z+17, r25	; 0x11
    15fa:	a2 8b       	std	Z+18, r26	; 0x12
    15fc:	b3 8b       	std	Z+19, r27	; 0x13
    15fe:	c8 01       	movw	r24, r16
    1600:	64 e1       	ldi	r22, 0x14	; 20
    1602:	70 e0       	ldi	r23, 0x00	; 0
    1604:	4a d8       	rcall	.-3948   	; 0x69a <Ethernet_Checksum16>

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1606:	f8 01       	movw	r30, r16
    1608:	93 87       	std	Z+11, r25	; 0x0b
    160a:	82 87       	std	Z+10, r24	; 0x0a
    160c:	ce 01       	movw	r24, r28
    160e:	02 c0       	rjmp	.+4      	; 0x1614 <IP_ProcessIPPacket+0x106>
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	90 e0       	ldi	r25, 0x00	; 0
    1614:	df 91       	pop	r29

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    161a:	0f 91       	pop	r16
    161c:	ff 90       	pop	r15
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    161e:	ef 90       	pop	r14
    1620:	df 90       	pop	r13
    1622:	bf 90       	pop	r11
    1624:	af 90       	pop	r10
    1626:	08 95       	ret

00001628 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1628:	db 01       	movw	r26, r22
    162a:	0d 90       	ld	r0, X+
    162c:	00 20       	and	r0, r0
    162e:	e9 f7       	brne	.-6      	; 0x162a <IsHTTPCommand+0x2>
    1630:	ad 01       	movw	r20, r26
    1632:	41 50       	subi	r20, 0x01	; 1
    1634:	50 40       	sbci	r21, 0x00	; 0
    1636:	46 1b       	sub	r20, r22
    1638:	57 0b       	sbc	r21, r23
    163a:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <strncmp>
    163e:	9c 01       	movw	r18, r24
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	21 15       	cp	r18, r1
    1644:	31 05       	cpc	r19, r1
    1646:	09 f0       	breq	.+2      	; 0x164a <IsHTTPCommand+0x22>
    1648:	80 e0       	ldi	r24, 0x00	; 0
}
    164a:	08 95       	ret

0000164c <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    164c:	af 92       	push	r10
    164e:	bf 92       	push	r11
    1650:	cf 92       	push	r12
    1652:	df 92       	push	r13
    1654:	ef 92       	push	r14
    1656:	ff 92       	push	r15
    1658:	0f 93       	push	r16
    165a:	1f 93       	push	r17
    165c:	cf 93       	push	r28
    165e:	df 93       	push	r29
    1660:	5c 01       	movw	r10, r24
    1662:	7b 01       	movw	r14, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1664:	8b 01       	movw	r16, r22
    1666:	0e 5f       	subi	r16, 0xFE	; 254
    1668:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    166a:	23 e0       	ldi	r18, 0x03	; 3
    166c:	c2 2e       	mov	r12, r18
    166e:	22 e0       	ldi	r18, 0x02	; 2
    1670:	d2 2e       	mov	r13, r18
    1672:	c6 0e       	add	r12, r22
    1674:	d7 1e       	adc	r13, r23
    1676:	d6 01       	movw	r26, r12
    1678:	8c 91       	ld	r24, X
    167a:	88 23       	and	r24, r24
    167c:	09 f4       	brne	.+2      	; 0x1680 <Webserver_ApplicationCallback+0x34>
    167e:	64 c0       	rjmp	.+200    	; 0x1748 <Webserver_ApplicationCallback+0xfc>
    1680:	eb 01       	movw	r28, r22
    1682:	ce 5f       	subi	r28, 0xFE	; 254
    1684:	dd 4f       	sbci	r29, 0xFD	; 253
    1686:	88 81       	ld	r24, Y
    1688:	88 23       	and	r24, r24
    168a:	09 f0       	breq	.+2      	; 0x168e <Webserver_ApplicationCallback+0x42>
    168c:	9e c0       	rjmp	.+316    	; 0x17ca <Webserver_ApplicationCallback+0x17e>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    168e:	c8 01       	movw	r24, r16
    1690:	64 ed       	ldi	r22, 0xD4	; 212
    1692:	71 e0       	ldi	r23, 0x01	; 1
    1694:	c9 df       	rcall	.-110    	; 0x1628 <IsHTTPCommand>
    1696:	88 23       	and	r24, r24
    1698:	01 f1       	breq	.+64     	; 0x16da <Webserver_ApplicationCallback+0x8e>
    169a:	c8 01       	movw	r24, r16
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    169c:	68 ed       	ldi	r22, 0xD8	; 216
    169e:	71 e0       	ldi	r23, 0x01	; 1
    16a0:	c3 df       	rcall	.-122    	; 0x1628 <IsHTTPCommand>
    16a2:	88 23       	and	r24, r24
    16a4:	51 f1       	breq	.+84     	; 0x16fa <Webserver_ApplicationCallback+0xae>
    16a6:	10 92 be 0d 	sts	0x0DBE, r1
			{
				PageBlock = 0;
    16aa:	c8 01       	movw	r24, r16
    16ac:	62 e6       	ldi	r22, 0x62	; 98

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    16ae:	73 e0       	ldi	r23, 0x03	; 3
    16b0:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <strcpy_P>
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	88 83       	st	Y, r24

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    16b8:	f8 01       	movw	r30, r16
    16ba:	01 90       	ld	r0, Z+
    16bc:	00 20       	and	r0, r0
    16be:	e9 f7       	brne	.-6      	; 0x16ba <Webserver_ApplicationCallback+0x6e>
    16c0:	31 97       	sbiw	r30, 0x01	; 1
    16c2:	e0 1b       	sub	r30, r16
    16c4:	f1 0b       	sbc	r31, r17
    16c6:	d7 01       	movw	r26, r14
    16c8:	11 96       	adiw	r26, 0x01	; 1
    16ca:	fc 93       	st	X, r31
    16cc:	ee 93       	st	-X, r30
    16ce:	f6 01       	movw	r30, r12
    16d0:	80 83       	st	Z, r24
    16d2:	f7 01       	movw	r30, r14
    16d4:	ec 5f       	subi	r30, 0xFC	; 252

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    16d6:	fd 4f       	sbci	r31, 0xFD	; 253
    16d8:	77 c0       	rjmp	.+238    	; 0x17c8 <Webserver_ApplicationCallback+0x17c>
    16da:	c8 01       	movw	r24, r16
    16dc:	6f ed       	ldi	r22, 0xDF	; 223

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    16de:	71 e0       	ldi	r23, 0x01	; 1
    16e0:	a3 df       	rcall	.-186    	; 0x1628 <IsHTTPCommand>
    16e2:	88 23       	and	r24, r24
    16e4:	f9 f0       	breq	.+62     	; 0x1724 <Webserver_ApplicationCallback+0xd8>
    16e6:	c8 01       	movw	r24, r16
    16e8:	64 ee       	ldi	r22, 0xE4	; 228
    16ea:	71 e0       	ldi	r23, 0x01	; 1
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    16ec:	9d df       	rcall	.-198    	; 0x1628 <IsHTTPCommand>
    16ee:	88 23       	and	r24, r24
    16f0:	21 f0       	breq	.+8      	; 0x16fa <Webserver_ApplicationCallback+0xae>
    16f2:	c8 01       	movw	r24, r16
    16f4:	62 e6       	ldi	r22, 0x62	; 98
    16f6:	73 e0       	ldi	r23, 0x03	; 3
    16f8:	03 c0       	rjmp	.+6      	; 0x1700 <Webserver_ApplicationCallback+0xb4>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    16fa:	c8 01       	movw	r24, r16
    16fc:	60 e2       	ldi	r22, 0x20	; 32
    16fe:	73 e0       	ldi	r23, 0x03	; 3
    1700:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <strcpy_P>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1704:	81 e0       	ldi	r24, 0x01	; 1
    1706:	88 83       	st	Y, r24
    1708:	f8 01       	movw	r30, r16
    170a:	01 90       	ld	r0, Z+

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    170c:	00 20       	and	r0, r0
    170e:	e9 f7       	brne	.-6      	; 0x170a <Webserver_ApplicationCallback+0xbe>
    1710:	31 97       	sbiw	r30, 0x01	; 1
    1712:	e0 1b       	sub	r30, r16
    1714:	f1 0b       	sbc	r31, r17
    1716:	d7 01       	movw	r26, r14
    1718:	11 96       	adiw	r26, 0x01	; 1
    171a:	fc 93       	st	X, r31
    171c:	ee 93       	st	-X, r30
    171e:	f6 01       	movw	r30, r12
    1720:	80 83       	st	Z, r24
    1722:	4e c0       	rjmp	.+156    	; 0x17c0 <Webserver_ApplicationCallback+0x174>
    1724:	c8 01       	movw	r24, r16
    1726:	6c ee       	ldi	r22, 0xEC	; 236
    1728:	71 e0       	ldi	r23, 0x01	; 1
    172a:	7e df       	rcall	.-260    	; 0x1628 <IsHTTPCommand>
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    172c:	88 23       	and	r24, r24
    172e:	29 f0       	breq	.+10     	; 0x173a <Webserver_ApplicationCallback+0xee>
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	88 83       	st	Y, r24
    1734:	d6 01       	movw	r26, r12
    1736:	8c 93       	st	X, r24
    1738:	43 c0       	rjmp	.+134    	; 0x17c0 <Webserver_ApplicationCallback+0x174>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    173a:	f6 01       	movw	r30, r12
    173c:	10 82       	st	Z, r1
    173e:	d7 01       	movw	r26, r14
    1740:	11 96       	adiw	r26, 0x01	; 1
    1742:	1c 92       	st	X, r1
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1744:	1e 92       	st	-X, r1
    1746:	41 c0       	rjmp	.+130    	; 0x17ca <Webserver_ApplicationCallback+0x17e>
    1748:	fb 01       	movw	r30, r22
    174a:	ec 5f       	subi	r30, 0xFC	; 252
    174c:	fd 4f       	sbci	r31, 0xFD	; 253
    174e:	80 81       	ld	r24, Z
    1750:	88 23       	and	r24, r24
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1752:	d9 f1       	breq	.+118    	; 0x17ca <Webserver_ApplicationCallback+0x17e>
    1754:	fb 01       	movw	r30, r22
    1756:	ee 5f       	subi	r30, 0xFE	; 254
    1758:	fd 4f       	sbci	r31, 0xFD	; 253
    175a:	80 81       	ld	r24, Z
    175c:	88 23       	and	r24, r24
    175e:	a9 f1       	breq	.+106    	; 0x17ca <Webserver_ApplicationCallback+0x17e>
    1760:	c0 91 be 0d 	lds	r28, 0x0DBE
    1764:	d0 e0       	ldi	r29, 0x00	; 0
    1766:	d6 95       	lsr	r29
    1768:	dc 2f       	mov	r29, r28
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    176a:	cc 27       	eor	r28, r28
    176c:	d7 95       	ror	r29
    176e:	c7 95       	ror	r28
    1770:	c0 5d       	subi	r28, 0xD0	; 208
    1772:	de 4f       	sbci	r29, 0xFE	; 254
    1774:	ce 01       	movw	r24, r28
    1776:	0e 94 78 15 	call	0x2af0	; 0x2af0 <__strlen_P>
    177a:	6c 01       	movw	r12, r24
    177c:	81 38       	cpi	r24, 0x81	; 129


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    177e:	91 05       	cpc	r25, r1
    1780:	18 f0       	brcs	.+6      	; 0x1788 <Webserver_ApplicationCallback+0x13c>
    1782:	80 e8       	ldi	r24, 0x80	; 128
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1784:	c8 2e       	mov	r12, r24
    1786:	d1 2c       	mov	r13, r1
    1788:	c8 01       	movw	r24, r16
    178a:	be 01       	movw	r22, r28
    178c:	a6 01       	movw	r20, r12
    178e:	0e 94 81 15 	call	0x2b02	; 0x2b02 <strncpy_P>

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1792:	f7 01       	movw	r30, r14
    1794:	ee 5f       	subi	r30, 0xFE	; 254
    1796:	fd 4f       	sbci	r31, 0xFD	; 253
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	80 83       	st	Z, r24

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    179c:	f7 01       	movw	r30, r14
    179e:	d1 82       	std	Z+1, r13	; 0x01
    17a0:	c0 82       	st	Z, r12
    17a2:	ed 5f       	subi	r30, 0xFD	; 253
    17a4:	fd 4f       	sbci	r31, 0xFD	; 253
    17a6:	80 83       	st	Z, r24
    17a8:	80 91 be 0d 	lds	r24, 0x0DBE
    17ac:	98 2f       	mov	r25, r24
    17ae:	9f 5f       	subi	r25, 0xFF	; 255
    17b0:	90 93 be 0d 	sts	0x0DBE, r25

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    17b4:	83 30       	cpi	r24, 0x03	; 3
    17b6:	49 f4       	brne	.+18     	; 0x17ca <Webserver_ApplicationCallback+0x17e>
    17b8:	f7 01       	movw	r30, r14
    17ba:	ec 5f       	subi	r30, 0xFC	; 252
    17bc:	fd 4f       	sbci	r31, 0xFD	; 253
    17be:	10 82       	st	Z, r1
    17c0:	f5 01       	movw	r30, r10
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    17c2:	eb 5e       	subi	r30, 0xEB	; 235
    17c4:	fd 4f       	sbci	r31, 0xFD	; 253
    17c6:	87 e0       	ldi	r24, 0x07	; 7
    17c8:	80 83       	st	Z, r24

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	1f 91       	pop	r17
    17d0:	0f 91       	pop	r16
    17d2:	ff 90       	pop	r15
		}
	}
}
    17d4:	ef 90       	pop	r14
    17d6:	df 90       	pop	r13
    17d8:	cf 90       	pop	r12
    17da:	bf 90       	pop	r11
    17dc:	af 90       	pop	r10
    17de:	08 95       	ret

000017e0 <Webserver_Init>:
    17e0:	80 e0       	ldi	r24, 0x00	; 0
    17e2:	90 e5       	ldi	r25, 0x50	; 80
    17e4:	61 e0       	ldi	r22, 0x01	; 1
    17e6:	46 e2       	ldi	r20, 0x26	; 38
    17e8:	5b e0       	ldi	r21, 0x0B	; 11
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    17ea:	9f c9       	rjmp	.-3266   	; 0xb2a <TCP_SetPortState>

000017ec <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    17ec:	af 92       	push	r10
    17ee:	bf 92       	push	r11
    17f0:	cf 92       	push	r12
    17f2:	df 92       	push	r13
    17f4:	ef 92       	push	r14
    17f6:	ff 92       	push	r15
    17f8:	1f 93       	push	r17
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	ec 01       	movw	r28, r24
    1800:	7b 01       	movw	r14, r22
    1802:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    1804:	27 d2       	rcall	.+1102   	; 0x1c54 <Endpoint_WaitUntilReady>
    1806:	18 2f       	mov	r17, r24
    1808:	88 23       	and	r24, r24
    180a:	a9 f5       	brne	.+106    	; 0x1876 <Endpoint_Write_Stream_LE+0x8a>
    180c:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    180e:	d1 04       	cpc	r13, r1
    1810:	39 f0       	breq	.+14     	; 0x1820 <Endpoint_Write_Stream_LE+0x34>
    1812:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    1814:	20 81       	ld	r18, Z
    1816:	31 81       	ldd	r19, Z+1	; 0x01
    1818:	e2 1a       	sub	r14, r18
    181a:	f3 0a       	sbc	r15, r19
    181c:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    181e:	d3 1f       	adc	r29, r19
    1820:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1822:	bb 24       	eor	r11, r11
    1824:	23 c0       	rjmp	.+70     	; 0x186c <Endpoint_Write_Stream_LE+0x80>
    1826:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    182a:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    182c:	16 c0       	rjmp	.+44     	; 0x185a <Endpoint_Write_Stream_LE+0x6e>
    182e:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1832:	8e 77       	andi	r24, 0x7E	; 126
    1834:	80 93 e8 00 	sts	0x00E8, r24
    1838:	d4 d4       	rcall	.+2472   	; 0x21e2 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    183a:	c1 14       	cp	r12, r1
    183c:	d1 04       	cpc	r13, r1
			#endif

			if (BytesProcessed != NULL)
    183e:	49 f0       	breq	.+18     	; 0x1852 <Endpoint_Write_Stream_LE+0x66>
    1840:	f6 01       	movw	r30, r12
    1842:	80 81       	ld	r24, Z
			{
				*BytesProcessed += BytesInTransfer;
    1844:	91 81       	ldd	r25, Z+1	; 0x01
    1846:	8a 0d       	add	r24, r10
    1848:	9b 1d       	adc	r25, r11
    184a:	91 83       	std	Z+1, r25	; 0x01
    184c:	80 83       	st	Z, r24
    184e:	15 e0       	ldi	r17, 0x05	; 5
    1850:	12 c0       	rjmp	.+36     	; 0x1876 <Endpoint_Write_Stream_LE+0x8a>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1852:	00 d2       	rcall	.+1024   	; 0x1c54 <Endpoint_WaitUntilReady>
    1854:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1856:	51 f0       	breq	.+20     	; 0x186c <Endpoint_Write_Stream_LE+0x80>
    1858:	0d c0       	rjmp	.+26     	; 0x1874 <Endpoint_Write_Stream_LE+0x88>
    185a:	89 91       	ld	r24, Y+
    185c:	80 93 f1 00 	sts	0x00F1, r24
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1860:	08 94       	sec
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1862:	e1 08       	sbc	r14, r1
    1864:	f1 08       	sbc	r15, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1866:	08 94       	sec
    1868:	a1 1c       	adc	r10, r1
    186a:	b1 1c       	adc	r11, r1
			BytesInTransfer++;
    186c:	e1 14       	cp	r14, r1
    186e:	f1 04       	cpc	r15, r1
    1870:	d1 f6       	brne	.-76     	; 0x1826 <Endpoint_Write_Stream_LE+0x3a>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    1872:	01 c0       	rjmp	.+2      	; 0x1876 <Endpoint_Write_Stream_LE+0x8a>
    1874:	18 2f       	mov	r17, r24
    1876:	81 2f       	mov	r24, r17
    1878:	df 91       	pop	r29
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    187a:	cf 91       	pop	r28
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    187c:	1f 91       	pop	r17
    187e:	ff 90       	pop	r15
    1880:	ef 90       	pop	r14
    1882:	df 90       	pop	r13
    1884:	cf 90       	pop	r12
    1886:	bf 90       	pop	r11
    1888:	af 90       	pop	r10
    188a:	08 95       	ret

0000188c <Endpoint_Read_Stream_LE>:
    188c:	af 92       	push	r10
    188e:	bf 92       	push	r11
    1890:	cf 92       	push	r12
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    1892:	df 92       	push	r13
    1894:	ef 92       	push	r14
    1896:	ff 92       	push	r15
    1898:	1f 93       	push	r17
    189a:	cf 93       	push	r28
    189c:	df 93       	push	r29
    189e:	ec 01       	movw	r28, r24
    18a0:	7b 01       	movw	r14, r22
    18a2:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    18a4:	d7 d1       	rcall	.+942    	; 0x1c54 <Endpoint_WaitUntilReady>
    18a6:	18 2f       	mov	r17, r24
    18a8:	88 23       	and	r24, r24
    18aa:	a9 f5       	brne	.+106    	; 0x1916 <Endpoint_Read_Stream_LE+0x8a>
    18ac:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    18ae:	d1 04       	cpc	r13, r1
    18b0:	39 f0       	breq	.+14     	; 0x18c0 <Endpoint_Read_Stream_LE+0x34>
    18b2:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    18b4:	20 81       	ld	r18, Z
    18b6:	31 81       	ldd	r19, Z+1	; 0x01
    18b8:	e2 1a       	sub	r14, r18
    18ba:	f3 0a       	sbc	r15, r19
    18bc:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    18be:	d3 1f       	adc	r29, r19
    18c0:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    18c2:	bb 24       	eor	r11, r11
    18c4:	23 c0       	rjmp	.+70     	; 0x190c <Endpoint_Read_Stream_LE+0x80>
    18c6:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    18ca:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    18cc:	16 c0       	rjmp	.+44     	; 0x18fa <Endpoint_Read_Stream_LE+0x6e>
    18ce:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    18d2:	8b 77       	andi	r24, 0x7B	; 123
    18d4:	80 93 e8 00 	sts	0x00E8, r24
    18d8:	84 d4       	rcall	.+2312   	; 0x21e2 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    18da:	c1 14       	cp	r12, r1
    18dc:	d1 04       	cpc	r13, r1
			#endif

			if (BytesProcessed != NULL)
    18de:	49 f0       	breq	.+18     	; 0x18f2 <Endpoint_Read_Stream_LE+0x66>
    18e0:	f6 01       	movw	r30, r12
    18e2:	80 81       	ld	r24, Z
			{
				*BytesProcessed += BytesInTransfer;
    18e4:	91 81       	ldd	r25, Z+1	; 0x01
    18e6:	8a 0d       	add	r24, r10
    18e8:	9b 1d       	adc	r25, r11
    18ea:	91 83       	std	Z+1, r25	; 0x01
    18ec:	80 83       	st	Z, r24
    18ee:	15 e0       	ldi	r17, 0x05	; 5
    18f0:	12 c0       	rjmp	.+36     	; 0x1916 <Endpoint_Read_Stream_LE+0x8a>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    18f2:	b0 d1       	rcall	.+864    	; 0x1c54 <Endpoint_WaitUntilReady>
    18f4:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    18f6:	51 f0       	breq	.+20     	; 0x190c <Endpoint_Read_Stream_LE+0x80>
    18f8:	0d c0       	rjmp	.+26     	; 0x1914 <Endpoint_Read_Stream_LE+0x88>
    18fa:	80 91 f1 00 	lds	r24, 0x00F1
    18fe:	89 93       	st	Y+, r24
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1900:	08 94       	sec
    1902:	e1 08       	sbc	r14, r1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1904:	f1 08       	sbc	r15, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1906:	08 94       	sec
    1908:	a1 1c       	adc	r10, r1
    190a:	b1 1c       	adc	r11, r1
			BytesInTransfer++;
    190c:	e1 14       	cp	r14, r1
    190e:	f1 04       	cpc	r15, r1
    1910:	d1 f6       	brne	.-76     	; 0x18c6 <Endpoint_Read_Stream_LE+0x3a>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    1912:	01 c0       	rjmp	.+2      	; 0x1916 <Endpoint_Read_Stream_LE+0x8a>
    1914:	18 2f       	mov	r17, r24
    1916:	81 2f       	mov	r24, r17
    1918:	df 91       	pop	r29
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    191a:	cf 91       	pop	r28
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    191c:	1f 91       	pop	r17
    191e:	ff 90       	pop	r15
    1920:	ef 90       	pop	r14
    1922:	df 90       	pop	r13
    1924:	cf 90       	pop	r12
    1926:	bf 90       	pop	r11
    1928:	af 90       	pop	r10
    192a:	08 95       	ret

0000192c <Endpoint_Write_Control_Stream_LE>:
    192c:	20 91 11 14 	lds	r18, 0x1411
    1930:	30 91 12 14 	lds	r19, 0x1412
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1934:	26 17       	cp	r18, r22
    1936:	37 07       	cpc	r19, r23
    1938:	20 f4       	brcc	.+8      	; 0x1942 <Endpoint_Write_Control_Stream_LE+0x16>
    193a:	b9 01       	movw	r22, r18
    193c:	fc 01       	movw	r30, r24
    193e:	20 e0       	ldi	r18, 0x00	; 0
    1940:	37 c0       	rjmp	.+110    	; 0x19b0 <Endpoint_Write_Control_Stream_LE+0x84>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1942:	61 15       	cp	r22, r1
    1944:	71 05       	cpc	r23, r1
    1946:	d1 f7       	brne	.-12     	; 0x193c <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1948:	20 91 e8 00 	lds	r18, 0x00E8
    194c:	2e 77       	andi	r18, 0x7E	; 126
    194e:	20 93 e8 00 	sts	0x00E8, r18
    1952:	f4 cf       	rjmp	.-24     	; 0x193c <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1954:	80 91 0a 14 	lds	r24, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1958:	88 23       	and	r24, r24
    195a:	09 f4       	brne	.+2      	; 0x195e <Endpoint_Write_Control_Stream_LE+0x32>
    195c:	3f c0       	rjmp	.+126    	; 0x19dc <Endpoint_Write_Control_Stream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    195e:	85 30       	cpi	r24, 0x05	; 5
    1960:	c9 f1       	breq	.+114    	; 0x19d4 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1962:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1966:	83 fd       	sbrc	r24, 3
    1968:	37 c0       	rjmp	.+110    	; 0x19d8 <Endpoint_Write_Control_Stream_LE+0xac>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    196a:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    196e:	82 fd       	sbrc	r24, 2
    1970:	2b c0       	rjmp	.+86     	; 0x19c8 <Endpoint_Write_Control_Stream_LE+0x9c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1972:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1976:	80 ff       	sbrs	r24, 0
    1978:	1b c0       	rjmp	.+54     	; 0x19b0 <Endpoint_Write_Control_Stream_LE+0x84>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    197a:	80 91 f2 00 	lds	r24, 0x00F2
    197e:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1982:	06 c0       	rjmp	.+12     	; 0x1990 <Endpoint_Write_Control_Stream_LE+0x64>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1984:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1986:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    198a:	61 50       	subi	r22, 0x01	; 1
    198c:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    198e:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1990:	61 15       	cp	r22, r1
    1992:	71 05       	cpc	r23, r1
    1994:	19 f0       	breq	.+6      	; 0x199c <Endpoint_Write_Control_Stream_LE+0x70>
    1996:	88 30       	cpi	r24, 0x08	; 8
    1998:	91 05       	cpc	r25, r1
    199a:	a0 f3       	brcs	.-24     	; 0x1984 <Endpoint_Write_Control_Stream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    199c:	21 e0       	ldi	r18, 0x01	; 1
    199e:	88 30       	cpi	r24, 0x08	; 8
    19a0:	91 05       	cpc	r25, r1
    19a2:	09 f0       	breq	.+2      	; 0x19a6 <Endpoint_Write_Control_Stream_LE+0x7a>
    19a4:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    19a6:	80 91 e8 00 	lds	r24, 0x00E8
    19aa:	8e 77       	andi	r24, 0x7E	; 126
    19ac:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    19b0:	61 15       	cp	r22, r1
    19b2:	71 05       	cpc	r23, r1
    19b4:	79 f6       	brne	.-98     	; 0x1954 <Endpoint_Write_Control_Stream_LE+0x28>
    19b6:	22 23       	and	r18, r18
    19b8:	69 f6       	brne	.-102    	; 0x1954 <Endpoint_Write_Control_Stream_LE+0x28>
    19ba:	06 c0       	rjmp	.+12     	; 0x19c8 <Endpoint_Write_Control_Stream_LE+0x9c>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    19bc:	80 91 0a 14 	lds	r24, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    19c0:	88 23       	and	r24, r24
    19c2:	61 f0       	breq	.+24     	; 0x19dc <Endpoint_Write_Control_Stream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    19c4:	85 30       	cpi	r24, 0x05	; 5
    19c6:	61 f0       	breq	.+24     	; 0x19e0 <Endpoint_Write_Control_Stream_LE+0xb4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    19c8:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    19cc:	82 ff       	sbrs	r24, 2
    19ce:	f6 cf       	rjmp	.-20     	; 0x19bc <Endpoint_Write_Control_Stream_LE+0x90>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    19d0:	80 e0       	ldi	r24, 0x00	; 0
    19d2:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    19d4:	83 e0       	ldi	r24, 0x03	; 3
    19d6:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    19dc:	82 e0       	ldi	r24, 0x02	; 2
    19de:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    19e0:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    19e2:	08 95       	ret

000019e4 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    19e4:	61 15       	cp	r22, r1
    19e6:	71 05       	cpc	r23, r1
    19e8:	29 f4       	brne	.+10     	; 0x19f4 <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    19ea:	20 91 e8 00 	lds	r18, 0x00E8
    19ee:	2b 77       	andi	r18, 0x7B	; 123
    19f0:	20 93 e8 00 	sts	0x00E8, r18

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    19f4:	38 2f       	mov	r19, r24
    19f6:	29 2f       	mov	r18, r25
    19f8:	26 c0       	rjmp	.+76     	; 0x1a46 <Endpoint_Read_Control_Stream_LE+0x62>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    19fa:	80 91 0a 14 	lds	r24, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    19fe:	88 23       	and	r24, r24
    1a00:	b1 f1       	breq	.+108    	; 0x1a6e <Endpoint_Read_Control_Stream_LE+0x8a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1a02:	85 30       	cpi	r24, 0x05	; 5
    1a04:	81 f1       	breq	.+96     	; 0x1a66 <Endpoint_Read_Control_Stream_LE+0x82>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1a06:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1a0a:	83 fd       	sbrc	r24, 3
    1a0c:	2e c0       	rjmp	.+92     	; 0x1a6a <Endpoint_Read_Control_Stream_LE+0x86>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1a0e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1a12:	82 ff       	sbrs	r24, 2
    1a14:	f2 cf       	rjmp	.-28     	; 0x19fa <Endpoint_Read_Control_Stream_LE+0x16>
    1a16:	e3 2f       	mov	r30, r19
    1a18:	f2 2f       	mov	r31, r18
    1a1a:	08 c0       	rjmp	.+16     	; 0x1a2c <Endpoint_Read_Control_Stream_LE+0x48>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1a1c:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1a20:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1a22:	3e 2f       	mov	r19, r30
    1a24:	2f 2f       	mov	r18, r31
				Length--;
    1a26:	61 50       	subi	r22, 0x01	; 1
    1a28:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    1a2a:	41 f0       	breq	.+16     	; 0x1a3c <Endpoint_Read_Control_Stream_LE+0x58>
    1a2c:	3e 2f       	mov	r19, r30
    1a2e:	2f 2f       	mov	r18, r31
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    1a30:	80 91 f2 00 	lds	r24, 0x00F2
    1a34:	90 91 f3 00 	lds	r25, 0x00F3
    1a38:	00 97       	sbiw	r24, 0x00	; 0
    1a3a:	81 f7       	brne	.-32     	; 0x1a1c <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1a3c:	80 91 e8 00 	lds	r24, 0x00E8
    1a40:	8b 77       	andi	r24, 0x7B	; 123
    1a42:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    1a46:	61 15       	cp	r22, r1
    1a48:	71 05       	cpc	r23, r1
    1a4a:	b9 f6       	brne	.-82     	; 0x19fa <Endpoint_Read_Control_Stream_LE+0x16>
    1a4c:	06 c0       	rjmp	.+12     	; 0x1a5a <Endpoint_Read_Control_Stream_LE+0x76>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1a4e:	80 91 0a 14 	lds	r24, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1a52:	88 23       	and	r24, r24
    1a54:	61 f0       	breq	.+24     	; 0x1a6e <Endpoint_Read_Control_Stream_LE+0x8a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1a56:	85 30       	cpi	r24, 0x05	; 5
    1a58:	61 f0       	breq	.+24     	; 0x1a72 <Endpoint_Read_Control_Stream_LE+0x8e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1a5a:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    1a5e:	80 ff       	sbrs	r24, 0
    1a60:	f6 cf       	rjmp	.-20     	; 0x1a4e <Endpoint_Read_Control_Stream_LE+0x6a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1a62:	80 e0       	ldi	r24, 0x00	; 0
    1a64:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1a66:	83 e0       	ldi	r24, 0x03	; 3
    1a68:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1a6e:	82 e0       	ldi	r24, 0x02	; 2
    1a70:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1a72:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1a74:	08 95       	ret

00001a76 <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1a76:	20 91 11 14 	lds	r18, 0x1411
    1a7a:	30 91 12 14 	lds	r19, 0x1412
    1a7e:	26 17       	cp	r18, r22
    1a80:	37 07       	cpc	r19, r23
    1a82:	20 f4       	brcc	.+8      	; 0x1a8c <Endpoint_Write_Control_PStream_LE+0x16>
    1a84:	b9 01       	movw	r22, r18
    1a86:	fc 01       	movw	r30, r24
    1a88:	20 e0       	ldi	r18, 0x00	; 0
    1a8a:	38 c0       	rjmp	.+112    	; 0x1afc <Endpoint_Write_Control_PStream_LE+0x86>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1a8c:	61 15       	cp	r22, r1
    1a8e:	71 05       	cpc	r23, r1
    1a90:	d1 f7       	brne	.-12     	; 0x1a86 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1a92:	20 91 e8 00 	lds	r18, 0x00E8
    1a96:	2e 77       	andi	r18, 0x7E	; 126
    1a98:	20 93 e8 00 	sts	0x00E8, r18
    1a9c:	f4 cf       	rjmp	.-24     	; 0x1a86 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1a9e:	80 91 0a 14 	lds	r24, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1aa2:	88 23       	and	r24, r24
    1aa4:	09 f4       	brne	.+2      	; 0x1aa8 <Endpoint_Write_Control_PStream_LE+0x32>
    1aa6:	40 c0       	rjmp	.+128    	; 0x1b28 <Endpoint_Write_Control_PStream_LE+0xb2>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1aa8:	85 30       	cpi	r24, 0x05	; 5
    1aaa:	d1 f1       	breq	.+116    	; 0x1b20 <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1aac:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1ab0:	83 fd       	sbrc	r24, 3
    1ab2:	38 c0       	rjmp	.+112    	; 0x1b24 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1ab4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1ab8:	82 fd       	sbrc	r24, 2
    1aba:	2c c0       	rjmp	.+88     	; 0x1b14 <Endpoint_Write_Control_PStream_LE+0x9e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1abc:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1ac0:	80 ff       	sbrs	r24, 0
    1ac2:	1c c0       	rjmp	.+56     	; 0x1afc <Endpoint_Write_Control_PStream_LE+0x86>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    1ac4:	80 91 f2 00 	lds	r24, 0x00F2
    1ac8:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1acc:	07 c0       	rjmp	.+14     	; 0x1adc <Endpoint_Write_Control_PStream_LE+0x66>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1ace:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1ad0:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1ad4:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1ad6:	61 50       	subi	r22, 0x01	; 1
    1ad8:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    1ada:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1adc:	61 15       	cp	r22, r1
    1ade:	71 05       	cpc	r23, r1
    1ae0:	19 f0       	breq	.+6      	; 0x1ae8 <Endpoint_Write_Control_PStream_LE+0x72>
    1ae2:	88 30       	cpi	r24, 0x08	; 8
    1ae4:	91 05       	cpc	r25, r1
    1ae6:	98 f3       	brcs	.-26     	; 0x1ace <Endpoint_Write_Control_PStream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1ae8:	21 e0       	ldi	r18, 0x01	; 1
    1aea:	88 30       	cpi	r24, 0x08	; 8
    1aec:	91 05       	cpc	r25, r1
    1aee:	09 f0       	breq	.+2      	; 0x1af2 <Endpoint_Write_Control_PStream_LE+0x7c>
    1af0:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1af2:	80 91 e8 00 	lds	r24, 0x00E8
    1af6:	8e 77       	andi	r24, 0x7E	; 126
    1af8:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1afc:	61 15       	cp	r22, r1
    1afe:	71 05       	cpc	r23, r1
    1b00:	71 f6       	brne	.-100    	; 0x1a9e <Endpoint_Write_Control_PStream_LE+0x28>
    1b02:	22 23       	and	r18, r18
    1b04:	61 f6       	brne	.-104    	; 0x1a9e <Endpoint_Write_Control_PStream_LE+0x28>
    1b06:	06 c0       	rjmp	.+12     	; 0x1b14 <Endpoint_Write_Control_PStream_LE+0x9e>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1b08:	80 91 0a 14 	lds	r24, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1b0c:	88 23       	and	r24, r24
    1b0e:	61 f0       	breq	.+24     	; 0x1b28 <Endpoint_Write_Control_PStream_LE+0xb2>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1b10:	85 30       	cpi	r24, 0x05	; 5
    1b12:	61 f0       	breq	.+24     	; 0x1b2c <Endpoint_Write_Control_PStream_LE+0xb6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1b14:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1b18:	82 ff       	sbrs	r24, 2
    1b1a:	f6 cf       	rjmp	.-20     	; 0x1b08 <Endpoint_Write_Control_PStream_LE+0x92>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1b1c:	80 e0       	ldi	r24, 0x00	; 0
    1b1e:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b20:	83 e0       	ldi	r24, 0x03	; 3
    1b22:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1b28:	82 e0       	ldi	r24, 0x02	; 2
    1b2a:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b2c:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1b2e:	08 95       	ret

00001b30 <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1b30:	98 2f       	mov	r25, r24
    1b32:	2a c0       	rjmp	.+84     	; 0x1b88 <Endpoint_ConfigureEndpoint_Prv+0x58>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1b34:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    1b38:	98 17       	cp	r25, r24
    1b3a:	39 f0       	breq	.+14     	; 0x1b4a <Endpoint_ConfigureEndpoint_Prv+0x1a>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1b3c:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1b40:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    1b44:	50 91 f0 00 	lds	r21, 0x00F0
    1b48:	03 c0       	rjmp	.+6      	; 0x1b50 <Endpoint_ConfigureEndpoint_Prv+0x20>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    1b4a:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    1b4c:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    1b4e:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1b50:	21 ff       	sbrs	r18, 1
    1b52:	19 c0       	rjmp	.+50     	; 0x1b86 <Endpoint_ConfigureEndpoint_Prv+0x56>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1b54:	30 91 eb 00 	lds	r19, 0x00EB
    1b58:	3e 7f       	andi	r19, 0xFE	; 254
    1b5a:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1b5e:	30 91 ed 00 	lds	r19, 0x00ED
    1b62:	3d 7f       	andi	r19, 0xFD	; 253
    1b64:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1b68:	30 91 eb 00 	lds	r19, 0x00EB
    1b6c:	31 60       	ori	r19, 0x01	; 1
    1b6e:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1b72:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1b76:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    1b7a:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1b7e:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    1b82:	27 ff       	sbrs	r18, 7
    1b84:	08 c0       	rjmp	.+16     	; 0x1b96 <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1b86:	9f 5f       	subi	r25, 0xFF	; 255
    1b88:	97 30       	cpi	r25, 0x07	; 7
    1b8a:	a0 f2       	brcs	.-88     	; 0x1b34 <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1b8c:	8f 70       	andi	r24, 0x0F	; 15
    1b8e:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    1b96:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1b98:	08 95       	ret

00001b9a <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    1b9a:	0f 93       	push	r16
    1b9c:	1f 93       	push	r17
    1b9e:	cf 93       	push	r28
    1ba0:	df 93       	push	r29
    1ba2:	16 2f       	mov	r17, r22
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    1ba4:	ec 01       	movw	r28, r24
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1ba6:	00 e0       	ldi	r16, 0x00	; 0
    1ba8:	2a c0       	rjmp	.+84     	; 0x1bfe <Endpoint_ConfigureEndpointTable+0x64>
	{
		if (!(Table[i].Address))
    1baa:	98 81       	ld	r25, Y
    1bac:	99 23       	and	r25, r25
    1bae:	29 f1       	breq	.+74     	; 0x1bfa <Endpoint_ConfigureEndpointTable+0x60>
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1bb0:	6b 81       	ldd	r22, Y+3	; 0x03
    1bb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb6:	2c 81       	ldd	r18, Y+4	; 0x04
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    1bb8:	89 2f       	mov	r24, r25
    1bba:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    1bbc:	87 30       	cpi	r24, 0x07	; 7
    1bbe:	18 f5       	brcc	.+70     	; 0x1c06 <Endpoint_ConfigureEndpointTable+0x6c>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    1bc0:	62 95       	swap	r22
    1bc2:	66 0f       	add	r22, r22
    1bc4:	66 0f       	add	r22, r22
    1bc6:	60 7c       	andi	r22, 0xC0	; 192
    1bc8:	99 1f       	adc	r25, r25
    1bca:	99 27       	eor	r25, r25
    1bcc:	99 1f       	adc	r25, r25
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1bce:	69 2b       	or	r22, r25
    1bd0:	22 30       	cpi	r18, 0x02	; 2
    1bd2:	10 f0       	brcs	.+4      	; 0x1bd8 <Endpoint_ConfigureEndpointTable+0x3e>
    1bd4:	96 e0       	ldi	r25, 0x06	; 6
    1bd6:	01 c0       	rjmp	.+2      	; 0x1bda <Endpoint_ConfigureEndpointTable+0x40>
    1bd8:	92 e0       	ldi	r25, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    1bda:	28 e0       	ldi	r18, 0x08	; 8
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    1bde:	40 e0       	ldi	r20, 0x00	; 0
    1be0:	03 c0       	rjmp	.+6      	; 0x1be8 <Endpoint_ConfigureEndpointTable+0x4e>
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    1be2:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    1be4:	22 0f       	add	r18, r18
    1be6:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1be8:	2e 17       	cp	r18, r30
    1bea:	3f 07       	cpc	r19, r31
    1bec:	d0 f3       	brcs	.-12     	; 0x1be2 <Endpoint_ConfigureEndpointTable+0x48>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    1bee:	42 95       	swap	r20
    1bf0:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1bf2:	49 2b       	or	r20, r25
    1bf4:	9d df       	rcall	.-198    	; 0x1b30 <Endpoint_ConfigureEndpoint_Prv>
    1bf6:	88 23       	and	r24, r24
    1bf8:	31 f0       	breq	.+12     	; 0x1c06 <Endpoint_ConfigureEndpointTable+0x6c>
    1bfa:	0f 5f       	subi	r16, 0xFF	; 255
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1bfc:	25 96       	adiw	r28, 0x05	; 5
    1bfe:	01 17       	cp	r16, r17
    1c00:	a1 f6       	brne	.-88     	; 0x1baa <Endpoint_ConfigureEndpointTable+0x10>
    1c02:	81 e0       	ldi	r24, 0x01	; 1
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}
	
	return true;
    1c04:	01 c0       	rjmp	.+2      	; 0x1c08 <Endpoint_ConfigureEndpointTable+0x6e>
    1c06:	80 e0       	ldi	r24, 0x00	; 0
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    1c08:	df 91       	pop	r29
	}
	
	return true;
}
    1c0a:	cf 91       	pop	r28
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	08 95       	ret

00001c12 <Endpoint_ClearStatusStage>:
    1c12:	80 91 0b 14 	lds	r24, 0x140B
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1c16:	87 ff       	sbrs	r24, 7
    1c18:	13 c0       	rjmp	.+38     	; 0x1c40 <Endpoint_ClearStatusStage+0x2e>
    1c1a:	04 c0       	rjmp	.+8      	; 0x1c24 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c1c:	80 91 0a 14 	lds	r24, 0x140A
    1c20:	88 23       	and	r24, r24
    1c22:	b9 f0       	breq	.+46     	; 0x1c52 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1c24:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1c28:	82 ff       	sbrs	r24, 2
    1c2a:	f8 cf       	rjmp	.-16     	; 0x1c1c <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1c2c:	80 91 e8 00 	lds	r24, 0x00E8
    1c30:	8b 77       	andi	r24, 0x7B	; 123
    1c32:	80 93 e8 00 	sts	0x00E8, r24
    1c36:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c38:	80 91 0a 14 	lds	r24, 0x140A
    1c3c:	88 23       	and	r24, r24
    1c3e:	49 f0       	breq	.+18     	; 0x1c52 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1c40:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1c44:	80 ff       	sbrs	r24, 0
    1c46:	f8 cf       	rjmp	.-16     	; 0x1c38 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1c48:	80 91 e8 00 	lds	r24, 0x00E8
    1c4c:	8e 77       	andi	r24, 0x7E	; 126
    1c4e:	80 93 e8 00 	sts	0x00E8, r24
    1c52:	08 95       	ret

00001c54 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1c54:	80 91 e4 00 	lds	r24, 0x00E4
    1c58:	90 91 e5 00 	lds	r25, 0x00E5
    1c5c:	45 e6       	ldi	r20, 0x65	; 101
    1c5e:	01 c0       	rjmp	.+2      	; 0x1c62 <Endpoint_WaitUntilReady+0xe>
    1c60:	c9 01       	movw	r24, r18
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1c62:	20 91 ec 00 	lds	r18, 0x00EC
    1c66:	20 ff       	sbrs	r18, 0
    1c68:	23 c0       	rjmp	.+70     	; 0x1cb0 <Endpoint_WaitUntilReady+0x5c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1c6a:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1c6e:	20 fd       	sbrc	r18, 0
    1c70:	15 c0       	rjmp	.+42     	; 0x1c9c <Endpoint_WaitUntilReady+0x48>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1c72:	20 91 0a 14 	lds	r18, 0x140A

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1c76:	22 23       	and	r18, r18
    1c78:	99 f0       	breq	.+38     	; 0x1ca0 <Endpoint_WaitUntilReady+0x4c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1c7a:	25 30       	cpi	r18, 0x05	; 5
    1c7c:	99 f0       	breq	.+38     	; 0x1ca4 <Endpoint_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1c7e:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1c82:	25 fd       	sbrc	r18, 5
    1c84:	11 c0       	rjmp	.+34     	; 0x1ca8 <Endpoint_WaitUntilReady+0x54>
    1c86:	20 91 e4 00 	lds	r18, 0x00E4
    1c8a:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1c8e:	28 17       	cp	r18, r24
    1c90:	39 07       	cpc	r19, r25
    1c92:	39 f3       	breq	.-50     	; 0x1c62 <Endpoint_WaitUntilReady+0xe>
    1c94:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1c96:	21 f7       	brne	.-56     	; 0x1c60 <Endpoint_WaitUntilReady+0xc>
			  return ENDPOINT_READYWAIT_Timeout;
    1c98:	84 e0       	ldi	r24, 0x04	; 4
    1c9a:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1c9c:	80 e0       	ldi	r24, 0x00	; 0
    1c9e:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1ca0:	82 e0       	ldi	r24, 0x02	; 2
    1ca2:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1ca4:	83 e0       	ldi	r24, 0x03	; 3
    1ca6:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1ca8:	81 e0       	ldi	r24, 0x01	; 1
    1caa:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    1cac:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1cae:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1cb0:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1cb4:	22 ff       	sbrs	r18, 2
    1cb6:	dd cf       	rjmp	.-70     	; 0x1c72 <Endpoint_WaitUntilReady+0x1e>
    1cb8:	f9 cf       	rjmp	.-14     	; 0x1cac <Endpoint_WaitUntilReady+0x58>

00001cba <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1cba:	0f 93       	push	r16
    1cbc:	1f 93       	push	r17
    1cbe:	cf 93       	push	r28
    1cc0:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1cc2:	4e d0       	rcall	.+156    	; 0x1d60 <USB_INT_DisableAllInterrupts>
    1cc4:	55 d0       	rcall	.+170    	; 0x1d70 <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1cc6:	c8 ed       	ldi	r28, 0xD8	; 216
    1cc8:	d0 e0       	ldi	r29, 0x00	; 0
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1cca:	88 81       	ld	r24, Y
    1ccc:	8f 77       	andi	r24, 0x7F	; 127
    1cce:	88 83       	st	Y, r24
    1cd0:	88 81       	ld	r24, Y
    1cd2:	80 68       	ori	r24, 0x80	; 128
				USBCON |=  (1 << USBE);
    1cd4:	88 83       	st	Y, r24
    1cd6:	88 81       	ld	r24, Y
    1cd8:	8f 7d       	andi	r24, 0xDF	; 223
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1cda:	88 83       	st	Y, r24
    1cdc:	e7 ed       	ldi	r30, 0xD7	; 215
    1cde:	f0 e0       	ldi	r31, 0x00	; 0

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1ce0:	80 81       	ld	r24, Z
    1ce2:	80 68       	ori	r24, 0x80	; 128
    1ce4:	80 83       	st	Z, r24
    1ce6:	19 bc       	out	0x29, r1	; 41
    1ce8:	10 92 0a 14 	sts	0x140A, r1
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1cec:	10 92 06 14 	sts	0x1406, r1
	USB_Device_ConfigurationNumber  = 0;
    1cf0:	10 92 08 14 	sts	0x1408, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1cf4:	10 92 07 14 	sts	0x1407, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1cf8:	00 ee       	ldi	r16, 0xE0	; 224
    1cfa:	10 e0       	ldi	r17, 0x00	; 0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1cfc:	f8 01       	movw	r30, r16
    1cfe:	80 81       	ld	r24, Z
    1d00:	8b 7f       	andi	r24, 0xFB	; 251
    1d02:	80 83       	st	Z, r24
    1d04:	88 81       	ld	r24, Y
    1d06:	81 60       	ori	r24, 0x01	; 1
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1d08:	88 83       	st	Y, r24
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
    1d0c:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1d0e:	42 e0       	ldi	r20, 0x02	; 2
    1d10:	0f df       	rcall	.-482    	; 0x1b30 <Endpoint_ConfigureEndpoint_Prv>
    1d12:	e1 ee       	ldi	r30, 0xE1	; 225
    1d14:	f0 e0       	ldi	r31, 0x00	; 0
    1d16:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1d18:	8e 7f       	andi	r24, 0xFE	; 254
    1d1a:	80 83       	st	Z, r24
    1d1c:	e2 ee       	ldi	r30, 0xE2	; 226
    1d1e:	f0 e0       	ldi	r31, 0x00	; 0
    1d20:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1d22:	81 60       	ori	r24, 0x01	; 1
    1d24:	80 83       	st	Z, r24
    1d26:	80 81       	ld	r24, Z
    1d28:	88 60       	ori	r24, 0x08	; 8
    1d2a:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	80 81       	ld	r24, Z
    1d30:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1d32:	80 83       	st	Z, r24
    1d34:	88 81       	ld	r24, Y
    1d36:	80 61       	ori	r24, 0x10	; 16
    1d38:	88 83       	st	Y, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	1f 91       	pop	r17
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1d40:	0f 91       	pop	r16
    1d42:	08 95       	ret

00001d44 <USB_Init>:
    1d44:	e8 ed       	ldi	r30, 0xD8	; 216
    1d46:	f0 e0       	ldi	r31, 0x00	; 0
    1d48:	80 81       	ld	r24, Z
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    1d4a:	8f 7e       	andi	r24, 0xEF	; 239
    1d4c:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    1d4e:	e7 ed       	ldi	r30, 0xD7	; 215
    1d50:	f0 e0       	ldi	r31, 0x00	; 0
    1d52:	80 81       	ld	r24, Z
    1d54:	81 60       	ori	r24, 0x01	; 1
    1d56:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1d58:	81 e0       	ldi	r24, 0x01	; 1
    1d5a:	80 93 09 14 	sts	0x1409, r24

	USB_ResetInterface();
    1d5e:	ad cf       	rjmp	.-166    	; 0x1cba <USB_ResetInterface>

00001d60 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1d60:	e8 ed       	ldi	r30, 0xD8	; 216
    1d62:	f0 e0       	ldi	r31, 0x00	; 0
    1d64:	80 81       	ld	r24, Z
    1d66:	8c 7f       	andi	r24, 0xFC	; 252
    1d68:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1d6a:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1d6e:	08 95       	ret

00001d70 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1d70:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1d74:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1d78:	08 95       	ret

00001d7a <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1d7a:	1f 92       	push	r1
    1d7c:	0f 92       	push	r0
    1d7e:	0f b6       	in	r0, 0x3f	; 63
    1d80:	0f 92       	push	r0
    1d82:	0b b6       	in	r0, 0x3b	; 59
    1d84:	0f 92       	push	r0
    1d86:	11 24       	eor	r1, r1
    1d88:	2f 93       	push	r18
    1d8a:	3f 93       	push	r19
    1d8c:	4f 93       	push	r20
    1d8e:	5f 93       	push	r21
    1d90:	6f 93       	push	r22
    1d92:	7f 93       	push	r23
    1d94:	8f 93       	push	r24
    1d96:	9f 93       	push	r25
    1d98:	af 93       	push	r26
    1d9a:	bf 93       	push	r27
    1d9c:	ef 93       	push	r30
    1d9e:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1da0:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1da4:	82 ff       	sbrs	r24, 2
    1da6:	0a c0       	rjmp	.+20     	; 0x1dbc <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1da8:	80 91 e2 00 	lds	r24, 0x00E2
    1dac:	82 ff       	sbrs	r24, 2
    1dae:	06 c0       	rjmp	.+12     	; 0x1dbc <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1db0:	80 91 e1 00 	lds	r24, 0x00E1
    1db4:	8b 7f       	andi	r24, 0xFB	; 251
    1db6:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1dba:	12 d2       	rcall	.+1060   	; 0x21e0 <USB_Event_Stub>
    1dbc:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1dc0:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1dc2:	1f c0       	rjmp	.+62     	; 0x1e02 <__vector_10+0x88>
    1dc4:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1dc8:	80 ff       	sbrs	r24, 0
    1dca:	1b c0       	rjmp	.+54     	; 0x1e02 <__vector_10+0x88>
    1dcc:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1dd0:	8e 7f       	andi	r24, 0xFE	; 254
    1dd2:	80 93 da 00 	sts	0x00DA, r24
    1dd6:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1dda:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1ddc:	0d c0       	rjmp	.+26     	; 0x1df8 <__vector_10+0x7e>
    1dde:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1de0:	89 bd       	out	0x29, r24	; 41
    1de2:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1de4:	89 bd       	out	0x29, r24	; 41
    1de6:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1de8:	00 fe       	sbrs	r0, 0
    1dea:	fd cf       	rjmp	.-6      	; 0x1de6 <__vector_10+0x6c>
    1dec:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1dee:	80 93 0a 14 	sts	0x140A, r24
    1df2:	0e 94 a0 02 	call	0x540	; 0x540 <EVENT_USB_Device_Connect>
			EVENT_USB_Device_Connect();
    1df6:	05 c0       	rjmp	.+10     	; 0x1e02 <__vector_10+0x88>
    1df8:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1dfa:	10 92 0a 14 	sts	0x140A, r1
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1dfe:	0e 94 a2 02 	call	0x544	; 0x544 <EVENT_USB_Device_Disconnect>
			EVENT_USB_Device_Disconnect();
    1e02:	80 91 e1 00 	lds	r24, 0x00E1
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1e06:	80 ff       	sbrs	r24, 0
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1e08:	18 c0       	rjmp	.+48     	; 0x1e3a <__vector_10+0xc0>
    1e0a:	80 91 e2 00 	lds	r24, 0x00E2
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1e0e:	80 ff       	sbrs	r24, 0
    1e10:	14 c0       	rjmp	.+40     	; 0x1e3a <__vector_10+0xc0>
    1e12:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1e16:	8e 7f       	andi	r24, 0xFE	; 254
    1e18:	80 93 e2 00 	sts	0x00E2, r24
    1e1c:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1e20:	80 61       	ori	r24, 0x10	; 16
    1e22:	80 93 e2 00 	sts	0x00E2, r24
    1e26:	80 91 d8 00 	lds	r24, 0x00D8
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    1e2a:	80 62       	ori	r24, 0x20	; 32
    1e2c:	80 93 d8 00 	sts	0x00D8, r24
    1e30:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1e32:	85 e0       	ldi	r24, 0x05	; 5

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1e34:	80 93 0a 14 	sts	0x140A, r24
    1e38:	d3 d1       	rcall	.+934    	; 0x21e0 <USB_Event_Stub>
		EVENT_USB_Device_Suspend();
    1e3a:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1e3e:	84 ff       	sbrs	r24, 4
    1e40:	2d c0       	rjmp	.+90     	; 0x1e9c <__vector_10+0x122>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1e42:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1e46:	84 ff       	sbrs	r24, 4
    1e48:	29 c0       	rjmp	.+82     	; 0x1e9c <__vector_10+0x122>
    1e4a:	8c e0       	ldi	r24, 0x0C	; 12
    1e4c:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1e4e:	8e e0       	ldi	r24, 0x0E	; 14
    1e50:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1e52:	09 b4       	in	r0, 0x29	; 41
    1e54:	00 fe       	sbrs	r0, 0
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1e56:	fd cf       	rjmp	.-6      	; 0x1e52 <__vector_10+0xd8>
    1e58:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1e5c:	8f 7d       	andi	r24, 0xDF	; 223
    1e5e:	80 93 d8 00 	sts	0x00D8, r24
    1e62:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1e66:	8f 7e       	andi	r24, 0xEF	; 239
    1e68:	80 93 e1 00 	sts	0x00E1, r24
    1e6c:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1e70:	8f 7e       	andi	r24, 0xEF	; 239
    1e72:	80 93 e2 00 	sts	0x00E2, r24
    1e76:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1e7a:	81 60       	ori	r24, 0x01	; 1
    1e7c:	80 93 e2 00 	sts	0x00E2, r24
    1e80:	80 91 06 14 	lds	r24, 0x1406
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1e84:	88 23       	and	r24, r24
    1e86:	21 f4       	brne	.+8      	; 0x1e90 <__vector_10+0x116>
    1e88:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1e8c:	87 ff       	sbrs	r24, 7
    1e8e:	02 c0       	rjmp	.+4      	; 0x1e94 <__vector_10+0x11a>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1e90:	84 e0       	ldi	r24, 0x04	; 4
    1e92:	01 c0       	rjmp	.+2      	; 0x1e96 <__vector_10+0x11c>
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	80 93 0a 14 	sts	0x140A, r24
    1e9a:	a2 d1       	rcall	.+836    	; 0x21e0 <USB_Event_Stub>
    1e9c:	80 91 e1 00 	lds	r24, 0x00E1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1ea0:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1ea2:	22 c0       	rjmp	.+68     	; 0x1ee8 <__vector_10+0x16e>
    1ea4:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1ea8:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1eaa:	1e c0       	rjmp	.+60     	; 0x1ee8 <__vector_10+0x16e>
    1eac:	80 91 e1 00 	lds	r24, 0x00E1
    1eb0:	87 7f       	andi	r24, 0xF7	; 247
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1eb2:	80 93 e1 00 	sts	0x00E1, r24
    1eb6:	82 e0       	ldi	r24, 0x02	; 2
    1eb8:	80 93 0a 14 	sts	0x140A, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1ebc:	10 92 06 14 	sts	0x1406, r1
    1ec0:	80 91 e1 00 	lds	r24, 0x00E1
		USB_Device_ConfigurationNumber = 0;
    1ec4:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1ec6:	80 93 e1 00 	sts	0x00E1, r24
    1eca:	80 91 e2 00 	lds	r24, 0x00E2
    1ece:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1ed0:	80 93 e2 00 	sts	0x00E2, r24
    1ed4:	80 91 e2 00 	lds	r24, 0x00E2
    1ed8:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1eda:	80 93 e2 00 	sts	0x00E2, r24
    1ede:	80 e0       	ldi	r24, 0x00	; 0
    1ee0:	60 e0       	ldi	r22, 0x00	; 0
    1ee2:	42 e0       	ldi	r20, 0x02	; 2
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1ee4:	25 de       	rcall	.-950    	; 0x1b30 <Endpoint_ConfigureEndpoint_Prv>
    1ee6:	7c d1       	rcall	.+760    	; 0x21e0 <USB_Event_Stub>
    1ee8:	ff 91       	pop	r31
    1eea:	ef 91       	pop	r30
    1eec:	bf 91       	pop	r27

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1eee:	af 91       	pop	r26
    1ef0:	9f 91       	pop	r25
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1ef2:	8f 91       	pop	r24
    1ef4:	7f 91       	pop	r23
    1ef6:	6f 91       	pop	r22
    1ef8:	5f 91       	pop	r21
    1efa:	4f 91       	pop	r20
    1efc:	3f 91       	pop	r19
    1efe:	2f 91       	pop	r18
    1f00:	0f 90       	pop	r0
    1f02:	0b be       	out	0x3b, r0	; 59
    1f04:	0f 90       	pop	r0
    1f06:	0f be       	out	0x3f, r0	; 63
    1f08:	0f 90       	pop	r0
    1f0a:	1f 90       	pop	r1
    1f0c:	18 95       	reti

00001f0e <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1f0e:	1f 93       	push	r17
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	cd b7       	in	r28, 0x3d	; 61
    1f16:	de b7       	in	r29, 0x3e	; 62
    1f18:	ac 97       	sbiw	r28, 0x2c	; 44
    1f1a:	0f b6       	in	r0, 0x3f	; 63
    1f1c:	f8 94       	cli
    1f1e:	de bf       	out	0x3e, r29	; 62
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1f24:	80 e0       	ldi	r24, 0x00	; 0
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    1f26:	eb e0       	ldi	r30, 0x0B	; 11
    1f28:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1f2a:	90 91 f1 00 	lds	r25, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    1f2e:	91 93       	st	Z+, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1f30:	8f 5f       	subi	r24, 0xFF	; 255
    1f32:	88 30       	cpi	r24, 0x08	; 8
    1f34:	d1 f7       	brne	.-12     	; 0x1f2a <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    1f36:	0e 94 ae 02 	call	0x55c	; 0x55c <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1f3a:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    1f3e:	83 ff       	sbrs	r24, 3
    1f40:	37 c1       	rjmp	.+622    	; 0x21b0 <__stack+0xb1>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1f42:	80 91 0b 14 	lds	r24, 0x140B

		switch (USB_ControlRequest.bRequest)
    1f46:	20 91 0c 14 	lds	r18, 0x140C
    1f4a:	25 30       	cpi	r18, 0x05	; 5
    1f4c:	09 f4       	brne	.+2      	; 0x1f50 <USB_Device_ProcessControlRequest+0x42>
    1f4e:	84 c0       	rjmp	.+264    	; 0x2058 <USB_Device_ProcessControlRequest+0x14a>
    1f50:	26 30       	cpi	r18, 0x06	; 6
    1f52:	40 f4       	brcc	.+16     	; 0x1f64 <USB_Device_ProcessControlRequest+0x56>
    1f54:	21 30       	cpi	r18, 0x01	; 1
    1f56:	a1 f1       	breq	.+104    	; 0x1fc0 <USB_Device_ProcessControlRequest+0xb2>
    1f58:	21 30       	cpi	r18, 0x01	; 1
    1f5a:	70 f0       	brcs	.+28     	; 0x1f78 <USB_Device_ProcessControlRequest+0x6a>
    1f5c:	23 30       	cpi	r18, 0x03	; 3
    1f5e:	09 f0       	breq	.+2      	; 0x1f62 <USB_Device_ProcessControlRequest+0x54>
    1f60:	27 c1       	rjmp	.+590    	; 0x21b0 <__stack+0xb1>
    1f62:	2e c0       	rjmp	.+92     	; 0x1fc0 <USB_Device_ProcessControlRequest+0xb2>
    1f64:	28 30       	cpi	r18, 0x08	; 8
    1f66:	09 f4       	brne	.+2      	; 0x1f6a <USB_Device_ProcessControlRequest+0x5c>
    1f68:	f4 c0       	rjmp	.+488    	; 0x2152 <__stack+0x53>
    1f6a:	29 30       	cpi	r18, 0x09	; 9
    1f6c:	09 f4       	brne	.+2      	; 0x1f70 <USB_Device_ProcessControlRequest+0x62>
    1f6e:	03 c1       	rjmp	.+518    	; 0x2176 <__stack+0x77>
    1f70:	26 30       	cpi	r18, 0x06	; 6
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <USB_Device_ProcessControlRequest+0x68>
    1f74:	1d c1       	rjmp	.+570    	; 0x21b0 <__stack+0xb1>
    1f76:	93 c0       	rjmp	.+294    	; 0x209e <USB_Device_ProcessControlRequest+0x190>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1f78:	80 38       	cpi	r24, 0x80	; 128
    1f7a:	21 f0       	breq	.+8      	; 0x1f84 <USB_Device_ProcessControlRequest+0x76>
    1f7c:	82 38       	cpi	r24, 0x82	; 130
    1f7e:	09 f0       	breq	.+2      	; 0x1f82 <USB_Device_ProcessControlRequest+0x74>
    1f80:	17 c1       	rjmp	.+558    	; 0x21b0 <__stack+0xb1>
    1f82:	08 c0       	rjmp	.+16     	; 0x1f94 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    1f84:	80 91 07 14 	lds	r24, 0x1407
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    1f88:	90 91 08 14 	lds	r25, 0x1408
    1f8c:	99 23       	and	r25, r25
    1f8e:	71 f0       	breq	.+28     	; 0x1fac <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1f90:	82 60       	ori	r24, 0x02	; 2
    1f92:	0c c0       	rjmp	.+24     	; 0x1fac <USB_Device_ProcessControlRequest+0x9e>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1f94:	80 91 0f 14 	lds	r24, 0x140F
    1f98:	8f 70       	andi	r24, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1f9a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1f9e:	90 91 eb 00 	lds	r25, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	95 ff       	sbrs	r25, 5
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1fa8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1fac:	90 91 e8 00 	lds	r25, 0x00E8
    1fb0:	97 7f       	andi	r25, 0xF7	; 247
    1fb2:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    1fb6:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    1fba:	10 92 f1 00 	sts	0x00F1, r1
    1fbe:	d4 c0       	rjmp	.+424    	; 0x2168 <__stack+0x69>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1fc0:	88 23       	and	r24, r24
    1fc2:	19 f0       	breq	.+6      	; 0x1fca <USB_Device_ProcessControlRequest+0xbc>
    1fc4:	82 30       	cpi	r24, 0x02	; 2
    1fc6:	09 f0       	breq	.+2      	; 0x1fca <USB_Device_ProcessControlRequest+0xbc>
    1fc8:	f3 c0       	rjmp	.+486    	; 0x21b0 <__stack+0xb1>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    1fca:	90 e0       	ldi	r25, 0x00	; 0
    1fcc:	8f 71       	andi	r24, 0x1F	; 31
    1fce:	90 70       	andi	r25, 0x00	; 0
    1fd0:	00 97       	sbiw	r24, 0x00	; 0
    1fd2:	29 f0       	breq	.+10     	; 0x1fde <USB_Device_ProcessControlRequest+0xd0>
    1fd4:	82 30       	cpi	r24, 0x02	; 2
    1fd6:	91 05       	cpc	r25, r1
    1fd8:	09 f0       	breq	.+2      	; 0x1fdc <USB_Device_ProcessControlRequest+0xce>
    1fda:	ea c0       	rjmp	.+468    	; 0x21b0 <__stack+0xb1>
    1fdc:	0b c0       	rjmp	.+22     	; 0x1ff4 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1fde:	80 91 0d 14 	lds	r24, 0x140D
    1fe2:	81 30       	cpi	r24, 0x01	; 1
    1fe4:	09 f0       	breq	.+2      	; 0x1fe8 <USB_Device_ProcessControlRequest+0xda>
    1fe6:	e4 c0       	rjmp	.+456    	; 0x21b0 <__stack+0xb1>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1fe8:	23 30       	cpi	r18, 0x03	; 3
    1fea:	09 f0       	breq	.+2      	; 0x1fee <USB_Device_ProcessControlRequest+0xe0>
    1fec:	80 e0       	ldi	r24, 0x00	; 0
    1fee:	80 93 08 14 	sts	0x1408, r24
    1ff2:	2c c0       	rjmp	.+88     	; 0x204c <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1ff4:	80 91 0d 14 	lds	r24, 0x140D
    1ff8:	88 23       	and	r24, r24
    1ffa:	41 f5       	brne	.+80     	; 0x204c <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1ffc:	20 91 0f 14 	lds	r18, 0x140F
    2000:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    2002:	09 f4       	brne	.+2      	; 0x2006 <USB_Device_ProcessControlRequest+0xf8>
    2004:	d5 c0       	rjmp	.+426    	; 0x21b0 <__stack+0xb1>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2006:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    200a:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    200e:	80 ff       	sbrs	r24, 0
    2010:	1d c0       	rjmp	.+58     	; 0x204c <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    2012:	80 91 0c 14 	lds	r24, 0x140C
    2016:	83 30       	cpi	r24, 0x03	; 3
    2018:	21 f4       	brne	.+8      	; 0x2022 <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    201a:	80 91 eb 00 	lds	r24, 0x00EB
    201e:	80 62       	ori	r24, 0x20	; 32
    2020:	13 c0       	rjmp	.+38     	; 0x2048 <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2022:	80 91 eb 00 	lds	r24, 0x00EB
    2026:	80 61       	ori	r24, 0x10	; 16
    2028:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    202c:	81 e0       	ldi	r24, 0x01	; 1
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	02 c0       	rjmp	.+4      	; 0x2036 <USB_Device_ProcessControlRequest+0x128>
    2032:	88 0f       	add	r24, r24
    2034:	99 1f       	adc	r25, r25
    2036:	2a 95       	dec	r18
    2038:	e2 f7       	brpl	.-8      	; 0x2032 <USB_Device_ProcessControlRequest+0x124>
    203a:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    203e:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2042:	80 91 eb 00 	lds	r24, 0x00EB
    2046:	88 60       	ori	r24, 0x08	; 8
    2048:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    204c:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2050:	80 91 e8 00 	lds	r24, 0x00E8
    2054:	87 7f       	andi	r24, 0xF7	; 247
    2056:	8b c0       	rjmp	.+278    	; 0x216e <__stack+0x6f>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2058:	88 23       	and	r24, r24
    205a:	09 f0       	breq	.+2      	; 0x205e <USB_Device_ProcessControlRequest+0x150>
    205c:	a9 c0       	rjmp	.+338    	; 0x21b0 <__stack+0xb1>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    205e:	10 91 0d 14 	lds	r17, 0x140D
    2062:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2064:	80 91 e3 00 	lds	r24, 0x00E3
    2068:	80 78       	andi	r24, 0x80	; 128
    206a:	81 2b       	or	r24, r17
    206c:	80 93 e3 00 	sts	0x00E3, r24
    2070:	80 91 e8 00 	lds	r24, 0x00E8
    2074:	87 7f       	andi	r24, 0xF7	; 247
    2076:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    207a:	cb dd       	rcall	.-1130   	; 0x1c12 <Endpoint_ClearStatusStage>
    207c:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2080:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    2082:	fc cf       	rjmp	.-8      	; 0x207c <USB_Device_ProcessControlRequest+0x16e>
    2084:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;
				
				UDADDR |= (1 << ADDEN);
    2088:	80 68       	ori	r24, 0x80	; 128
    208a:	80 93 e3 00 	sts	0x00E3, r24
    208e:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2090:	11 f0       	breq	.+4      	; 0x2096 <USB_Device_ProcessControlRequest+0x188>
    2092:	83 e0       	ldi	r24, 0x03	; 3
    2094:	01 c0       	rjmp	.+2      	; 0x2098 <USB_Device_ProcessControlRequest+0x18a>
    2096:	82 e0       	ldi	r24, 0x02	; 2
    2098:	80 93 0a 14 	sts	0x140A, r24
    209c:	89 c0       	rjmp	.+274    	; 0x21b0 <__stack+0xb1>
    209e:	80 58       	subi	r24, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    20a0:	82 30       	cpi	r24, 0x02	; 2
    20a2:	08 f0       	brcs	.+2      	; 0x20a6 <USB_Device_ProcessControlRequest+0x198>
    20a4:	85 c0       	rjmp	.+266    	; 0x21b0 <__stack+0xb1>
    20a6:	80 91 0d 14 	lds	r24, 0x140D
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    20aa:	90 91 0e 14 	lds	r25, 0x140E
    20ae:	23 e0       	ldi	r18, 0x03	; 3
    20b0:	8c 3d       	cpi	r24, 0xDC	; 220
    20b2:	92 07       	cpc	r25, r18
    20b4:	a9 f5       	brne	.+106    	; 0x2120 <__stack+0x21>
    20b6:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    20b8:	8c 83       	std	Y+4, r24	; 0x04
    20ba:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    20bc:	8b 83       	std	Y+3, r24	; 0x03
    20be:	5f b7       	in	r21, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    20c0:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    20c2:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    20c4:	13 96       	adiw	r26, 0x03	; 3
    20c6:	80 e0       	ldi	r24, 0x00	; 0
    20c8:	90 e0       	ldi	r25, 0x00	; 0
    20ca:	4e e0       	ldi	r20, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    20cc:	61 e2       	ldi	r22, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    20ce:	e4 2f       	mov	r30, r20
    20d0:	f0 e0       	ldi	r31, 0x00	; 0
    20d2:	60 93 57 00 	sts	0x0057, r22
    20d6:	e4 91       	lpm	r30, Z
    20d8:	80 ff       	sbrs	r24, 0

					if (SerialCharNum & 0x01)
    20da:	03 c0       	rjmp	.+6      	; 0x20e2 <USB_Device_ProcessControlRequest+0x1d4>
    20dc:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    20de:	ef 70       	andi	r30, 0x0F	; 15
    20e0:	4f 5f       	subi	r20, 0xFF	; 255
						SigReadAddress++;
    20e2:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    20e4:	2e 2f       	mov	r18, r30
    20e6:	30 e0       	ldi	r19, 0x00	; 0
    20e8:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    20ea:	18 f0       	brcs	.+6      	; 0x20f2 <USB_Device_ProcessControlRequest+0x1e4>
    20ec:	29 5c       	subi	r18, 0xC9	; 201
    20ee:	3f 4f       	sbci	r19, 0xFF	; 255
    20f0:	02 c0       	rjmp	.+4      	; 0x20f6 <USB_Device_ProcessControlRequest+0x1e8>
    20f2:	20 5d       	subi	r18, 0xD0	; 208
    20f4:	3f 4f       	sbci	r19, 0xFF	; 255
    20f6:	13 96       	adiw	r26, 0x03	; 3
    20f8:	3c 93       	st	X, r19
    20fa:	2e 93       	st	-X, r18
    20fc:	12 97       	sbiw	r26, 0x02	; 2
    20fe:	01 96       	adiw	r24, 0x01	; 1
    2100:	12 96       	adiw	r26, 0x02	; 2
    2102:	84 31       	cpi	r24, 0x14	; 20
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2104:	91 05       	cpc	r25, r1
    2106:	19 f7       	brne	.-58     	; 0x20ce <USB_Device_ProcessControlRequest+0x1c0>
    2108:	5f bf       	out	0x3f, r21	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    210a:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    210e:	87 7f       	andi	r24, 0xF7	; 247
    2110:	80 93 e8 00 	sts	0x00E8, r24
    2114:	ce 01       	movw	r24, r28

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    2116:	03 96       	adiw	r24, 0x03	; 3
    2118:	6a e2       	ldi	r22, 0x2A	; 42
    211a:	70 e0       	ldi	r23, 0x00	; 0
    211c:	07 dc       	rcall	.-2034   	; 0x192c <Endpoint_Write_Control_Stream_LE>
    211e:	13 c0       	rjmp	.+38     	; 0x2146 <__stack+0x47>
    2120:	60 91 0f 14 	lds	r22, 0x140F
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2124:	ae 01       	movw	r20, r28
    2126:	4f 5f       	subi	r20, 0xFF	; 255
    2128:	5f 4f       	sbci	r21, 0xFF	; 255
    212a:	0e 94 b2 02 	call	0x564	; 0x564 <CALLBACK_USB_GetDescriptor>
    212e:	bc 01       	movw	r22, r24
    2130:	00 97       	sbiw	r24, 0x00	; 0
    2132:	09 f4       	brne	.+2      	; 0x2136 <__stack+0x37>
    2134:	3d c0       	rjmp	.+122    	; 0x21b0 <__stack+0xb1>
    2136:	80 91 e8 00 	lds	r24, 0x00E8
    213a:	87 7f       	andi	r24, 0xF7	; 247
    213c:	80 93 e8 00 	sts	0x00E8, r24
    2140:	89 81       	ldd	r24, Y+1	; 0x01
    2142:	9a 81       	ldd	r25, Y+2	; 0x02
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2144:	98 dc       	rcall	.-1744   	; 0x1a76 <Endpoint_Write_Control_PStream_LE>
    2146:	80 91 e8 00 	lds	r24, 0x00E8
    214a:	8b 77       	andi	r24, 0x7B	; 123
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    214c:	80 93 e8 00 	sts	0x00E8, r24
    2150:	2f c0       	rjmp	.+94     	; 0x21b0 <__stack+0xb1>
    2152:	80 38       	cpi	r24, 0x80	; 128
    2154:	69 f5       	brne	.+90     	; 0x21b0 <__stack+0xb1>
    2156:	80 91 e8 00 	lds	r24, 0x00E8
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    215a:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    215c:	80 93 e8 00 	sts	0x00E8, r24
    2160:	80 91 06 14 	lds	r24, 0x1406
    2164:	80 93 f1 00 	sts	0x00F1, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2168:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    216c:	8e 77       	andi	r24, 0x7E	; 126
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    216e:	80 93 e8 00 	sts	0x00E8, r24
    2172:	4f dd       	rcall	.-1378   	; 0x1c12 <Endpoint_ClearStatusStage>
    2174:	1d c0       	rjmp	.+58     	; 0x21b0 <__stack+0xb1>
    2176:	88 23       	and	r24, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2178:	d9 f4       	brne	.+54     	; 0x21b0 <__stack+0xb1>
    217a:	90 91 0d 14 	lds	r25, 0x140D
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    217e:	92 30       	cpi	r25, 0x02	; 2
    2180:	b8 f4       	brcc	.+46     	; 0x21b0 <__stack+0xb1>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2182:	80 91 e8 00 	lds	r24, 0x00E8
    2186:	87 7f       	andi	r24, 0xF7	; 247
    2188:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    218c:	90 93 06 14 	sts	0x1406, r25
    2190:	40 dd       	rcall	.-1408   	; 0x1c12 <Endpoint_ClearStatusStage>
    2192:	80 91 06 14 	lds	r24, 0x1406
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2196:	88 23       	and	r24, r24

	Endpoint_ClearStatusStage();
    2198:	21 f4       	brne	.+8      	; 0x21a2 <__stack+0xa3>
    219a:	80 91 e3 00 	lds	r24, 0x00E3

	if (USB_Device_ConfigurationNumber)
    219e:	87 ff       	sbrs	r24, 7
    21a0:	02 c0       	rjmp	.+4      	; 0x21a6 <__stack+0xa7>
    21a2:	84 e0       	ldi	r24, 0x04	; 4
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    21a4:	01 c0       	rjmp	.+2      	; 0x21a8 <__stack+0xa9>
    21a6:	81 e0       	ldi	r24, 0x01	; 1
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    21a8:	80 93 0a 14 	sts	0x140A, r24
    21ac:	0e 94 a4 02 	call	0x548	; 0x548 <EVENT_USB_Device_ConfigurationChanged>
    21b0:	80 91 e8 00 	lds	r24, 0x00E8
    21b4:	83 ff       	sbrs	r24, 3

	EVENT_USB_Device_ConfigurationChanged();
    21b6:	0a c0       	rjmp	.+20     	; 0x21cc <__stack+0xcd>
    21b8:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    21bc:	87 7f       	andi	r24, 0xF7	; 247
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    21be:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    21c2:	80 91 eb 00 	lds	r24, 0x00EB
    21c6:	80 62       	ori	r24, 0x20	; 32
    21c8:	80 93 eb 00 	sts	0x00EB, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    21cc:	ac 96       	adiw	r28, 0x2c	; 44
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	f8 94       	cli
    21d2:	de bf       	out	0x3e, r29	; 62
    21d4:	0f be       	out	0x3f, r0	; 63
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    21d6:	cd bf       	out	0x3d, r28	; 61
    21d8:	df 91       	pop	r29
    21da:	cf 91       	pop	r28
    21dc:	1f 91       	pop	r17
    21de:	08 95       	ret

000021e0 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    21e0:	08 95       	ret

000021e2 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    21e2:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    21e4:	80 91 0a 14 	lds	r24, 0x140A
    21e8:	88 23       	and	r24, r24
    21ea:	a9 f0       	breq	.+42     	; 0x2216 <USB_USBTask+0x34>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    21ec:	80 91 e9 00 	lds	r24, 0x00E9
    21f0:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    21f2:	90 91 ec 00 	lds	r25, 0x00EC
    21f6:	90 ff       	sbrs	r25, 0
    21f8:	02 c0       	rjmp	.+4      	; 0x21fe <USB_USBTask+0x1c>
    21fa:	c0 e8       	ldi	r28, 0x80	; 128
    21fc:	01 c0       	rjmp	.+2      	; 0x2200 <USB_USBTask+0x1e>
    21fe:	c0 e0       	ldi	r28, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2200:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2202:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2206:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    220a:	83 ff       	sbrs	r24, 3
    220c:	01 c0       	rjmp	.+2      	; 0x2210 <USB_USBTask+0x2e>
	  USB_Device_ProcessControlRequest();
    220e:	7f de       	rcall	.-770    	; 0x1f0e <USB_Device_ProcessControlRequest>
    2210:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2212:	c0 93 e9 00 	sts	0x00E9, r28
    2216:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    2218:	08 95       	ret

0000221a <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    221a:	0f 93       	push	r16
    221c:	1f 93       	push	r17
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
    2222:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2224:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    2228:	83 ff       	sbrs	r24, 3
    222a:	c5 c2       	rjmp	.+1418   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    222c:	88 81       	ld	r24, Y
    222e:	90 e0       	ldi	r25, 0x00	; 0
    2230:	20 91 0f 14 	lds	r18, 0x140F
    2234:	30 91 10 14 	lds	r19, 0x1410
    2238:	28 17       	cp	r18, r24
    223a:	39 07       	cpc	r19, r25
    223c:	09 f0       	breq	.+2      	; 0x2240 <RNDIS_Device_ProcessControlRequest+0x26>
    223e:	bb c2       	rjmp	.+1398   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
	  return;

	switch (USB_ControlRequest.bRequest)
    2240:	80 91 0c 14 	lds	r24, 0x140C
    2244:	88 23       	and	r24, r24
    2246:	21 f0       	breq	.+8      	; 0x2250 <RNDIS_Device_ProcessControlRequest+0x36>
    2248:	81 30       	cpi	r24, 0x01	; 1
    224a:	09 f0       	breq	.+2      	; 0x224e <RNDIS_Device_ProcessControlRequest+0x34>
    224c:	b4 c2       	rjmp	.+1384   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    224e:	6f c2       	rjmp	.+1246   	; 0x272e <RNDIS_Device_ProcessControlRequest+0x514>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    2250:	80 91 0b 14 	lds	r24, 0x140B
    2254:	81 32       	cpi	r24, 0x21	; 33
    2256:	09 f0       	breq	.+2      	; 0x225a <RNDIS_Device_ProcessControlRequest+0x40>
    2258:	ae c2       	rjmp	.+1372   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    225a:	80 91 e8 00 	lds	r24, 0x00E8
    225e:	87 7f       	andi	r24, 0xF7	; 247
    2260:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    2264:	60 91 11 14 	lds	r22, 0x1411
    2268:	70 91 12 14 	lds	r23, 0x1412
    226c:	ce 01       	movw	r24, r28
    226e:	48 96       	adiw	r24, 0x18	; 24
    2270:	b9 db       	rcall	.-2190   	; 0x19e4 <Endpoint_Read_Control_Stream_LE>
    2272:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2276:	8e 77       	andi	r24, 0x7E	; 126
    2278:	80 93 e8 00 	sts	0x00E8, r24
    227c:	88 8d       	ldd	r24, Y+24	; 0x18
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    227e:	99 8d       	ldd	r25, Y+25	; 0x19
    2280:	aa 8d       	ldd	r26, Y+26	; 0x1a
    2282:	bb 8d       	ldd	r27, Y+27	; 0x1b
    2284:	84 30       	cpi	r24, 0x04	; 4
    2286:	91 05       	cpc	r25, r1
    2288:	a1 05       	cpc	r26, r1
    228a:	b1 05       	cpc	r27, r1
    228c:	09 f4       	brne	.+2      	; 0x2290 <RNDIS_Device_ProcessControlRequest+0x76>
    228e:	82 c0       	rjmp	.+260    	; 0x2394 <RNDIS_Device_ProcessControlRequest+0x17a>
    2290:	85 30       	cpi	r24, 0x05	; 5
    2292:	91 05       	cpc	r25, r1
    2294:	a1 05       	cpc	r26, r1
    2296:	b1 05       	cpc	r27, r1
    2298:	60 f4       	brcc	.+24     	; 0x22b2 <RNDIS_Device_ProcessControlRequest+0x98>
    229a:	82 30       	cpi	r24, 0x02	; 2
    229c:	91 05       	cpc	r25, r1
    229e:	a1 05       	cpc	r26, r1
    22a0:	b1 05       	cpc	r27, r1
    22a2:	d1 f0       	breq	.+52     	; 0x22d8 <RNDIS_Device_ProcessControlRequest+0xbe>
    22a4:	83 30       	cpi	r24, 0x03	; 3
    22a6:	91 05       	cpc	r25, r1
    22a8:	a1 05       	cpc	r26, r1
    22aa:	b1 05       	cpc	r27, r1
    22ac:	09 f0       	breq	.+2      	; 0x22b0 <RNDIS_Device_ProcessControlRequest+0x96>
    22ae:	83 c2       	rjmp	.+1286   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    22b0:	65 c0       	rjmp	.+202    	; 0x237c <RNDIS_Device_ProcessControlRequest+0x162>
    22b2:	86 30       	cpi	r24, 0x06	; 6
    22b4:	91 05       	cpc	r25, r1
    22b6:	a1 05       	cpc	r26, r1
    22b8:	b1 05       	cpc	r27, r1
    22ba:	09 f4       	brne	.+2      	; 0x22be <RNDIS_Device_ProcessControlRequest+0xa4>
    22bc:	04 c2       	rjmp	.+1032   	; 0x26c6 <RNDIS_Device_ProcessControlRequest+0x4ac>
    22be:	86 30       	cpi	r24, 0x06	; 6
    22c0:	91 05       	cpc	r25, r1
    22c2:	a1 05       	cpc	r26, r1
    22c4:	b1 05       	cpc	r27, r1
    22c6:	08 f4       	brcc	.+2      	; 0x22ca <RNDIS_Device_ProcessControlRequest+0xb0>
    22c8:	aa c1       	rjmp	.+852    	; 0x261e <RNDIS_Device_ProcessControlRequest+0x404>
    22ca:	88 30       	cpi	r24, 0x08	; 8
    22cc:	91 05       	cpc	r25, r1
    22ce:	a1 05       	cpc	r26, r1
    22d0:	b1 05       	cpc	r27, r1
    22d2:	09 f0       	breq	.+2      	; 0x22d6 <RNDIS_Device_ProcessControlRequest+0xbc>
    22d4:	70 c2       	rjmp	.+1248   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    22d6:	11 c2       	rjmp	.+1058   	; 0x26fa <RNDIS_Device_ProcessControlRequest+0x4e0>
    22d8:	fe 01       	movw	r30, r28
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    22da:	e8 56       	subi	r30, 0x68	; 104
    22dc:	ff 4f       	sbci	r31, 0xFF	; 255
    22de:	21 e0       	ldi	r18, 0x01	; 1
    22e0:	20 83       	st	Z, r18
    22e2:	82 e0       	ldi	r24, 0x02	; 2
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    22e4:	90 e0       	ldi	r25, 0x00	; 0
    22e6:	a0 e0       	ldi	r26, 0x00	; 0
    22e8:	b0 e8       	ldi	r27, 0x80	; 128
    22ea:	88 8f       	std	Y+24, r24	; 0x18
    22ec:	99 8f       	std	Y+25, r25	; 0x19
    22ee:	aa 8f       	std	Y+26, r26	; 0x1a
    22f0:	bb 8f       	std	Y+27, r27	; 0x1b
    22f2:	84 e3       	ldi	r24, 0x34	; 52
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	a0 e0       	ldi	r26, 0x00	; 0
    22f8:	b0 e0       	ldi	r27, 0x00	; 0
    22fa:	8c 8f       	std	Y+28, r24	; 0x1c
    22fc:	9d 8f       	std	Y+29, r25	; 0x1d
    22fe:	ae 8f       	std	Y+30, r26	; 0x1e
    2300:	bf 8f       	std	Y+31, r27	; 0x1f
    2302:	1c a2       	lds	r17, 0x9c
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2304:	1d a2       	lds	r17, 0x9d
    2306:	1e a2       	lds	r17, 0x9e
    2308:	1f a2       	lds	r17, 0x9f
    230a:	81 e0       	ldi	r24, 0x01	; 1

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	a0 e0       	ldi	r26, 0x00	; 0
    2310:	b0 e0       	ldi	r27, 0x00	; 0
    2312:	88 a7       	lds	r24, 0x78
    2314:	99 a7       	lds	r25, 0x79
    2316:	aa a7       	lds	r26, 0x7a
    2318:	bb a7       	lds	r27, 0x7b
    231a:	1c a6       	lds	r17, 0xbc
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    231c:	1d a6       	lds	r17, 0xbd
    231e:	1e a6       	lds	r17, 0xbe
    2320:	1f a6       	lds	r17, 0xbf
    2322:	88 ab       	sts	0x58, r24
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    2324:	99 ab       	sts	0x59, r25
    2326:	aa ab       	sts	0x5a, r26
    2328:	bb ab       	sts	0x5b, r27
    232a:	1c aa       	sts	0x9c, r17
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    232c:	1d aa       	sts	0x9d, r17
    232e:	1e aa       	sts	0x9e, r17
    2330:	1f aa       	sts	0x9f, r17
    2332:	88 af       	sts	0x78, r24
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    2334:	99 af       	sts	0x79, r25
    2336:	aa af       	sts	0x7a, r26
    2338:	bb af       	sts	0x7b, r27
    233a:	88 e0       	ldi	r24, 0x08	; 8
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    233c:	96 e0       	ldi	r25, 0x06	; 6
    233e:	a0 e0       	ldi	r26, 0x00	; 0
    2340:	b0 e0       	ldi	r27, 0x00	; 0
    2342:	8c af       	sts	0x7c, r24
    2344:	9d af       	sts	0x7d, r25
    2346:	ae af       	sts	0x7e, r26
    2348:	bf af       	sts	0x7f, r27
    234a:	fe 01       	movw	r30, r28
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    234c:	e0 5c       	subi	r30, 0xC0	; 192
    234e:	ff 4f       	sbci	r31, 0xFF	; 255
    2350:	10 82       	st	Z, r1
    2352:	11 82       	std	Z+1, r1	; 0x01
    2354:	12 82       	std	Z+2, r1	; 0x02
    2356:	13 82       	std	Z+3, r1	; 0x03
    2358:	fe 01       	movw	r30, r28
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    235a:	ec 5b       	subi	r30, 0xBC	; 188
    235c:	ff 4f       	sbci	r31, 0xFF	; 255
    235e:	10 82       	st	Z, r1
    2360:	11 82       	std	Z+1, r1	; 0x01
    2362:	12 82       	std	Z+2, r1	; 0x02
    2364:	13 82       	std	Z+3, r1	; 0x03
    2366:	fe 01       	movw	r30, r28
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    2368:	e8 5b       	subi	r30, 0xB8	; 184
    236a:	ff 4f       	sbci	r31, 0xFF	; 255
    236c:	10 82       	st	Z, r1
    236e:	11 82       	std	Z+1, r1	; 0x01
    2370:	12 82       	std	Z+2, r1	; 0x02
    2372:	13 82       	std	Z+3, r1	; 0x03
    2374:	c7 56       	subi	r28, 0x67	; 103

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    2376:	df 4f       	sbci	r29, 0xFF	; 255
    2378:	28 83       	st	Y, r18
    237a:	1d c2       	rjmp	.+1082   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    237c:	fe 01       	movw	r30, r28
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    237e:	e8 56       	subi	r30, 0x68	; 104
    2380:	ff 4f       	sbci	r31, 0xFF	; 255
    2382:	10 82       	st	Z, r1
    2384:	1c 8e       	std	Y+28, r1	; 0x1c

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    2386:	1d 8e       	std	Y+29, r1	; 0x1d
    2388:	1e 8e       	std	Y+30, r1	; 0x1e
    238a:	1f 8e       	std	Y+31, r1	; 0x1f
    238c:	c7 56       	subi	r28, 0x67	; 103

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    238e:	df 4f       	sbci	r29, 0xFF	; 255
    2390:	18 82       	st	Y, r1
    2392:	11 c2       	rjmp	.+1058   	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    2394:	fe 01       	movw	r30, r28
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2396:	e8 56       	subi	r30, 0x68	; 104
    2398:	ff 4f       	sbci	r31, 0xFF	; 255
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	80 83       	st	Z, r24
    239e:	8c a1       	lds	r24, 0x4c

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    23a0:	9d a1       	lds	r25, 0x4d
    23a2:	ae a1       	lds	r26, 0x4e
    23a4:	bf a1       	lds	r27, 0x4f
    23a6:	9e 01       	movw	r18, r28

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    23a8:	20 5d       	subi	r18, 0xD0	; 208
    23aa:	3f 4f       	sbci	r19, 0xFF	; 255
    23ac:	44 e0       	ldi	r20, 0x04	; 4
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    23ae:	50 e0       	ldi	r21, 0x00	; 0
    23b0:	60 e0       	ldi	r22, 0x00	; 0
    23b2:	70 e8       	ldi	r23, 0x80	; 128
    23b4:	48 8f       	std	Y+24, r20	; 0x18
    23b6:	59 8f       	std	Y+25, r21	; 0x19
    23b8:	6a 8f       	std	Y+26, r22	; 0x1a
    23ba:	7b 8f       	std	Y+27, r23	; 0x1b
    23bc:	8e 30       	cpi	r24, 0x0E	; 14
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    23be:	41 e0       	ldi	r20, 0x01	; 1
    23c0:	94 07       	cpc	r25, r20
    23c2:	41 e0       	ldi	r20, 0x01	; 1
    23c4:	a4 07       	cpc	r26, r20
    23c6:	40 e0       	ldi	r20, 0x00	; 0
    23c8:	b4 07       	cpc	r27, r20
    23ca:	09 f4       	brne	.+2      	; 0x23ce <RNDIS_Device_ProcessControlRequest+0x1b4>
    23cc:	f7 c0       	rjmp	.+494    	; 0x25bc <RNDIS_Device_ProcessControlRequest+0x3a2>
    23ce:	8f 30       	cpi	r24, 0x0F	; 15
    23d0:	e1 e0       	ldi	r30, 0x01	; 1
    23d2:	9e 07       	cpc	r25, r30
    23d4:	e1 e0       	ldi	r30, 0x01	; 1
    23d6:	ae 07       	cpc	r26, r30
    23d8:	e0 e0       	ldi	r30, 0x00	; 0
    23da:	be 07       	cpc	r27, r30
    23dc:	08 f0       	brcs	.+2      	; 0x23e0 <RNDIS_Device_ProcessControlRequest+0x1c6>
    23de:	64 c0       	rjmp	.+200    	; 0x24a8 <RNDIS_Device_ProcessControlRequest+0x28e>
    23e0:	86 30       	cpi	r24, 0x06	; 6
    23e2:	f1 e0       	ldi	r31, 0x01	; 1
    23e4:	9f 07       	cpc	r25, r31
    23e6:	f1 e0       	ldi	r31, 0x01	; 1
    23e8:	af 07       	cpc	r26, r31
    23ea:	f0 e0       	ldi	r31, 0x00	; 0
    23ec:	bf 07       	cpc	r27, r31
    23ee:	09 f4       	brne	.+2      	; 0x23f2 <RNDIS_Device_ProcessControlRequest+0x1d8>
    23f0:	bd c0       	rjmp	.+378    	; 0x256c <RNDIS_Device_ProcessControlRequest+0x352>
    23f2:	87 30       	cpi	r24, 0x07	; 7
    23f4:	41 e0       	ldi	r20, 0x01	; 1
    23f6:	94 07       	cpc	r25, r20
    23f8:	41 e0       	ldi	r20, 0x01	; 1
    23fa:	a4 07       	cpc	r26, r20
    23fc:	40 e0       	ldi	r20, 0x00	; 0
    23fe:	b4 07       	cpc	r27, r20
    2400:	28 f5       	brcc	.+74     	; 0x244c <RNDIS_Device_ProcessControlRequest+0x232>
    2402:	82 30       	cpi	r24, 0x02	; 2
    2404:	e1 e0       	ldi	r30, 0x01	; 1
    2406:	9e 07       	cpc	r25, r30
    2408:	e1 e0       	ldi	r30, 0x01	; 1
    240a:	ae 07       	cpc	r26, r30
    240c:	e0 e0       	ldi	r30, 0x00	; 0
    240e:	be 07       	cpc	r27, r30
    2410:	09 f4       	brne	.+2      	; 0x2414 <RNDIS_Device_ProcessControlRequest+0x1fa>
    2412:	dc c0       	rjmp	.+440    	; 0x25cc <RNDIS_Device_ProcessControlRequest+0x3b2>
    2414:	83 30       	cpi	r24, 0x03	; 3
    2416:	f1 e0       	ldi	r31, 0x01	; 1
    2418:	9f 07       	cpc	r25, r31
    241a:	f1 e0       	ldi	r31, 0x01	; 1
    241c:	af 07       	cpc	r26, r31
    241e:	f0 e0       	ldi	r31, 0x00	; 0
    2420:	bf 07       	cpc	r27, r31
    2422:	50 f4       	brcc	.+20     	; 0x2438 <RNDIS_Device_ProcessControlRequest+0x21e>
    2424:	81 30       	cpi	r24, 0x01	; 1
    2426:	41 e0       	ldi	r20, 0x01	; 1
    2428:	94 07       	cpc	r25, r20
    242a:	41 e0       	ldi	r20, 0x01	; 1
    242c:	a4 07       	cpc	r26, r20
    242e:	40 e0       	ldi	r20, 0x00	; 0
    2430:	b4 07       	cpc	r27, r20
    2432:	09 f0       	breq	.+2      	; 0x2436 <RNDIS_Device_ProcessControlRequest+0x21c>
    2434:	db c0       	rjmp	.+438    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    2436:	8c c0       	rjmp	.+280    	; 0x2550 <RNDIS_Device_ProcessControlRequest+0x336>
    2438:	85 30       	cpi	r24, 0x05	; 5
    243a:	e1 e0       	ldi	r30, 0x01	; 1
    243c:	9e 07       	cpc	r25, r30
    243e:	e1 e0       	ldi	r30, 0x01	; 1
    2440:	ae 07       	cpc	r26, r30
    2442:	e0 e0       	ldi	r30, 0x00	; 0
    2444:	be 07       	cpc	r27, r30
    2446:	08 f0       	brcs	.+2      	; 0x244a <RNDIS_Device_ProcessControlRequest+0x230>
    2448:	d1 c0       	rjmp	.+418    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    244a:	c0 c0       	rjmp	.+384    	; 0x25cc <RNDIS_Device_ProcessControlRequest+0x3b2>
    244c:	8c 30       	cpi	r24, 0x0C	; 12
    244e:	f1 e0       	ldi	r31, 0x01	; 1
    2450:	9f 07       	cpc	r25, r31
    2452:	f1 e0       	ldi	r31, 0x01	; 1
    2454:	af 07       	cpc	r26, r31
    2456:	f0 e0       	ldi	r31, 0x00	; 0
    2458:	bf 07       	cpc	r27, r31
    245a:	98 f4       	brcc	.+38     	; 0x2482 <RNDIS_Device_ProcessControlRequest+0x268>
    245c:	8a 30       	cpi	r24, 0x0A	; 10
    245e:	21 e0       	ldi	r18, 0x01	; 1
    2460:	92 07       	cpc	r25, r18
    2462:	21 e0       	ldi	r18, 0x01	; 1
    2464:	a2 07       	cpc	r26, r18
    2466:	20 e0       	ldi	r18, 0x00	; 0
    2468:	b2 07       	cpc	r27, r18
    246a:	08 f0       	brcs	.+2      	; 0x246e <RNDIS_Device_ProcessControlRequest+0x254>
    246c:	7f c0       	rjmp	.+254    	; 0x256c <RNDIS_Device_ProcessControlRequest+0x352>
    246e:	87 30       	cpi	r24, 0x07	; 7
    2470:	41 e0       	ldi	r20, 0x01	; 1
    2472:	94 07       	cpc	r25, r20
    2474:	41 e0       	ldi	r20, 0x01	; 1
    2476:	a4 07       	cpc	r26, r20
    2478:	40 e0       	ldi	r20, 0x00	; 0
    247a:	b4 07       	cpc	r27, r20
    247c:	09 f0       	breq	.+2      	; 0x2480 <RNDIS_Device_ProcessControlRequest+0x266>
    247e:	b6 c0       	rjmp	.+364    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    2480:	88 c0       	rjmp	.+272    	; 0x2592 <RNDIS_Device_ProcessControlRequest+0x378>
    2482:	8c 30       	cpi	r24, 0x0C	; 12
    2484:	e1 e0       	ldi	r30, 0x01	; 1
    2486:	9e 07       	cpc	r25, r30
    2488:	e1 e0       	ldi	r30, 0x01	; 1
    248a:	ae 07       	cpc	r26, r30
    248c:	e0 e0       	ldi	r30, 0x00	; 0
    248e:	be 07       	cpc	r27, r30
    2490:	09 f4       	brne	.+2      	; 0x2494 <RNDIS_Device_ProcessControlRequest+0x27a>
    2492:	67 c0       	rjmp	.+206    	; 0x2562 <RNDIS_Device_ProcessControlRequest+0x348>
    2494:	8d 30       	cpi	r24, 0x0D	; 13
    2496:	f1 e0       	ldi	r31, 0x01	; 1
    2498:	9f 07       	cpc	r25, r31
    249a:	f1 e0       	ldi	r31, 0x01	; 1
    249c:	af 07       	cpc	r26, r31
    249e:	f0 e0       	ldi	r31, 0x00	; 0
    24a0:	bf 07       	cpc	r27, r31
    24a2:	09 f0       	breq	.+2      	; 0x24a6 <RNDIS_Device_ProcessControlRequest+0x28c>
    24a4:	a3 c0       	rjmp	.+326    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    24a6:	67 c0       	rjmp	.+206    	; 0x2576 <RNDIS_Device_ProcessControlRequest+0x35c>
    24a8:	86 30       	cpi	r24, 0x06	; 6
    24aa:	41 e0       	ldi	r20, 0x01	; 1
    24ac:	94 07       	cpc	r25, r20
    24ae:	42 e0       	ldi	r20, 0x02	; 2
    24b0:	a4 07       	cpc	r26, r20
    24b2:	40 e0       	ldi	r20, 0x00	; 0
    24b4:	b4 07       	cpc	r27, r20
    24b6:	28 f5       	brcc	.+74     	; 0x2502 <RNDIS_Device_ProcessControlRequest+0x2e8>
    24b8:	81 30       	cpi	r24, 0x01	; 1
    24ba:	e1 e0       	ldi	r30, 0x01	; 1
    24bc:	9e 07       	cpc	r25, r30
    24be:	e2 e0       	ldi	r30, 0x02	; 2
    24c0:	ae 07       	cpc	r26, r30
    24c2:	e0 e0       	ldi	r30, 0x00	; 0
    24c4:	be 07       	cpc	r27, r30
    24c6:	08 f0       	brcs	.+2      	; 0x24ca <RNDIS_Device_ProcessControlRequest+0x2b0>
    24c8:	81 c0       	rjmp	.+258    	; 0x25cc <RNDIS_Device_ProcessControlRequest+0x3b2>
    24ca:	84 31       	cpi	r24, 0x14	; 20
    24cc:	f1 e0       	ldi	r31, 0x01	; 1
    24ce:	9f 07       	cpc	r25, r31
    24d0:	f1 e0       	ldi	r31, 0x01	; 1
    24d2:	af 07       	cpc	r26, r31
    24d4:	f0 e0       	ldi	r31, 0x00	; 0
    24d6:	bf 07       	cpc	r27, r31
    24d8:	09 f4       	brne	.+2      	; 0x24dc <RNDIS_Device_ProcessControlRequest+0x2c2>
    24da:	78 c0       	rjmp	.+240    	; 0x25cc <RNDIS_Device_ProcessControlRequest+0x3b2>
    24dc:	82 30       	cpi	r24, 0x02	; 2
    24de:	22 e0       	ldi	r18, 0x02	; 2
    24e0:	92 07       	cpc	r25, r18
    24e2:	21 e0       	ldi	r18, 0x01	; 1
    24e4:	a2 07       	cpc	r26, r18
    24e6:	20 e0       	ldi	r18, 0x00	; 0
    24e8:	b2 07       	cpc	r27, r18
    24ea:	09 f4       	brne	.+2      	; 0x24ee <RNDIS_Device_ProcessControlRequest+0x2d4>
    24ec:	6f c0       	rjmp	.+222    	; 0x25cc <RNDIS_Device_ProcessControlRequest+0x3b2>
    24ee:	81 31       	cpi	r24, 0x11	; 17
    24f0:	41 e0       	ldi	r20, 0x01	; 1
    24f2:	94 07       	cpc	r25, r20
    24f4:	41 e0       	ldi	r20, 0x01	; 1
    24f6:	a4 07       	cpc	r26, r20
    24f8:	40 e0       	ldi	r20, 0x00	; 0
    24fa:	b4 07       	cpc	r27, r20
    24fc:	09 f0       	breq	.+2      	; 0x2500 <RNDIS_Device_ProcessControlRequest+0x2e6>
    24fe:	76 c0       	rjmp	.+236    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    2500:	6a c0       	rjmp	.+212    	; 0x25d6 <RNDIS_Device_ProcessControlRequest+0x3bc>
    2502:	84 30       	cpi	r24, 0x04	; 4
    2504:	e1 e0       	ldi	r30, 0x01	; 1
    2506:	9e 07       	cpc	r25, r30
    2508:	e1 e0       	ldi	r30, 0x01	; 1
    250a:	ae 07       	cpc	r26, r30
    250c:	e1 e0       	ldi	r30, 0x01	; 1
    250e:	be 07       	cpc	r27, r30
    2510:	09 f4       	brne	.+2      	; 0x2514 <RNDIS_Device_ProcessControlRequest+0x2fa>
    2512:	4f c0       	rjmp	.+158    	; 0x25b2 <RNDIS_Device_ProcessControlRequest+0x398>
    2514:	85 30       	cpi	r24, 0x05	; 5
    2516:	f1 e0       	ldi	r31, 0x01	; 1
    2518:	9f 07       	cpc	r25, r31
    251a:	f1 e0       	ldi	r31, 0x01	; 1
    251c:	af 07       	cpc	r26, r31
    251e:	f1 e0       	ldi	r31, 0x01	; 1
    2520:	bf 07       	cpc	r27, r31
    2522:	58 f4       	brcc	.+22     	; 0x253a <RNDIS_Device_ProcessControlRequest+0x320>
    2524:	81 50       	subi	r24, 0x01	; 1
    2526:	91 40       	sbci	r25, 0x01	; 1
    2528:	a1 40       	sbci	r26, 0x01	; 1
    252a:	b1 40       	sbci	r27, 0x01	; 1
    252c:	82 30       	cpi	r24, 0x02	; 2
    252e:	91 05       	cpc	r25, r1
    2530:	a1 05       	cpc	r26, r1
    2532:	b1 05       	cpc	r27, r1
    2534:	08 f0       	brcs	.+2      	; 0x2538 <RNDIS_Device_ProcessControlRequest+0x31e>
    2536:	5a c0       	rjmp	.+180    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    2538:	31 c0       	rjmp	.+98     	; 0x259c <RNDIS_Device_ProcessControlRequest+0x382>
    253a:	81 50       	subi	r24, 0x01	; 1
    253c:	91 40       	sbci	r25, 0x01	; 1
    253e:	a2 40       	sbci	r26, 0x02	; 2
    2540:	b1 40       	sbci	r27, 0x01	; 1
    2542:	83 30       	cpi	r24, 0x03	; 3
    2544:	91 05       	cpc	r25, r1
    2546:	a1 05       	cpc	r26, r1
    2548:	b1 05       	cpc	r27, r1
    254a:	08 f0       	brcs	.+2      	; 0x254e <RNDIS_Device_ProcessControlRequest+0x334>
    254c:	4f c0       	rjmp	.+158    	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x3d2>
    254e:	3e c0       	rjmp	.+124    	; 0x25cc <RNDIS_Device_ProcessControlRequest+0x3b2>
    2550:	c9 01       	movw	r24, r18
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2552:	66 eb       	ldi	r22, 0xB6	; 182
    2554:	73 e0       	ldi	r23, 0x03	; 3
    2556:	4c e6       	ldi	r20, 0x6C	; 108
    2558:	50 e0       	ldi	r21, 0x00	; 0
    255a:	ba d2       	rcall	.+1396   	; 0x2ad0 <memcpy_P>
    255c:	0c e6       	ldi	r16, 0x6C	; 108
    255e:	10 e0       	ldi	r17, 0x00	; 0
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    2560:	10 c1       	rjmp	.+544    	; 0x2782 <RNDIS_Device_ProcessControlRequest+0x568>
    2562:	8f ef       	ldi	r24, 0xFF	; 255
    2564:	9f ef       	ldi	r25, 0xFF	; 255
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    2566:	af ef       	ldi	r26, 0xFF	; 255
    2568:	b0 e0       	ldi	r27, 0x00	; 0
    256a:	39 c0       	rjmp	.+114    	; 0x25de <RNDIS_Device_ProcessControlRequest+0x3c4>
    256c:	8c ed       	ldi	r24, 0xDC	; 220
    256e:	95 e0       	ldi	r25, 0x05	; 5
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    2570:	a0 e0       	ldi	r26, 0x00	; 0
    2572:	b0 e0       	ldi	r27, 0x00	; 0
    2574:	34 c0       	rjmp	.+104    	; 0x25de <RNDIS_Device_ProcessControlRequest+0x3c4>
    2576:	68 89       	ldd	r22, Y+16	; 0x10
    2578:	79 89       	ldd	r23, Y+17	; 0x11

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    257a:	fb 01       	movw	r30, r22
    257c:	df 01       	movw	r26, r30
    257e:	0d 90       	ld	r0, X+
    2580:	00 20       	and	r0, r0
    2582:	e9 f7       	brne	.-6      	; 0x257e <RNDIS_Device_ProcessControlRequest+0x364>
    2584:	8d 01       	movw	r16, r26
    2586:	0e 1b       	sub	r16, r30
    2588:	1f 0b       	sbc	r17, r31
    258a:	c9 01       	movw	r24, r18
    258c:	a8 01       	movw	r20, r16

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    258e:	d5 d2       	rcall	.+1450   	; 0x2b3a <memcpy>
    2590:	f8 c0       	rjmp	.+496    	; 0x2782 <RNDIS_Device_ProcessControlRequest+0x568>
    2592:	80 ea       	ldi	r24, 0xA0	; 160
    2594:	96 e8       	ldi	r25, 0x86	; 134
    2596:	a1 e0       	ldi	r26, 0x01	; 1
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    2598:	b0 e0       	ldi	r27, 0x00	; 0
    259a:	21 c0       	rjmp	.+66     	; 0x25de <RNDIS_Device_ProcessControlRequest+0x3c4>
    259c:	d9 01       	movw	r26, r18
    259e:	fe 01       	movw	r30, r28
    25a0:	72 96       	adiw	r30, 0x12	; 18
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    25a2:	86 e0       	ldi	r24, 0x06	; 6
    25a4:	01 90       	ld	r0, Z+
    25a6:	0d 92       	st	X+, r0
    25a8:	81 50       	subi	r24, 0x01	; 1
    25aa:	e1 f7       	brne	.-8      	; 0x25a4 <RNDIS_Device_ProcessControlRequest+0x38a>
    25ac:	06 e0       	ldi	r16, 0x06	; 6
    25ae:	10 e0       	ldi	r17, 0x00	; 0
    25b0:	e8 c0       	rjmp	.+464    	; 0x2782 <RNDIS_Device_ProcessControlRequest+0x568>
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    25b2:	81 e0       	ldi	r24, 0x01	; 1
    25b4:	90 e0       	ldi	r25, 0x00	; 0
    25b6:	a0 e0       	ldi	r26, 0x00	; 0
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    25b8:	b0 e0       	ldi	r27, 0x00	; 0
    25ba:	11 c0       	rjmp	.+34     	; 0x25de <RNDIS_Device_ProcessControlRequest+0x3c4>
    25bc:	fe 01       	movw	r30, r28
    25be:	e6 56       	subi	r30, 0x66	; 102
    25c0:	ff 4f       	sbci	r31, 0xFF	; 255

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    25c2:	80 81       	ld	r24, Z
    25c4:	91 81       	ldd	r25, Z+1	; 0x01
    25c6:	a2 81       	ldd	r26, Z+2	; 0x02
    25c8:	b3 81       	ldd	r27, Z+3	; 0x03
    25ca:	09 c0       	rjmp	.+18     	; 0x25de <RNDIS_Device_ProcessControlRequest+0x3c4>
    25cc:	18 aa       	sts	0x98, r17
    25ce:	19 aa       	sts	0x99, r17
    25d0:	1a aa       	sts	0x9a, r17
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    25d2:	1b aa       	sts	0x9b, r17
    25d4:	08 c0       	rjmp	.+16     	; 0x25e6 <RNDIS_Device_ProcessControlRequest+0x3cc>
    25d6:	8c e5       	ldi	r24, 0x5C	; 92
    25d8:	96 e0       	ldi	r25, 0x06	; 6
    25da:	a0 e0       	ldi	r26, 0x00	; 0
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    25dc:	b0 e0       	ldi	r27, 0x00	; 0
    25de:	88 ab       	sts	0x58, r24
    25e0:	99 ab       	sts	0x59, r25
    25e2:	aa ab       	sts	0x5a, r26
    25e4:	bb ab       	sts	0x5b, r27
    25e6:	04 e0       	ldi	r16, 0x04	; 4
    25e8:	10 e0       	ldi	r17, 0x00	; 0
    25ea:	cb c0       	rjmp	.+406    	; 0x2782 <RNDIS_Device_ProcessControlRequest+0x568>
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    25ec:	8b eb       	ldi	r24, 0xBB	; 187
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	a0 e0       	ldi	r26, 0x00	; 0
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    25f2:	b0 ec       	ldi	r27, 0xC0	; 192
    25f4:	8c a3       	lds	r24, 0x5c
    25f6:	9d a3       	lds	r25, 0x5d
    25f8:	ae a3       	lds	r26, 0x5e
    25fa:	bf a3       	lds	r27, 0x5f
    25fc:	88 e1       	ldi	r24, 0x18	; 24
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	a0 e0       	ldi	r26, 0x00	; 0
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    2602:	b0 e0       	ldi	r27, 0x00	; 0
    2604:	8c 8f       	std	Y+28, r24	; 0x1c
    2606:	9d 8f       	std	Y+29, r25	; 0x1d
    2608:	ae 8f       	std	Y+30, r26	; 0x1e
    260a:	bf 8f       	std	Y+31, r27	; 0x1f
    260c:	18 a6       	lds	r17, 0xb8
    260e:	19 a6       	lds	r17, 0xb9
    2610:	1a a6       	lds	r17, 0xba

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    2612:	1b a6       	lds	r17, 0xbb
    2614:	1c a6       	lds	r17, 0xbc
    2616:	1d a6       	lds	r17, 0xbd
    2618:	1e a6       	lds	r17, 0xbe
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    261a:	1f a6       	lds	r17, 0xbf
    261c:	cc c0       	rjmp	.+408    	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    261e:	fe 01       	movw	r30, r28
    2620:	e8 56       	subi	r30, 0x68	; 104
    2622:	ff 4f       	sbci	r31, 0xFF	; 255
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2624:	81 e0       	ldi	r24, 0x01	; 1
    2626:	80 83       	st	Z, r24
    2628:	8c a1       	lds	r24, 0x4c
    262a:	9d a1       	lds	r25, 0x4d
    262c:	ae a1       	lds	r26, 0x4e

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    262e:	bf a1       	lds	r27, 0x4f
    2630:	45 e0       	ldi	r20, 0x05	; 5
    2632:	50 e0       	ldi	r21, 0x00	; 0
    2634:	60 e0       	ldi	r22, 0x00	; 0

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    2636:	70 e8       	ldi	r23, 0x80	; 128
    2638:	48 8f       	std	Y+24, r20	; 0x18
    263a:	59 8f       	std	Y+25, r21	; 0x19
    263c:	6a 8f       	std	Y+26, r22	; 0x1a
    263e:	7b 8f       	std	Y+27, r23	; 0x1b
    2640:	40 e1       	ldi	r20, 0x10	; 16
    2642:	50 e0       	ldi	r21, 0x00	; 0
    2644:	60 e0       	ldi	r22, 0x00	; 0
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    2646:	70 e0       	ldi	r23, 0x00	; 0
    2648:	4c 8f       	std	Y+28, r20	; 0x1c
    264a:	5d 8f       	std	Y+29, r21	; 0x1d
    264c:	6e 8f       	std	Y+30, r22	; 0x1e
    264e:	7f 8f       	std	Y+31, r23	; 0x1f
    2650:	4c a5       	lds	r20, 0x6c
    2652:	5d a5       	lds	r21, 0x6d
    2654:	6e a5       	lds	r22, 0x6e
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    2656:	7f a5       	lds	r23, 0x6f
    2658:	8e 30       	cpi	r24, 0x0E	; 14
    265a:	e1 e0       	ldi	r30, 0x01	; 1
    265c:	9e 07       	cpc	r25, r30
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    265e:	e1 e0       	ldi	r30, 0x01	; 1
    2660:	ae 07       	cpc	r26, r30
    2662:	e0 e0       	ldi	r30, 0x00	; 0
    2664:	be 07       	cpc	r27, r30
    2666:	49 f0       	breq	.+18     	; 0x267a <RNDIS_Device_ProcessControlRequest+0x460>
    2668:	83 30       	cpi	r24, 0x03	; 3
    266a:	f1 e0       	ldi	r31, 0x01	; 1
    266c:	9f 07       	cpc	r25, r31
    266e:	f1 e0       	ldi	r31, 0x01	; 1
    2670:	af 07       	cpc	r26, r31
    2672:	f1 e0       	ldi	r31, 0x01	; 1
    2674:	bf 07       	cpc	r27, r31
    2676:	f1 f4       	brne	.+60     	; 0x26b4 <RNDIS_Device_ProcessControlRequest+0x49a>
    2678:	19 c0       	rjmp	.+50     	; 0x26ac <RNDIS_Device_ProcessControlRequest+0x492>
    267a:	4c 0f       	add	r20, r28
    267c:	5d 1f       	adc	r21, r29
    267e:	fa 01       	movw	r30, r20
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    2680:	80 a1       	lds	r24, 0x40
    2682:	91 a1       	lds	r25, 0x41
    2684:	a2 a1       	lds	r26, 0x42
    2686:	b3 a1       	lds	r27, 0x43
    2688:	fe 01       	movw	r30, r28
    268a:	e6 56       	subi	r30, 0x66	; 102
    268c:	ff 4f       	sbci	r31, 0xFF	; 255
    268e:	80 83       	st	Z, r24
    2690:	91 83       	std	Z+1, r25	; 0x01
    2692:	a2 83       	std	Z+2, r26	; 0x02
    2694:	b3 83       	std	Z+3, r27	; 0x03
    2696:	00 97       	sbiw	r24, 0x00	; 0
    2698:	a1 05       	cpc	r26, r1
    269a:	b1 05       	cpc	r27, r1
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    269c:	11 f0       	breq	.+4      	; 0x26a2 <RNDIS_Device_ProcessControlRequest+0x488>
    269e:	82 e0       	ldi	r24, 0x02	; 2
    26a0:	01 c0       	rjmp	.+2      	; 0x26a4 <RNDIS_Device_ProcessControlRequest+0x48a>
    26a2:	81 e0       	ldi	r24, 0x01	; 1
    26a4:	fe 01       	movw	r30, r28
    26a6:	e7 56       	subi	r30, 0x67	; 103
    26a8:	ff 4f       	sbci	r31, 0xFF	; 255
    26aa:	80 83       	st	Z, r24
    26ac:	80 e0       	ldi	r24, 0x00	; 0
    26ae:	90 e0       	ldi	r25, 0x00	; 0
    26b0:	dc 01       	movw	r26, r24
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    26b2:	04 c0       	rjmp	.+8      	; 0x26bc <RNDIS_Device_ProcessControlRequest+0x4a2>
    26b4:	8b eb       	ldi	r24, 0xBB	; 187
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	a0 e0       	ldi	r26, 0x00	; 0
    26ba:	b0 ec       	ldi	r27, 0xC0	; 192
    26bc:	8c a3       	lds	r24, 0x5c
    26be:	9d a3       	lds	r25, 0x5d
    26c0:	ae a3       	lds	r26, 0x5e
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    26c2:	bf a3       	lds	r27, 0x5f
    26c4:	78 c0       	rjmp	.+240    	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    26c6:	fe 01       	movw	r30, r28
    26c8:	e8 56       	subi	r30, 0x68	; 104
    26ca:	ff 4f       	sbci	r31, 0xFF	; 255
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    26cc:	81 e0       	ldi	r24, 0x01	; 1
    26ce:	80 83       	st	Z, r24
    26d0:	86 e0       	ldi	r24, 0x06	; 6
    26d2:	90 e0       	ldi	r25, 0x00	; 0
    26d4:	a0 e0       	ldi	r26, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    26d6:	b0 e8       	ldi	r27, 0x80	; 128
    26d8:	88 8f       	std	Y+24, r24	; 0x18
    26da:	99 8f       	std	Y+25, r25	; 0x19
    26dc:	aa 8f       	std	Y+26, r26	; 0x1a
    26de:	bb 8f       	std	Y+27, r27	; 0x1b
    26e0:	80 e1       	ldi	r24, 0x10	; 16
    26e2:	90 e0       	ldi	r25, 0x00	; 0
    26e4:	a0 e0       	ldi	r26, 0x00	; 0
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    26e6:	b0 e0       	ldi	r27, 0x00	; 0
    26e8:	8c 8f       	std	Y+28, r24	; 0x1c
    26ea:	9d 8f       	std	Y+29, r25	; 0x1d
    26ec:	ae 8f       	std	Y+30, r26	; 0x1e
    26ee:	bf 8f       	std	Y+31, r27	; 0x1f
    26f0:	18 a2       	lds	r17, 0x98
    26f2:	19 a2       	lds	r17, 0x99
    26f4:	1a a2       	lds	r17, 0x9a
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    26f6:	1b a2       	lds	r17, 0x9b
    26f8:	15 c0       	rjmp	.+42     	; 0x2724 <RNDIS_Device_ProcessControlRequest+0x50a>
    26fa:	fe 01       	movw	r30, r28
    26fc:	e8 56       	subi	r30, 0x68	; 104
    26fe:	ff 4f       	sbci	r31, 0xFF	; 255
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2700:	81 e0       	ldi	r24, 0x01	; 1
    2702:	80 83       	st	Z, r24
    2704:	88 e0       	ldi	r24, 0x08	; 8
    2706:	90 e0       	ldi	r25, 0x00	; 0
    2708:	a0 e0       	ldi	r26, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    270a:	b0 e8       	ldi	r27, 0x80	; 128
    270c:	88 8f       	std	Y+24, r24	; 0x18
    270e:	99 8f       	std	Y+25, r25	; 0x19
    2710:	aa 8f       	std	Y+26, r26	; 0x1a
    2712:	bb 8f       	std	Y+27, r27	; 0x1b
    2714:	80 e1       	ldi	r24, 0x10	; 16
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	a0 e0       	ldi	r26, 0x00	; 0
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    271a:	b0 e0       	ldi	r27, 0x00	; 0
    271c:	8c 8f       	std	Y+28, r24	; 0x1c
    271e:	9d 8f       	std	Y+29, r25	; 0x1d
    2720:	ae 8f       	std	Y+30, r26	; 0x1e
    2722:	bf 8f       	std	Y+31, r27	; 0x1f
    2724:	1c a2       	lds	r17, 0x9c
    2726:	1d a2       	lds	r17, 0x9d
    2728:	1e a2       	lds	r17, 0x9e
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    272a:	1f a2       	lds	r17, 0x9f
    272c:	44 c0       	rjmp	.+136    	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    272e:	80 91 0b 14 	lds	r24, 0x140B
    2732:	81 3a       	cpi	r24, 0xA1	; 161
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2734:	09 f0       	breq	.+2      	; 0x2738 <RNDIS_Device_ProcessControlRequest+0x51e>
    2736:	3f c0       	rjmp	.+126    	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    2738:	8c 8d       	ldd	r24, Y+28	; 0x1c
    273a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    273c:	ae 8d       	ldd	r26, Y+30	; 0x1e
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

				if (!(MessageHeader->MessageLength))
    273e:	bf 8d       	ldd	r27, Y+31	; 0x1f
    2740:	00 97       	sbiw	r24, 0x00	; 0
    2742:	a1 05       	cpc	r26, r1
    2744:	b1 05       	cpc	r27, r1
    2746:	49 f4       	brne	.+18     	; 0x275a <RNDIS_Device_ProcessControlRequest+0x540>
    2748:	18 8e       	std	Y+24, r1	; 0x18
    274a:	81 e0       	ldi	r24, 0x01	; 1
    274c:	90 e0       	ldi	r25, 0x00	; 0
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    274e:	a0 e0       	ldi	r26, 0x00	; 0
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    2750:	b0 e0       	ldi	r27, 0x00	; 0
    2752:	8c 8f       	std	Y+28, r24	; 0x1c
    2754:	9d 8f       	std	Y+29, r25	; 0x1d
    2756:	ae 8f       	std	Y+30, r26	; 0x1e
    2758:	bf 8f       	std	Y+31, r27	; 0x1f
    275a:	80 91 e8 00 	lds	r24, 0x00E8
    275e:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2760:	80 93 e8 00 	sts	0x00E8, r24
    2764:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2766:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2768:	ce 01       	movw	r24, r28
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    276a:	48 96       	adiw	r24, 0x18	; 24
    276c:	df d8       	rcall	.-3650   	; 0x192c <Endpoint_Write_Control_Stream_LE>
    276e:	80 91 e8 00 	lds	r24, 0x00E8
    2772:	8b 77       	andi	r24, 0x7B	; 123
    2774:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2778:	1c 8e       	std	Y+28, r1	; 0x1c
    277a:	1d 8e       	std	Y+29, r1	; 0x1d
    277c:	1e 8e       	std	Y+30, r1	; 0x1e
    277e:	1f 8e       	std	Y+31, r1	; 0x1f
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    2780:	1a c0       	rjmp	.+52     	; 0x27b6 <RNDIS_Device_ProcessControlRequest+0x59c>
    2782:	1c a2       	lds	r17, 0x9c
    2784:	1d a2       	lds	r17, 0x9d
    2786:	1e a2       	lds	r17, 0x9e
    2788:	1f a2       	lds	r17, 0x9f
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    278a:	c8 01       	movw	r24, r16
    278c:	48 96       	adiw	r24, 0x18	; 24
    278e:	a0 e0       	ldi	r26, 0x00	; 0
    2790:	b0 e0       	ldi	r27, 0x00	; 0
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    2792:	8c 8f       	std	Y+28, r24	; 0x1c
    2794:	9d 8f       	std	Y+29, r25	; 0x1d
    2796:	ae 8f       	std	Y+30, r26	; 0x1e
    2798:	bf 8f       	std	Y+31, r27	; 0x1f
    279a:	20 e0       	ldi	r18, 0x00	; 0
    279c:	30 e0       	ldi	r19, 0x00	; 0
    279e:	08 a7       	lds	r16, 0x78
    27a0:	19 a7       	lds	r17, 0x79

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    27a2:	2a a7       	lds	r18, 0x7a
    27a4:	3b a7       	lds	r19, 0x7b
    27a6:	80 e1       	ldi	r24, 0x10	; 16
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	a0 e0       	ldi	r26, 0x00	; 0
    27ac:	b0 e0       	ldi	r27, 0x00	; 0
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    27ae:	8c a7       	lds	r24, 0x7c
    27b0:	9d a7       	lds	r25, 0x7d
    27b2:	ae a7       	lds	r26, 0x7e
    27b4:	bf a7       	lds	r27, 0x7f
    27b6:	df 91       	pop	r29
    27b8:	cf 91       	pop	r28
    27ba:	1f 91       	pop	r17
    27bc:	0f 91       	pop	r16
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    27be:	08 95       	ret

000027c0 <RNDIS_Device_ConfigureEndpoints>:
    27c0:	cf 93       	push	r28
    27c2:	df 93       	push	r29
    27c4:	ec 01       	movw	r28, r24
    27c6:	48 96       	adiw	r24, 0x18	; 24

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    27c8:	fc 01       	movw	r30, r24
    27ca:	86 e8       	ldi	r24, 0x86	; 134
    27cc:	df 01       	movw	r26, r30
    27ce:	1d 92       	st	X+, r1
    27d0:	8a 95       	dec	r24
    27d2:	e9 f7       	brne	.-6      	; 0x27ce <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    27d4:	82 e0       	ldi	r24, 0x02	; 2
    27d6:	8c 83       	std	Y+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    27d8:	89 87       	std	Y+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    27da:	83 e0       	ldi	r24, 0x03	; 3
    27dc:	8e 87       	std	Y+14, r24	; 0x0e

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    27de:	ce 01       	movw	r24, r28
    27e0:	01 96       	adiw	r24, 0x01	; 1
    27e2:	61 e0       	ldi	r22, 0x01	; 1
    27e4:	da d9       	rcall	.-3148   	; 0x1b9a <Endpoint_ConfigureEndpointTable>
    27e6:	88 23       	and	r24, r24
    27e8:	59 f0       	breq	.+22     	; 0x2800 <RNDIS_Device_ConfigureEndpoints+0x40>
    27ea:	ce 01       	movw	r24, r28
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    27ec:	06 96       	adiw	r24, 0x06	; 6
    27ee:	61 e0       	ldi	r22, 0x01	; 1
    27f0:	d4 d9       	rcall	.-3160   	; 0x1b9a <Endpoint_ConfigureEndpointTable>
    27f2:	88 23       	and	r24, r24
    27f4:	29 f0       	breq	.+10     	; 0x2800 <RNDIS_Device_ConfigureEndpoints+0x40>
    27f6:	ce 01       	movw	r24, r28
    27f8:	0b 96       	adiw	r24, 0x0b	; 11
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    27fa:	61 e0       	ldi	r22, 0x01	; 1
    27fc:	ce d9       	rcall	.-3172   	; 0x1b9a <Endpoint_ConfigureEndpointTable>
    27fe:	01 c0       	rjmp	.+2      	; 0x2802 <RNDIS_Device_ConfigureEndpoints+0x42>
    2800:	80 e0       	ldi	r24, 0x00	; 0
    2802:	df 91       	pop	r29
    2804:	cf 91       	pop	r28

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;
    2806:	08 95       	ret

00002808 <RNDIS_Device_USBTask>:

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
	  return false;

	return true;
}
    2808:	0f 93       	push	r16
    280a:	1f 93       	push	r17
    280c:	cf 93       	push	r28

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    280e:	df 93       	push	r29
    2810:	cd b7       	in	r28, 0x3d	; 61
    2812:	de b7       	in	r29, 0x3e	; 62
    2814:	28 97       	sbiw	r28, 0x08	; 8
    2816:	0f b6       	in	r0, 0x3f	; 63
    2818:	f8 94       	cli
    281a:	de bf       	out	0x3e, r29	; 62
    281c:	0f be       	out	0x3f, r0	; 63
    281e:	cd bf       	out	0x3d, r28	; 61
    2820:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    2822:	80 91 0a 14 	lds	r24, 0x140A
    2826:	84 30       	cpi	r24, 0x04	; 4
    2828:	41 f5       	brne	.+80     	; 0x287a <RNDIS_Device_USBTask+0x72>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    282a:	f8 01       	movw	r30, r16
    282c:	83 85       	ldd	r24, Z+11	; 0x0b
    282e:	8f 70       	andi	r24, 0x0F	; 15
    2830:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2834:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2838:	80 ff       	sbrs	r24, 0
    283a:	1f c0       	rjmp	.+62     	; 0x287a <RNDIS_Device_USBTask+0x72>
    283c:	e8 56       	subi	r30, 0x68	; 104
    283e:	ff 4f       	sbci	r31, 0xFF	; 255
    2840:	80 81       	ld	r24, Z
    2842:	88 23       	and	r24, r24
    2844:	d1 f0       	breq	.+52     	; 0x287a <RNDIS_Device_USBTask+0x72>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    2846:	de 01       	movw	r26, r28
    2848:	11 96       	adiw	r26, 0x01	; 1
    284a:	ea ef       	ldi	r30, 0xFA	; 250
    284c:	f1 e0       	ldi	r31, 0x01	; 1
    284e:	88 e0       	ldi	r24, 0x08	; 8
    2850:	01 90       	ld	r0, Z+
    2852:	0d 92       	st	X+, r0
    2854:	81 50       	subi	r24, 0x01	; 1
    2856:	e1 f7       	brne	.-8      	; 0x2850 <RNDIS_Device_USBTask+0x48>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    2858:	ce 01       	movw	r24, r28
    285a:	01 96       	adiw	r24, 0x01	; 1
    285c:	68 e0       	ldi	r22, 0x08	; 8
    285e:	70 e0       	ldi	r23, 0x00	; 0
    2860:	40 e0       	ldi	r20, 0x00	; 0
    2862:	50 e0       	ldi	r21, 0x00	; 0
    2864:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2868:	80 91 e8 00 	lds	r24, 0x00E8
    286c:	8e 77       	andi	r24, 0x7E	; 126
    286e:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2872:	f8 01       	movw	r30, r16
    2874:	e8 56       	subi	r30, 0x68	; 104
    2876:	ff 4f       	sbci	r31, 0xFF	; 255
    2878:	10 82       	st	Z, r1
	}
}
    287a:	28 96       	adiw	r28, 0x08	; 8
    287c:	0f b6       	in	r0, 0x3f	; 63
    287e:	f8 94       	cli
    2880:	de bf       	out	0x3e, r29	; 62
    2882:	0f be       	out	0x3f, r0	; 63
    2884:	cd bf       	out	0x3d, r28	; 61
    2886:	df 91       	pop	r29
    2888:	cf 91       	pop	r28
    288a:	1f 91       	pop	r17
    288c:	0f 91       	pop	r16
    288e:	08 95       	ret

00002890 <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2890:	20 91 0a 14 	lds	r18, 0x140A
    2894:	24 30       	cpi	r18, 0x04	; 4
    2896:	81 f4       	brne	.+32     	; 0x28b8 <RNDIS_Device_IsPacketReceived+0x28>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    2898:	fc 01       	movw	r30, r24
    289a:	e7 56       	subi	r30, 0x67	; 103
    289c:	ff 4f       	sbci	r31, 0xFF	; 255
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    289e:	20 81       	ld	r18, Z
    28a0:	22 30       	cpi	r18, 0x02	; 2
    28a2:	61 f4       	brne	.+24     	; 0x28bc <RNDIS_Device_IsPacketReceived+0x2c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    28a4:	fc 01       	movw	r30, r24
    28a6:	86 81       	ldd	r24, Z+6	; 0x06
    28a8:	8f 70       	andi	r24, 0x0F	; 15
    28aa:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    28ae:	90 91 e8 00 	lds	r25, 0x00E8
    28b2:	81 e0       	ldi	r24, 0x01	; 1
    28b4:	92 fd       	sbrc	r25, 2
    28b6:	03 c0       	rjmp	.+6      	; 0x28be <RNDIS_Device_IsPacketReceived+0x2e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	08 95       	ret
    28bc:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    28be:	08 95       	ret

000028c0 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    28c0:	ef 92       	push	r14
    28c2:	ff 92       	push	r15
    28c4:	0f 93       	push	r16
    28c6:	1f 93       	push	r17
    28c8:	cf 93       	push	r28
    28ca:	df 93       	push	r29
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	ac 97       	sbiw	r28, 0x2c	; 44
    28d2:	0f b6       	in	r0, 0x3f	; 63
    28d4:	f8 94       	cli
    28d6:	de bf       	out	0x3e, r29	; 62
    28d8:	0f be       	out	0x3f, r0	; 63
    28da:	cd bf       	out	0x3d, r28	; 61
    28dc:	7b 01       	movw	r14, r22
    28de:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    28e0:	20 91 0a 14 	lds	r18, 0x140A
    28e4:	24 30       	cpi	r18, 0x04	; 4
    28e6:	e1 f5       	brne	.+120    	; 0x2960 <RNDIS_Device_ReadPacket+0xa0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    28e8:	fc 01       	movw	r30, r24
    28ea:	e7 56       	subi	r30, 0x67	; 103
    28ec:	ff 4f       	sbci	r31, 0xFF	; 255

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    28ee:	20 81       	ld	r18, Z
    28f0:	22 30       	cpi	r18, 0x02	; 2
    28f2:	b1 f5       	brne	.+108    	; 0x2960 <RNDIS_Device_ReadPacket+0xa0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    28f4:	fc 01       	movw	r30, r24
    28f6:	86 81       	ldd	r24, Z+6	; 0x06
    28f8:	8f 70       	andi	r24, 0x0F	; 15
    28fa:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;
    28fe:	fa 01       	movw	r30, r20
    2900:	11 82       	std	Z+1, r1	; 0x01
    2902:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2904:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    2908:	82 ff       	sbrs	r24, 2
    290a:	2c c0       	rjmp	.+88     	; 0x2964 <RNDIS_Device_ReadPacket+0xa4>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    290c:	ce 01       	movw	r24, r28
    290e:	01 96       	adiw	r24, 0x01	; 1
    2910:	6c e2       	ldi	r22, 0x2C	; 44
    2912:	70 e0       	ldi	r23, 0x00	; 0
    2914:	40 e0       	ldi	r20, 0x00	; 0
    2916:	50 e0       	ldi	r21, 0x00	; 0
    2918:	0e 94 46 0c 	call	0x188c	; 0x188c <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    291c:	4d 85       	ldd	r20, Y+13	; 0x0d
    291e:	5e 85       	ldd	r21, Y+14	; 0x0e
    2920:	6f 85       	ldd	r22, Y+15	; 0x0f
    2922:	78 89       	ldd	r23, Y+16	; 0x10
    2924:	4d 3d       	cpi	r20, 0xDD	; 221
    2926:	f5 e0       	ldi	r31, 0x05	; 5
    2928:	5f 07       	cpc	r21, r31
    292a:	f0 e0       	ldi	r31, 0x00	; 0
    292c:	6f 07       	cpc	r22, r31
    292e:	f0 e0       	ldi	r31, 0x00	; 0
    2930:	7f 07       	cpc	r23, r31
    2932:	38 f0       	brcs	.+14     	; 0x2942 <RNDIS_Device_ReadPacket+0x82>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2934:	80 91 eb 00 	lds	r24, 0x00EB
    2938:	80 62       	ori	r24, 0x20	; 32
    293a:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    293e:	80 e8       	ldi	r24, 0x80	; 128
    2940:	12 c0       	rjmp	.+36     	; 0x2966 <RNDIS_Device_ReadPacket+0xa6>
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    2942:	f8 01       	movw	r30, r16
    2944:	51 83       	std	Z+1, r21	; 0x01
    2946:	40 83       	st	Z, r20

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    2948:	c7 01       	movw	r24, r14
    294a:	ba 01       	movw	r22, r20
    294c:	40 e0       	ldi	r20, 0x00	; 0
    294e:	50 e0       	ldi	r21, 0x00	; 0
    2950:	0e 94 46 0c 	call	0x188c	; 0x188c <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2954:	80 91 e8 00 	lds	r24, 0x00E8
    2958:	8b 77       	andi	r24, 0x7B	; 123
    295a:	80 93 e8 00 	sts	0x00E8, r24
    295e:	02 c0       	rjmp	.+4      	; 0x2964 <RNDIS_Device_ReadPacket+0xa4>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2960:	82 e0       	ldi	r24, 0x02	; 2
    2962:	01 c0       	rjmp	.+2      	; 0x2966 <RNDIS_Device_ReadPacket+0xa6>
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;

	if (!(Endpoint_IsOUTReceived()))
		return ENDPOINT_RWSTREAM_NoError;
    2964:	80 e0       	ldi	r24, 0x00	; 0

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    2966:	ac 96       	adiw	r28, 0x2c	; 44
    2968:	0f b6       	in	r0, 0x3f	; 63
    296a:	f8 94       	cli
    296c:	de bf       	out	0x3e, r29	; 62
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	cd bf       	out	0x3d, r28	; 61
    2972:	df 91       	pop	r29
    2974:	cf 91       	pop	r28
    2976:	1f 91       	pop	r17
    2978:	0f 91       	pop	r16
    297a:	ff 90       	pop	r15
    297c:	ef 90       	pop	r14
    297e:	08 95       	ret

00002980 <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    2980:	cf 92       	push	r12
    2982:	df 92       	push	r13
    2984:	ef 92       	push	r14
    2986:	ff 92       	push	r15
    2988:	1f 93       	push	r17
    298a:	cf 93       	push	r28
    298c:	df 93       	push	r29
    298e:	cd b7       	in	r28, 0x3d	; 61
    2990:	de b7       	in	r29, 0x3e	; 62
    2992:	ac 97       	sbiw	r28, 0x2c	; 44
    2994:	0f b6       	in	r0, 0x3f	; 63
    2996:	f8 94       	cli
    2998:	de bf       	out	0x3e, r29	; 62
    299a:	0f be       	out	0x3f, r0	; 63
    299c:	cd bf       	out	0x3d, r28	; 61
    299e:	6b 01       	movw	r12, r22
    29a0:	7a 01       	movw	r14, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    29a2:	20 91 0a 14 	lds	r18, 0x140A
    29a6:	24 30       	cpi	r18, 0x04	; 4
    29a8:	09 f0       	breq	.+2      	; 0x29ac <RNDIS_Device_SendPacket+0x2c>
    29aa:	4a c0       	rjmp	.+148    	; 0x2a40 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    29ac:	fc 01       	movw	r30, r24
    29ae:	e7 56       	subi	r30, 0x67	; 103
    29b0:	ff 4f       	sbci	r31, 0xFF	; 255
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    29b2:	20 81       	ld	r18, Z
    29b4:	22 30       	cpi	r18, 0x02	; 2
    29b6:	09 f0       	breq	.+2      	; 0x29ba <RNDIS_Device_SendPacket+0x3a>
    29b8:	43 c0       	rjmp	.+134    	; 0x2a40 <RNDIS_Device_SendPacket+0xc0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    29ba:	dc 01       	movw	r26, r24
    29bc:	11 96       	adiw	r26, 0x01	; 1
    29be:	8c 91       	ld	r24, X
    29c0:	8f 70       	andi	r24, 0x0F	; 15
    29c2:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    29c6:	46 d9       	rcall	.-3444   	; 0x1c54 <Endpoint_WaitUntilReady>
    29c8:	18 2f       	mov	r17, r24
    29ca:	88 23       	and	r24, r24
    29cc:	d1 f5       	brne	.+116    	; 0x2a42 <RNDIS_Device_SendPacket+0xc2>
    29ce:	fe 01       	movw	r30, r28
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    29d0:	31 96       	adiw	r30, 0x01	; 1
    29d2:	8c e2       	ldi	r24, 0x2C	; 44
    29d4:	df 01       	movw	r26, r30
    29d6:	1d 92       	st	X+, r1
    29d8:	8a 95       	dec	r24
    29da:	e9 f7       	brne	.-6      	; 0x29d6 <RNDIS_Device_SendPacket+0x56>
    29dc:	81 e0       	ldi	r24, 0x01	; 1

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	a0 e0       	ldi	r26, 0x00	; 0
    29e2:	b0 e0       	ldi	r27, 0x00	; 0
    29e4:	89 83       	std	Y+1, r24	; 0x01
    29e6:	9a 83       	std	Y+2, r25	; 0x02
    29e8:	ab 83       	std	Y+3, r26	; 0x03
    29ea:	bc 83       	std	Y+4, r27	; 0x04
    29ec:	c7 01       	movw	r24, r14
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    29ee:	8c 96       	adiw	r24, 0x2c	; 44
    29f0:	a0 e0       	ldi	r26, 0x00	; 0
    29f2:	b0 e0       	ldi	r27, 0x00	; 0
    29f4:	8d 83       	std	Y+5, r24	; 0x05
    29f6:	9e 83       	std	Y+6, r25	; 0x06
    29f8:	af 83       	std	Y+7, r26	; 0x07
    29fa:	b8 87       	std	Y+8, r27	; 0x08
    29fc:	84 e2       	ldi	r24, 0x24	; 36
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    29fe:	90 e0       	ldi	r25, 0x00	; 0
    2a00:	a0 e0       	ldi	r26, 0x00	; 0
    2a02:	b0 e0       	ldi	r27, 0x00	; 0
    2a04:	89 87       	std	Y+9, r24	; 0x09
    2a06:	9a 87       	std	Y+10, r25	; 0x0a
    2a08:	ab 87       	std	Y+11, r26	; 0x0b
    2a0a:	bc 87       	std	Y+12, r27	; 0x0c
    2a0c:	c7 01       	movw	r24, r14
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    2a0e:	a0 e0       	ldi	r26, 0x00	; 0
    2a10:	b0 e0       	ldi	r27, 0x00	; 0
    2a12:	8d 87       	std	Y+13, r24	; 0x0d
    2a14:	9e 87       	std	Y+14, r25	; 0x0e
    2a16:	af 87       	std	Y+15, r26	; 0x0f
    2a18:	b8 8b       	std	Y+16, r27	; 0x10
    2a1a:	cf 01       	movw	r24, r30

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2a1c:	6c e2       	ldi	r22, 0x2C	; 44
    2a1e:	70 e0       	ldi	r23, 0x00	; 0
    2a20:	40 e0       	ldi	r20, 0x00	; 0
    2a22:	50 e0       	ldi	r21, 0x00	; 0
    2a24:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <Endpoint_Write_Stream_LE>
    2a28:	c6 01       	movw	r24, r12
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    2a2a:	b7 01       	movw	r22, r14
    2a2c:	40 e0       	ldi	r20, 0x00	; 0
    2a2e:	50 e0       	ldi	r21, 0x00	; 0
    2a30:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <Endpoint_Write_Stream_LE>
    2a34:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2a38:	8e 77       	andi	r24, 0x7E	; 126
    2a3a:	80 93 e8 00 	sts	0x00E8, r24
    2a3e:	01 c0       	rjmp	.+2      	; 0x2a42 <RNDIS_Device_SendPacket+0xc2>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    2a40:	12 e0       	ldi	r17, 0x02	; 2
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2a42:	81 2f       	mov	r24, r17
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    2a44:	ac 96       	adiw	r28, 0x2c	; 44
    2a46:	0f b6       	in	r0, 0x3f	; 63
    2a48:	f8 94       	cli
    2a4a:	de bf       	out	0x3e, r29	; 62
    2a4c:	0f be       	out	0x3f, r0	; 63
    2a4e:	cd bf       	out	0x3d, r28	; 61
    2a50:	df 91       	pop	r29
    2a52:	cf 91       	pop	r28
    2a54:	1f 91       	pop	r17
    2a56:	ff 90       	pop	r15
    2a58:	ef 90       	pop	r14
    2a5a:	df 90       	pop	r13
    2a5c:	cf 90       	pop	r12
    2a5e:	08 95       	ret

00002a60 <Serial_putchar>:
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2a60:	90 91 c8 00 	lds	r25, 0x00C8
    2a64:	95 ff       	sbrs	r25, 5
    2a66:	fc cf       	rjmp	.-8      	; 0x2a60 <Serial_putchar>
				UDR1 = DataByte;
    2a68:	80 93 ce 00 	sts	0x00CE, r24
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2a6c:	80 e0       	ldi	r24, 0x00	; 0
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	08 95       	ret

00002a72 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2a72:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2a76:	87 ff       	sbrs	r24, 7
    2a78:	08 c0       	rjmp	.+16     	; 0x2a8a <Serial_getchar+0x18>
    2a7a:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2a7e:	87 ff       	sbrs	r24, 7
    2a80:	07 c0       	rjmp	.+14     	; 0x2a90 <Serial_getchar+0x1e>
				  return -1;

				return UDR1;
    2a82:	80 91 ce 00 	lds	r24, 0x00CE
    2a86:	90 e0       	ldi	r25, 0x00	; 0
    2a88:	08 95       	ret
	  return _FDEV_EOF;
    2a8a:	8e ef       	ldi	r24, 0xFE	; 254
    2a8c:	9f ef       	ldi	r25, 0xFF	; 255
    2a8e:	08 95       	ret
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2a90:	8f ef       	ldi	r24, 0xFF	; 255
    2a92:	9f ef       	ldi	r25, 0xFF	; 255

	return Serial_ReceiveByte();
}
    2a94:	08 95       	ret

00002a96 <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*((uint8_t*)Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    2a96:	fc 01       	movw	r30, r24
	if (!(Stream))
    2a98:	00 97       	sbiw	r24, 0x00	; 0
    2a9a:	51 f4       	brne	.+20     	; 0x2ab0 <Serial_CreateStream+0x1a>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    2a9c:	e3 e1       	ldi	r30, 0x13	; 19
    2a9e:	f4 e1       	ldi	r31, 0x14	; 20
    2aa0:	f0 93 22 14 	sts	0x1422, r31
    2aa4:	e0 93 21 14 	sts	0x1421, r30
		stdout = Stream;
    2aa8:	f0 93 24 14 	sts	0x1424, r31
    2aac:	e0 93 23 14 	sts	0x1423, r30
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    2ab0:	8e e0       	ldi	r24, 0x0E	; 14
    2ab2:	df 01       	movw	r26, r30
    2ab4:	1d 92       	st	X+, r1
    2ab6:	8a 95       	dec	r24
    2ab8:	e9 f7       	brne	.-6      	; 0x2ab4 <Serial_CreateStream+0x1e>
    2aba:	83 e0       	ldi	r24, 0x03	; 3
    2abc:	83 83       	std	Z+3, r24	; 0x03
    2abe:	80 e3       	ldi	r24, 0x30	; 48
    2ac0:	95 e1       	ldi	r25, 0x15	; 21
    2ac2:	91 87       	std	Z+9, r25	; 0x09
    2ac4:	80 87       	std	Z+8, r24	; 0x08
    2ac6:	89 e3       	ldi	r24, 0x39	; 57
    2ac8:	95 e1       	ldi	r25, 0x15	; 21
    2aca:	93 87       	std	Z+11, r25	; 0x0b
    2acc:	82 87       	std	Z+10, r24	; 0x0a
}
    2ace:	08 95       	ret

00002ad0 <memcpy_P>:
    2ad0:	fb 01       	movw	r30, r22
    2ad2:	dc 01       	movw	r26, r24
    2ad4:	02 c0       	rjmp	.+4      	; 0x2ada <memcpy_P+0xa>
    2ad6:	05 90       	lpm	r0, Z+
    2ad8:	0d 92       	st	X+, r0
    2ada:	41 50       	subi	r20, 0x01	; 1
    2adc:	50 40       	sbci	r21, 0x00	; 0
    2ade:	d8 f7       	brcc	.-10     	; 0x2ad6 <memcpy_P+0x6>
    2ae0:	08 95       	ret

00002ae2 <strcpy_P>:
    2ae2:	fb 01       	movw	r30, r22
    2ae4:	dc 01       	movw	r26, r24
    2ae6:	05 90       	lpm	r0, Z+
    2ae8:	0d 92       	st	X+, r0
    2aea:	00 20       	and	r0, r0
    2aec:	e1 f7       	brne	.-8      	; 0x2ae6 <strcpy_P+0x4>
    2aee:	08 95       	ret

00002af0 <__strlen_P>:
    2af0:	fc 01       	movw	r30, r24
    2af2:	05 90       	lpm	r0, Z+
    2af4:	00 20       	and	r0, r0
    2af6:	e9 f7       	brne	.-6      	; 0x2af2 <__strlen_P+0x2>
    2af8:	80 95       	com	r24
    2afa:	90 95       	com	r25
    2afc:	8e 0f       	add	r24, r30
    2afe:	9f 1f       	adc	r25, r31
    2b00:	08 95       	ret

00002b02 <strncpy_P>:
    2b02:	fb 01       	movw	r30, r22
    2b04:	dc 01       	movw	r26, r24
    2b06:	41 50       	subi	r20, 0x01	; 1
    2b08:	50 40       	sbci	r21, 0x00	; 0
    2b0a:	48 f0       	brcs	.+18     	; 0x2b1e <strncpy_P+0x1c>
    2b0c:	05 90       	lpm	r0, Z+
    2b0e:	0d 92       	st	X+, r0
    2b10:	00 20       	and	r0, r0
    2b12:	c9 f7       	brne	.-14     	; 0x2b06 <strncpy_P+0x4>
    2b14:	01 c0       	rjmp	.+2      	; 0x2b18 <strncpy_P+0x16>
    2b16:	1d 92       	st	X+, r1
    2b18:	41 50       	subi	r20, 0x01	; 1
    2b1a:	50 40       	sbci	r21, 0x00	; 0
    2b1c:	e0 f7       	brcc	.-8      	; 0x2b16 <strncpy_P+0x14>
    2b1e:	08 95       	ret

00002b20 <memcmp>:
    2b20:	fb 01       	movw	r30, r22
    2b22:	dc 01       	movw	r26, r24
    2b24:	04 c0       	rjmp	.+8      	; 0x2b2e <memcmp+0xe>
    2b26:	8d 91       	ld	r24, X+
    2b28:	01 90       	ld	r0, Z+
    2b2a:	80 19       	sub	r24, r0
    2b2c:	21 f4       	brne	.+8      	; 0x2b36 <memcmp+0x16>
    2b2e:	41 50       	subi	r20, 0x01	; 1
    2b30:	50 40       	sbci	r21, 0x00	; 0
    2b32:	c8 f7       	brcc	.-14     	; 0x2b26 <memcmp+0x6>
    2b34:	88 1b       	sub	r24, r24
    2b36:	99 0b       	sbc	r25, r25
    2b38:	08 95       	ret

00002b3a <memcpy>:
    2b3a:	fb 01       	movw	r30, r22
    2b3c:	dc 01       	movw	r26, r24
    2b3e:	02 c0       	rjmp	.+4      	; 0x2b44 <memcpy+0xa>
    2b40:	01 90       	ld	r0, Z+
    2b42:	0d 92       	st	X+, r0
    2b44:	41 50       	subi	r20, 0x01	; 1
    2b46:	50 40       	sbci	r21, 0x00	; 0
    2b48:	d8 f7       	brcc	.-10     	; 0x2b40 <memcpy+0x6>
    2b4a:	08 95       	ret

00002b4c <memmove>:
    2b4c:	68 17       	cp	r22, r24
    2b4e:	79 07       	cpc	r23, r25
    2b50:	68 f4       	brcc	.+26     	; 0x2b6c <memmove+0x20>
    2b52:	fb 01       	movw	r30, r22
    2b54:	dc 01       	movw	r26, r24
    2b56:	e4 0f       	add	r30, r20
    2b58:	f5 1f       	adc	r31, r21
    2b5a:	a4 0f       	add	r26, r20
    2b5c:	b5 1f       	adc	r27, r21
    2b5e:	02 c0       	rjmp	.+4      	; 0x2b64 <memmove+0x18>
    2b60:	02 90       	ld	r0, -Z
    2b62:	0e 92       	st	-X, r0
    2b64:	41 50       	subi	r20, 0x01	; 1
    2b66:	50 40       	sbci	r21, 0x00	; 0
    2b68:	d8 f7       	brcc	.-10     	; 0x2b60 <memmove+0x14>
    2b6a:	08 95       	ret
    2b6c:	e6 cf       	rjmp	.-52     	; 0x2b3a <memcpy>

00002b6e <strncmp>:
    2b6e:	fb 01       	movw	r30, r22
    2b70:	dc 01       	movw	r26, r24
    2b72:	41 50       	subi	r20, 0x01	; 1
    2b74:	50 40       	sbci	r21, 0x00	; 0
    2b76:	30 f0       	brcs	.+12     	; 0x2b84 <strncmp+0x16>
    2b78:	8d 91       	ld	r24, X+
    2b7a:	01 90       	ld	r0, Z+
    2b7c:	80 19       	sub	r24, r0
    2b7e:	19 f4       	brne	.+6      	; 0x2b86 <strncmp+0x18>
    2b80:	00 20       	and	r0, r0
    2b82:	b9 f7       	brne	.-18     	; 0x2b72 <strncmp+0x4>
    2b84:	88 1b       	sub	r24, r24
    2b86:	99 0b       	sbc	r25, r25
    2b88:	08 95       	ret

00002b8a <_exit>:
    2b8a:	f8 94       	cli

00002b8c <__stop_program>:
    2b8c:	ff cf       	rjmp	.-2      	; 0x2b8c <__stop_program>
