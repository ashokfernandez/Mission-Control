
GenericHID.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000cd4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000015  00800100  00800100  00000d48  2**0
                  ALLOC
  2 .stab         000008f4  00000000  00000000  00000d48  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000013d  00000000  00000000  0000163c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000290  00000000  00000000  00001779  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000787  00000000  00000000  00001a09  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003a77  00000000  00000000  00002190  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f7d  00000000  00000000  00005c07  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000344f  00000000  00000000  00006b84  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003c0  00000000  00000000  00009fd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a2b  00000000  00000000  0000a394  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001bf0  00000000  00000000  0000bdbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000300  00000000  00000000  0000d9af  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

	return Endpoint_IsConfigured();
}

void Endpoint_ClearEndpoints(void)
{
   0:	9f c0       	rjmp	.+318    	; 0x140 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
   2:	00 00       	nop
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
   4:	ba c0       	rjmp	.+372    	; 0x17a <__bad_interrupt>
   6:	00 00       	nop
   8:	b8 c0       	rjmp	.+368    	; 0x17a <__bad_interrupt>
   a:	00 00       	nop
   c:	b6 c0       	rjmp	.+364    	; 0x17a <__bad_interrupt>
   e:	00 00       	nop
  10:	b4 c0       	rjmp	.+360    	; 0x17a <__bad_interrupt>
  12:	00 00       	nop
  14:	b2 c0       	rjmp	.+356    	; 0x17a <__bad_interrupt>
  16:	00 00       	nop
  18:	b0 c0       	rjmp	.+352    	; 0x17a <__bad_interrupt>
  1a:	00 00       	nop
  1c:	ae c0       	rjmp	.+348    	; 0x17a <__bad_interrupt>
  1e:	00 00       	nop
  20:	ac c0       	rjmp	.+344    	; 0x17a <__bad_interrupt>
  22:	00 00       	nop
  24:	aa c0       	rjmp	.+340    	; 0x17a <__bad_interrupt>
  26:	00 00       	nop
  28:	b4 c2       	rjmp	.+1384   	; 0x592 <__vector_10>
  2a:	00 00       	nop
  2c:	a6 c0       	rjmp	.+332    	; 0x17a <__bad_interrupt>
  2e:	00 00       	nop
  30:	a4 c0       	rjmp	.+328    	; 0x17a <__bad_interrupt>
  32:	00 00       	nop
  34:	a2 c0       	rjmp	.+324    	; 0x17a <__bad_interrupt>
  36:	00 00       	nop
  38:	a0 c0       	rjmp	.+320    	; 0x17a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	9e c0       	rjmp	.+316    	; 0x17a <__bad_interrupt>
  3e:	00 00       	nop
  40:	9c c0       	rjmp	.+312    	; 0x17a <__bad_interrupt>
  42:	00 00       	nop
  44:	9a c0       	rjmp	.+308    	; 0x17a <__bad_interrupt>
  46:	00 00       	nop
  48:	98 c0       	rjmp	.+304    	; 0x17a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	96 c0       	rjmp	.+300    	; 0x17a <__bad_interrupt>
  4e:	00 00       	nop
  50:	94 c0       	rjmp	.+296    	; 0x17a <__bad_interrupt>
  52:	00 00       	nop
  54:	92 c0       	rjmp	.+292    	; 0x17a <__bad_interrupt>
  56:	00 00       	nop
  58:	90 c0       	rjmp	.+288    	; 0x17a <__bad_interrupt>
  5a:	00 00       	nop
  5c:	8e c0       	rjmp	.+284    	; 0x17a <__bad_interrupt>
  5e:	00 00       	nop
  60:	8c c0       	rjmp	.+280    	; 0x17a <__bad_interrupt>
  62:	00 00       	nop
  64:	8a c0       	rjmp	.+276    	; 0x17a <__bad_interrupt>
  66:	00 00       	nop
  68:	88 c0       	rjmp	.+272    	; 0x17a <__bad_interrupt>
  6a:	00 00       	nop
  6c:	86 c0       	rjmp	.+268    	; 0x17a <__bad_interrupt>
  6e:	00 00       	nop
  70:	84 c0       	rjmp	.+264    	; 0x17a <__bad_interrupt>
  72:	00 00       	nop
  74:	82 c0       	rjmp	.+260    	; 0x17a <__bad_interrupt>
  76:	00 00       	nop
  78:	80 c0       	rjmp	.+256    	; 0x17a <__bad_interrupt>
  7a:	00 00       	nop
  7c:	7e c0       	rjmp	.+252    	; 0x17a <__bad_interrupt>
  7e:	00 00       	nop
  80:	7c c0       	rjmp	.+248    	; 0x17a <__bad_interrupt>
  82:	00 00       	nop
  84:	7a c0       	rjmp	.+244    	; 0x17a <__bad_interrupt>
  86:	00 00       	nop
  88:	78 c0       	rjmp	.+240    	; 0x17a <__bad_interrupt>
  8a:	00 00       	nop
  8c:	76 c0       	rjmp	.+236    	; 0x17a <__bad_interrupt>
  8e:	00 00       	nop
  90:	74 c0       	rjmp	.+232    	; 0x17a <__bad_interrupt>
  92:	00 00       	nop
  94:	72 c0       	rjmp	.+228    	; 0x17a <__bad_interrupt>
  96:	00 00       	nop

00000098 <GenericReport>:
  98:	06 9c ff 09 01 a1 01 09 02 75 08 95 08 15 00 25     .........u.....%
  a8:	ff 81 02 09 03 75 08 95 08 15 00 25 ff 91 02 c0     .....u.....%....

000000b8 <DeviceDescriptor>:
  b8:	12 01 10 01 00 00 00 08 eb 03 4f 20 01 00 01 02     ..........O ....
  c8:	00 01                                               ..

000000ca <ConfigurationDescriptor>:
  ca:	09 02 29 00 01 01 00 c0 32 09 04 00 00 02 03 00     ..).....2.......
  da:	00 00 09 21 11 01 00 01 22 20 00 07 05 81 03 08     ...!...." ......
  ea:	00 01 07 05 02 03 08 00 01                          .........

000000f3 <LanguageString>:
  f3:	04 03 09 04                                         ....

000000f7 <ManufacturerString>:
  f7:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
 107:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000111 <ProductString>:
 111:	2c 03 4c 00 55 00 46 00 41 00 20 00 47 00 65 00     ,.L.U.F.A. .G.e.
 121:	6e 00 65 00 72 00 69 00 63 00 20 00 48 00 49 00     n.e.r.i.c. .H.I.
 131:	44 00 20 00 44 00 65 00 6d 00 6f 00 00 00 00        D. .D.e.m.o....

00000140 <__ctors_end>:
 140:	11 24       	eor	r1, r1
 142:	1f be       	out	0x3f, r1	; 63
 144:	cf ef       	ldi	r28, 0xFF	; 255
 146:	d0 e2       	ldi	r29, 0x20	; 32
 148:	de bf       	out	0x3e, r29	; 62
 14a:	cd bf       	out	0x3d, r28	; 61

0000014c <__do_copy_data>:
 14c:	11 e0       	ldi	r17, 0x01	; 1
 14e:	a0 e0       	ldi	r26, 0x00	; 0
 150:	b1 e0       	ldi	r27, 0x01	; 1
 152:	e4 ed       	ldi	r30, 0xD4	; 212
 154:	fc e0       	ldi	r31, 0x0C	; 12
 156:	00 e0       	ldi	r16, 0x00	; 0
 158:	0b bf       	out	0x3b, r16	; 59
 15a:	02 c0       	rjmp	.+4      	; 0x160 <__do_copy_data+0x14>
 15c:	07 90       	elpm	r0, Z+
 15e:	0d 92       	st	X+, r0
 160:	a0 30       	cpi	r26, 0x00	; 0
 162:	b1 07       	cpc	r27, r17
 164:	d9 f7       	brne	.-10     	; 0x15c <__do_copy_data+0x10>

00000166 <__do_clear_bss>:
 166:	11 e0       	ldi	r17, 0x01	; 1
 168:	a0 e0       	ldi	r26, 0x00	; 0
 16a:	b1 e0       	ldi	r27, 0x01	; 1
 16c:	01 c0       	rjmp	.+2      	; 0x170 <.do_clear_bss_start>

0000016e <.do_clear_bss_loop>:
 16e:	1d 92       	st	X+, r1

00000170 <.do_clear_bss_start>:
 170:	a5 31       	cpi	r26, 0x15	; 21
 172:	b1 07       	cpc	r27, r17
 174:	e1 f7       	brne	.-8      	; 0x16e <.do_clear_bss_loop>
 176:	fb d0       	rcall	.+502    	; 0x36e <main>
 178:	ab c5       	rjmp	.+2902   	; 0xcd0 <_exit>

0000017a <__bad_interrupt>:
 17a:	42 cf       	rjmp	.-380    	; 0x0 <__vectors>

0000017c <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
 17c:	8b b1       	in	r24, 0x0b	; 11
 17e:	8f 70       	andi	r24, 0x0F	; 15
 180:	80 6a       	ori	r24, 0xA0	; 160
 182:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
 184:	08 95       	ret

00000186 <EVENT_USB_Device_Disconnect>:
 186:	8b b1       	in	r24, 0x0b	; 11
 188:	8f 70       	andi	r24, 0x0F	; 15
 18a:	80 61       	ori	r24, 0x10	; 16
 18c:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
 18e:	08 95       	ret

00000190 <ProcessGenericHIDReport>:
/** Function to process the lest received report from the host.
 *
 *  \param[in] DataArray  Pointer to a buffer where the last report data is stored
 */
void ProcessGenericHIDReport(uint8_t* DataArray)
{
 190:	ac 01       	movw	r20, r24
 192:	20 e0       	ldi	r18, 0x00	; 0
 194:	30 e0       	ldi	r19, 0x00	; 0
		DataArray is an array holding the last report from the host. This function is called
		each time the host has sent a report to the device.
	*/

	for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
	  LastReceived[i] = DataArray[i];
 196:	f9 01       	movw	r30, r18
 198:	e0 50       	subi	r30, 0x00	; 0
 19a:	ff 4f       	sbci	r31, 0xFF	; 255
 19c:	da 01       	movw	r26, r20
 19e:	a2 0f       	add	r26, r18
 1a0:	b3 1f       	adc	r27, r19
 1a2:	8c 91       	ld	r24, X
 1a4:	80 83       	st	Z, r24
 1a6:	2f 5f       	subi	r18, 0xFF	; 255
 1a8:	3f 4f       	sbci	r19, 0xFF	; 255
		This is where you need to process the reports being sent from the host to the device.
		DataArray is an array holding the last report from the host. This function is called
		each time the host has sent a report to the device.
	*/

	for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
 1aa:	28 30       	cpi	r18, 0x08	; 8
 1ac:	31 05       	cpc	r19, r1
 1ae:	99 f7       	brne	.-26     	; 0x196 <ProcessGenericHIDReport+0x6>
	  LastReceived[i] = DataArray[i];
}
 1b0:	08 95       	ret

000001b2 <CreateGenericHIDReport>:
/** Function to create the next report to send back to the host at the next reporting interval.
 *
 *  \param[out] DataArray  Pointer to a buffer where the next report data should be stored
 */
void CreateGenericHIDReport(uint8_t* DataArray)
{
 1b2:	ac 01       	movw	r20, r24
 1b4:	20 e0       	ldi	r18, 0x00	; 0
 1b6:	30 e0       	ldi	r19, 0x00	; 0
		function is called each time the host is ready to accept a new report. DataArray is
		an array to hold the report to the host.
	*/

	for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
	  DataArray[i] = LastReceived[i];
 1b8:	fa 01       	movw	r30, r20
 1ba:	e2 0f       	add	r30, r18
 1bc:	f3 1f       	adc	r31, r19
 1be:	d9 01       	movw	r26, r18
 1c0:	a0 50       	subi	r26, 0x00	; 0
 1c2:	bf 4f       	sbci	r27, 0xFF	; 255
 1c4:	8c 91       	ld	r24, X
 1c6:	80 83       	st	Z, r24
 1c8:	2f 5f       	subi	r18, 0xFF	; 255
 1ca:	3f 4f       	sbci	r19, 0xFF	; 255
		This is where you need to create reports to be sent to the host from the device. This
		function is called each time the host is ready to accept a new report. DataArray is
		an array to hold the report to the host.
	*/

	for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
 1cc:	28 30       	cpi	r18, 0x08	; 8
 1ce:	31 05       	cpc	r19, r1
 1d0:	99 f7       	brne	.-26     	; 0x1b8 <CreateGenericHIDReport+0x6>
	  DataArray[i] = LastReceived[i];
}
 1d2:	08 95       	ret

000001d4 <HID_Task>:

void HID_Task(void)
{
 1d4:	0f 93       	push	r16
 1d6:	1f 93       	push	r17
 1d8:	df 93       	push	r29
 1da:	cf 93       	push	r28
 1dc:	cd b7       	in	r28, 0x3d	; 61
 1de:	de b7       	in	r29, 0x3e	; 62
 1e0:	28 97       	sbiw	r28, 0x08	; 8
 1e2:	0f b6       	in	r0, 0x3f	; 63
 1e4:	f8 94       	cli
 1e6:	de bf       	out	0x3e, r29	; 62
 1e8:	0f be       	out	0x3f, r0	; 63
 1ea:	cd bf       	out	0x3d, r28	; 61
	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
 1ec:	80 91 0c 01 	lds	r24, 0x010C
 1f0:	84 30       	cpi	r24, 0x04	; 4
 1f2:	71 f5       	brne	.+92     	; 0x250 <HID_Task+0x7c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 1f4:	82 e0       	ldi	r24, 0x02	; 2
 1f6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 1fa:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(GENERIC_OUT_EPNUM);

	/* Check to see if a packet has been sent from the host */
	if (Endpoint_IsOUTReceived())
 1fe:	82 ff       	sbrs	r24, 2
 200:	12 c0       	rjmp	.+36     	; 0x226 <HID_Task+0x52>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
 202:	80 91 e8 00 	lds	r24, 0x00E8
	{
		/* Check to see if the packet contains data */
		if (Endpoint_IsReadWriteAllowed())
 206:	85 ff       	sbrs	r24, 5
 208:	09 c0       	rjmp	.+18     	; 0x21c <HID_Task+0x48>
		{
			/* Create a temporary buffer to hold the read in report from the host */
			uint8_t GenericData[GENERIC_REPORT_SIZE];

			/* Read Generic Report Data */
			Endpoint_Read_Stream_LE(&GenericData, sizeof(GenericData));
 20a:	8e 01       	movw	r16, r28
 20c:	0f 5f       	subi	r16, 0xFF	; 255
 20e:	1f 4f       	sbci	r17, 0xFF	; 255
 210:	c8 01       	movw	r24, r16
 212:	68 e0       	ldi	r22, 0x08	; 8
 214:	70 e0       	ldi	r23, 0x00	; 0
 216:	ef d4       	rcall	.+2526   	; 0xbf6 <Endpoint_Read_Stream_LE>

			/* Process Generic Report Data */
			ProcessGenericHIDReport(GenericData);
 218:	c8 01       	movw	r24, r16
 21a:	ba df       	rcall	.-140    	; 0x190 <ProcessGenericHIDReport>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 21c:	80 91 e8 00 	lds	r24, 0x00E8
 220:	8b 77       	andi	r24, 0x7B	; 123
 222:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 226:	81 e0       	ldi	r24, 0x01	; 1
 228:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 22c:	80 91 e8 00 	lds	r24, 0x00E8
	}

	Endpoint_SelectEndpoint(GENERIC_IN_EPNUM);

	/* Check to see if the host is ready to accept another packet */
	if (Endpoint_IsINReady())
 230:	80 ff       	sbrs	r24, 0
 232:	0e c0       	rjmp	.+28     	; 0x250 <HID_Task+0x7c>
	{
		/* Create a temporary buffer to hold the report to send to the host */
		uint8_t GenericData[GENERIC_REPORT_SIZE];

		/* Create Generic Report Data */
		CreateGenericHIDReport(GenericData);
 234:	8e 01       	movw	r16, r28
 236:	0f 5f       	subi	r16, 0xFF	; 255
 238:	1f 4f       	sbci	r17, 0xFF	; 255
 23a:	c8 01       	movw	r24, r16
 23c:	ba df       	rcall	.-140    	; 0x1b2 <CreateGenericHIDReport>

		/* Write Generic Report Data */
		Endpoint_Write_Stream_LE(&GenericData, sizeof(GenericData));
 23e:	c8 01       	movw	r24, r16
 240:	68 e0       	ldi	r22, 0x08	; 8
 242:	70 e0       	ldi	r23, 0x00	; 0
 244:	05 d5       	rcall	.+2570   	; 0xc50 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 246:	80 91 e8 00 	lds	r24, 0x00E8
 24a:	8e 77       	andi	r24, 0x7E	; 126
 24c:	80 93 e8 00 	sts	0x00E8, r24

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();
	}
}
 250:	28 96       	adiw	r28, 0x08	; 8
 252:	0f b6       	in	r0, 0x3f	; 63
 254:	f8 94       	cli
 256:	de bf       	out	0x3e, r29	; 62
 258:	0f be       	out	0x3f, r0	; 63
 25a:	cd bf       	out	0x3d, r28	; 61
 25c:	cf 91       	pop	r28
 25e:	df 91       	pop	r29
 260:	1f 91       	pop	r17
 262:	0f 91       	pop	r16
 264:	08 95       	ret

00000266 <EVENT_USB_Device_ControlRequest>:
/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to
 *  the device from the USB host before passing along unhandled control requests to the library for processing
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
 266:	0f 93       	push	r16
 268:	1f 93       	push	r17
 26a:	df 93       	push	r29
 26c:	cf 93       	push	r28
 26e:	cd b7       	in	r28, 0x3d	; 61
 270:	de b7       	in	r29, 0x3e	; 62
 272:	28 97       	sbiw	r28, 0x08	; 8
 274:	0f b6       	in	r0, 0x3f	; 63
 276:	f8 94       	cli
 278:	de bf       	out	0x3e, r29	; 62
 27a:	0f be       	out	0x3f, r0	; 63
 27c:	cd bf       	out	0x3d, r28	; 61
	/* Handle HID Class specific requests */
	switch (USB_ControlRequest.bRequest)
 27e:	80 91 0e 01 	lds	r24, 0x010E
 282:	81 30       	cpi	r24, 0x01	; 1
 284:	19 f0       	breq	.+6      	; 0x28c <EVENT_USB_Device_ControlRequest+0x26>
 286:	89 30       	cpi	r24, 0x09	; 9
 288:	81 f5       	brne	.+96     	; 0x2ea <EVENT_USB_Device_ControlRequest+0x84>
 28a:	18 c0       	rjmp	.+48     	; 0x2bc <EVENT_USB_Device_ControlRequest+0x56>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
 28c:	80 91 0d 01 	lds	r24, 0x010D
 290:	81 3a       	cpi	r24, 0xA1	; 161
 292:	59 f5       	brne	.+86     	; 0x2ea <EVENT_USB_Device_ControlRequest+0x84>
			{
				uint8_t GenericData[GENERIC_REPORT_SIZE];
				CreateGenericHIDReport(GenericData);
 294:	8e 01       	movw	r16, r28
 296:	0f 5f       	subi	r16, 0xFF	; 255
 298:	1f 4f       	sbci	r17, 0xFF	; 255
 29a:	c8 01       	movw	r24, r16
 29c:	8a df       	rcall	.-236    	; 0x1b2 <CreateGenericHIDReport>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 29e:	80 91 e8 00 	lds	r24, 0x00E8
 2a2:	87 7f       	andi	r24, 0xF7	; 247
 2a4:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_ClearSETUP();

				/* Write the report data to the control endpoint */
				Endpoint_Write_Control_Stream_LE(&GenericData, sizeof(GenericData));
 2a8:	c8 01       	movw	r24, r16
 2aa:	68 e0       	ldi	r22, 0x08	; 8
 2ac:	70 e0       	ldi	r23, 0x00	; 0
 2ae:	a4 d3       	rcall	.+1864   	; 0x9f8 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 2b0:	80 91 e8 00 	lds	r24, 0x00E8
 2b4:	8b 77       	andi	r24, 0x7B	; 123
 2b6:	80 93 e8 00 	sts	0x00E8, r24
 2ba:	17 c0       	rjmp	.+46     	; 0x2ea <EVENT_USB_Device_ControlRequest+0x84>
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
 2bc:	80 91 0d 01 	lds	r24, 0x010D
 2c0:	81 32       	cpi	r24, 0x21	; 33
 2c2:	99 f4       	brne	.+38     	; 0x2ea <EVENT_USB_Device_ControlRequest+0x84>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 2c4:	80 91 e8 00 	lds	r24, 0x00E8
 2c8:	87 7f       	andi	r24, 0xF7	; 247
 2ca:	80 93 e8 00 	sts	0x00E8, r24
				uint8_t GenericData[GENERIC_REPORT_SIZE];

				Endpoint_ClearSETUP();

				/* Read the report data from the control endpoint */
				Endpoint_Read_Control_Stream_LE(&GenericData, sizeof(GenericData));
 2ce:	8e 01       	movw	r16, r28
 2d0:	0f 5f       	subi	r16, 0xFF	; 255
 2d2:	1f 4f       	sbci	r17, 0xFF	; 255
 2d4:	c8 01       	movw	r24, r16
 2d6:	68 e0       	ldi	r22, 0x08	; 8
 2d8:	70 e0       	ldi	r23, 0x00	; 0
 2da:	4c d4       	rcall	.+2200   	; 0xb74 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 2dc:	80 91 e8 00 	lds	r24, 0x00E8
 2e0:	8b 77       	andi	r24, 0x7B	; 123
 2e2:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				ProcessGenericHIDReport(GenericData);
 2e6:	c8 01       	movw	r24, r16
 2e8:	53 df       	rcall	.-346    	; 0x190 <ProcessGenericHIDReport>
			}

			break;
	}
}
 2ea:	28 96       	adiw	r28, 0x08	; 8
 2ec:	0f b6       	in	r0, 0x3f	; 63
 2ee:	f8 94       	cli
 2f0:	de bf       	out	0x3e, r29	; 62
 2f2:	0f be       	out	0x3f, r0	; 63
 2f4:	cd bf       	out	0x3d, r28	; 61
 2f6:	cf 91       	pop	r28
 2f8:	df 91       	pop	r29
 2fa:	1f 91       	pop	r17
 2fc:	0f 91       	pop	r16
 2fe:	08 95       	ret

00000300 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the generic HID device endpoints.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
 300:	0f 93       	push	r16
 302:	1f 93       	push	r17
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
 304:	81 e0       	ldi	r24, 0x01	; 1
 306:	61 ec       	ldi	r22, 0xC1	; 193
 308:	42 e0       	ldi	r20, 0x02	; 2
 30a:	7a d0       	rcall	.+244    	; 0x400 <Endpoint_ConfigureEndpoint_Prv>
 30c:	08 2f       	mov	r16, r24
	                                            GENERIC_EPSIZE, ENDPOINT_BANK_SINGLE);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(GENERIC_OUT_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_OUT,
	                                            GENERIC_EPSIZE, ENDPOINT_BANK_SINGLE);

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
 30e:	82 e0       	ldi	r24, 0x02	; 2
 310:	60 ec       	ldi	r22, 0xC0	; 192
 312:	42 e0       	ldi	r20, 0x02	; 2
 314:	75 d0       	rcall	.+234    	; 0x400 <Endpoint_ConfigureEndpoint_Prv>
 316:	10 e0       	ldi	r17, 0x00	; 0
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	08 23       	and	r16, r24
 31c:	19 23       	and	r17, r25
 31e:	00 ff       	sbrs	r16, 0
 320:	02 c0       	rjmp	.+4      	; 0x326 <EVENT_USB_Device_ConfigurationChanged+0x26>
 322:	90 e6       	ldi	r25, 0x60	; 96
 324:	01 c0       	rjmp	.+2      	; 0x328 <EVENT_USB_Device_ConfigurationChanged+0x28>
 326:	90 e9       	ldi	r25, 0x90	; 144
 328:	8b b1       	in	r24, 0x0b	; 11
 32a:	8f 70       	andi	r24, 0x0F	; 15
 32c:	98 2b       	or	r25, r24
 32e:	9b b9       	out	0x0b, r25	; 11
}
 330:	1f 91       	pop	r17
 332:	0f 91       	pop	r16
 334:	08 95       	ret

00000336 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
 336:	84 b7       	in	r24, 0x34	; 52
 338:	87 7f       	andi	r24, 0xF7	; 247
 33a:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
 33c:	88 e1       	ldi	r24, 0x18	; 24
 33e:	0f b6       	in	r0, 0x3f	; 63
 340:	f8 94       	cli
 342:	80 93 60 00 	sts	0x0060, r24
 346:	10 92 60 00 	sts	0x0060, r1
 34a:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
 34c:	80 e0       	ldi	r24, 0x00	; 0
 34e:	90 e0       	ldi	r25, 0x00	; 0
 350:	20 e8       	ldi	r18, 0x80	; 128
 352:	0f b6       	in	r0, 0x3f	; 63
 354:	f8 94       	cli
 356:	20 93 61 00 	sts	0x0061, r18
 35a:	80 93 61 00 	sts	0x0061, r24
 35e:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
 360:	8a b1       	in	r24, 0x0a	; 10
 362:	80 6f       	ori	r24, 0xF0	; 240
 364:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
 366:	8b b1       	in	r24, 0x0b	; 11
 368:	8f 70       	andi	r24, 0x0F	; 15
 36a:	8b b9       	out	0x0b, r24	; 11

	/* Hardware Initialization */
	LEDs_Init();
	USB_Init();
}
 36c:	fc c0       	rjmp	.+504    	; 0x566 <USB_Init>

0000036e <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
 36e:	e3 df       	rcall	.-58     	; 0x336 <SetupHardware>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
 370:	8b b1       	in	r24, 0x0b	; 11
 372:	8f 70       	andi	r24, 0x0F	; 15
 374:	80 61       	ori	r24, 0x10	; 16
 376:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
 378:	78 94       	sei

	for (;;)
	{
		HID_Task();
 37a:	2c df       	rcall	.-424    	; 0x1d4 <HID_Task>
		USB_USBTask();
 37c:	96 d4       	rcall	.+2348   	; 0xcaa <USB_USBTask>
 37e:	fd cf       	rjmp	.-6      	; 0x37a <main+0xc>

00000380 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
 380:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
 382:	93 30       	cpi	r25, 0x03	; 3
 384:	b1 f0       	breq	.+44     	; 0x3b2 <CALLBACK_USB_GetDescriptor+0x32>
 386:	94 30       	cpi	r25, 0x04	; 4
 388:	28 f4       	brcc	.+10     	; 0x394 <CALLBACK_USB_GetDescriptor+0x14>
 38a:	91 30       	cpi	r25, 0x01	; 1
 38c:	41 f0       	breq	.+16     	; 0x39e <CALLBACK_USB_GetDescriptor+0x1e>
 38e:	92 30       	cpi	r25, 0x02	; 2
 390:	79 f5       	brne	.+94     	; 0x3f0 <CALLBACK_USB_GetDescriptor+0x70>
 392:	0a c0       	rjmp	.+20     	; 0x3a8 <CALLBACK_USB_GetDescriptor+0x28>
 394:	91 32       	cpi	r25, 0x21	; 33
 396:	11 f1       	breq	.+68     	; 0x3dc <CALLBACK_USB_GetDescriptor+0x5c>
 398:	92 32       	cpi	r25, 0x22	; 34
 39a:	51 f5       	brne	.+84     	; 0x3f0 <CALLBACK_USB_GetDescriptor+0x70>
 39c:	24 c0       	rjmp	.+72     	; 0x3e6 <CALLBACK_USB_GetDescriptor+0x66>
 39e:	e8 eb       	ldi	r30, 0xB8	; 184
 3a0:	f0 e0       	ldi	r31, 0x00	; 0
 3a2:	22 e1       	ldi	r18, 0x12	; 18
 3a4:	30 e0       	ldi	r19, 0x00	; 0
 3a6:	28 c0       	rjmp	.+80     	; 0x3f8 <CALLBACK_USB_GetDescriptor+0x78>
 3a8:	ea ec       	ldi	r30, 0xCA	; 202
 3aa:	f0 e0       	ldi	r31, 0x00	; 0
 3ac:	29 e2       	ldi	r18, 0x29	; 41
 3ae:	30 e0       	ldi	r19, 0x00	; 0
 3b0:	23 c0       	rjmp	.+70     	; 0x3f8 <CALLBACK_USB_GetDescriptor+0x78>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
 3b2:	81 30       	cpi	r24, 0x01	; 1
 3b4:	49 f0       	breq	.+18     	; 0x3c8 <CALLBACK_USB_GetDescriptor+0x48>
 3b6:	81 30       	cpi	r24, 0x01	; 1
 3b8:	18 f0       	brcs	.+6      	; 0x3c0 <CALLBACK_USB_GetDescriptor+0x40>
 3ba:	82 30       	cpi	r24, 0x02	; 2
 3bc:	c9 f4       	brne	.+50     	; 0x3f0 <CALLBACK_USB_GetDescriptor+0x70>
 3be:	0a c0       	rjmp	.+20     	; 0x3d4 <CALLBACK_USB_GetDescriptor+0x54>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
 3c0:	e3 ef       	ldi	r30, 0xF3	; 243
 3c2:	f0 e0       	ldi	r31, 0x00	; 0
 3c4:	84 91       	lpm	r24, Z+
 3c6:	03 c0       	rjmp	.+6      	; 0x3ce <CALLBACK_USB_GetDescriptor+0x4e>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 3c8:	e7 ef       	ldi	r30, 0xF7	; 247
 3ca:	f0 e0       	ldi	r31, 0x00	; 0
 3cc:	84 91       	lpm	r24, Z+
 3ce:	28 2f       	mov	r18, r24
 3d0:	30 e0       	ldi	r19, 0x00	; 0
 3d2:	12 c0       	rjmp	.+36     	; 0x3f8 <CALLBACK_USB_GetDescriptor+0x78>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
 3d4:	e1 e1       	ldi	r30, 0x11	; 17
 3d6:	f1 e0       	ldi	r31, 0x01	; 1
 3d8:	84 91       	lpm	r24, Z+
 3da:	f9 cf       	rjmp	.-14     	; 0x3ce <CALLBACK_USB_GetDescriptor+0x4e>
 3dc:	ec ed       	ldi	r30, 0xDC	; 220
 3de:	f0 e0       	ldi	r31, 0x00	; 0
 3e0:	29 e0       	ldi	r18, 0x09	; 9
 3e2:	30 e0       	ldi	r19, 0x00	; 0
 3e4:	09 c0       	rjmp	.+18     	; 0x3f8 <CALLBACK_USB_GetDescriptor+0x78>

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
 3e6:	e8 e9       	ldi	r30, 0x98	; 152
 3e8:	f0 e0       	ldi	r31, 0x00	; 0
 3ea:	20 e2       	ldi	r18, 0x20	; 32
 3ec:	30 e0       	ldi	r19, 0x00	; 0
 3ee:	04 c0       	rjmp	.+8      	; 0x3f8 <CALLBACK_USB_GetDescriptor+0x78>
 3f0:	e0 e0       	ldi	r30, 0x00	; 0
 3f2:	f0 e0       	ldi	r31, 0x00	; 0
 3f4:	20 e0       	ldi	r18, 0x00	; 0
 3f6:	30 e0       	ldi	r19, 0x00	; 0
			Address = &GenericReport;
			Size    = sizeof(GenericReport);
			break;
	}

	*DescriptorAddress = Address;
 3f8:	ed 93       	st	X+, r30
 3fa:	fc 93       	st	X, r31
	return Size;
}
 3fc:	c9 01       	movw	r24, r18
 3fe:	08 95       	ret

00000400 <Endpoint_ConfigureEndpoint_Prv>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 400:	80 93 e9 00 	sts	0x00E9, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
 404:	80 91 eb 00 	lds	r24, 0x00EB
 408:	81 60       	ori	r24, 0x01	; 1
 40a:	80 93 eb 00 	sts	0x00EB, r24
                                    const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
 40e:	10 92 ed 00 	sts	0x00ED, r1
	UECFG0X = UECFG0XData;
 412:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
 416:	40 93 ed 00 	sts	0x00ED, r20
			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
 41a:	80 91 ee 00 	lds	r24, 0x00EE

	return Endpoint_IsConfigured();
}
 41e:	88 1f       	adc	r24, r24
 420:	88 27       	eor	r24, r24
 422:	88 1f       	adc	r24, r24
 424:	08 95       	ret

00000426 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
 426:	80 91 0d 01 	lds	r24, 0x010D
 42a:	88 23       	and	r24, r24
 42c:	9c f4       	brge	.+38     	; 0x454 <Endpoint_ClearStatusStage+0x2e>
 42e:	04 c0       	rjmp	.+8      	; 0x438 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
 430:	80 91 0c 01 	lds	r24, 0x010C
 434:	88 23       	and	r24, r24
 436:	b9 f0       	breq	.+46     	; 0x466 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 438:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
 43c:	82 ff       	sbrs	r24, 2
 43e:	f8 cf       	rjmp	.-16     	; 0x430 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 440:	80 91 e8 00 	lds	r24, 0x00E8
 444:	8b 77       	andi	r24, 0x7B	; 123
 446:	80 93 e8 00 	sts	0x00E8, r24
 44a:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
 44c:	80 91 0c 01 	lds	r24, 0x010C
 450:	88 23       	and	r24, r24
 452:	49 f0       	breq	.+18     	; 0x466 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 454:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
 458:	80 ff       	sbrs	r24, 0
 45a:	f8 cf       	rjmp	.-16     	; 0x44c <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 45c:	80 91 e8 00 	lds	r24, 0x00E8
 460:	8e 77       	andi	r24, 0x7E	; 126
 462:	80 93 e8 00 	sts	0x00E8, r24
 466:	08 95       	ret

00000468 <Endpoint_WaitUntilReady>:
			/** Returns the current USB frame number, when in device mode. Every millisecond the USB bus is active (i.e. enumerated to a host)
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
 468:	40 91 e4 00 	lds	r20, 0x00E4
 46c:	50 91 e5 00 	lds	r21, 0x00E5
 470:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
 472:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
 476:	80 ff       	sbrs	r24, 0
 478:	05 c0       	rjmp	.+10     	; 0x484 <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 47a:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
 47e:	80 ff       	sbrs	r24, 0
 480:	05 c0       	rjmp	.+10     	; 0x48c <Endpoint_WaitUntilReady+0x24>
 482:	22 c0       	rjmp	.+68     	; 0x4c8 <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 484:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
 488:	82 fd       	sbrc	r24, 2
 48a:	1e c0       	rjmp	.+60     	; 0x4c8 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 48c:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 490:	88 23       	and	r24, r24
 492:	11 f4       	brne	.+4      	; 0x498 <Endpoint_WaitUntilReady+0x30>
 494:	82 e0       	ldi	r24, 0x02	; 2
 496:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 498:	85 30       	cpi	r24, 0x05	; 5
 49a:	11 f4       	brne	.+4      	; 0x4a0 <Endpoint_WaitUntilReady+0x38>
 49c:	83 e0       	ldi	r24, 0x03	; 3
 49e:	08 95       	ret
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
 4a0:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
 4a4:	85 ff       	sbrs	r24, 5
 4a6:	02 c0       	rjmp	.+4      	; 0x4ac <Endpoint_WaitUntilReady+0x44>
 4a8:	81 e0       	ldi	r24, 0x01	; 1
 4aa:	08 95       	ret
 4ac:	80 91 e4 00 	lds	r24, 0x00E4
 4b0:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
 4b4:	84 17       	cp	r24, r20
 4b6:	95 07       	cpc	r25, r21
 4b8:	e1 f2       	breq	.-72     	; 0x472 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
 4ba:	22 23       	and	r18, r18
 4bc:	11 f4       	brne	.+4      	; 0x4c2 <Endpoint_WaitUntilReady+0x5a>
 4be:	84 e0       	ldi	r24, 0x04	; 4
 4c0:	08 95       	ret
 4c2:	21 50       	subi	r18, 0x01	; 1
 4c4:	ac 01       	movw	r20, r24
 4c6:	d5 cf       	rjmp	.-86     	; 0x472 <Endpoint_WaitUntilReady+0xa>
 4c8:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
 4ca:	08 95       	ret

000004cc <USB_ResetInterface>:
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
 4cc:	55 d0       	rcall	.+170    	; 0x578 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
 4ce:	5c d0       	rcall	.+184    	; 0x588 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
 4d0:	80 91 d8 00 	lds	r24, 0x00D8

				USBCON = (Temp & ~(1 << USBE));
 4d4:	98 2f       	mov	r25, r24
 4d6:	9f 77       	andi	r25, 0x7F	; 127
 4d8:	90 93 d8 00 	sts	0x00D8, r25
				USBCON = (Temp |  (1 << USBE));
 4dc:	80 68       	ori	r24, 0x80	; 128
 4de:	80 93 d8 00 	sts	0x00D8, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
 4e2:	8c e0       	ldi	r24, 0x0C	; 12
 4e4:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
 4e6:	89 b5       	in	r24, 0x29	; 41
 4e8:	82 60       	ori	r24, 0x02	; 2
 4ea:	89 bd       	out	0x29, r24	; 41
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
 4ec:	09 b4       	in	r0, 0x29	; 41
 4ee:	00 fe       	sbrs	r0, 0
 4f0:	fd cf       	rjmp	.-6      	; 0x4ec <USB_ResetInterface+0x20>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
 4f2:	80 91 d8 00 	lds	r24, 0x00D8
 4f6:	8f 7d       	andi	r24, 0xDF	; 223
 4f8:	80 93 d8 00 	sts	0x00D8, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
 4fc:	80 91 d7 00 	lds	r24, 0x00D7
 500:	80 68       	ori	r24, 0x80	; 128
 502:	80 93 d7 00 	sts	0x00D7, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
 506:	10 92 0c 01 	sts	0x010C, r1
	USB_ConfigurationNumber  = 0;
 50a:	10 92 0a 01 	sts	0x010A, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
 50e:	10 92 09 01 	sts	0x0109, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
 512:	10 92 08 01 	sts	0x0108, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
 516:	80 91 e0 00 	lds	r24, 0x00E0
 51a:	8b 7f       	andi	r24, 0xFB	; 251
 51c:	80 93 e0 00 	sts	0x00E0, r24
	if (USB_Options & USB_DEVICE_OPT_LOWSPEED)
	  USB_Device_SetLowSpeed();
	else
	  USB_Device_SetFullSpeed();

	USB_INT_Enable(USB_INT_VBUS);
 520:	80 91 d8 00 	lds	r24, 0x00D8
 524:	81 60       	ori	r24, 0x01	; 1
 526:	80 93 d8 00 	sts	0x00D8, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
 52a:	80 e0       	ldi	r24, 0x00	; 0
 52c:	60 e0       	ldi	r22, 0x00	; 0
 52e:	42 e0       	ldi	r20, 0x02	; 2
 530:	67 df       	rcall	.-306    	; 0x400 <Endpoint_ConfigureEndpoint_Prv>

	Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
							   ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
							   ENDPOINT_BANK_SINGLE);

	USB_INT_Clear(USB_INT_SUSPI);
 532:	80 91 e1 00 	lds	r24, 0x00E1
 536:	8e 7f       	andi	r24, 0xFE	; 254
 538:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_SUSPI);
 53c:	80 91 e2 00 	lds	r24, 0x00E2
 540:	81 60       	ori	r24, 0x01	; 1
 542:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Enable(USB_INT_EORSTI);
 546:	80 91 e2 00 	lds	r24, 0x00E2
 54a:	88 60       	ori	r24, 0x08	; 8
 54c:	80 93 e2 00 	sts	0x00E2, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
 550:	80 91 e0 00 	lds	r24, 0x00E0
 554:	8e 7f       	andi	r24, 0xFE	; 254
 556:	80 93 e0 00 	sts	0x00E0, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
 55a:	80 91 d8 00 	lds	r24, 0x00D8
 55e:	80 61       	ori	r24, 0x10	; 16
 560:	80 93 d8 00 	sts	0x00D8, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
 564:	08 95       	ret

00000566 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
 566:	e7 ed       	ldi	r30, 0xD7	; 215
 568:	f0 e0       	ldi	r31, 0x00	; 0
 56a:	80 81       	ld	r24, Z
 56c:	81 60       	ori	r24, 0x01	; 1
 56e:	80 83       	st	Z, r24
	{
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
 570:	81 e0       	ldi	r24, 0x01	; 1
 572:	80 93 0b 01 	sts	0x010B, r24

	USB_ResetInterface();
}
 576:	aa cf       	rjmp	.-172    	; 0x4cc <USB_ResetInterface>

00000578 <USB_INT_DisableAllInterrupts>:
#include "USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
 578:	e8 ed       	ldi	r30, 0xD8	; 216
 57a:	f0 e0       	ldi	r31, 0x00	; 0
 57c:	80 81       	ld	r24, Z
 57e:	8c 7f       	andi	r24, 0xFC	; 252
 580:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
 582:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
 586:	08 95       	ret

00000588 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT  = 0;
 588:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
 58c:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
 590:	08 95       	ret

00000592 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
 592:	1f 92       	push	r1
 594:	0f 92       	push	r0
 596:	0f b6       	in	r0, 0x3f	; 63
 598:	0f 92       	push	r0
 59a:	0b b6       	in	r0, 0x3b	; 59
 59c:	0f 92       	push	r0
 59e:	11 24       	eor	r1, r1
 5a0:	2f 93       	push	r18
 5a2:	3f 93       	push	r19
 5a4:	4f 93       	push	r20
 5a6:	5f 93       	push	r21
 5a8:	6f 93       	push	r22
 5aa:	7f 93       	push	r23
 5ac:	8f 93       	push	r24
 5ae:	9f 93       	push	r25
 5b0:	af 93       	push	r26
 5b2:	bf 93       	push	r27
 5b4:	ef 93       	push	r30
 5b6:	ff 93       	push	r31
	#if defined(USB_CAN_BE_DEVICE)
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUS) && USB_INT_IsEnabled(USB_INT_VBUS))
 5b8:	80 91 da 00 	lds	r24, 0x00DA
 5bc:	80 ff       	sbrs	r24, 0
 5be:	15 c0       	rjmp	.+42     	; 0x5ea <__vector_10+0x58>
 5c0:	80 91 d8 00 	lds	r24, 0x00D8
 5c4:	80 ff       	sbrs	r24, 0
 5c6:	11 c0       	rjmp	.+34     	; 0x5ea <__vector_10+0x58>
	{
		USB_INT_Clear(USB_INT_VBUS);
 5c8:	80 91 da 00 	lds	r24, 0x00DA
 5cc:	8e 7f       	andi	r24, 0xFE	; 254
 5ce:	80 93 da 00 	sts	0x00DA, r24
				 *  \note This function is not available on some AVR models which do not support hardware VBUS monitoring.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
 5d2:	80 91 d9 00 	lds	r24, 0x00D9

		if (USB_VBUS_GetStatus())
 5d6:	80 ff       	sbrs	r24, 0
 5d8:	05 c0       	rjmp	.+10     	; 0x5e4 <__vector_10+0x52>
		{
			USB_DeviceState = DEVICE_STATE_Powered;
 5da:	81 e0       	ldi	r24, 0x01	; 1
 5dc:	80 93 0c 01 	sts	0x010C, r24
			EVENT_USB_Device_Connect();
 5e0:	cd dd       	rcall	.-1126   	; 0x17c <EVENT_USB_Device_Connect>
 5e2:	03 c0       	rjmp	.+6      	; 0x5ea <__vector_10+0x58>
		}
		else
		{
			USB_DeviceState = DEVICE_STATE_Unattached;
 5e4:	10 92 0c 01 	sts	0x010C, r1
			EVENT_USB_Device_Disconnect();
 5e8:	ce dd       	rcall	.-1124   	; 0x186 <EVENT_USB_Device_Disconnect>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
 5ea:	80 91 e1 00 	lds	r24, 0x00E1
 5ee:	80 ff       	sbrs	r24, 0
 5f0:	1d c0       	rjmp	.+58     	; 0x62c <__vector_10+0x9a>
 5f2:	80 91 e2 00 	lds	r24, 0x00E2
 5f6:	80 ff       	sbrs	r24, 0
 5f8:	19 c0       	rjmp	.+50     	; 0x62c <__vector_10+0x9a>
	{
		USB_INT_Clear(USB_INT_SUSPI);
 5fa:	80 91 e1 00 	lds	r24, 0x00E1
 5fe:	8e 7f       	andi	r24, 0xFE	; 254
 600:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPI);
 604:	80 91 e2 00 	lds	r24, 0x00E2
 608:	8e 7f       	andi	r24, 0xFE	; 254
 60a:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
 60e:	80 91 e2 00 	lds	r24, 0x00E2
 612:	80 61       	ori	r24, 0x10	; 16
 614:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
 618:	80 91 d8 00 	lds	r24, 0x00D8
 61c:	80 62       	ori	r24, 0x20	; 32
 61e:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
 622:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
 624:	85 e0       	ldi	r24, 0x05	; 5
 626:	80 93 0c 01 	sts	0x010C, r24
		EVENT_USB_Device_Suspend();
 62a:	e5 d1       	rcall	.+970    	; 0x9f6 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
 62c:	80 91 e1 00 	lds	r24, 0x00E1
 630:	84 ff       	sbrs	r24, 4
 632:	2e c0       	rjmp	.+92     	; 0x690 <__vector_10+0xfe>
 634:	80 91 e2 00 	lds	r24, 0x00E2
 638:	84 ff       	sbrs	r24, 4
 63a:	2a c0       	rjmp	.+84     	; 0x690 <__vector_10+0xfe>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
 63c:	8c e0       	ldi	r24, 0x0C	; 12
 63e:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
 640:	89 b5       	in	r24, 0x29	; 41
 642:	82 60       	ori	r24, 0x02	; 2
 644:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
 646:	09 b4       	in	r0, 0x29	; 41
 648:	00 fe       	sbrs	r0, 0
 64a:	fd cf       	rjmp	.-6      	; 0x646 <__vector_10+0xb4>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
 64c:	80 91 d8 00 	lds	r24, 0x00D8
 650:	8f 7d       	andi	r24, 0xDF	; 223
 652:	80 93 d8 00 	sts	0x00D8, r24
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUPI);
 656:	80 91 e1 00 	lds	r24, 0x00E1
 65a:	8f 7e       	andi	r24, 0xEF	; 239
 65c:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUPI);
 660:	80 91 e2 00 	lds	r24, 0x00E2
 664:	8f 7e       	andi	r24, 0xEF	; 239
 666:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPI);
 66a:	80 91 e2 00 	lds	r24, 0x00E2
 66e:	81 60       	ori	r24, 0x01	; 1
 670:	80 93 e2 00 	sts	0x00E2, r24

		if (USB_ConfigurationNumber)
 674:	80 91 0a 01 	lds	r24, 0x010A
 678:	88 23       	and	r24, r24
 67a:	31 f4       	brne	.+12     	; 0x688 <__vector_10+0xf6>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
 67c:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
 680:	87 fd       	sbrc	r24, 7
 682:	02 c0       	rjmp	.+4      	; 0x688 <__vector_10+0xf6>
 684:	81 e0       	ldi	r24, 0x01	; 1
 686:	01 c0       	rjmp	.+2      	; 0x68a <__vector_10+0xf8>
 688:	84 e0       	ldi	r24, 0x04	; 4
 68a:	80 93 0c 01 	sts	0x010C, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
 68e:	b3 d1       	rcall	.+870    	; 0x9f6 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
 690:	80 91 e1 00 	lds	r24, 0x00E1
 694:	83 ff       	sbrs	r24, 3
 696:	22 c0       	rjmp	.+68     	; 0x6dc <__vector_10+0x14a>
 698:	80 91 e2 00 	lds	r24, 0x00E2
 69c:	83 ff       	sbrs	r24, 3
 69e:	1e c0       	rjmp	.+60     	; 0x6dc <__vector_10+0x14a>
	{
		USB_INT_Clear(USB_INT_EORSTI);
 6a0:	80 91 e1 00 	lds	r24, 0x00E1
 6a4:	87 7f       	andi	r24, 0xF7	; 247
 6a6:	80 93 e1 00 	sts	0x00E1, r24

		USB_DeviceState         = DEVICE_STATE_Default;
 6aa:	82 e0       	ldi	r24, 0x02	; 2
 6ac:	80 93 0c 01 	sts	0x010C, r24
		USB_ConfigurationNumber = 0;
 6b0:	10 92 0a 01 	sts	0x010A, r1

		USB_INT_Clear(USB_INT_SUSPI);
 6b4:	80 91 e1 00 	lds	r24, 0x00E1
 6b8:	8e 7f       	andi	r24, 0xFE	; 254
 6ba:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPI);
 6be:	80 91 e2 00 	lds	r24, 0x00E2
 6c2:	8e 7f       	andi	r24, 0xFE	; 254
 6c4:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
 6c8:	80 91 e2 00 	lds	r24, 0x00E2
 6cc:	80 61       	ori	r24, 0x10	; 16
 6ce:	80 93 e2 00 	sts	0x00E2, r24
 6d2:	80 e0       	ldi	r24, 0x00	; 0
 6d4:	60 e0       	ldi	r22, 0x00	; 0
 6d6:	42 e0       	ldi	r20, 0x02	; 2
 6d8:	93 de       	rcall	.-730    	; 0x400 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
 6da:	8d d1       	rcall	.+794    	; 0x9f6 <USB_Event_Stub>
	}

	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
 6dc:	80 91 e1 00 	lds	r24, 0x00E1
 6e0:	82 ff       	sbrs	r24, 2
 6e2:	0a c0       	rjmp	.+20     	; 0x6f8 <__vector_10+0x166>
 6e4:	80 91 e2 00 	lds	r24, 0x00E2
 6e8:	82 ff       	sbrs	r24, 2
 6ea:	06 c0       	rjmp	.+12     	; 0x6f8 <__vector_10+0x166>
	{
		USB_INT_Clear(USB_INT_SOFI);
 6ec:	80 91 e1 00 	lds	r24, 0x00E1
 6f0:	8b 7f       	andi	r24, 0xFB	; 251
 6f2:	80 93 e1 00 	sts	0x00E1, r24

		EVENT_USB_Device_StartOfFrame();
 6f6:	7f d1       	rcall	.+766    	; 0x9f6 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
 6f8:	ff 91       	pop	r31
 6fa:	ef 91       	pop	r30
 6fc:	bf 91       	pop	r27
 6fe:	af 91       	pop	r26
 700:	9f 91       	pop	r25
 702:	8f 91       	pop	r24
 704:	7f 91       	pop	r23
 706:	6f 91       	pop	r22
 708:	5f 91       	pop	r21
 70a:	4f 91       	pop	r20
 70c:	3f 91       	pop	r19
 70e:	2f 91       	pop	r18
 710:	0f 90       	pop	r0
 712:	0b be       	out	0x3b, r0	; 59
 714:	0f 90       	pop	r0
 716:	0f be       	out	0x3f, r0	; 63
 718:	0f 90       	pop	r0
 71a:	1f 90       	pop	r1
 71c:	18 95       	reti

0000071e <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
 71e:	0f 93       	push	r16
 720:	1f 93       	push	r17
 722:	df 93       	push	r29
 724:	cf 93       	push	r28
 726:	cd b7       	in	r28, 0x3d	; 61
 728:	de b7       	in	r29, 0x3e	; 62
 72a:	ac 97       	sbiw	r28, 0x2c	; 44
 72c:	0f b6       	in	r0, 0x3f	; 63
 72e:	f8 94       	cli
 730:	de bf       	out	0x3e, r29	; 62
 732:	0f be       	out	0x3f, r0	; 63
 734:	cd bf       	out	0x3d, r28	; 61
 736:	ed e0       	ldi	r30, 0x0D	; 13
 738:	f1 e0       	ldi	r31, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 73a:	80 91 f1 00 	lds	r24, 0x00F1
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
 73e:	81 93       	st	Z+, r24

void USB_Device_ProcessControlRequest(void)
{
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
 740:	21 e0       	ldi	r18, 0x01	; 1
 742:	e5 31       	cpi	r30, 0x15	; 21
 744:	f2 07       	cpc	r31, r18
 746:	c9 f7       	brne	.-14     	; 0x73a <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_Byte();

	EVENT_USB_Device_ControlRequest();
 748:	8e dd       	rcall	.-1252   	; 0x266 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 74a:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
 74e:	83 ff       	sbrs	r24, 3
 750:	39 c1       	rjmp	.+626    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
 752:	80 91 0d 01 	lds	r24, 0x010D

		switch (USB_ControlRequest.bRequest)
 756:	30 91 0e 01 	lds	r19, 0x010E
 75a:	35 30       	cpi	r19, 0x05	; 5
 75c:	09 f4       	brne	.+2      	; 0x760 <USB_Device_ProcessControlRequest+0x42>
 75e:	87 c0       	rjmp	.+270    	; 0x86e <USB_Device_ProcessControlRequest+0x150>
 760:	36 30       	cpi	r19, 0x06	; 6
 762:	40 f4       	brcc	.+16     	; 0x774 <USB_Device_ProcessControlRequest+0x56>
 764:	31 30       	cpi	r19, 0x01	; 1
 766:	c9 f1       	breq	.+114    	; 0x7da <USB_Device_ProcessControlRequest+0xbc>
 768:	31 30       	cpi	r19, 0x01	; 1
 76a:	70 f0       	brcs	.+28     	; 0x788 <USB_Device_ProcessControlRequest+0x6a>
 76c:	33 30       	cpi	r19, 0x03	; 3
 76e:	09 f0       	breq	.+2      	; 0x772 <USB_Device_ProcessControlRequest+0x54>
 770:	29 c1       	rjmp	.+594    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
 772:	33 c0       	rjmp	.+102    	; 0x7da <USB_Device_ProcessControlRequest+0xbc>
 774:	38 30       	cpi	r19, 0x08	; 8
 776:	09 f4       	brne	.+2      	; 0x77a <USB_Device_ProcessControlRequest+0x5c>
 778:	f7 c0       	rjmp	.+494    	; 0x968 <USB_Device_ProcessControlRequest+0x24a>
 77a:	39 30       	cpi	r19, 0x09	; 9
 77c:	09 f4       	brne	.+2      	; 0x780 <USB_Device_ProcessControlRequest+0x62>
 77e:	06 c1       	rjmp	.+524    	; 0x98c <USB_Device_ProcessControlRequest+0x26e>
 780:	36 30       	cpi	r19, 0x06	; 6
 782:	09 f0       	breq	.+2      	; 0x786 <USB_Device_ProcessControlRequest+0x68>
 784:	1f c1       	rjmp	.+574    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
 786:	99 c0       	rjmp	.+306    	; 0x8ba <USB_Device_ProcessControlRequest+0x19c>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 788:	80 38       	cpi	r24, 0x80	; 128
 78a:	21 f0       	breq	.+8      	; 0x794 <USB_Device_ProcessControlRequest+0x76>
 78c:	82 38       	cpi	r24, 0x82	; 130
 78e:	09 f0       	breq	.+2      	; 0x792 <USB_Device_ProcessControlRequest+0x74>
 790:	19 c1       	rjmp	.+562    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
 792:	08 c0       	rjmp	.+16     	; 0x7a4 <USB_Device_ProcessControlRequest+0x86>
 794:	90 91 08 01 	lds	r25, 0x0108
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
 798:	80 91 09 01 	lds	r24, 0x0109
 79c:	88 23       	and	r24, r24
 79e:	99 f0       	breq	.+38     	; 0x7c6 <USB_Device_ProcessControlRequest+0xa8>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
 7a0:	92 60       	ori	r25, 0x02	; 2
 7a2:	11 c0       	rjmp	.+34     	; 0x7c6 <USB_Device_ProcessControlRequest+0xa8>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
 7a4:	80 91 11 01 	lds	r24, 0x0111
 7a8:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 7aa:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
 7ae:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
 7b2:	90 e0       	ldi	r25, 0x00	; 0
 7b4:	25 e0       	ldi	r18, 0x05	; 5
 7b6:	96 95       	lsr	r25
 7b8:	87 95       	ror	r24
 7ba:	2a 95       	dec	r18
 7bc:	e1 f7       	brne	.-8      	; 0x7b6 <USB_Device_ProcessControlRequest+0x98>
 7be:	98 2f       	mov	r25, r24
 7c0:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 7c2:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 7c6:	80 91 e8 00 	lds	r24, 0x00E8
 7ca:	87 7f       	andi	r24, 0xF7	; 247
 7cc:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
 7d0:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Word >> 8);
 7d4:	10 92 f1 00 	sts	0x00F1, r1
 7d8:	d2 c0       	rjmp	.+420    	; 0x97e <USB_Device_ProcessControlRequest+0x260>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 7da:	88 23       	and	r24, r24
 7dc:	19 f0       	breq	.+6      	; 0x7e4 <USB_Device_ProcessControlRequest+0xc6>
 7de:	82 30       	cpi	r24, 0x02	; 2
 7e0:	09 f0       	breq	.+2      	; 0x7e4 <USB_Device_ProcessControlRequest+0xc6>
 7e2:	f0 c0       	rjmp	.+480    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
 7e4:	90 e0       	ldi	r25, 0x00	; 0
 7e6:	8f 71       	andi	r24, 0x1F	; 31
 7e8:	90 70       	andi	r25, 0x00	; 0
 7ea:	00 97       	sbiw	r24, 0x00	; 0
 7ec:	21 f0       	breq	.+8      	; 0x7f6 <USB_Device_ProcessControlRequest+0xd8>
 7ee:	02 97       	sbiw	r24, 0x02	; 2
 7f0:	09 f0       	breq	.+2      	; 0x7f4 <USB_Device_ProcessControlRequest+0xd6>
 7f2:	e8 c0       	rjmp	.+464    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
 7f4:	0c c0       	rjmp	.+24     	; 0x80e <USB_Device_ProcessControlRequest+0xf0>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
 7f6:	80 91 0f 01 	lds	r24, 0x010F
 7fa:	81 30       	cpi	r24, 0x01	; 1
 7fc:	09 f0       	breq	.+2      	; 0x800 <USB_Device_ProcessControlRequest+0xe2>
 7fe:	e2 c0       	rjmp	.+452    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
 800:	10 92 09 01 	sts	0x0109, r1
 804:	33 30       	cpi	r19, 0x03	; 3
 806:	69 f5       	brne	.+90     	; 0x862 <USB_Device_ProcessControlRequest+0x144>
 808:	80 93 09 01 	sts	0x0109, r24
 80c:	2a c0       	rjmp	.+84     	; 0x862 <USB_Device_ProcessControlRequest+0x144>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
 80e:	80 91 0f 01 	lds	r24, 0x010F
 812:	88 23       	and	r24, r24
 814:	31 f5       	brne	.+76     	; 0x862 <USB_Device_ProcessControlRequest+0x144>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
 816:	20 91 11 01 	lds	r18, 0x0111
 81a:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
 81c:	09 f4       	brne	.+2      	; 0x820 <USB_Device_ProcessControlRequest+0x102>
 81e:	d2 c0       	rjmp	.+420    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 820:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
 824:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
 828:	80 ff       	sbrs	r24, 0
 82a:	1b c0       	rjmp	.+54     	; 0x862 <USB_Device_ProcessControlRequest+0x144>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
 82c:	33 30       	cpi	r19, 0x03	; 3
 82e:	21 f4       	brne	.+8      	; 0x838 <USB_Device_ProcessControlRequest+0x11a>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
 830:	80 91 eb 00 	lds	r24, 0x00EB
 834:	80 62       	ori	r24, 0x20	; 32
 836:	13 c0       	rjmp	.+38     	; 0x85e <USB_Device_ProcessControlRequest+0x140>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
 838:	80 91 eb 00 	lds	r24, 0x00EB
 83c:	80 61       	ori	r24, 0x10	; 16
 83e:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
 842:	81 e0       	ldi	r24, 0x01	; 1
 844:	90 e0       	ldi	r25, 0x00	; 0
 846:	02 c0       	rjmp	.+4      	; 0x84c <USB_Device_ProcessControlRequest+0x12e>
 848:	88 0f       	add	r24, r24
 84a:	99 1f       	adc	r25, r25
 84c:	2a 95       	dec	r18
 84e:	e2 f7       	brpl	.-8      	; 0x848 <USB_Device_ProcessControlRequest+0x12a>
 850:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
 854:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
 858:	80 91 eb 00 	lds	r24, 0x00EB
 85c:	88 60       	ori	r24, 0x08	; 8
 85e:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 862:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 866:	80 91 e8 00 	lds	r24, 0x00E8
 86a:	87 7f       	andi	r24, 0xF7	; 247
 86c:	8b c0       	rjmp	.+278    	; 0x984 <USB_Device_ProcessControlRequest+0x266>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 86e:	88 23       	and	r24, r24
 870:	09 f0       	breq	.+2      	; 0x874 <USB_Device_ProcessControlRequest+0x156>
 872:	a8 c0       	rjmp	.+336    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
 874:	10 91 0f 01 	lds	r17, 0x010F
 878:	1f 77       	andi	r17, 0x7F	; 127

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 87a:	0f b7       	in	r16, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 87c:	f8 94       	cli
 87e:	80 91 e8 00 	lds	r24, 0x00E8
 882:	87 7f       	andi	r24, 0xF7	; 247
 884:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_ClearSETUP();

		Endpoint_ClearStatusStage();
 888:	ce dd       	rcall	.-1124   	; 0x426 <Endpoint_ClearStatusStage>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 88a:	80 91 e8 00 	lds	r24, 0x00E8

		while (!(Endpoint_IsINReady()));
 88e:	80 ff       	sbrs	r24, 0
 890:	fc cf       	rjmp	.-8      	; 0x88a <USB_Device_ProcessControlRequest+0x16c>

		USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
 892:	11 23       	and	r17, r17
 894:	11 f4       	brne	.+4      	; 0x89a <USB_Device_ProcessControlRequest+0x17c>
 896:	82 e0       	ldi	r24, 0x02	; 2
 898:	01 c0       	rjmp	.+2      	; 0x89c <USB_Device_ProcessControlRequest+0x17e>
 89a:	83 e0       	ldi	r24, 0x03	; 3
 89c:	80 93 0c 01 	sts	0x010C, r24
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR  = ((UDADDR & (1 << ADDEN)) | (Address & 0x7F));
 8a0:	80 91 e3 00 	lds	r24, 0x00E3
 8a4:	80 78       	andi	r24, 0x80	; 128
 8a6:	18 2b       	or	r17, r24
 8a8:	10 93 e3 00 	sts	0x00E3, r17
				UDADDR |= (1 << ADDEN);
 8ac:	80 91 e3 00 	lds	r24, 0x00E3
 8b0:	80 68       	ori	r24, 0x80	; 128
 8b2:	80 93 e3 00 	sts	0x00E3, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 8b6:	0f bf       	out	0x3f, r16	; 63
    __asm__ volatile ("" ::: "memory");
 8b8:	85 c0       	rjmp	.+266    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 8ba:	80 58       	subi	r24, 0x80	; 128
 8bc:	82 30       	cpi	r24, 0x02	; 2
 8be:	08 f0       	brcs	.+2      	; 0x8c2 <USB_Device_ProcessControlRequest+0x1a4>
 8c0:	81 c0       	rjmp	.+258    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
	#if !defined(USE_FLASH_DESCRIPTORS) && !defined(USE_EEPROM_DESCRIPTORS) && !defined(USE_RAM_DESCRIPTORS)
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
 8c2:	80 91 0f 01 	lds	r24, 0x010F
 8c6:	90 91 10 01 	lds	r25, 0x0110
 8ca:	23 e0       	ldi	r18, 0x03	; 3
 8cc:	8c 3d       	cpi	r24, 0xDC	; 220
 8ce:	92 07       	cpc	r25, r18
 8d0:	99 f5       	brne	.+102    	; 0x938 <USB_Device_ProcessControlRequest+0x21a>
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 8d2:	7f b7       	in	r23, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 8d4:	f8 94       	cli
 8d6:	de 01       	movw	r26, r28
 8d8:	15 96       	adiw	r26, 0x05	; 5
 8da:	6e e0       	ldi	r22, 0x0E	; 14
 8dc:	40 e0       	ldi	r20, 0x00	; 0
 8de:	50 e0       	ldi	r21, 0x00	; 0
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
		{
			uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
 8e0:	11 e2       	ldi	r17, 0x21	; 33
 8e2:	e6 2f       	mov	r30, r22
 8e4:	f0 e0       	ldi	r31, 0x00	; 0
 8e6:	10 93 57 00 	sts	0x0057, r17
 8ea:	84 91       	lpm	r24, Z+

			if (SerialCharNum & 0x01)
 8ec:	40 ff       	sbrs	r20, 0
 8ee:	03 c0       	rjmp	.+6      	; 0x8f6 <USB_Device_ProcessControlRequest+0x1d8>
			{
				SerialByte >>= 4;
 8f0:	82 95       	swap	r24
 8f2:	8f 70       	andi	r24, 0x0F	; 15
				SigReadAddress++;
 8f4:	6f 5f       	subi	r22, 0xFF	; 255
			}

			SerialByte &= 0x0F;
 8f6:	8f 70       	andi	r24, 0x0F	; 15
 8f8:	28 2f       	mov	r18, r24
 8fa:	30 e0       	ldi	r19, 0x00	; 0

			SignatureDescriptor.UnicodeString[SerialCharNum] = (SerialByte >= 10) ?
 8fc:	8a 30       	cpi	r24, 0x0A	; 10
 8fe:	18 f0       	brcs	.+6      	; 0x906 <USB_Device_ProcessControlRequest+0x1e8>
 900:	c9 01       	movw	r24, r18
 902:	c7 96       	adiw	r24, 0x37	; 55
 904:	02 c0       	rjmp	.+4      	; 0x90a <USB_Device_ProcessControlRequest+0x1ec>
 906:	c9 01       	movw	r24, r18
 908:	c0 96       	adiw	r24, 0x30	; 48
 90a:	8d 93       	st	X+, r24
 90c:	9d 93       	st	X+, r25
 90e:	4f 5f       	subi	r20, 0xFF	; 255
 910:	5f 4f       	sbci	r21, 0xFF	; 255

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
 912:	44 31       	cpi	r20, 0x14	; 20
 914:	51 05       	cpc	r21, r1
 916:	29 f7       	brne	.-54     	; 0x8e2 <USB_Device_ProcessControlRequest+0x1c4>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 918:	7f bf       	out	0x3f, r23	; 63
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);
 91a:	8a e2       	ldi	r24, 0x2A	; 42
 91c:	8b 83       	std	Y+3, r24	; 0x03
	{
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
 91e:	83 e0       	ldi	r24, 0x03	; 3
 920:	8c 83       	std	Y+4, r24	; 0x04
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 922:	80 91 e8 00 	lds	r24, 0x00E8
 926:	87 7f       	andi	r24, 0xF7	; 247
 928:	80 93 e8 00 	sts	0x00E8, r24
		}
	}

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
 92c:	ce 01       	movw	r24, r28
 92e:	03 96       	adiw	r24, 0x03	; 3
 930:	6a e2       	ldi	r22, 0x2A	; 42
 932:	70 e0       	ldi	r23, 0x00	; 0
 934:	61 d0       	rcall	.+194    	; 0x9f8 <Endpoint_Write_Control_Stream_LE>
 936:	12 c0       	rjmp	.+36     	; 0x95c <USB_Device_ProcessControlRequest+0x23e>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
 938:	60 91 11 01 	lds	r22, 0x0111
 93c:	ae 01       	movw	r20, r28
 93e:	4f 5f       	subi	r20, 0xFF	; 255
 940:	5f 4f       	sbci	r21, 0xFF	; 255
 942:	1e dd       	rcall	.-1476   	; 0x380 <CALLBACK_USB_GetDescriptor>
 944:	bc 01       	movw	r22, r24
 946:	00 97       	sbiw	r24, 0x00	; 0
 948:	09 f4       	brne	.+2      	; 0x94c <USB_Device_ProcessControlRequest+0x22e>
 94a:	3c c0       	rjmp	.+120    	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
 94c:	80 91 e8 00 	lds	r24, 0x00E8
 950:	87 7f       	andi	r24, 0xF7	; 247
 952:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
 956:	89 81       	ldd	r24, Y+1	; 0x01
 958:	9a 81       	ldd	r25, Y+2	; 0x02
 95a:	ac d0       	rcall	.+344    	; 0xab4 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 95c:	80 91 e8 00 	lds	r24, 0x00E8
 960:	8b 77       	andi	r24, 0x7B	; 123
 962:	80 93 e8 00 	sts	0x00E8, r24
 966:	2e c0       	rjmp	.+92     	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
 968:	80 38       	cpi	r24, 0x80	; 128
 96a:	61 f5       	brne	.+88     	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 96c:	80 91 e8 00 	lds	r24, 0x00E8
 970:	87 7f       	andi	r24, 0xF7	; 247
 972:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
 976:	80 91 0a 01 	lds	r24, 0x010A
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 97a:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 97e:	80 91 e8 00 	lds	r24, 0x00E8
 982:	8e 77       	andi	r24, 0x7E	; 126
 984:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
 988:	4e dd       	rcall	.-1380   	; 0x426 <Endpoint_ClearStatusStage>
 98a:	1c c0       	rjmp	.+56     	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 98c:	88 23       	and	r24, r24
 98e:	d1 f4       	brne	.+52     	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
 990:	90 91 0f 01 	lds	r25, 0x010F
 994:	92 30       	cpi	r25, 0x02	; 2
 996:	b0 f4       	brcc	.+44     	; 0x9c4 <USB_Device_ProcessControlRequest+0x2a6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 998:	80 91 e8 00 	lds	r24, 0x00E8
 99c:	87 7f       	andi	r24, 0xF7	; 247
 99e:	80 93 e8 00 	sts	0x00E8, r24
	}
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
 9a2:	90 93 0a 01 	sts	0x010A, r25

	Endpoint_ClearStatusStage();
 9a6:	3f dd       	rcall	.-1410   	; 0x426 <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
 9a8:	80 91 0a 01 	lds	r24, 0x010A
 9ac:	88 23       	and	r24, r24
 9ae:	31 f4       	brne	.+12     	; 0x9bc <USB_Device_ProcessControlRequest+0x29e>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
 9b0:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
 9b4:	87 fd       	sbrc	r24, 7
 9b6:	02 c0       	rjmp	.+4      	; 0x9bc <USB_Device_ProcessControlRequest+0x29e>
 9b8:	81 e0       	ldi	r24, 0x01	; 1
 9ba:	01 c0       	rjmp	.+2      	; 0x9be <USB_Device_ProcessControlRequest+0x2a0>
 9bc:	84 e0       	ldi	r24, 0x04	; 4
 9be:	80 93 0c 01 	sts	0x010C, r24

	EVENT_USB_Device_ConfigurationChanged();
 9c2:	9e dc       	rcall	.-1732   	; 0x300 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 9c4:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
 9c8:	83 ff       	sbrs	r24, 3
 9ca:	0a c0       	rjmp	.+20     	; 0x9e0 <USB_Device_ProcessControlRequest+0x2c2>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
 9cc:	80 91 eb 00 	lds	r24, 0x00EB
 9d0:	80 62       	ori	r24, 0x20	; 32
 9d2:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 9d6:	80 91 e8 00 	lds	r24, 0x00E8
 9da:	87 7f       	andi	r24, 0xF7	; 247
 9dc:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
 9e0:	ac 96       	adiw	r28, 0x2c	; 44
 9e2:	0f b6       	in	r0, 0x3f	; 63
 9e4:	f8 94       	cli
 9e6:	de bf       	out	0x3e, r29	; 62
 9e8:	0f be       	out	0x3f, r0	; 63
 9ea:	cd bf       	out	0x3d, r28	; 61
 9ec:	cf 91       	pop	r28
 9ee:	df 91       	pop	r29
 9f0:	1f 91       	pop	r17
 9f2:	0f 91       	pop	r16
 9f4:	08 95       	ret

000009f6 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
 9f6:	08 95       	ret

000009f8 <Endpoint_Write_Control_Stream_LE>:
 9f8:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
 9fa:	40 91 13 01 	lds	r20, 0x0113
 9fe:	50 91 14 01 	lds	r21, 0x0114
 a02:	46 17       	cp	r20, r22
 a04:	57 07       	cpc	r21, r23
 a06:	18 f4       	brcc	.+6      	; 0xa0e <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
 a08:	f9 01       	movw	r30, r18
 a0a:	90 e0       	ldi	r25, 0x00	; 0
 a0c:	3d c0       	rjmp	.+122    	; 0xa88 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
 a0e:	61 15       	cp	r22, r1
 a10:	71 05       	cpc	r23, r1
 a12:	11 f0       	breq	.+4      	; 0xa18 <Endpoint_Write_Control_Stream_LE+0x20>
 a14:	ab 01       	movw	r20, r22
 a16:	f8 cf       	rjmp	.-16     	; 0xa08 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 a18:	80 91 e8 00 	lds	r24, 0x00E8
 a1c:	8e 77       	andi	r24, 0x7E	; 126
 a1e:	80 93 e8 00 	sts	0x00E8, r24
 a22:	40 e0       	ldi	r20, 0x00	; 0
 a24:	50 e0       	ldi	r21, 0x00	; 0
 a26:	f0 cf       	rjmp	.-32     	; 0xa08 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 a28:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 a2c:	88 23       	and	r24, r24
 a2e:	f1 f1       	breq	.+124    	; 0xaac <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 a30:	85 30       	cpi	r24, 0x05	; 5
 a32:	f1 f1       	breq	.+124    	; 0xab0 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 a34:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
 a38:	83 ff       	sbrs	r24, 3
 a3a:	02 c0       	rjmp	.+4      	; 0xa40 <Endpoint_Write_Control_Stream_LE+0x48>
 a3c:	81 e0       	ldi	r24, 0x01	; 1
 a3e:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 a40:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
 a44:	82 fd       	sbrc	r24, 2
 a46:	2c c0       	rjmp	.+88     	; 0xaa0 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 a48:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
 a4c:	80 ff       	sbrs	r24, 0
 a4e:	1c c0       	rjmp	.+56     	; 0xa88 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
 a50:	20 91 f2 00 	lds	r18, 0x00F2
 a54:	30 91 f3 00 	lds	r19, 0x00F3
 a58:	07 c0       	rjmp	.+14     	; 0xa68 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
 a5a:	81 91       	ld	r24, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 a5c:	80 93 f1 00 	sts	0x00F1, r24
				Length--;
 a60:	41 50       	subi	r20, 0x01	; 1
 a62:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
 a64:	2f 5f       	subi	r18, 0xFF	; 255
 a66:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
 a68:	41 15       	cp	r20, r1
 a6a:	51 05       	cpc	r21, r1
 a6c:	19 f0       	breq	.+6      	; 0xa74 <Endpoint_Write_Control_Stream_LE+0x7c>
 a6e:	28 30       	cpi	r18, 0x08	; 8
 a70:	31 05       	cpc	r19, r1
 a72:	98 f3       	brcs	.-26     	; 0xa5a <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
 a74:	90 e0       	ldi	r25, 0x00	; 0
 a76:	28 30       	cpi	r18, 0x08	; 8
 a78:	31 05       	cpc	r19, r1
 a7a:	09 f4       	brne	.+2      	; 0xa7e <Endpoint_Write_Control_Stream_LE+0x86>
 a7c:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 a7e:	80 91 e8 00 	lds	r24, 0x00E8
 a82:	8e 77       	andi	r24, 0x7E	; 126
 a84:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
 a88:	41 15       	cp	r20, r1
 a8a:	51 05       	cpc	r21, r1
 a8c:	69 f6       	brne	.-102    	; 0xa28 <Endpoint_Write_Control_Stream_LE+0x30>
 a8e:	99 23       	and	r25, r25
 a90:	59 f6       	brne	.-106    	; 0xa28 <Endpoint_Write_Control_Stream_LE+0x30>
 a92:	06 c0       	rjmp	.+12     	; 0xaa0 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 a94:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 a98:	88 23       	and	r24, r24
 a9a:	41 f0       	breq	.+16     	; 0xaac <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 a9c:	85 30       	cpi	r24, 0x05	; 5
 a9e:	41 f0       	breq	.+16     	; 0xab0 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 aa0:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
 aa4:	82 ff       	sbrs	r24, 2
 aa6:	f6 cf       	rjmp	.-20     	; 0xa94 <Endpoint_Write_Control_Stream_LE+0x9c>
 aa8:	80 e0       	ldi	r24, 0x00	; 0
 aaa:	08 95       	ret
 aac:	82 e0       	ldi	r24, 0x02	; 2
 aae:	08 95       	ret
 ab0:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
 ab2:	08 95       	ret

00000ab4 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
 ab4:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
 ab6:	40 91 13 01 	lds	r20, 0x0113
 aba:	50 91 14 01 	lds	r21, 0x0114
 abe:	46 17       	cp	r20, r22
 ac0:	57 07       	cpc	r21, r23
 ac2:	10 f4       	brcc	.+4      	; 0xac8 <Endpoint_Write_Control_PStream_LE+0x14>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
 ac4:	60 e0       	ldi	r22, 0x00	; 0
 ac6:	40 c0       	rjmp	.+128    	; 0xb48 <Endpoint_Write_Control_PStream_LE+0x94>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
 ac8:	61 15       	cp	r22, r1
 aca:	71 05       	cpc	r23, r1
 acc:	11 f0       	breq	.+4      	; 0xad2 <Endpoint_Write_Control_PStream_LE+0x1e>
 ace:	ab 01       	movw	r20, r22
 ad0:	f9 cf       	rjmp	.-14     	; 0xac4 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 ad2:	80 91 e8 00 	lds	r24, 0x00E8
 ad6:	8e 77       	andi	r24, 0x7E	; 126
 ad8:	80 93 e8 00 	sts	0x00E8, r24
 adc:	40 e0       	ldi	r20, 0x00	; 0
 ade:	50 e0       	ldi	r21, 0x00	; 0
 ae0:	f1 cf       	rjmp	.-30     	; 0xac4 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 ae2:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 ae6:	88 23       	and	r24, r24
 ae8:	09 f4       	brne	.+2      	; 0xaec <Endpoint_Write_Control_PStream_LE+0x38>
 aea:	40 c0       	rjmp	.+128    	; 0xb6c <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 aec:	85 30       	cpi	r24, 0x05	; 5
 aee:	09 f4       	brne	.+2      	; 0xaf2 <Endpoint_Write_Control_PStream_LE+0x3e>
 af0:	3f c0       	rjmp	.+126    	; 0xb70 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 af2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
 af6:	83 ff       	sbrs	r24, 3
 af8:	02 c0       	rjmp	.+4      	; 0xafe <Endpoint_Write_Control_PStream_LE+0x4a>
 afa:	81 e0       	ldi	r24, 0x01	; 1
 afc:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 afe:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
 b02:	82 fd       	sbrc	r24, 2
 b04:	2d c0       	rjmp	.+90     	; 0xb60 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 b06:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
 b0a:	80 ff       	sbrs	r24, 0
 b0c:	1d c0       	rjmp	.+58     	; 0xb48 <Endpoint_Write_Control_PStream_LE+0x94>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
 b0e:	80 91 f2 00 	lds	r24, 0x00F2
 b12:	90 91 f3 00 	lds	r25, 0x00F3
 b16:	09 c0       	rjmp	.+18     	; 0xb2a <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
 b18:	f9 01       	movw	r30, r18
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
 b1a:	2f 5f       	subi	r18, 0xFF	; 255
 b1c:	3f 4f       	sbci	r19, 0xFF	; 255
 b1e:	e4 91       	lpm	r30, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 b20:	e0 93 f1 00 	sts	0x00F1, r30
				Length--;
 b24:	41 50       	subi	r20, 0x01	; 1
 b26:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
 b28:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
 b2a:	41 15       	cp	r20, r1
 b2c:	51 05       	cpc	r21, r1
 b2e:	19 f0       	breq	.+6      	; 0xb36 <Endpoint_Write_Control_PStream_LE+0x82>
 b30:	88 30       	cpi	r24, 0x08	; 8
 b32:	91 05       	cpc	r25, r1
 b34:	88 f3       	brcs	.-30     	; 0xb18 <Endpoint_Write_Control_PStream_LE+0x64>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
 b36:	60 e0       	ldi	r22, 0x00	; 0
 b38:	08 97       	sbiw	r24, 0x08	; 8
 b3a:	09 f4       	brne	.+2      	; 0xb3e <Endpoint_Write_Control_PStream_LE+0x8a>
 b3c:	61 e0       	ldi	r22, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 b3e:	80 91 e8 00 	lds	r24, 0x00E8
 b42:	8e 77       	andi	r24, 0x7E	; 126
 b44:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
 b48:	41 15       	cp	r20, r1
 b4a:	51 05       	cpc	r21, r1
 b4c:	51 f6       	brne	.-108    	; 0xae2 <Endpoint_Write_Control_PStream_LE+0x2e>
 b4e:	66 23       	and	r22, r22
 b50:	41 f6       	brne	.-112    	; 0xae2 <Endpoint_Write_Control_PStream_LE+0x2e>
 b52:	06 c0       	rjmp	.+12     	; 0xb60 <Endpoint_Write_Control_PStream_LE+0xac>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 b54:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 b58:	88 23       	and	r24, r24
 b5a:	41 f0       	breq	.+16     	; 0xb6c <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 b5c:	85 30       	cpi	r24, 0x05	; 5
 b5e:	41 f0       	breq	.+16     	; 0xb70 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 b60:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
 b64:	82 ff       	sbrs	r24, 2
 b66:	f6 cf       	rjmp	.-20     	; 0xb54 <Endpoint_Write_Control_PStream_LE+0xa0>
 b68:	80 e0       	ldi	r24, 0x00	; 0
 b6a:	08 95       	ret
 b6c:	82 e0       	ldi	r24, 0x02	; 2
 b6e:	08 95       	ret
 b70:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
 b72:	08 95       	ret

00000b74 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
 b74:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
 b76:	61 15       	cp	r22, r1
 b78:	71 05       	cpc	r23, r1
 b7a:	29 f4       	brne	.+10     	; 0xb86 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 b7c:	80 91 e8 00 	lds	r24, 0x00E8
 b80:	8b 77       	andi	r24, 0x7B	; 123
 b82:	80 93 e8 00 	sts	0x00E8, r24
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
 b86:	f9 01       	movw	r30, r18
 b88:	22 c0       	rjmp	.+68     	; 0xbce <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 b8a:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 b8e:	88 23       	and	r24, r24
 b90:	71 f1       	breq	.+92     	; 0xbee <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 b92:	85 30       	cpi	r24, 0x05	; 5
 b94:	71 f1       	breq	.+92     	; 0xbf2 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 b96:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
 b9a:	83 ff       	sbrs	r24, 3
 b9c:	02 c0       	rjmp	.+4      	; 0xba2 <Endpoint_Read_Control_Stream_LE+0x2e>
 b9e:	81 e0       	ldi	r24, 0x01	; 1
 ba0:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 ba2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
 ba6:	82 ff       	sbrs	r24, 2
 ba8:	f0 cf       	rjmp	.-32     	; 0xb8a <Endpoint_Read_Control_Stream_LE+0x16>
 baa:	06 c0       	rjmp	.+12     	; 0xbb8 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 bac:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
 bb0:	81 93       	st	Z+, r24
				Length--;
 bb2:	61 50       	subi	r22, 0x01	; 1
 bb4:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
 bb6:	31 f0       	breq	.+12     	; 0xbc4 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
 bb8:	80 91 f2 00 	lds	r24, 0x00F2
 bbc:	90 91 f3 00 	lds	r25, 0x00F3
 bc0:	89 2b       	or	r24, r25
 bc2:	a1 f7       	brne	.-24     	; 0xbac <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 bc4:	80 91 e8 00 	lds	r24, 0x00E8
 bc8:	8b 77       	andi	r24, 0x7B	; 123
 bca:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
 bce:	61 15       	cp	r22, r1
 bd0:	71 05       	cpc	r23, r1
 bd2:	d9 f6       	brne	.-74     	; 0xb8a <Endpoint_Read_Control_Stream_LE+0x16>
 bd4:	06 c0       	rjmp	.+12     	; 0xbe2 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 bd6:	80 91 0c 01 	lds	r24, 0x010C

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 bda:	88 23       	and	r24, r24
 bdc:	41 f0       	breq	.+16     	; 0xbee <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 bde:	85 30       	cpi	r24, 0x05	; 5
 be0:	41 f0       	breq	.+16     	; 0xbf2 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
 be2:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
 be6:	80 ff       	sbrs	r24, 0
 be8:	f6 cf       	rjmp	.-20     	; 0xbd6 <Endpoint_Read_Control_Stream_LE+0x62>
 bea:	80 e0       	ldi	r24, 0x00	; 0
 bec:	08 95       	ret
 bee:	82 e0       	ldi	r24, 0x02	; 2
 bf0:	08 95       	ret
 bf2:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
 bf4:	08 95       	ret

00000bf6 <Endpoint_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
 bf6:	ff 92       	push	r15
 bf8:	0f 93       	push	r16
 bfa:	1f 93       	push	r17
 bfc:	cf 93       	push	r28
 bfe:	df 93       	push	r29
 c00:	18 2f       	mov	r17, r24
 c02:	09 2f       	mov	r16, r25
 c04:	eb 01       	movw	r28, r22
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
 c06:	30 dc       	rcall	.-1952   	; 0x468 <Endpoint_WaitUntilReady>
 c08:	f8 2e       	mov	r15, r24
 c0a:	88 23       	and	r24, r24
 c0c:	d1 f4       	brne	.+52     	; 0xc42 <Endpoint_Read_Stream_LE+0x4c>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
 c0e:	81 2f       	mov	r24, r17
 c10:	90 2f       	mov	r25, r16
 c12:	9c 01       	movw	r18, r24
 c14:	89 01       	movw	r16, r18
 c16:	13 c0       	rjmp	.+38     	; 0xc3e <Endpoint_Read_Stream_LE+0x48>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
 c18:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
 c1c:	85 fd       	sbrc	r24, 5
 c1e:	09 c0       	rjmp	.+18     	; 0xc32 <Endpoint_Read_Stream_LE+0x3c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 c20:	80 91 e8 00 	lds	r24, 0x00E8
 c24:	8b 77       	andi	r24, 0x7B	; 123
 c26:	80 93 e8 00 	sts	0x00E8, r24
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
 c2a:	1e dc       	rcall	.-1988   	; 0x468 <Endpoint_WaitUntilReady>
 c2c:	88 23       	and	r24, r24
 c2e:	39 f0       	breq	.+14     	; 0xc3e <Endpoint_Read_Stream_LE+0x48>
 c30:	09 c0       	rjmp	.+18     	; 0xc44 <Endpoint_Read_Stream_LE+0x4e>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 c32:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
 c36:	f8 01       	movw	r30, r16
 c38:	81 93       	st	Z+, r24
 c3a:	8f 01       	movw	r16, r30
			Length--;
 c3c:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
 c3e:	20 97       	sbiw	r28, 0x00	; 0
 c40:	59 f7       	brne	.-42     	; 0xc18 <Endpoint_Read_Stream_LE+0x22>
 c42:	8f 2d       	mov	r24, r15
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
 c44:	df 91       	pop	r29
 c46:	cf 91       	pop	r28
 c48:	1f 91       	pop	r17
 c4a:	0f 91       	pop	r16
 c4c:	ff 90       	pop	r15
 c4e:	08 95       	ret

00000c50 <Endpoint_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
 c50:	ff 92       	push	r15
 c52:	0f 93       	push	r16
 c54:	1f 93       	push	r17
 c56:	cf 93       	push	r28
 c58:	df 93       	push	r29
 c5a:	18 2f       	mov	r17, r24
 c5c:	09 2f       	mov	r16, r25
 c5e:	eb 01       	movw	r28, r22
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
 c60:	03 dc       	rcall	.-2042   	; 0x468 <Endpoint_WaitUntilReady>
 c62:	f8 2e       	mov	r15, r24
 c64:	88 23       	and	r24, r24
 c66:	d1 f4       	brne	.+52     	; 0xc9c <Endpoint_Write_Stream_LE+0x4c>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
 c68:	81 2f       	mov	r24, r17
 c6a:	90 2f       	mov	r25, r16
 c6c:	9c 01       	movw	r18, r24
 c6e:	89 01       	movw	r16, r18
 c70:	13 c0       	rjmp	.+38     	; 0xc98 <Endpoint_Write_Stream_LE+0x48>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
 c72:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
 c76:	85 fd       	sbrc	r24, 5
 c78:	09 c0       	rjmp	.+18     	; 0xc8c <Endpoint_Write_Stream_LE+0x3c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 c7a:	80 91 e8 00 	lds	r24, 0x00E8
 c7e:	8e 77       	andi	r24, 0x7E	; 126
 c80:	80 93 e8 00 	sts	0x00E8, r24
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
 c84:	f1 db       	rcall	.-2078   	; 0x468 <Endpoint_WaitUntilReady>
 c86:	88 23       	and	r24, r24
 c88:	39 f0       	breq	.+14     	; 0xc98 <Endpoint_Write_Stream_LE+0x48>
 c8a:	09 c0       	rjmp	.+18     	; 0xc9e <Endpoint_Write_Stream_LE+0x4e>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
 c8c:	f8 01       	movw	r30, r16
 c8e:	81 91       	ld	r24, Z+
 c90:	8f 01       	movw	r16, r30
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 c92:	80 93 f1 00 	sts	0x00F1, r24
			Length--;
 c96:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
 c98:	20 97       	sbiw	r28, 0x00	; 0
 c9a:	59 f7       	brne	.-42     	; 0xc72 <Endpoint_Write_Stream_LE+0x22>
 c9c:	8f 2d       	mov	r24, r15
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
 c9e:	df 91       	pop	r29
 ca0:	cf 91       	pop	r28
 ca2:	1f 91       	pop	r17
 ca4:	0f 91       	pop	r16
 ca6:	ff 90       	pop	r15
 ca8:	08 95       	ret

00000caa <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
 caa:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
 cac:	80 91 0c 01 	lds	r24, 0x010C
 cb0:	88 23       	and	r24, r24
 cb2:	61 f0       	breq	.+24     	; 0xccc <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
 cb4:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 cb8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 cbc:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
 cc0:	83 ff       	sbrs	r24, 3
 cc2:	01 c0       	rjmp	.+2      	; 0xcc6 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
 cc4:	2c dd       	rcall	.-1448   	; 0x71e <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
 cc6:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 cc8:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
 ccc:	1f 91       	pop	r17
 cce:	08 95       	ret

00000cd0 <_exit>:
 cd0:	f8 94       	cli

00000cd2 <__stop_program>:
 cd2:	ff cf       	rjmp	.-2      	; 0xcd2 <__stop_program>
