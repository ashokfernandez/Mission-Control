
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000cc4  00800100  00002dd8  00002e6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002dd8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000065b  00800dc4  00800dc4  00003b30  2**0
                  ALLOC
  3 .stab         00000e7c  00000000  00000000  00003b30  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000048c  00000000  00000000  000049ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000600  00000000  00000000  00004e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000f2a  00000000  00000000  00005438  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000a193  00000000  00000000  00006362  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003098  00000000  00000000  000104f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000079ca  00000000  00000000  0001358d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000880  00000000  00000000  0001af58  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003736  00000000  00000000  0001b7d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003c14  00000000  00000000  0001ef0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000648  00000000  00000000  00022b22  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

	return Endpoint_IsConfigured();
}

void Endpoint_ClearEndpoints(void)
{
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 a6 0e 	jmp	0x1d4c	; 0x1d4c <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 30 31 31 32 32 09 09 3c 2f 70 3e     </i>101122..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	1d e0       	ldi	r17, 0x0D	; 13
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e8 ed       	ldi	r30, 0xD8	; 216
     436:	fd e2       	ldi	r31, 0x2D	; 45
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	a4 3c       	cpi	r26, 0xC4	; 196
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	a4 ec       	ldi	r26, 0xC4	; 196
     44c:	bd e0       	ldi	r27, 0x0D	; 13
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	af 31       	cpi	r26, 0x1F	; 31
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	55 d0       	rcall	.+170    	; 0x504 <main>
     45a:	0c 94 ea 16 	jmp	0x2dd4	; 0x2dd4 <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     460:	8b b1       	in	r24, 0x0b	; 11
     462:	8f 70       	andi	r24, 0x0F	; 15
     464:	80 6a       	ori	r24, 0xA0	; 160
     466:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     468:	08 95       	ret

0000046a <EVENT_USB_Device_Disconnect>:
     46a:	8b b1       	in	r24, 0x0b	; 11
     46c:	8f 70       	andi	r24, 0x0F	; 15
     46e:	80 61       	ori	r24, 0x10	; 16
     470:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     472:	08 95       	ret

00000474 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     474:	88 e1       	ldi	r24, 0x18	; 24
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0c 94 a7 13 	jmp	0x274e	; 0x274e <RNDIS_Device_ProcessControlRequest>

0000047c <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     47c:	88 e1       	ldi	r24, 0x18	; 24
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     484:	80 fd       	sbrc	r24, 0
     486:	02 c0       	rjmp	.+4      	; 0x48c <EVENT_USB_Device_ConfigurationChanged+0x10>
     488:	90 e9       	ldi	r25, 0x90	; 144
     48a:	01 c0       	rjmp	.+2      	; 0x48e <EVENT_USB_Device_ConfigurationChanged+0x12>
     48c:	90 e6       	ldi	r25, 0x60	; 96
     48e:	8b b1       	in	r24, 0x0b	; 11
     490:	8f 70       	andi	r24, 0x0F	; 15
     492:	98 2b       	or	r25, r24
     494:	9b b9       	out	0x0b, r25	; 11
}
     496:	08 95       	ret

00000498 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     498:	84 b7       	in	r24, 0x34	; 52
     49a:	87 7f       	andi	r24, 0xF7	; 247
     49c:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     49e:	38 e1       	ldi	r19, 0x18	; 24
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	30 93 60 00 	sts	0x0060, r19
     4a8:	10 92 60 00 	sts	0x0060, r1
     4ac:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     4ae:	80 e0       	ldi	r24, 0x00	; 0
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	20 e8       	ldi	r18, 0x80	; 128
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	f8 94       	cli
     4b8:	20 93 61 00 	sts	0x0061, r18
     4bc:	80 93 61 00 	sts	0x0061, r24
     4c0:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4c2:	8a b1       	in	r24, 0x0a	; 10
     4c4:	80 6f       	ori	r24, 0xF0	; 240
     4c6:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4c8:	8b b1       	in	r24, 0x0b	; 11
     4ca:	8f 70       	andi	r24, 0x0F	; 15
     4cc:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4ce:	83 e3       	ldi	r24, 0x33	; 51
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	90 93 cd 00 	sts	0x00CD, r25
     4d6:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4e0:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4e4:	30 93 c9 00 	sts	0x00C9, r19

				DDRD  |= (1 << 3);
     4e8:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4ea:	5a 9a       	sbi	0x0b, 2	; 11
			static inline void SerialStream_Init(const uint32_t BaudRate,
			                                     const bool DoubleSpeed)
			{
				Serial_Init(BaudRate, DoubleSpeed);

				stdout = &USARTStream;
     4ec:	85 eb       	ldi	r24, 0xB5	; 181
     4ee:	9d e0       	ldi	r25, 0x0D	; 13
     4f0:	90 93 1c 14 	sts	0x141C, r25
     4f4:	80 93 1b 14 	sts	0x141B, r24
				stdin  = &USARTStream;
     4f8:	90 93 1a 14 	sts	0x141A, r25
     4fc:	80 93 19 14 	sts	0x1419, r24

	/* Hardware Initialization */
	LEDs_Init();
	SerialStream_Init(9600, false);
	USB_Init();
     500:	0c 94 90 0e 	jmp	0x1d20	; 0x1d20 <USB_Init>

00000504 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     504:	c9 df       	rcall	.-110    	; 0x498 <SetupHardware>

	TCP_Init();
     506:	42 d1       	rcall	.+644    	; 0x78c <TCP_Init>
	Webserver_Init();
     508:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     50c:	8b b1       	in	r24, 0x0b	; 11
     50e:	8f 70       	andi	r24, 0x0F	; 15
     510:	80 61       	ori	r24, 0x10	; 16
     512:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     514:	78 94       	sei

	for (;;)
	{
		if (Ethernet_RNDIS_Interface.State.FrameIN.FrameInBuffer)
     516:	80 91 91 07 	lds	r24, 0x0791
     51a:	88 23       	and	r24, r24
     51c:	69 f0       	breq	.+26     	; 0x538 <main+0x34>
     51e:	8b b1       	in	r24, 0x0b	; 11
     520:	8f 70       	andi	r24, 0x0F	; 15
     522:	80 62       	ori	r24, 0x20	; 32
     524:	8b b9       	out	0x0b, r24	; 11
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
			Ethernet_ProcessPacket(&Ethernet_RNDIS_Interface.State.FrameIN, &Ethernet_RNDIS_Interface.State.FrameOUT);
     526:	83 eb       	ldi	r24, 0xB3	; 179
     528:	91 e0       	ldi	r25, 0x01	; 1
     52a:	62 e9       	ldi	r22, 0x92	; 146
     52c:	77 e0       	ldi	r23, 0x07	; 7
     52e:	6e d0       	rcall	.+220    	; 0x60c <Ethernet_ProcessPacket>
     530:	8b b1       	in	r24, 0x0b	; 11
     532:	8f 70       	andi	r24, 0x0F	; 15
     534:	80 66       	ori	r24, 0x60	; 96
     536:	8b b9       	out	0x0b, r24	; 11
			LEDs_SetAllLEDs(LEDMASK_USB_READY);
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface);
     538:	88 e1       	ldi	r24, 0x18	; 24
     53a:	91 e0       	ldi	r25, 0x01	; 1
     53c:	a1 d6       	rcall	.+3394   	; 0x1280 <TCP_TCPTask>

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     53e:	88 e1       	ldi	r24, 0x18	; 24
     540:	91 e0       	ldi	r25, 0x01	; 1
     542:	0e 94 66 12 	call	0x24cc	; 0x24cc <RNDIS_Device_USBTask>
		USB_USBTask();
     546:	0e 94 53 12 	call	0x24a6	; 0x24a6 <USB_USBTask>
     54a:	e5 cf       	rjmp	.-54     	; 0x516 <main+0x12>

0000054c <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     54c:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     54e:	92 30       	cpi	r25, 0x02	; 2
     550:	49 f0       	breq	.+18     	; 0x564 <CALLBACK_USB_GetDescriptor+0x18>
     552:	93 30       	cpi	r25, 0x03	; 3
     554:	61 f0       	breq	.+24     	; 0x56e <CALLBACK_USB_GetDescriptor+0x22>
     556:	91 30       	cpi	r25, 0x01	; 1
     558:	f9 f4       	brne	.+62     	; 0x598 <CALLBACK_USB_GetDescriptor+0x4c>
     55a:	e8 e9       	ldi	r30, 0x98	; 152
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	22 e1       	ldi	r18, 0x12	; 18
     560:	30 e0       	ldi	r19, 0x00	; 0
     562:	1e c0       	rjmp	.+60     	; 0x5a0 <CALLBACK_USB_GetDescriptor+0x54>
     564:	ea ea       	ldi	r30, 0xAA	; 170
     566:	f0 e0       	ldi	r31, 0x00	; 0
     568:	2e e3       	ldi	r18, 0x3E	; 62
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	19 c0       	rjmp	.+50     	; 0x5a0 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     56e:	81 30       	cpi	r24, 0x01	; 1
     570:	49 f0       	breq	.+18     	; 0x584 <CALLBACK_USB_GetDescriptor+0x38>
     572:	81 30       	cpi	r24, 0x01	; 1
     574:	18 f0       	brcs	.+6      	; 0x57c <CALLBACK_USB_GetDescriptor+0x30>
     576:	82 30       	cpi	r24, 0x02	; 2
     578:	79 f4       	brne	.+30     	; 0x598 <CALLBACK_USB_GetDescriptor+0x4c>
     57a:	08 c0       	rjmp	.+16     	; 0x58c <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     57c:	e8 ee       	ldi	r30, 0xE8	; 232
     57e:	f0 e0       	ldi	r31, 0x00	; 0
     580:	84 91       	lpm	r24, Z+
     582:	07 c0       	rjmp	.+14     	; 0x592 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     584:	ec ee       	ldi	r30, 0xEC	; 236
     586:	f0 e0       	ldi	r31, 0x00	; 0
     588:	84 91       	lpm	r24, Z+
     58a:	03 c0       	rjmp	.+6      	; 0x592 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     58c:	e6 e0       	ldi	r30, 0x06	; 6
     58e:	f1 e0       	ldi	r31, 0x01	; 1
     590:	84 91       	lpm	r24, Z+
     592:	28 2f       	mov	r18, r24
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	04 c0       	rjmp	.+8      	; 0x5a0 <CALLBACK_USB_GetDescriptor+0x54>
     598:	e0 e0       	ldi	r30, 0x00	; 0
     59a:	f0 e0       	ldi	r31, 0x00	; 0
     59c:	20 e0       	ldi	r18, 0x00	; 0
     59e:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     5a0:	ed 93       	st	X+, r30
     5a2:	fc 93       	st	X, r31
	return Size;
}
     5a4:	c9 01       	movw	r24, r18
     5a6:	08 95       	ret

000005a8 <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     5a8:	cf 93       	push	r28
     5aa:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     5ac:	76 95       	lsr	r23
     5ae:	67 95       	ror	r22
     5b0:	ec 01       	movw	r28, r24
     5b2:	20 e0       	ldi	r18, 0x00	; 0
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	40 e0       	ldi	r20, 0x00	; 0
     5b8:	50 e0       	ldi	r21, 0x00	; 0
     5ba:	e0 e0       	ldi	r30, 0x00	; 0
     5bc:	f0 e0       	ldi	r31, 0x00	; 0
     5be:	09 c0       	rjmp	.+18     	; 0x5d2 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     5c0:	89 91       	ld	r24, Y+
     5c2:	99 91       	ld	r25, Y+
     5c4:	a0 e0       	ldi	r26, 0x00	; 0
     5c6:	b0 e0       	ldi	r27, 0x00	; 0
     5c8:	28 0f       	add	r18, r24
     5ca:	39 1f       	adc	r19, r25
     5cc:	4a 1f       	adc	r20, r26
     5ce:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     5d0:	31 96       	adiw	r30, 0x01	; 1
     5d2:	e6 17       	cp	r30, r22
     5d4:	f7 07       	cpc	r31, r23
     5d6:	a0 f3       	brcs	.-24     	; 0x5c0 <Ethernet_Checksum16+0x18>
     5d8:	0b c0       	rjmp	.+22     	; 0x5f0 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     5da:	da 01       	movw	r26, r20
     5dc:	c9 01       	movw	r24, r18
     5de:	a0 70       	andi	r26, 0x00	; 0
     5e0:	b0 70       	andi	r27, 0x00	; 0
     5e2:	9a 01       	movw	r18, r20
     5e4:	44 27       	eor	r20, r20
     5e6:	55 27       	eor	r21, r21
     5e8:	28 0f       	add	r18, r24
     5ea:	39 1f       	adc	r19, r25
     5ec:	4a 1f       	adc	r20, r26
     5ee:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     5f0:	da 01       	movw	r26, r20
     5f2:	c9 01       	movw	r24, r18
     5f4:	80 70       	andi	r24, 0x00	; 0
     5f6:	90 70       	andi	r25, 0x00	; 0
     5f8:	00 97       	sbiw	r24, 0x00	; 0
     5fa:	a1 05       	cpc	r26, r1
     5fc:	b1 05       	cpc	r27, r1
     5fe:	69 f7       	brne	.-38     	; 0x5da <Ethernet_Checksum16+0x32>
     600:	20 95       	com	r18
     602:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     604:	c9 01       	movw	r24, r18
     606:	df 91       	pop	r29
     608:	cf 91       	pop	r28
     60a:	08 95       	ret

0000060c <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     60c:	0f 93       	push	r16
     60e:	1f 93       	push	r17
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	ec 01       	movw	r28, r24
     616:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN);
     618:	6d d0       	rcall	.+218    	; 0x6f4 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     61a:	ce 01       	movw	r24, r28
     61c:	61 e7       	ldi	r22, 0x71	; 113
     61e:	7d e0       	ldi	r23, 0x0D	; 13
     620:	46 e0       	ldi	r20, 0x06	; 6
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
     628:	00 97       	sbiw	r24, 0x00	; 0
     62a:	51 f0       	breq	.+20     	; 0x640 <Ethernet_ProcessPacket+0x34>
     62c:	ce 01       	movw	r24, r28
     62e:	6b e7       	ldi	r22, 0x7B	; 123
     630:	7d e0       	ldi	r23, 0x0D	; 13
     632:	46 e0       	ldi	r20, 0x06	; 6
     634:	50 e0       	ldi	r21, 0x00	; 0
     636:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
     63a:	00 97       	sbiw	r24, 0x00	; 0
     63c:	09 f0       	breq	.+2      	; 0x640 <Ethernet_ProcessPacket+0x34>
     63e:	52 c0       	rjmp	.+164    	; 0x6e4 <Ethernet_ProcessPacket+0xd8>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     640:	c4 52       	subi	r28, 0x24	; 36
     642:	da 4f       	sbci	r29, 0xFA	; 250
     644:	88 81       	ld	r24, Y
     646:	99 81       	ldd	r25, Y+1	; 0x01
     648:	cc 5d       	subi	r28, 0xDC	; 220
     64a:	d5 40       	sbci	r29, 0x05	; 5

				Temp = Data.Bytes[0];
     64c:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     64e:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     650:	92 2f       	mov	r25, r18
     652:	81 50       	subi	r24, 0x01	; 1
     654:	96 40       	sbci	r25, 0x06	; 6
     656:	08 f4       	brcc	.+2      	; 0x65a <Ethernet_ProcessPacket+0x4e>
     658:	45 c0       	rjmp	.+138    	; 0x6e4 <Ethernet_ProcessPacket+0xd8>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     65a:	2c 85       	ldd	r18, Y+12	; 0x0c
     65c:	3d 85       	ldd	r19, Y+13	; 0x0d

				Temp = Data.Bytes[0];
     65e:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     660:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     662:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     664:	88 e0       	ldi	r24, 0x08	; 8
     666:	20 30       	cpi	r18, 0x00	; 0
     668:	38 07       	cpc	r19, r24
     66a:	59 f0       	breq	.+22     	; 0x682 <Ethernet_ProcessPacket+0x76>
     66c:	26 50       	subi	r18, 0x06	; 6
     66e:	38 40       	sbci	r19, 0x08	; 8
     670:	c9 f5       	brne	.+114    	; 0x6e4 <Ethernet_ProcessPacket+0xd8>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     672:	b8 01       	movw	r22, r16
     674:	62 5f       	subi	r22, 0xF2	; 242
     676:	7f 4f       	sbci	r23, 0xFF	; 255
     678:	ce 01       	movw	r24, r28
     67a:	0e 96       	adiw	r24, 0x0e	; 14
     67c:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <ARP_ProcessARPPacket>
     680:	09 c0       	rjmp	.+18     	; 0x694 <Ethernet_ProcessPacket+0x88>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     682:	be 01       	movw	r22, r28
     684:	62 5f       	subi	r22, 0xF2	; 242
     686:	7f 4f       	sbci	r23, 0xFF	; 255
     688:	a8 01       	movw	r20, r16
     68a:	42 5f       	subi	r20, 0xF2	; 242
     68c:	5f 4f       	sbci	r21, 0xFF	; 255
     68e:	ce 01       	movw	r24, r28
     690:	0e 94 65 0c 	call	0x18ca	; 0x18ca <IP_ProcessIPPacket>
     694:	9c 01       	movw	r18, r24
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     696:	18 16       	cp	r1, r24
     698:	19 06       	cpc	r1, r25
     69a:	04 f5       	brge	.+64     	; 0x6dc <Ethernet_ProcessPacket+0xd0>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     69c:	d8 01       	movw	r26, r16
     69e:	16 96       	adiw	r26, 0x06	; 6
     6a0:	e1 e7       	ldi	r30, 0x71	; 113
     6a2:	fd e0       	ldi	r31, 0x0D	; 13
     6a4:	86 e0       	ldi	r24, 0x06	; 6
     6a6:	01 90       	ld	r0, Z+
     6a8:	0d 92       	st	X+, r0
     6aa:	81 50       	subi	r24, 0x01	; 1
     6ac:	e1 f7       	brne	.-8      	; 0x6a6 <Ethernet_ProcessPacket+0x9a>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     6ae:	d8 01       	movw	r26, r16
     6b0:	fe 01       	movw	r30, r28
     6b2:	36 96       	adiw	r30, 0x06	; 6
     6b4:	86 e0       	ldi	r24, 0x06	; 6
     6b6:	01 90       	ld	r0, Z+
     6b8:	0d 92       	st	X+, r0
     6ba:	81 50       	subi	r24, 0x01	; 1
     6bc:	e1 f7       	brne	.-8      	; 0x6b6 <Ethernet_ProcessPacket+0xaa>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     6be:	8c 85       	ldd	r24, Y+12	; 0x0c
     6c0:	9d 85       	ldd	r25, Y+13	; 0x0d
     6c2:	f8 01       	movw	r30, r16
     6c4:	95 87       	std	Z+13, r25	; 0x0d
     6c6:	84 87       	std	Z+12, r24	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     6c8:	04 52       	subi	r16, 0x24	; 36
     6ca:	1a 4f       	sbci	r17, 0xFA	; 250
     6cc:	22 5f       	subi	r18, 0xF2	; 242
     6ce:	3f 4f       	sbci	r19, 0xFF	; 255
     6d0:	f8 01       	movw	r30, r16
     6d2:	21 93       	st	Z+, r18
     6d4:	31 93       	st	Z+, r19
			FrameOUT->FrameInBuffer         = true;
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	80 83       	st	Z, r24
     6da:	04 c0       	rjmp	.+8      	; 0x6e4 <Ethernet_ProcessPacket+0xd8>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     6dc:	ff ef       	ldi	r31, 0xFF	; 255
     6de:	8f 3f       	cpi	r24, 0xFF	; 255
     6e0:	9f 07       	cpc	r25, r31
     6e2:	19 f0       	breq	.+6      	; 0x6ea <Ethernet_ProcessPacket+0xde>
	{
		/* Clear the frame buffer */
		FrameIN->FrameInBuffer = false;
     6e4:	c2 52       	subi	r28, 0x22	; 34
     6e6:	da 4f       	sbci	r29, 0xFA	; 250
     6e8:	18 82       	st	Y, r1
	}
}
     6ea:	df 91       	pop	r29
     6ec:	cf 91       	pop	r28
     6ee:	1f 91       	pop	r17
     6f0:	0f 91       	pop	r16
     6f2:	08 95       	ret

000006f4 <DecodeEthernetFrameHeader>:
	if (SwapEndian_16(FrameINData->FrameLength) > ETHERNET_VER2_MINSIZE)
	  printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	else
	  printf_P(PSTR("  + Protocol: UNKNOWN E1\r\n"));
	#endif
}
     6f4:	08 95       	ret

000006f6 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     6f6:	08 95       	ret

000006f8 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     6f8:	08 95       	ret

000006fa <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     6fa:	08 95       	ret

000006fc <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     6fc:	08 95       	ret

000006fe <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     6fe:	08 95       	ret

00000700 <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     700:	08 95       	ret

00000702 <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     702:	ef 92       	push	r14
     704:	ff 92       	push	r15
     706:	0f 93       	push	r16
     708:	1f 93       	push	r17
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	7c 01       	movw	r14, r24
     710:	8b 01       	movw	r16, r22
     712:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     714:	cb 01       	movw	r24, r22
     716:	f1 df       	rcall	.-30     	; 0x6fa <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     718:	f8 01       	movw	r30, r16
     71a:	80 81       	ld	r24, Z
     71c:	88 30       	cpi	r24, 0x08	; 8
     71e:	19 f0       	breq	.+6      	; 0x726 <ICMP_ProcessICMPPacket+0x24>
     720:	20 e0       	ldi	r18, 0x00	; 0
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	2b c0       	rjmp	.+86     	; 0x77c <ICMP_ProcessICMPPacket+0x7a>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     726:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     728:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     72a:	1b 82       	std	Y+3, r1	; 0x03
     72c:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     72e:	f8 01       	movw	r30, r16
     730:	84 81       	ldd	r24, Z+4	; 0x04
     732:	95 81       	ldd	r25, Z+5	; 0x05
     734:	9d 83       	std	Y+5, r25	; 0x05
     736:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     738:	86 81       	ldd	r24, Z+6	; 0x06
     73a:	97 81       	ldd	r25, Z+7	; 0x07
     73c:	9f 83       	std	Y+7, r25	; 0x07
     73e:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     740:	b8 01       	movw	r22, r16
     742:	68 5f       	subi	r22, 0xF8	; 248
     744:	7f 4f       	sbci	r23, 0xFF	; 255
     746:	8c ed       	ldi	r24, 0xDC	; 220
     748:	95 e0       	ldi	r25, 0x05	; 5
     74a:	e8 0e       	add	r14, r24
     74c:	f9 1e       	adc	r15, r25
     74e:	f7 01       	movw	r30, r14
     750:	80 81       	ld	r24, Z
     752:	91 81       	ldd	r25, Z+1	; 0x01
     754:	87 01       	movw	r16, r14
     756:	0c 5d       	subi	r16, 0xDC	; 220
     758:	15 40       	sbci	r17, 0x05	; 5
     75a:	08 0f       	add	r16, r24
     75c:	19 1f       	adc	r17, r25
     75e:	06 1b       	sub	r16, r22
     760:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     762:	ce 01       	movw	r24, r28
     764:	08 96       	adiw	r24, 0x08	; 8
     766:	a8 01       	movw	r20, r16
     768:	0e 94 cb 16 	call	0x2d96	; 0x2d96 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     76c:	08 5f       	subi	r16, 0xF8	; 248
     76e:	1f 4f       	sbci	r17, 0xFF	; 255
     770:	ce 01       	movw	r24, r28
     772:	b8 01       	movw	r22, r16
     774:	19 df       	rcall	.-462    	; 0x5a8 <Ethernet_Checksum16>
     776:	9b 83       	std	Y+3, r25	; 0x03
     778:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     77a:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     77c:	c9 01       	movw	r24, r18
     77e:	df 91       	pop	r29
     780:	cf 91       	pop	r28
     782:	1f 91       	pop	r17
     784:	0f 91       	pop	r16
     786:	ff 90       	pop	r15
     788:	ef 90       	pop	r14
     78a:	08 95       	ret

0000078c <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     78c:	10 92 09 14 	sts	0x1409, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     790:	8a e0       	ldi	r24, 0x0A	; 10
     792:	80 93 da 0f 	sts	0x0FDA, r24
     796:	80 93 f0 11 	sts	0x11F0, r24
     79a:	80 93 06 14 	sts	0x1406, r24
}
     79e:	08 95       	ret

000007a0 <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     7a0:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     7a2:	80 91 07 14 	lds	r24, 0x1407
     7a6:	90 91 08 14 	lds	r25, 0x1408
     7aa:	82 17       	cp	r24, r18
     7ac:	93 07       	cpc	r25, r19
     7ae:	19 f4       	brne	.+6      	; 0x7b6 <TCP_SetPortState+0x16>
     7b0:	80 e0       	ldi	r24, 0x00	; 0
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	13 c0       	rjmp	.+38     	; 0x7dc <TCP_SetPortState+0x3c>
     7b6:	80 91 0c 14 	lds	r24, 0x140C
     7ba:	90 91 0d 14 	lds	r25, 0x140D
     7be:	82 17       	cp	r24, r18
     7c0:	93 07       	cpc	r25, r19
     7c2:	19 f4       	brne	.+6      	; 0x7ca <TCP_SetPortState+0x2a>
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	09 c0       	rjmp	.+18     	; 0x7dc <TCP_SetPortState+0x3c>
     7ca:	80 91 11 14 	lds	r24, 0x1411
     7ce:	90 91 12 14 	lds	r25, 0x1412
     7d2:	82 17       	cp	r24, r18
     7d4:	93 07       	cpc	r25, r19
     7d6:	79 f4       	brne	.+30     	; 0x7f6 <TCP_SetPortState+0x56>
     7d8:	82 e0       	ldi	r24, 0x02	; 2
     7da:	90 e0       	ldi	r25, 0x00	; 0
		{
			PortStateTable[PTableEntry].State = State;
     7dc:	fc 01       	movw	r30, r24
     7de:	ee 0f       	add	r30, r30
     7e0:	ff 1f       	adc	r31, r31
     7e2:	ee 0f       	add	r30, r30
     7e4:	ff 1f       	adc	r31, r31
     7e6:	e8 0f       	add	r30, r24
     7e8:	f9 1f       	adc	r31, r25
     7ea:	e9 5f       	subi	r30, 0xF9	; 249
     7ec:	fb 4e       	sbci	r31, 0xEB	; 235
     7ee:	62 83       	std	Z+2, r22	; 0x02
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     7f0:	54 83       	std	Z+4, r21	; 0x04
     7f2:	43 83       	std	Z+3, r20	; 0x03
     7f4:	02 c0       	rjmp	.+4      	; 0x7fa <TCP_SetPortState+0x5a>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     7f6:	61 30       	cpi	r22, 0x01	; 1
     7f8:	11 f0       	breq	.+4      	; 0x7fe <TCP_SetPortState+0x5e>
     7fa:	81 e0       	ldi	r24, 0x01	; 1
     7fc:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     7fe:	80 91 09 14 	lds	r24, 0x1409
     802:	88 23       	and	r24, r24
     804:	19 f4       	brne	.+6      	; 0x80c <TCP_SetPortState+0x6c>
     806:	80 e0       	ldi	r24, 0x00	; 0
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	0f c0       	rjmp	.+30     	; 0x82a <TCP_SetPortState+0x8a>
     80c:	80 91 0e 14 	lds	r24, 0x140E
     810:	88 23       	and	r24, r24
     812:	19 f4       	brne	.+6      	; 0x81a <TCP_SetPortState+0x7a>
     814:	81 e0       	ldi	r24, 0x01	; 1
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	08 c0       	rjmp	.+16     	; 0x82a <TCP_SetPortState+0x8a>
     81a:	80 91 13 14 	lds	r24, 0x1413
     81e:	88 23       	and	r24, r24
     820:	11 f0       	breq	.+4      	; 0x826 <TCP_SetPortState+0x86>
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	08 95       	ret
     826:	82 e0       	ldi	r24, 0x02	; 2
     828:	90 e0       	ldi	r25, 0x00	; 0
			{
				PortStateTable[PTableEntry].Port  = Port;
     82a:	fc 01       	movw	r30, r24
     82c:	ee 0f       	add	r30, r30
     82e:	ff 1f       	adc	r31, r31
     830:	ee 0f       	add	r30, r30
     832:	ff 1f       	adc	r31, r31
     834:	e8 0f       	add	r30, r24
     836:	f9 1f       	adc	r31, r25
     838:	e9 5f       	subi	r30, 0xF9	; 249
     83a:	fb 4e       	sbci	r31, 0xEB	; 235
     83c:	31 83       	std	Z+1, r19	; 0x01
     83e:	20 83       	st	Z, r18
				PortStateTable[PTableEntry].State = State;
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	82 83       	std	Z+2, r24	; 0x02
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     844:	54 83       	std	Z+4, r21	; 0x04
     846:	43 83       	std	Z+3, r20	; 0x03
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     848:	08 95       	ret

0000084a <TCP_GetPortState>:
 *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 *
 *  \return A value from the TCP_PortStates_t enum
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
     84a:	9c 01       	movw	r18, r24
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     84c:	80 91 07 14 	lds	r24, 0x1407
     850:	90 91 08 14 	lds	r25, 0x1408
     854:	82 17       	cp	r24, r18
     856:	93 07       	cpc	r25, r19
     858:	19 f4       	brne	.+6      	; 0x860 <TCP_GetPortState+0x16>
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	15 c0       	rjmp	.+42     	; 0x88a <TCP_GetPortState+0x40>
     860:	80 91 0c 14 	lds	r24, 0x140C
     864:	90 91 0d 14 	lds	r25, 0x140D
     868:	82 17       	cp	r24, r18
     86a:	93 07       	cpc	r25, r19
     86c:	19 f4       	brne	.+6      	; 0x874 <TCP_GetPortState+0x2a>
     86e:	81 e0       	ldi	r24, 0x01	; 1
     870:	90 e0       	ldi	r25, 0x00	; 0
     872:	0b c0       	rjmp	.+22     	; 0x88a <TCP_GetPortState+0x40>
     874:	80 91 11 14 	lds	r24, 0x1411
     878:	90 91 12 14 	lds	r25, 0x1412
     87c:	82 17       	cp	r24, r18
     87e:	93 07       	cpc	r25, r19
     880:	11 f0       	breq	.+4      	; 0x886 <TCP_GetPortState+0x3c>
     882:	80 e0       	ldi	r24, 0x00	; 0
     884:	08 95       	ret
     886:	82 e0       	ldi	r24, 0x02	; 2
     888:	90 e0       	ldi	r25, 0x00	; 0
		  return PortStateTable[PTableEntry].State;
     88a:	fc 01       	movw	r30, r24
     88c:	ee 0f       	add	r30, r30
     88e:	ff 1f       	adc	r31, r31
     890:	ee 0f       	add	r30, r30
     892:	ff 1f       	adc	r31, r31
     894:	e8 0f       	add	r30, r24
     896:	f9 1f       	adc	r31, r25
     898:	e9 5f       	subi	r30, 0xF9	; 249
     89a:	fb 4e       	sbci	r31, 0xEB	; 235
     89c:	82 81       	ldd	r24, Z+2	; 0x02
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     89e:	08 95       	ret

000008a0 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               const uint16_t TCPOutSize)
{
     8a0:	2f 92       	push	r2
     8a2:	3f 92       	push	r3
     8a4:	4f 92       	push	r4
     8a6:	5f 92       	push	r5
     8a8:	6f 92       	push	r6
     8aa:	7f 92       	push	r7
     8ac:	8f 92       	push	r8
     8ae:	9f 92       	push	r9
     8b0:	af 92       	push	r10
     8b2:	bf 92       	push	r11
     8b4:	cf 92       	push	r12
     8b6:	df 92       	push	r13
     8b8:	ef 92       	push	r14
     8ba:	ff 92       	push	r15
     8bc:	0f 93       	push	r16
     8be:	1f 93       	push	r17
     8c0:	df 93       	push	r29
     8c2:	cf 93       	push	r28
     8c4:	cd b7       	in	r28, 0x3d	; 61
     8c6:	de b7       	in	r29, 0x3e	; 62
     8c8:	2a 97       	sbiw	r28, 0x0a	; 10
     8ca:	0f b6       	in	r0, 0x3f	; 63
     8cc:	f8 94       	cli
     8ce:	de bf       	out	0x3e, r29	; 62
     8d0:	0f be       	out	0x3f, r0	; 63
     8d2:	cd bf       	out	0x3d, r28	; 61
     8d4:	9a 87       	std	Y+10, r25	; 0x0a
     8d6:	89 87       	std	Y+9, r24	; 0x09
     8d8:	3a 01       	movw	r6, r20
     8da:	49 83       	std	Y+1, r20	; 0x01
     8dc:	5a 83       	std	Y+2, r21	; 0x02
     8de:	6b 83       	std	Y+3, r22	; 0x03
     8e0:	7c 83       	std	Y+4, r23	; 0x04
     8e2:	58 01       	movw	r10, r16
     8e4:	0d 83       	std	Y+5, r16	; 0x05
     8e6:	1e 83       	std	Y+6, r17	; 0x06
     8e8:	2f 83       	std	Y+7, r18	; 0x07
     8ea:	38 87       	std	Y+8, r19	; 0x08
     8ec:	b7 01       	movw	r22, r14
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
     8ee:	88 24       	eor	r8, r8
     8f0:	99 24       	eor	r9, r9
	Checksum += ((uint16_t*)&SourceAddress)[1];
     8f2:	eb 80       	ldd	r14, Y+3	; 0x03
     8f4:	fc 80       	ldd	r15, Y+4	; 0x04
     8f6:	00 e0       	ldi	r16, 0x00	; 0
     8f8:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     8fa:	cc 24       	eor	r12, r12
     8fc:	dd 24       	eor	r13, r13
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     8fe:	2f 81       	ldd	r18, Y+7	; 0x07
     900:	38 85       	ldd	r19, Y+8	; 0x08
     902:	40 e0       	ldi	r20, 0x00	; 0
     904:	50 e0       	ldi	r21, 0x00	; 0
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     906:	87 2f       	mov	r24, r23
				Data.Bytes[1] = Temp;
     908:	96 2f       	mov	r25, r22

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     90a:	1c 01       	movw	r2, r24
     90c:	44 24       	eor	r4, r4
     90e:	55 24       	eor	r5, r5
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	96 e0       	ldi	r25, 0x06	; 6
     914:	a0 e0       	ldi	r26, 0x00	; 0
     916:	b0 e0       	ldi	r27, 0x00	; 0
     918:	28 0e       	add	r2, r24
     91a:	39 1e       	adc	r3, r25
     91c:	4a 1e       	adc	r4, r26
     91e:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     920:	26 0c       	add	r2, r6
     922:	37 1c       	adc	r3, r7
     924:	48 1c       	adc	r4, r8
     926:	59 1c       	adc	r5, r9
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     928:	2a 0c       	add	r2, r10
     92a:	3b 1c       	adc	r3, r11
     92c:	4c 1c       	adc	r4, r12
     92e:	5d 1c       	adc	r5, r13
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     930:	2e 0c       	add	r2, r14
     932:	3f 1c       	adc	r3, r15
     934:	40 1e       	adc	r4, r16
     936:	51 1e       	adc	r5, r17
	Checksum += SwapEndian_16(TCPOutSize);
     938:	22 0e       	add	r2, r18
     93a:	33 1e       	adc	r3, r19
     93c:	44 1e       	adc	r4, r20
     93e:	55 1e       	adc	r5, r21

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     940:	fb 01       	movw	r30, r22
     942:	f6 95       	lsr	r31
     944:	e7 95       	ror	r30
     946:	49 85       	ldd	r20, Y+9	; 0x09
     948:	5a 85       	ldd	r21, Y+10	; 0x0a
     94a:	20 e0       	ldi	r18, 0x00	; 0
     94c:	30 e0       	ldi	r19, 0x00	; 0
     94e:	0c c0       	rjmp	.+24     	; 0x968 <TCP_Checksum16+0xc8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     950:	da 01       	movw	r26, r20
     952:	8d 91       	ld	r24, X+
     954:	9d 91       	ld	r25, X+
     956:	ad 01       	movw	r20, r26
     958:	a0 e0       	ldi	r26, 0x00	; 0
     95a:	b0 e0       	ldi	r27, 0x00	; 0
     95c:	28 0e       	add	r2, r24
     95e:	39 1e       	adc	r3, r25
     960:	4a 1e       	adc	r4, r26
     962:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     964:	2f 5f       	subi	r18, 0xFF	; 255
     966:	3f 4f       	sbci	r19, 0xFF	; 255
     968:	2e 17       	cp	r18, r30
     96a:	3f 07       	cpc	r19, r31
     96c:	88 f3       	brcs	.-30     	; 0x950 <TCP_Checksum16+0xb0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     96e:	60 ff       	sbrs	r22, 0
     970:	17 c0       	rjmp	.+46     	; 0x9a0 <TCP_Checksum16+0x100>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     972:	ee 0f       	add	r30, r30
     974:	ff 1f       	adc	r31, r31
     976:	89 85       	ldd	r24, Y+9	; 0x09
     978:	9a 85       	ldd	r25, Y+10	; 0x0a
     97a:	e8 0f       	add	r30, r24
     97c:	f9 1f       	adc	r31, r25
     97e:	80 81       	ld	r24, Z
     980:	28 0e       	add	r2, r24
     982:	31 1c       	adc	r3, r1
     984:	41 1c       	adc	r4, r1
     986:	51 1c       	adc	r5, r1
     988:	0b c0       	rjmp	.+22     	; 0x9a0 <TCP_Checksum16+0x100>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     98a:	d2 01       	movw	r26, r4
     98c:	c1 01       	movw	r24, r2
     98e:	a0 70       	andi	r26, 0x00	; 0
     990:	b0 70       	andi	r27, 0x00	; 0
     992:	12 01       	movw	r2, r4
     994:	44 24       	eor	r4, r4
     996:	55 24       	eor	r5, r5
     998:	28 0e       	add	r2, r24
     99a:	39 1e       	adc	r3, r25
     99c:	4a 1e       	adc	r4, r26
     99e:	5b 1e       	adc	r5, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     9a0:	d2 01       	movw	r26, r4
     9a2:	c1 01       	movw	r24, r2
     9a4:	80 70       	andi	r24, 0x00	; 0
     9a6:	90 70       	andi	r25, 0x00	; 0
     9a8:	00 97       	sbiw	r24, 0x00	; 0
     9aa:	a1 05       	cpc	r26, r1
     9ac:	b1 05       	cpc	r27, r1
     9ae:	69 f7       	brne	.-38     	; 0x98a <TCP_Checksum16+0xea>
     9b0:	91 01       	movw	r18, r2
     9b2:	20 95       	com	r18
     9b4:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     9b6:	c9 01       	movw	r24, r18
     9b8:	2a 96       	adiw	r28, 0x0a	; 10
     9ba:	0f b6       	in	r0, 0x3f	; 63
     9bc:	f8 94       	cli
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	0f be       	out	0x3f, r0	; 63
     9c2:	cd bf       	out	0x3d, r28	; 61
     9c4:	cf 91       	pop	r28
     9c6:	df 91       	pop	r29
     9c8:	1f 91       	pop	r17
     9ca:	0f 91       	pop	r16
     9cc:	ff 90       	pop	r15
     9ce:	ef 90       	pop	r14
     9d0:	df 90       	pop	r13
     9d2:	cf 90       	pop	r12
     9d4:	bf 90       	pop	r11
     9d6:	af 90       	pop	r10
     9d8:	9f 90       	pop	r9
     9da:	8f 90       	pop	r8
     9dc:	7f 90       	pop	r7
     9de:	6f 90       	pop	r6
     9e0:	5f 90       	pop	r5
     9e2:	4f 90       	pop	r4
     9e4:	3f 90       	pop	r3
     9e6:	2f 90       	pop	r2
     9e8:	08 95       	ret

000009ea <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     9ea:	4f 92       	push	r4
     9ec:	5f 92       	push	r5
     9ee:	6f 92       	push	r6
     9f0:	7f 92       	push	r7
     9f2:	8f 92       	push	r8
     9f4:	9f 92       	push	r9
     9f6:	af 92       	push	r10
     9f8:	bf 92       	push	r11
     9fa:	cf 92       	push	r12
     9fc:	df 92       	push	r13
     9fe:	ef 92       	push	r14
     a00:	ff 92       	push	r15
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	df 93       	push	r29
     a08:	cf 93       	push	r28
     a0a:	00 d0       	rcall	.+0      	; 0xa0c <TCP_GetConnectionInfo+0x22>
     a0c:	00 d0       	rcall	.+0      	; 0xa0e <TCP_GetConnectionInfo+0x24>
     a0e:	cd b7       	in	r28, 0x3d	; 61
     a10:	de b7       	in	r29, 0x3e	; 62
     a12:	4c 01       	movw	r8, r24
     a14:	49 83       	std	Y+1, r20	; 0x01
     a16:	5a 83       	std	Y+2, r21	; 0x02
     a18:	6b 83       	std	Y+3, r22	; 0x03
     a1a:	7c 83       	std	Y+4, r23	; 0x04
     a1c:	59 01       	movw	r10, r18
     a1e:	25 ec       	ldi	r18, 0xC5	; 197
     a20:	e2 2e       	mov	r14, r18
     a22:	2d e0       	ldi	r18, 0x0D	; 13
     a24:	f2 2e       	mov	r15, r18
     a26:	00 e0       	ldi	r16, 0x00	; 0
     a28:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     a2a:	96 e1       	ldi	r25, 0x16	; 22
     a2c:	49 2e       	mov	r4, r25
     a2e:	92 e0       	ldi	r25, 0x02	; 2
     a30:	59 2e       	mov	r5, r25
     a32:	3e 01       	movw	r6, r28
     a34:	08 94       	sec
     a36:	61 1c       	adc	r6, r1
     a38:	71 1c       	adc	r7, r1
     a3a:	f7 01       	movw	r30, r14
     a3c:	80 81       	ld	r24, Z
     a3e:	91 81       	ldd	r25, Z+1	; 0x01
     a40:	88 15       	cp	r24, r8
     a42:	99 05       	cpc	r25, r9
     a44:	d9 f4       	brne	.+54     	; 0xa7c <TCP_GetConnectionInfo+0x92>
     a46:	04 9d       	mul	r16, r4
     a48:	60 01       	movw	r12, r0
     a4a:	05 9d       	mul	r16, r5
     a4c:	d0 0c       	add	r13, r0
     a4e:	14 9d       	mul	r17, r4
     a50:	d0 0c       	add	r13, r0
     a52:	11 24       	eor	r1, r1
     a54:	c6 01       	movw	r24, r12
     a56:	87 53       	subi	r24, 0x37	; 55
     a58:	92 4f       	sbci	r25, 0xF2	; 242
     a5a:	b3 01       	movw	r22, r6
     a5c:	44 e0       	ldi	r20, 0x04	; 4
     a5e:	50 e0       	ldi	r21, 0x00	; 0
     a60:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
     a64:	00 97       	sbiw	r24, 0x00	; 0
     a66:	51 f4       	brne	.+20     	; 0xa7c <TCP_GetConnectionInfo+0x92>
     a68:	f7 01       	movw	r30, r14
     a6a:	82 81       	ldd	r24, Z+2	; 0x02
     a6c:	93 81       	ldd	r25, Z+3	; 0x03
     a6e:	8a 15       	cp	r24, r10
     a70:	9b 05       	cpc	r25, r11
     a72:	21 f4       	brne	.+8      	; 0xa7c <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     a74:	96 01       	movw	r18, r12
     a76:	23 53       	subi	r18, 0x33	; 51
     a78:	32 4f       	sbci	r19, 0xF2	; 242
     a7a:	0b c0       	rjmp	.+22     	; 0xa92 <TCP_GetConnectionInfo+0xa8>
     a7c:	0f 5f       	subi	r16, 0xFF	; 255
     a7e:	1f 4f       	sbci	r17, 0xFF	; 255
     a80:	86 e1       	ldi	r24, 0x16	; 22
     a82:	92 e0       	ldi	r25, 0x02	; 2
     a84:	e8 0e       	add	r14, r24
     a86:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     a88:	03 30       	cpi	r16, 0x03	; 3
     a8a:	11 05       	cpc	r17, r1
     a8c:	b1 f6       	brne	.-84     	; 0xa3a <TCP_GetConnectionInfo+0x50>
     a8e:	20 e0       	ldi	r18, 0x00	; 0
     a90:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     a92:	c9 01       	movw	r24, r18
     a94:	0f 90       	pop	r0
     a96:	0f 90       	pop	r0
     a98:	0f 90       	pop	r0
     a9a:	0f 90       	pop	r0
     a9c:	cf 91       	pop	r28
     a9e:	df 91       	pop	r29
     aa0:	1f 91       	pop	r17
     aa2:	0f 91       	pop	r16
     aa4:	ff 90       	pop	r15
     aa6:	ef 90       	pop	r14
     aa8:	df 90       	pop	r13
     aaa:	cf 90       	pop	r12
     aac:	bf 90       	pop	r11
     aae:	af 90       	pop	r10
     ab0:	9f 90       	pop	r9
     ab2:	8f 90       	pop	r8
     ab4:	7f 90       	pop	r7
     ab6:	6f 90       	pop	r6
     ab8:	5f 90       	pop	r5
     aba:	4f 90       	pop	r4
     abc:	08 95       	ret

00000abe <TCP_GetConnectionState>:
 *  \return A value from the TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     abe:	4f 92       	push	r4
     ac0:	5f 92       	push	r5
     ac2:	6f 92       	push	r6
     ac4:	7f 92       	push	r7
     ac6:	8f 92       	push	r8
     ac8:	9f 92       	push	r9
     aca:	af 92       	push	r10
     acc:	bf 92       	push	r11
     ace:	cf 92       	push	r12
     ad0:	df 92       	push	r13
     ad2:	ef 92       	push	r14
     ad4:	ff 92       	push	r15
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	df 93       	push	r29
     adc:	cf 93       	push	r28
     ade:	00 d0       	rcall	.+0      	; 0xae0 <TCP_GetConnectionState+0x22>
     ae0:	00 d0       	rcall	.+0      	; 0xae2 <TCP_GetConnectionState+0x24>
     ae2:	cd b7       	in	r28, 0x3d	; 61
     ae4:	de b7       	in	r29, 0x3e	; 62
     ae6:	4c 01       	movw	r8, r24
     ae8:	49 83       	std	Y+1, r20	; 0x01
     aea:	5a 83       	std	Y+2, r21	; 0x02
     aec:	6b 83       	std	Y+3, r22	; 0x03
     aee:	7c 83       	std	Y+4, r23	; 0x04
     af0:	59 01       	movw	r10, r18
     af2:	45 ec       	ldi	r20, 0xC5	; 197
     af4:	e4 2e       	mov	r14, r20
     af6:	4d e0       	ldi	r20, 0x0D	; 13
     af8:	f4 2e       	mov	r15, r20
     afa:	00 e0       	ldi	r16, 0x00	; 0
     afc:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     afe:	36 e1       	ldi	r19, 0x16	; 22
     b00:	43 2e       	mov	r4, r19
     b02:	32 e0       	ldi	r19, 0x02	; 2
     b04:	53 2e       	mov	r5, r19
     b06:	3e 01       	movw	r6, r28
     b08:	08 94       	sec
     b0a:	61 1c       	adc	r6, r1
     b0c:	71 1c       	adc	r7, r1
     b0e:	f7 01       	movw	r30, r14
     b10:	80 81       	ld	r24, Z
     b12:	91 81       	ldd	r25, Z+1	; 0x01
     b14:	88 15       	cp	r24, r8
     b16:	99 05       	cpc	r25, r9
     b18:	e1 f4       	brne	.+56     	; 0xb52 <TCP_GetConnectionState+0x94>
     b1a:	04 9d       	mul	r16, r4
     b1c:	60 01       	movw	r12, r0
     b1e:	05 9d       	mul	r16, r5
     b20:	d0 0c       	add	r13, r0
     b22:	14 9d       	mul	r17, r4
     b24:	d0 0c       	add	r13, r0
     b26:	11 24       	eor	r1, r1
     b28:	c6 01       	movw	r24, r12
     b2a:	87 53       	subi	r24, 0x37	; 55
     b2c:	92 4f       	sbci	r25, 0xF2	; 242
     b2e:	b3 01       	movw	r22, r6
     b30:	44 e0       	ldi	r20, 0x04	; 4
     b32:	50 e0       	ldi	r21, 0x00	; 0
     b34:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
     b38:	00 97       	sbiw	r24, 0x00	; 0
     b3a:	59 f4       	brne	.+22     	; 0xb52 <TCP_GetConnectionState+0x94>
     b3c:	f7 01       	movw	r30, r14
     b3e:	82 81       	ldd	r24, Z+2	; 0x02
     b40:	93 81       	ldd	r25, Z+3	; 0x03
     b42:	8a 15       	cp	r24, r10
     b44:	9b 05       	cpc	r25, r11
     b46:	29 f4       	brne	.+10     	; 0xb52 <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     b48:	f6 01       	movw	r30, r12
     b4a:	e6 52       	subi	r30, 0x26	; 38
     b4c:	f0 4f       	sbci	r31, 0xF0	; 240
     b4e:	80 81       	ld	r24, Z
     b50:	0a c0       	rjmp	.+20     	; 0xb66 <TCP_GetConnectionState+0xa8>
     b52:	0f 5f       	subi	r16, 0xFF	; 255
     b54:	1f 4f       	sbci	r17, 0xFF	; 255
     b56:	86 e1       	ldi	r24, 0x16	; 22
     b58:	92 e0       	ldi	r25, 0x02	; 2
     b5a:	e8 0e       	add	r14, r24
     b5c:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     b5e:	03 30       	cpi	r16, 0x03	; 3
     b60:	11 05       	cpc	r17, r1
     b62:	a9 f6       	brne	.-86     	; 0xb0e <TCP_GetConnectionState+0x50>
     b64:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     b66:	0f 90       	pop	r0
     b68:	0f 90       	pop	r0
     b6a:	0f 90       	pop	r0
     b6c:	0f 90       	pop	r0
     b6e:	cf 91       	pop	r28
     b70:	df 91       	pop	r29
     b72:	1f 91       	pop	r17
     b74:	0f 91       	pop	r16
     b76:	ff 90       	pop	r15
     b78:	ef 90       	pop	r14
     b7a:	df 90       	pop	r13
     b7c:	cf 90       	pop	r12
     b7e:	bf 90       	pop	r11
     b80:	af 90       	pop	r10
     b82:	9f 90       	pop	r9
     b84:	8f 90       	pop	r8
     b86:	7f 90       	pop	r7
     b88:	6f 90       	pop	r6
     b8a:	5f 90       	pop	r5
     b8c:	4f 90       	pop	r4
     b8e:	08 95       	ret

00000b90 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     b90:	3f 92       	push	r3
     b92:	4f 92       	push	r4
     b94:	5f 92       	push	r5
     b96:	6f 92       	push	r6
     b98:	7f 92       	push	r7
     b9a:	8f 92       	push	r8
     b9c:	9f 92       	push	r9
     b9e:	af 92       	push	r10
     ba0:	bf 92       	push	r11
     ba2:	cf 92       	push	r12
     ba4:	df 92       	push	r13
     ba6:	ef 92       	push	r14
     ba8:	ff 92       	push	r15
     baa:	0f 93       	push	r16
     bac:	1f 93       	push	r17
     bae:	df 93       	push	r29
     bb0:	cf 93       	push	r28
     bb2:	00 d0       	rcall	.+0      	; 0xbb4 <TCP_SetConnectionState+0x24>
     bb4:	00 d0       	rcall	.+0      	; 0xbb6 <TCP_SetConnectionState+0x26>
     bb6:	cd b7       	in	r28, 0x3d	; 61
     bb8:	de b7       	in	r29, 0x3e	; 62
     bba:	5c 01       	movw	r10, r24
     bbc:	49 83       	std	Y+1, r20	; 0x01
     bbe:	5a 83       	std	Y+2, r21	; 0x02
     bc0:	6b 83       	std	Y+3, r22	; 0x03
     bc2:	7c 83       	std	Y+4, r23	; 0x04
     bc4:	49 01       	movw	r8, r18
     bc6:	30 2e       	mov	r3, r16
     bc8:	75 ec       	ldi	r23, 0xC5	; 197
     bca:	e7 2e       	mov	r14, r23
     bcc:	7d e0       	ldi	r23, 0x0D	; 13
     bce:	f7 2e       	mov	r15, r23
     bd0:	00 e0       	ldi	r16, 0x00	; 0
     bd2:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     bd4:	66 e1       	ldi	r22, 0x16	; 22
     bd6:	46 2e       	mov	r4, r22
     bd8:	62 e0       	ldi	r22, 0x02	; 2
     bda:	56 2e       	mov	r5, r22
     bdc:	3e 01       	movw	r6, r28
     bde:	08 94       	sec
     be0:	61 1c       	adc	r6, r1
     be2:	71 1c       	adc	r7, r1
     be4:	f7 01       	movw	r30, r14
     be6:	80 81       	ld	r24, Z
     be8:	91 81       	ldd	r25, Z+1	; 0x01
     bea:	8a 15       	cp	r24, r10
     bec:	9b 05       	cpc	r25, r11
     bee:	d9 f4       	brne	.+54     	; 0xc26 <TCP_SetConnectionState+0x96>
     bf0:	04 9d       	mul	r16, r4
     bf2:	60 01       	movw	r12, r0
     bf4:	05 9d       	mul	r16, r5
     bf6:	d0 0c       	add	r13, r0
     bf8:	14 9d       	mul	r17, r4
     bfa:	d0 0c       	add	r13, r0
     bfc:	11 24       	eor	r1, r1
     bfe:	c6 01       	movw	r24, r12
     c00:	87 53       	subi	r24, 0x37	; 55
     c02:	92 4f       	sbci	r25, 0xF2	; 242
     c04:	b3 01       	movw	r22, r6
     c06:	44 e0       	ldi	r20, 0x04	; 4
     c08:	50 e0       	ldi	r21, 0x00	; 0
     c0a:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
     c0e:	00 97       	sbiw	r24, 0x00	; 0
     c10:	51 f4       	brne	.+20     	; 0xc26 <TCP_SetConnectionState+0x96>
     c12:	f7 01       	movw	r30, r14
     c14:	82 81       	ldd	r24, Z+2	; 0x02
     c16:	93 81       	ldd	r25, Z+3	; 0x03
     c18:	88 15       	cp	r24, r8
     c1a:	99 05       	cpc	r25, r9
     c1c:	21 f4       	brne	.+8      	; 0xc26 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     c1e:	f6 01       	movw	r30, r12
     c20:	e6 52       	subi	r30, 0x26	; 38
     c22:	f0 4f       	sbci	r31, 0xF0	; 240
     c24:	47 c0       	rjmp	.+142    	; 0xcb4 <TCP_SetConnectionState+0x124>
			return true;
     c26:	0f 5f       	subi	r16, 0xFF	; 255
     c28:	1f 4f       	sbci	r17, 0xFF	; 255
     c2a:	86 e1       	ldi	r24, 0x16	; 22
     c2c:	92 e0       	ldi	r25, 0x02	; 2
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c32:	03 30       	cpi	r16, 0x03	; 3
     c34:	11 05       	cpc	r17, r1
     c36:	b1 f6       	brne	.-84     	; 0xbe4 <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     c38:	80 91 da 0f 	lds	r24, 0x0FDA
     c3c:	8a 30       	cpi	r24, 0x0A	; 10
     c3e:	19 f4       	brne	.+6      	; 0xc46 <TCP_SetConnectionState+0xb6>
     c40:	40 e0       	ldi	r20, 0x00	; 0
     c42:	50 e0       	ldi	r21, 0x00	; 0
     c44:	0f c0       	rjmp	.+30     	; 0xc64 <TCP_SetConnectionState+0xd4>
     c46:	80 91 f0 11 	lds	r24, 0x11F0
     c4a:	8a 30       	cpi	r24, 0x0A	; 10
     c4c:	19 f4       	brne	.+6      	; 0xc54 <TCP_SetConnectionState+0xc4>
     c4e:	41 e0       	ldi	r20, 0x01	; 1
     c50:	50 e0       	ldi	r21, 0x00	; 0
     c52:	08 c0       	rjmp	.+16     	; 0xc64 <TCP_SetConnectionState+0xd4>
     c54:	80 91 06 14 	lds	r24, 0x1406
     c58:	8a 30       	cpi	r24, 0x0A	; 10
     c5a:	11 f0       	breq	.+4      	; 0xc60 <TCP_SetConnectionState+0xd0>
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	2c c0       	rjmp	.+88     	; 0xcb8 <TCP_SetConnectionState+0x128>
     c60:	42 e0       	ldi	r20, 0x02	; 2
     c62:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     c64:	86 e1       	ldi	r24, 0x16	; 22
     c66:	92 e0       	ldi	r25, 0x02	; 2
     c68:	48 9f       	mul	r20, r24
     c6a:	90 01       	movw	r18, r0
     c6c:	49 9f       	mul	r20, r25
     c6e:	30 0d       	add	r19, r0
     c70:	58 9f       	mul	r21, r24
     c72:	30 0d       	add	r19, r0
     c74:	11 24       	eor	r1, r1
     c76:	2b 53       	subi	r18, 0x3B	; 59
     c78:	32 4f       	sbci	r19, 0xF2	; 242
     c7a:	f9 01       	movw	r30, r18
     c7c:	b1 82       	std	Z+1, r11	; 0x01
     c7e:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	9a 81       	ldd	r25, Y+2	; 0x02
     c84:	ab 81       	ldd	r26, Y+3	; 0x03
     c86:	bc 81       	ldd	r27, Y+4	; 0x04
     c88:	84 83       	std	Z+4, r24	; 0x04
     c8a:	95 83       	std	Z+5, r25	; 0x05
     c8c:	a6 83       	std	Z+6, r26	; 0x06
     c8e:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     c90:	8b e0       	ldi	r24, 0x0B	; 11
     c92:	91 e0       	ldi	r25, 0x01	; 1
     c94:	48 9f       	mul	r20, r24
     c96:	f0 01       	movw	r30, r0
     c98:	49 9f       	mul	r20, r25
     c9a:	f0 0d       	add	r31, r0
     c9c:	58 9f       	mul	r21, r24
     c9e:	f0 0d       	add	r31, r0
     ca0:	11 24       	eor	r1, r1
     ca2:	ee 0f       	add	r30, r30
     ca4:	ff 1f       	adc	r31, r31
     ca6:	e9 53       	subi	r30, 0x39	; 57
     ca8:	f2 4f       	sbci	r31, 0xF2	; 242
     caa:	91 82       	std	Z+1, r9	; 0x01
     cac:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     cae:	2b 5e       	subi	r18, 0xEB	; 235
     cb0:	3d 4f       	sbci	r19, 0xFD	; 253
     cb2:	f9 01       	movw	r30, r18
     cb4:	30 82       	st	Z, r3
     cb6:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     cb8:	0f 90       	pop	r0
     cba:	0f 90       	pop	r0
     cbc:	0f 90       	pop	r0
     cbe:	0f 90       	pop	r0
     cc0:	cf 91       	pop	r28
     cc2:	df 91       	pop	r29
     cc4:	1f 91       	pop	r17
     cc6:	0f 91       	pop	r16
     cc8:	ff 90       	pop	r15
     cca:	ef 90       	pop	r14
     ccc:	df 90       	pop	r13
     cce:	cf 90       	pop	r12
     cd0:	bf 90       	pop	r11
     cd2:	af 90       	pop	r10
     cd4:	9f 90       	pop	r9
     cd6:	8f 90       	pop	r8
     cd8:	7f 90       	pop	r7
     cda:	6f 90       	pop	r6
     cdc:	5f 90       	pop	r5
     cde:	4f 90       	pop	r4
     ce0:	3f 90       	pop	r3
     ce2:	08 95       	ret

00000ce4 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     ce4:	af 92       	push	r10
     ce6:	bf 92       	push	r11
     ce8:	cf 92       	push	r12
     cea:	df 92       	push	r13
     cec:	ef 92       	push	r14
     cee:	ff 92       	push	r15
     cf0:	0f 93       	push	r16
     cf2:	1f 93       	push	r17
     cf4:	cf 93       	push	r28
     cf6:	df 93       	push	r29
     cf8:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     cfa:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     cfc:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     cfe:	cb 01       	movw	r24, r22
     d00:	fd dc       	rcall	.-1542   	; 0x6fc <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     d02:	d7 01       	movw	r26, r14
     d04:	12 96       	adiw	r26, 0x02	; 2
     d06:	8d 91       	ld	r24, X+
     d08:	9c 91       	ld	r25, X
     d0a:	13 97       	sbiw	r26, 0x03	; 3
     d0c:	9e dd       	rcall	.-1220   	; 0x84a <TCP_GetPortState>
     d0e:	81 30       	cpi	r24, 0x01	; 1
     d10:	09 f0       	breq	.+2      	; 0xd14 <TCP_ProcessTCPPacket+0x30>
     d12:	2a c2       	rjmp	.+1108   	; 0x1168 <TCP_ProcessTCPPacket+0x484>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     d14:	e7 01       	movw	r28, r14
     d16:	8d 85       	ldd	r24, Y+13	; 0x0d
     d18:	81 ff       	sbrs	r24, 1
     d1a:	0b c0       	rjmp	.+22     	; 0xd32 <TCP_ProcessTCPPacket+0x4e>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     d1c:	f5 01       	movw	r30, r10
     d1e:	44 85       	ldd	r20, Z+12	; 0x0c
     d20:	55 85       	ldd	r21, Z+13	; 0x0d
     d22:	66 85       	ldd	r22, Z+14	; 0x0e
     d24:	77 85       	ldd	r23, Z+15	; 0x0f
     d26:	28 81       	ld	r18, Y
     d28:	39 81       	ldd	r19, Y+1	; 0x01
     d2a:	8a 81       	ldd	r24, Y+2	; 0x02
     d2c:	9b 81       	ldd	r25, Y+3	; 0x03
     d2e:	00 e0       	ldi	r16, 0x00	; 0
     d30:	2f df       	rcall	.-418    	; 0xb90 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     d32:	d7 01       	movw	r26, r14
     d34:	1d 96       	adiw	r26, 0x0d	; 13
     d36:	8c 91       	ld	r24, X
     d38:	1d 97       	sbiw	r26, 0x0d	; 13
     d3a:	12 96       	adiw	r26, 0x02	; 2
     d3c:	ed 91       	ld	r30, X+
     d3e:	fc 91       	ld	r31, X
     d40:	13 97       	sbiw	r26, 0x03	; 3
     d42:	e5 01       	movw	r28, r10
     d44:	4c 85       	ldd	r20, Y+12	; 0x0c
     d46:	5d 85       	ldd	r21, Y+13	; 0x0d
     d48:	6e 85       	ldd	r22, Y+14	; 0x0e
     d4a:	7f 85       	ldd	r23, Y+15	; 0x0f
     d4c:	2d 91       	ld	r18, X+
     d4e:	3c 91       	ld	r19, X
     d50:	82 ff       	sbrs	r24, 2
     d52:	08 c0       	rjmp	.+16     	; 0xd64 <TCP_ProcessTCPPacket+0x80>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     d54:	cf 01       	movw	r24, r30
     d56:	0a e0       	ldi	r16, 0x0A	; 10
     d58:	1b df       	rcall	.-458    	; 0xb90 <TCP_SetConnectionState>
     d5a:	88 23       	and	r24, r24
     d5c:	09 f4       	brne	.+2      	; 0xd60 <TCP_ProcessTCPPacket+0x7c>
     d5e:	38 c2       	rjmp	.+1136   	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     d60:	84 e1       	ldi	r24, 0x14	; 20
     d62:	5d c0       	rjmp	.+186    	; 0xe1e <TCP_ProcessTCPPacket+0x13a>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     d64:	cf 01       	movw	r24, r30
     d66:	ab de       	rcall	.-682    	; 0xabe <TCP_GetConnectionState>
     d68:	84 30       	cpi	r24, 0x04	; 4
     d6a:	09 f4       	brne	.+2      	; 0xd6e <TCP_ProcessTCPPacket+0x8a>
     d6c:	68 c1       	rjmp	.+720    	; 0x103e <TCP_ProcessTCPPacket+0x35a>
     d6e:	85 30       	cpi	r24, 0x05	; 5
     d70:	48 f4       	brcc	.+18     	; 0xd84 <TCP_ProcessTCPPacket+0xa0>
     d72:	82 30       	cpi	r24, 0x02	; 2
     d74:	09 f4       	brne	.+2      	; 0xd78 <TCP_ProcessTCPPacket+0x94>
     d76:	56 c0       	rjmp	.+172    	; 0xe24 <TCP_ProcessTCPPacket+0x140>
     d78:	83 30       	cpi	r24, 0x03	; 3
     d7a:	08 f0       	brcs	.+2      	; 0xd7e <TCP_ProcessTCPPacket+0x9a>
     d7c:	7f c0       	rjmp	.+254    	; 0xe7c <TCP_ProcessTCPPacket+0x198>
     d7e:	88 23       	and	r24, r24
     d80:	59 f0       	breq	.+22     	; 0xd98 <TCP_ProcessTCPPacket+0xb4>
     d82:	26 c2       	rjmp	.+1100   	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
     d84:	86 30       	cpi	r24, 0x06	; 6
     d86:	09 f4       	brne	.+2      	; 0xd8a <TCP_ProcessTCPPacket+0xa6>
     d88:	dc c1       	rjmp	.+952    	; 0x1142 <TCP_ProcessTCPPacket+0x45e>
     d8a:	86 30       	cpi	r24, 0x06	; 6
     d8c:	08 f4       	brcc	.+2      	; 0xd90 <TCP_ProcessTCPPacket+0xac>
     d8e:	9e c1       	rjmp	.+828    	; 0x10cc <TCP_ProcessTCPPacket+0x3e8>
     d90:	87 30       	cpi	r24, 0x07	; 7
     d92:	09 f0       	breq	.+2      	; 0xd96 <TCP_ProcessTCPPacket+0xb2>
     d94:	1d c2       	rjmp	.+1082   	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
     d96:	35 c1       	rjmp	.+618    	; 0x1002 <TCP_ProcessTCPPacket+0x31e>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     d98:	d7 01       	movw	r26, r14
     d9a:	1d 96       	adiw	r26, 0x0d	; 13
     d9c:	8c 91       	ld	r24, X
     d9e:	1d 97       	sbiw	r26, 0x0d	; 13
     da0:	82 30       	cpi	r24, 0x02	; 2
     da2:	09 f0       	breq	.+2      	; 0xda6 <TCP_ProcessTCPPacket+0xc2>
     da4:	15 c2       	rjmp	.+1066   	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     da6:	e5 01       	movw	r28, r10
     da8:	4c 85       	ldd	r20, Y+12	; 0x0c
     daa:	5d 85       	ldd	r21, Y+13	; 0x0d
     dac:	6e 85       	ldd	r22, Y+14	; 0x0e
     dae:	7f 85       	ldd	r23, Y+15	; 0x0f
     db0:	2d 91       	ld	r18, X+
     db2:	3c 91       	ld	r19, X
     db4:	11 97       	sbiw	r26, 0x01	; 1
     db6:	12 96       	adiw	r26, 0x02	; 2
     db8:	8d 91       	ld	r24, X+
     dba:	9c 91       	ld	r25, X
     dbc:	13 97       	sbiw	r26, 0x03	; 3
     dbe:	02 e0       	ldi	r16, 0x02	; 2
     dc0:	e7 de       	rcall	.-562    	; 0xb90 <TCP_SetConnectionState>
     dc2:	88 23       	and	r24, r24
     dc4:	59 f1       	breq	.+86     	; 0xe1c <TCP_ProcessTCPPacket+0x138>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     dc6:	82 e1       	ldi	r24, 0x12	; 18
     dc8:	f6 01       	movw	r30, r12
     dca:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     dcc:	4c 85       	ldd	r20, Y+12	; 0x0c
     dce:	5d 85       	ldd	r21, Y+13	; 0x0d
     dd0:	6e 85       	ldd	r22, Y+14	; 0x0e
     dd2:	7f 85       	ldd	r23, Y+15	; 0x0f
     dd4:	d7 01       	movw	r26, r14
     dd6:	2d 91       	ld	r18, X+
     dd8:	3c 91       	ld	r19, X
     dda:	11 97       	sbiw	r26, 0x01	; 1
     ddc:	12 96       	adiw	r26, 0x02	; 2
     dde:	8d 91       	ld	r24, X+
     de0:	9c 91       	ld	r25, X
     de2:	13 97       	sbiw	r26, 0x03	; 3
     de4:	02 de       	rcall	.-1020   	; 0x9ea <TCP_GetConnectionInfo>
     de6:	fc 01       	movw	r30, r24
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
     de8:	e7 01       	movw	r28, r14
     dea:	8c 81       	ldd	r24, Y+4	; 0x04
     dec:	9d 81       	ldd	r25, Y+5	; 0x05
     dee:	ae 81       	ldd	r26, Y+6	; 0x06
     df0:	bf 81       	ldd	r27, Y+7	; 0x07

				Temp = Data.Bytes[0];
     df2:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[3];
     df4:	8b 2f       	mov	r24, r27
				Data.Bytes[3] = Temp;
     df6:	b2 2f       	mov	r27, r18

				Temp = Data.Bytes[1];
     df8:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
     dfa:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
     dfc:	a2 2f       	mov	r26, r18

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     dfe:	01 96       	adiw	r24, 0x01	; 1
     e00:	a1 1d       	adc	r26, r1
     e02:	b1 1d       	adc	r27, r1
     e04:	80 83       	st	Z, r24
     e06:	91 83       	std	Z+1, r25	; 0x01
     e08:	a2 83       	std	Z+2, r26	; 0x02
     e0a:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
     e0c:	14 82       	std	Z+4, r1	; 0x04
     e0e:	15 82       	std	Z+5, r1	; 0x05
     e10:	16 82       	std	Z+6, r1	; 0x06
     e12:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
     e14:	e4 5f       	subi	r30, 0xF4	; 244
     e16:	fd 4f       	sbci	r31, 0xFD	; 253
     e18:	10 82       	st	Z, r1
     e1a:	e8 c1       	rjmp	.+976    	; 0x11ec <TCP_ProcessTCPPacket+0x508>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     e1c:	84 e0       	ldi	r24, 0x04	; 4
     e1e:	f6 01       	movw	r30, r12
     e20:	85 87       	std	Z+13, r24	; 0x0d
     e22:	e4 c1       	rjmp	.+968    	; 0x11ec <TCP_ProcessTCPPacket+0x508>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     e24:	d7 01       	movw	r26, r14
     e26:	1d 96       	adiw	r26, 0x0d	; 13
     e28:	8c 91       	ld	r24, X
     e2a:	1d 97       	sbiw	r26, 0x0d	; 13
     e2c:	80 31       	cpi	r24, 0x10	; 16
     e2e:	09 f0       	breq	.+2      	; 0xe32 <TCP_ProcessTCPPacket+0x14e>
     e30:	cf c1       	rjmp	.+926    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e32:	e5 01       	movw	r28, r10
     e34:	4c 85       	ldd	r20, Y+12	; 0x0c
     e36:	5d 85       	ldd	r21, Y+13	; 0x0d
     e38:	6e 85       	ldd	r22, Y+14	; 0x0e
     e3a:	7f 85       	ldd	r23, Y+15	; 0x0f
     e3c:	2d 91       	ld	r18, X+
     e3e:	3c 91       	ld	r19, X
     e40:	11 97       	sbiw	r26, 0x01	; 1
     e42:	12 96       	adiw	r26, 0x02	; 2
     e44:	8d 91       	ld	r24, X+
     e46:	9c 91       	ld	r25, X
     e48:	13 97       	sbiw	r26, 0x03	; 3
     e4a:	03 e0       	ldi	r16, 0x03	; 3
     e4c:	a1 de       	rcall	.-702    	; 0xb90 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e4e:	4c 85       	ldd	r20, Y+12	; 0x0c
     e50:	5d 85       	ldd	r21, Y+13	; 0x0d
     e52:	6e 85       	ldd	r22, Y+14	; 0x0e
     e54:	7f 85       	ldd	r23, Y+15	; 0x0f
     e56:	f7 01       	movw	r30, r14
     e58:	20 81       	ld	r18, Z
     e5a:	31 81       	ldd	r19, Z+1	; 0x01
     e5c:	82 81       	ldd	r24, Z+2	; 0x02
     e5e:	93 81       	ldd	r25, Z+3	; 0x03
     e60:	c4 dd       	rcall	.-1144   	; 0x9ea <TCP_GetConnectionInfo>
     e62:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     e64:	84 81       	ldd	r24, Z+4	; 0x04
     e66:	95 81       	ldd	r25, Z+5	; 0x05
     e68:	a6 81       	ldd	r26, Z+6	; 0x06
     e6a:	b7 81       	ldd	r27, Z+7	; 0x07
     e6c:	01 96       	adiw	r24, 0x01	; 1
     e6e:	a1 1d       	adc	r26, r1
     e70:	b1 1d       	adc	r27, r1
     e72:	84 83       	std	Z+4, r24	; 0x04
     e74:	95 83       	std	Z+5, r25	; 0x05
     e76:	a6 83       	std	Z+6, r26	; 0x06
     e78:	b7 83       	std	Z+7, r27	; 0x07
     e7a:	aa c1       	rjmp	.+852    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     e7c:	d7 01       	movw	r26, r14
     e7e:	1d 96       	adiw	r26, 0x0d	; 13
     e80:	8c 91       	ld	r24, X
     e82:	1d 97       	sbiw	r26, 0x0d	; 13
     e84:	81 31       	cpi	r24, 0x11	; 17
     e86:	a9 f5       	brne	.+106    	; 0xef2 <TCP_ProcessTCPPacket+0x20e>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     e88:	e6 01       	movw	r28, r12
     e8a:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e8c:	f5 01       	movw	r30, r10
     e8e:	44 85       	ldd	r20, Z+12	; 0x0c
     e90:	55 85       	ldd	r21, Z+13	; 0x0d
     e92:	66 85       	ldd	r22, Z+14	; 0x0e
     e94:	77 85       	ldd	r23, Z+15	; 0x0f
     e96:	2d 91       	ld	r18, X+
     e98:	3c 91       	ld	r19, X
     e9a:	11 97       	sbiw	r26, 0x01	; 1
     e9c:	12 96       	adiw	r26, 0x02	; 2
     e9e:	8d 91       	ld	r24, X+
     ea0:	9c 91       	ld	r25, X
     ea2:	13 97       	sbiw	r26, 0x03	; 3
     ea4:	06 e0       	ldi	r16, 0x06	; 6
     ea6:	74 de       	rcall	.-792    	; 0xb90 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     ea8:	d5 01       	movw	r26, r10
     eaa:	1c 96       	adiw	r26, 0x0c	; 12
     eac:	4d 91       	ld	r20, X+
     eae:	5d 91       	ld	r21, X+
     eb0:	6d 91       	ld	r22, X+
     eb2:	7c 91       	ld	r23, X
     eb4:	1f 97       	sbiw	r26, 0x0f	; 15
     eb6:	e7 01       	movw	r28, r14
     eb8:	28 81       	ld	r18, Y
     eba:	39 81       	ldd	r19, Y+1	; 0x01
     ebc:	8a 81       	ldd	r24, Y+2	; 0x02
     ebe:	9b 81       	ldd	r25, Y+3	; 0x03
     ec0:	94 dd       	rcall	.-1240   	; 0x9ea <TCP_GetConnectionInfo>
     ec2:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     ec4:	80 81       	ld	r24, Z
     ec6:	91 81       	ldd	r25, Z+1	; 0x01
     ec8:	a2 81       	ldd	r26, Z+2	; 0x02
     eca:	b3 81       	ldd	r27, Z+3	; 0x03
     ecc:	01 96       	adiw	r24, 0x01	; 1
     ece:	a1 1d       	adc	r26, r1
     ed0:	b1 1d       	adc	r27, r1
     ed2:	80 83       	st	Z, r24
     ed4:	91 83       	std	Z+1, r25	; 0x01
     ed6:	a2 83       	std	Z+2, r26	; 0x02
     ed8:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     eda:	84 81       	ldd	r24, Z+4	; 0x04
     edc:	95 81       	ldd	r25, Z+5	; 0x05
     ede:	a6 81       	ldd	r26, Z+6	; 0x06
     ee0:	b7 81       	ldd	r27, Z+7	; 0x07
     ee2:	01 96       	adiw	r24, 0x01	; 1
     ee4:	a1 1d       	adc	r26, r1
     ee6:	b1 1d       	adc	r27, r1
     ee8:	84 83       	std	Z+4, r24	; 0x04
     eea:	95 83       	std	Z+5, r25	; 0x05
     eec:	a6 83       	std	Z+6, r26	; 0x06
     eee:	b7 83       	std	Z+7, r27	; 0x07
     ef0:	7d c1       	rjmp	.+762    	; 0x11ec <TCP_ProcessTCPPacket+0x508>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     ef2:	80 31       	cpi	r24, 0x10	; 16
     ef4:	19 f0       	breq	.+6      	; 0xefc <TCP_ProcessTCPPacket+0x218>
     ef6:	88 31       	cpi	r24, 0x18	; 24
     ef8:	09 f0       	breq	.+2      	; 0xefc <TCP_ProcessTCPPacket+0x218>
     efa:	6a c1       	rjmp	.+724    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     efc:	f5 01       	movw	r30, r10
     efe:	44 85       	ldd	r20, Z+12	; 0x0c
     f00:	55 85       	ldd	r21, Z+13	; 0x0d
     f02:	66 85       	ldd	r22, Z+14	; 0x0e
     f04:	77 85       	ldd	r23, Z+15	; 0x0f
     f06:	d7 01       	movw	r26, r14
     f08:	2d 91       	ld	r18, X+
     f0a:	3c 91       	ld	r19, X
     f0c:	11 97       	sbiw	r26, 0x01	; 1
     f0e:	12 96       	adiw	r26, 0x02	; 2
     f10:	8d 91       	ld	r24, X+
     f12:	9c 91       	ld	r25, X
     f14:	13 97       	sbiw	r26, 0x03	; 3
     f16:	69 dd       	rcall	.-1326   	; 0x9ea <TCP_GetConnectionInfo>
     f18:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     f1a:	fc 01       	movw	r30, r24
     f1c:	e4 5f       	subi	r30, 0xF4	; 244
     f1e:	fd 4f       	sbci	r31, 0xFD	; 253
     f20:	80 81       	ld	r24, Z
     f22:	88 23       	and	r24, r24
     f24:	81 f4       	brne	.+32     	; 0xf46 <TCP_ProcessTCPPacket+0x262>
     f26:	c5 5f       	subi	r28, 0xF5	; 245
     f28:	dd 4f       	sbci	r29, 0xFD	; 253
     f2a:	88 81       	ld	r24, Y
     f2c:	cb 50       	subi	r28, 0x0B	; 11
     f2e:	d2 40       	sbci	r29, 0x02	; 2
     f30:	88 23       	and	r24, r24
     f32:	49 f4       	brne	.+18     	; 0xf46 <TCP_ProcessTCPPacket+0x262>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     f34:	c6 5f       	subi	r28, 0xF6	; 246
     f36:	dd 4f       	sbci	r29, 0xFD	; 253
     f38:	18 82       	st	Y, r1
     f3a:	ca 50       	subi	r28, 0x0A	; 10
     f3c:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
     f42:	19 86       	std	Y+9, r1	; 0x09
     f44:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     f46:	c6 5f       	subi	r28, 0xF6	; 246
     f48:	dd 4f       	sbci	r29, 0xFD	; 253
     f4a:	88 81       	ld	r24, Y
     f4c:	ca 50       	subi	r28, 0x0A	; 10
     f4e:	d2 40       	sbci	r29, 0x02	; 2
     f50:	88 23       	and	r24, r24
     f52:	09 f0       	breq	.+2      	; 0xf56 <TCP_ProcessTCPPacket+0x272>
     f54:	3a c1       	rjmp	.+628    	; 0x11ca <TCP_ProcessTCPPacket+0x4e6>
     f56:	68 85       	ldd	r22, Y+8	; 0x08
     f58:	79 85       	ldd	r23, Y+9	; 0x09
     f5a:	b2 e0       	ldi	r27, 0x02	; 2
     f5c:	60 30       	cpi	r22, 0x00	; 0
     f5e:	7b 07       	cpc	r23, r27
     f60:	09 f4       	brne	.+2      	; 0xf64 <TCP_ProcessTCPPacket+0x280>
     f62:	33 c1       	rjmp	.+614    	; 0x11ca <TCP_ProcessTCPPacket+0x4e6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     f64:	f5 01       	movw	r30, r10
     f66:	20 81       	ld	r18, Z
     f68:	2f 70       	andi	r18, 0x0F	; 15
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	22 0f       	add	r18, r18
     f6e:	33 1f       	adc	r19, r19
     f70:	22 0f       	add	r18, r18
     f72:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     f74:	d7 01       	movw	r26, r14
     f76:	1c 96       	adiw	r26, 0x0c	; 12
     f78:	8c 91       	ld	r24, X
     f7a:	82 95       	swap	r24
     f7c:	8f 70       	andi	r24, 0x0F	; 15
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	88 0f       	add	r24, r24
     f82:	99 1f       	adc	r25, r25
     f84:	88 0f       	add	r24, r24
     f86:	99 1f       	adc	r25, r25
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     f88:	02 81       	ldd	r16, Z+2	; 0x02
     f8a:	13 81       	ldd	r17, Z+3	; 0x03

				Temp = Data.Bytes[0];
     f8c:	40 2f       	mov	r20, r16
				Data.Bytes[0] = Data.Bytes[1];
     f8e:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     f90:	14 2f       	mov	r17, r20
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     f92:	02 1b       	sub	r16, r18
     f94:	13 0b       	sbc	r17, r19
     f96:	08 1b       	sub	r16, r24
     f98:	19 0b       	sbc	r17, r25

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     f9a:	9b 01       	movw	r18, r22
     f9c:	26 5f       	subi	r18, 0xF6	; 246
     f9e:	3f 4f       	sbci	r19, 0xFF	; 255
     fa0:	2c 0f       	add	r18, r28
     fa2:	3d 1f       	adc	r19, r29
     fa4:	a7 01       	movw	r20, r14
     fa6:	48 0f       	add	r20, r24
     fa8:	59 1f       	adc	r21, r25
     faa:	c9 01       	movw	r24, r18
     fac:	ba 01       	movw	r22, r20
     fae:	a8 01       	movw	r20, r16
     fb0:	0e 94 c2 16 	call	0x2d84	; 0x2d84 <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
     fb4:	98 01       	movw	r18, r16
     fb6:	40 e0       	ldi	r20, 0x00	; 0
     fb8:	50 e0       	ldi	r21, 0x00	; 0
     fba:	88 81       	ld	r24, Y
     fbc:	99 81       	ldd	r25, Y+1	; 0x01
     fbe:	aa 81       	ldd	r26, Y+2	; 0x02
     fc0:	bb 81       	ldd	r27, Y+3	; 0x03
     fc2:	82 0f       	add	r24, r18
     fc4:	93 1f       	adc	r25, r19
     fc6:	a4 1f       	adc	r26, r20
     fc8:	b5 1f       	adc	r27, r21
     fca:	88 83       	st	Y, r24
     fcc:	99 83       	std	Y+1, r25	; 0x01
     fce:	aa 83       	std	Y+2, r26	; 0x02
     fd0:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
     fd2:	88 85       	ldd	r24, Y+8	; 0x08
     fd4:	99 85       	ldd	r25, Y+9	; 0x09
     fd6:	80 0f       	add	r24, r16
     fd8:	91 1f       	adc	r25, r17
     fda:	99 87       	std	Y+9, r25	; 0x09
     fdc:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
     fde:	80 50       	subi	r24, 0x00	; 0
     fe0:	92 40       	sbci	r25, 0x02	; 2
     fe2:	21 f0       	breq	.+8      	; 0xfec <TCP_ProcessTCPPacket+0x308>
     fe4:	f7 01       	movw	r30, r14
     fe6:	85 85       	ldd	r24, Z+13	; 0x0d
     fe8:	83 ff       	sbrs	r24, 3
     fea:	f2 c0       	rjmp	.+484    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
							{
								ConnectionInfo->Buffer.InUse = false;
     fec:	c4 5f       	subi	r28, 0xF4	; 244
     fee:	dd 4f       	sbci	r29, 0xFD	; 253
     ff0:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
     ff2:	fe 01       	movw	r30, r28
     ff4:	81 e0       	ldi	r24, 0x01	; 1
     ff6:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
     ff8:	80 e1       	ldi	r24, 0x10	; 16
     ffa:	d6 01       	movw	r26, r12
     ffc:	1d 96       	adiw	r26, 0x0d	; 13
     ffe:	8c 93       	st	X, r24
    1000:	f5 c0       	rjmp	.+490    	; 0x11ec <TCP_ProcessTCPPacket+0x508>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1002:	e5 01       	movw	r28, r10
    1004:	4c 85       	ldd	r20, Y+12	; 0x0c
    1006:	5d 85       	ldd	r21, Y+13	; 0x0d
    1008:	6e 85       	ldd	r22, Y+14	; 0x0e
    100a:	7f 85       	ldd	r23, Y+15	; 0x0f
    100c:	f7 01       	movw	r30, r14
    100e:	20 81       	ld	r18, Z
    1010:	31 81       	ldd	r19, Z+1	; 0x01
    1012:	82 81       	ldd	r24, Z+2	; 0x02
    1014:	93 81       	ldd	r25, Z+3	; 0x03
    1016:	e9 dc       	rcall	.-1582   	; 0x9ea <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1018:	21 e1       	ldi	r18, 0x11	; 17
    101a:	d6 01       	movw	r26, r12
    101c:	1d 96       	adiw	r26, 0x0d	; 13
    101e:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1020:	fc 01       	movw	r30, r24
    1022:	e4 5f       	subi	r30, 0xF4	; 244
    1024:	fd 4f       	sbci	r31, 0xFD	; 253
    1026:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1028:	4c 85       	ldd	r20, Y+12	; 0x0c
    102a:	5d 85       	ldd	r21, Y+13	; 0x0d
    102c:	6e 85       	ldd	r22, Y+14	; 0x0e
    102e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1030:	e7 01       	movw	r28, r14
    1032:	28 81       	ld	r18, Y
    1034:	39 81       	ldd	r19, Y+1	; 0x01
    1036:	8a 81       	ldd	r24, Y+2	; 0x02
    1038:	9b 81       	ldd	r25, Y+3	; 0x03
    103a:	04 e0       	ldi	r16, 0x04	; 4
    103c:	80 c0       	rjmp	.+256    	; 0x113e <TCP_ProcessTCPPacket+0x45a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    103e:	f7 01       	movw	r30, r14
    1040:	85 85       	ldd	r24, Z+13	; 0x0d
    1042:	81 31       	cpi	r24, 0x11	; 17
    1044:	a1 f5       	brne	.+104    	; 0x10ae <TCP_ProcessTCPPacket+0x3ca>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1046:	d5 01       	movw	r26, r10
    1048:	1c 96       	adiw	r26, 0x0c	; 12
    104a:	4d 91       	ld	r20, X+
    104c:	5d 91       	ld	r21, X+
    104e:	6d 91       	ld	r22, X+
    1050:	7c 91       	ld	r23, X
    1052:	1f 97       	sbiw	r26, 0x0f	; 15
    1054:	20 81       	ld	r18, Z
    1056:	31 81       	ldd	r19, Z+1	; 0x01
    1058:	82 81       	ldd	r24, Z+2	; 0x02
    105a:	93 81       	ldd	r25, Z+3	; 0x03
    105c:	c6 dc       	rcall	.-1652   	; 0x9ea <TCP_GetConnectionInfo>
    105e:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1060:	80 e1       	ldi	r24, 0x10	; 16
    1062:	e6 01       	movw	r28, r12
    1064:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1066:	80 81       	ld	r24, Z
    1068:	91 81       	ldd	r25, Z+1	; 0x01
    106a:	a2 81       	ldd	r26, Z+2	; 0x02
    106c:	b3 81       	ldd	r27, Z+3	; 0x03
    106e:	01 96       	adiw	r24, 0x01	; 1
    1070:	a1 1d       	adc	r26, r1
    1072:	b1 1d       	adc	r27, r1
    1074:	80 83       	st	Z, r24
    1076:	91 83       	std	Z+1, r25	; 0x01
    1078:	a2 83       	std	Z+2, r26	; 0x02
    107a:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    107c:	84 81       	ldd	r24, Z+4	; 0x04
    107e:	95 81       	ldd	r25, Z+5	; 0x05
    1080:	a6 81       	ldd	r26, Z+6	; 0x06
    1082:	b7 81       	ldd	r27, Z+7	; 0x07
    1084:	01 96       	adiw	r24, 0x01	; 1
    1086:	a1 1d       	adc	r26, r1
    1088:	b1 1d       	adc	r27, r1
    108a:	84 83       	std	Z+4, r24	; 0x04
    108c:	95 83       	std	Z+5, r25	; 0x05
    108e:	a6 83       	std	Z+6, r26	; 0x06
    1090:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1092:	f5 01       	movw	r30, r10
    1094:	44 85       	ldd	r20, Z+12	; 0x0c
    1096:	55 85       	ldd	r21, Z+13	; 0x0d
    1098:	66 85       	ldd	r22, Z+14	; 0x0e
    109a:	77 85       	ldd	r23, Z+15	; 0x0f
    109c:	d7 01       	movw	r26, r14
    109e:	2d 91       	ld	r18, X+
    10a0:	3c 91       	ld	r19, X
    10a2:	11 97       	sbiw	r26, 0x01	; 1
    10a4:	12 96       	adiw	r26, 0x02	; 2
    10a6:	8d 91       	ld	r24, X+
    10a8:	9c 91       	ld	r25, X
    10aa:	13 97       	sbiw	r26, 0x03	; 3
    10ac:	47 c0       	rjmp	.+142    	; 0x113c <TCP_ProcessTCPPacket+0x458>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    10ae:	80 31       	cpi	r24, 0x10	; 16
    10b0:	09 f0       	breq	.+2      	; 0x10b4 <TCP_ProcessTCPPacket+0x3d0>
    10b2:	8e c0       	rjmp	.+284    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10b4:	e5 01       	movw	r28, r10
    10b6:	4c 85       	ldd	r20, Y+12	; 0x0c
    10b8:	5d 85       	ldd	r21, Y+13	; 0x0d
    10ba:	6e 85       	ldd	r22, Y+14	; 0x0e
    10bc:	7f 85       	ldd	r23, Y+15	; 0x0f
    10be:	f7 01       	movw	r30, r14
    10c0:	20 81       	ld	r18, Z
    10c2:	31 81       	ldd	r19, Z+1	; 0x01
    10c4:	82 81       	ldd	r24, Z+2	; 0x02
    10c6:	93 81       	ldd	r25, Z+3	; 0x03
    10c8:	05 e0       	ldi	r16, 0x05	; 5
    10ca:	4c c0       	rjmp	.+152    	; 0x1164 <TCP_ProcessTCPPacket+0x480>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    10cc:	d7 01       	movw	r26, r14
    10ce:	1d 96       	adiw	r26, 0x0d	; 13
    10d0:	8c 91       	ld	r24, X
    10d2:	1d 97       	sbiw	r26, 0x0d	; 13
    10d4:	81 31       	cpi	r24, 0x11	; 17
    10d6:	09 f0       	breq	.+2      	; 0x10da <TCP_ProcessTCPPacket+0x3f6>
    10d8:	7b c0       	rjmp	.+246    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10da:	e5 01       	movw	r28, r10
    10dc:	4c 85       	ldd	r20, Y+12	; 0x0c
    10de:	5d 85       	ldd	r21, Y+13	; 0x0d
    10e0:	6e 85       	ldd	r22, Y+14	; 0x0e
    10e2:	7f 85       	ldd	r23, Y+15	; 0x0f
    10e4:	2d 91       	ld	r18, X+
    10e6:	3c 91       	ld	r19, X
    10e8:	11 97       	sbiw	r26, 0x01	; 1
    10ea:	12 96       	adiw	r26, 0x02	; 2
    10ec:	8d 91       	ld	r24, X+
    10ee:	9c 91       	ld	r25, X
    10f0:	13 97       	sbiw	r26, 0x03	; 3
    10f2:	7b dc       	rcall	.-1802   	; 0x9ea <TCP_GetConnectionInfo>
    10f4:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    10f6:	80 e1       	ldi	r24, 0x10	; 16
    10f8:	d6 01       	movw	r26, r12
    10fa:	1d 96       	adiw	r26, 0x0d	; 13
    10fc:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    10fe:	80 81       	ld	r24, Z
    1100:	91 81       	ldd	r25, Z+1	; 0x01
    1102:	a2 81       	ldd	r26, Z+2	; 0x02
    1104:	b3 81       	ldd	r27, Z+3	; 0x03
    1106:	01 96       	adiw	r24, 0x01	; 1
    1108:	a1 1d       	adc	r26, r1
    110a:	b1 1d       	adc	r27, r1
    110c:	80 83       	st	Z, r24
    110e:	91 83       	std	Z+1, r25	; 0x01
    1110:	a2 83       	std	Z+2, r26	; 0x02
    1112:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1114:	84 81       	ldd	r24, Z+4	; 0x04
    1116:	95 81       	ldd	r25, Z+5	; 0x05
    1118:	a6 81       	ldd	r26, Z+6	; 0x06
    111a:	b7 81       	ldd	r27, Z+7	; 0x07
    111c:	01 96       	adiw	r24, 0x01	; 1
    111e:	a1 1d       	adc	r26, r1
    1120:	b1 1d       	adc	r27, r1
    1122:	84 83       	std	Z+4, r24	; 0x04
    1124:	95 83       	std	Z+5, r25	; 0x05
    1126:	a6 83       	std	Z+6, r26	; 0x06
    1128:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    112a:	4c 85       	ldd	r20, Y+12	; 0x0c
    112c:	5d 85       	ldd	r21, Y+13	; 0x0d
    112e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1130:	7f 85       	ldd	r23, Y+15	; 0x0f
    1132:	e7 01       	movw	r28, r14
    1134:	28 81       	ld	r18, Y
    1136:	39 81       	ldd	r19, Y+1	; 0x01
    1138:	8a 81       	ldd	r24, Y+2	; 0x02
    113a:	9b 81       	ldd	r25, Y+3	; 0x03
    113c:	0a e0       	ldi	r16, 0x0A	; 10
    113e:	28 dd       	rcall	.-1456   	; 0xb90 <TCP_SetConnectionState>
    1140:	55 c0       	rjmp	.+170    	; 0x11ec <TCP_ProcessTCPPacket+0x508>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1142:	f7 01       	movw	r30, r14
    1144:	85 85       	ldd	r24, Z+13	; 0x0d
    1146:	80 31       	cpi	r24, 0x10	; 16
    1148:	09 f0       	breq	.+2      	; 0x114c <TCP_ProcessTCPPacket+0x468>
    114a:	42 c0       	rjmp	.+132    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    114c:	d5 01       	movw	r26, r10
    114e:	1c 96       	adiw	r26, 0x0c	; 12
    1150:	4d 91       	ld	r20, X+
    1152:	5d 91       	ld	r21, X+
    1154:	6d 91       	ld	r22, X+
    1156:	7c 91       	ld	r23, X
    1158:	1f 97       	sbiw	r26, 0x0f	; 15
    115a:	20 81       	ld	r18, Z
    115c:	31 81       	ldd	r19, Z+1	; 0x01
    115e:	82 81       	ldd	r24, Z+2	; 0x02
    1160:	93 81       	ldd	r25, Z+3	; 0x03
    1162:	0a e0       	ldi	r16, 0x0A	; 10
    1164:	15 dd       	rcall	.-1494   	; 0xb90 <TCP_SetConnectionState>
    1166:	34 c0       	rjmp	.+104    	; 0x11d0 <TCP_ProcessTCPPacket+0x4ec>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1168:	84 e1       	ldi	r24, 0x14	; 20
    116a:	e6 01       	movw	r28, r12
    116c:	8d 87       	std	Y+13, r24	; 0x0d
    116e:	3e c0       	rjmp	.+124    	; 0x11ec <TCP_ProcessTCPPacket+0x508>
    1170:	82 e0       	ldi	r24, 0x02	; 2
    1172:	90 e0       	ldi	r25, 0x00	; 0
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    1174:	f6 01       	movw	r30, r12
    1176:	97 87       	std	Z+15, r25	; 0x0f
    1178:	86 87       	std	Z+14, r24	; 0x0e
    117a:	0c c0       	rjmp	.+24     	; 0x1194 <TCP_ProcessTCPPacket+0x4b0>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    117c:	80 e0       	ldi	r24, 0x00	; 0
    117e:	92 e0       	ldi	r25, 0x02	; 2
    1180:	20 85       	ldd	r18, Z+8	; 0x08
    1182:	31 85       	ldd	r19, Z+9	; 0x09
    1184:	82 1b       	sub	r24, r18
    1186:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1188:	d6 01       	movw	r26, r12
    118a:	1e 96       	adiw	r26, 0x0e	; 14
    118c:	9c 93       	st	X, r25
    118e:	1e 97       	sbiw	r26, 0x0e	; 14
    1190:	1f 96       	adiw	r26, 0x0f	; 15
    1192:	8c 93       	st	X, r24

		TCPHeaderOUT->UrgentPointer        = 0;
    1194:	e6 01       	movw	r28, r12
    1196:	1b 8a       	std	Y+19, r1	; 0x13
    1198:	1a 8a       	std	Y+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    119a:	19 8a       	std	Y+17, r1	; 0x11
    119c:	18 8a       	std	Y+16, r1	; 0x10
		TCPHeaderOUT->Reserved             = 0;
    119e:	8c 85       	ldd	r24, Y+12	; 0x0c
    11a0:	80 7f       	andi	r24, 0xF0	; 240
    11a2:	8c 87       	std	Y+12, r24	; 0x0c

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    11a4:	f5 01       	movw	r30, r10
    11a6:	40 89       	ldd	r20, Z+16	; 0x10
    11a8:	51 89       	ldd	r21, Z+17	; 0x11
    11aa:	62 89       	ldd	r22, Z+18	; 0x12
    11ac:	73 89       	ldd	r23, Z+19	; 0x13
    11ae:	04 85       	ldd	r16, Z+12	; 0x0c
    11b0:	15 85       	ldd	r17, Z+13	; 0x0d
    11b2:	26 85       	ldd	r18, Z+14	; 0x0e
    11b4:	37 85       	ldd	r19, Z+15	; 0x0f
    11b6:	c6 01       	movw	r24, r12
    11b8:	e4 e1       	ldi	r30, 0x14	; 20
    11ba:	ee 2e       	mov	r14, r30
    11bc:	f1 2c       	mov	r15, r1
    11be:	70 db       	rcall	.-2336   	; 0x8a0 <TCP_Checksum16>
    11c0:	99 8b       	std	Y+17, r25	; 0x11
    11c2:	88 8b       	std	Y+16, r24	; 0x10
    11c4:	24 e1       	ldi	r18, 0x14	; 20
    11c6:	30 e0       	ldi	r19, 0x00	; 0
    11c8:	05 c0       	rjmp	.+10     	; 0x11d4 <TCP_ProcessTCPPacket+0x4f0>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    11ca:	2f ef       	ldi	r18, 0xFF	; 255
    11cc:	3f ef       	ldi	r19, 0xFF	; 255
    11ce:	02 c0       	rjmp	.+4      	; 0x11d4 <TCP_ProcessTCPPacket+0x4f0>
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    11d4:	c9 01       	movw	r24, r18
    11d6:	df 91       	pop	r29
    11d8:	cf 91       	pop	r28
    11da:	1f 91       	pop	r17
    11dc:	0f 91       	pop	r16
    11de:	ff 90       	pop	r15
    11e0:	ef 90       	pop	r14
    11e2:	df 90       	pop	r13
    11e4:	cf 90       	pop	r12
    11e6:	bf 90       	pop	r11
    11e8:	af 90       	pop	r10
    11ea:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    11ec:	d5 01       	movw	r26, r10
    11ee:	1c 96       	adiw	r26, 0x0c	; 12
    11f0:	4d 91       	ld	r20, X+
    11f2:	5d 91       	ld	r21, X+
    11f4:	6d 91       	ld	r22, X+
    11f6:	7c 91       	ld	r23, X
    11f8:	1f 97       	sbiw	r26, 0x0f	; 15
    11fa:	e7 01       	movw	r28, r14
    11fc:	28 81       	ld	r18, Y
    11fe:	39 81       	ldd	r19, Y+1	; 0x01
    1200:	8a 81       	ldd	r24, Y+2	; 0x02
    1202:	9b 81       	ldd	r25, Y+3	; 0x03
    1204:	f2 db       	rcall	.-2076   	; 0x9ea <TCP_GetConnectionInfo>
    1206:	fc 01       	movw	r30, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1208:	8a 81       	ldd	r24, Y+2	; 0x02
    120a:	9b 81       	ldd	r25, Y+3	; 0x03
    120c:	d6 01       	movw	r26, r12
    120e:	11 96       	adiw	r26, 0x01	; 1
    1210:	9c 93       	st	X, r25
    1212:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1214:	88 81       	ld	r24, Y
    1216:	99 81       	ldd	r25, Y+1	; 0x01
    1218:	13 96       	adiw	r26, 0x03	; 3
    121a:	9c 93       	st	X, r25
    121c:	8e 93       	st	-X, r24
    121e:	12 97       	sbiw	r26, 0x02	; 2
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    1220:	34 81       	ldd	r19, Z+4	; 0x04
    1222:	25 81       	ldd	r18, Z+5	; 0x05
    1224:	96 81       	ldd	r25, Z+6	; 0x06
    1226:	87 81       	ldd	r24, Z+7	; 0x07
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1228:	14 96       	adiw	r26, 0x04	; 4
    122a:	8c 93       	st	X, r24
    122c:	14 97       	sbiw	r26, 0x04	; 4
    122e:	15 96       	adiw	r26, 0x05	; 5
    1230:	9c 93       	st	X, r25
    1232:	15 97       	sbiw	r26, 0x05	; 5
    1234:	16 96       	adiw	r26, 0x06	; 6
    1236:	2c 93       	st	X, r18
    1238:	16 97       	sbiw	r26, 0x06	; 6
    123a:	17 96       	adiw	r26, 0x07	; 7
    123c:	3c 93       	st	X, r19
    123e:	17 97       	sbiw	r26, 0x07	; 7
    1240:	30 81       	ld	r19, Z
    1242:	21 81       	ldd	r18, Z+1	; 0x01
    1244:	92 81       	ldd	r25, Z+2	; 0x02
    1246:	83 81       	ldd	r24, Z+3	; 0x03
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    1248:	18 96       	adiw	r26, 0x08	; 8
    124a:	8c 93       	st	X, r24
    124c:	18 97       	sbiw	r26, 0x08	; 8
    124e:	19 96       	adiw	r26, 0x09	; 9
    1250:	9c 93       	st	X, r25
    1252:	19 97       	sbiw	r26, 0x09	; 9
    1254:	1a 96       	adiw	r26, 0x0a	; 10
    1256:	2c 93       	st	X, r18
    1258:	1a 97       	sbiw	r26, 0x0a	; 10
    125a:	1b 96       	adiw	r26, 0x0b	; 11
    125c:	3c 93       	st	X, r19
    125e:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1260:	1c 96       	adiw	r26, 0x0c	; 12
    1262:	8c 91       	ld	r24, X
    1264:	1c 97       	sbiw	r26, 0x0c	; 12
    1266:	8f 70       	andi	r24, 0x0F	; 15
    1268:	80 65       	ori	r24, 0x50	; 80
    126a:	1c 96       	adiw	r26, 0x0c	; 12
    126c:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    126e:	e4 5f       	subi	r30, 0xF4	; 244
    1270:	fd 4f       	sbci	r31, 0xFD	; 253
    1272:	80 81       	ld	r24, Z
    1274:	ec 50       	subi	r30, 0x0C	; 12
    1276:	f2 40       	sbci	r31, 0x02	; 2
    1278:	88 23       	and	r24, r24
    127a:	09 f4       	brne	.+2      	; 0x127e <TCP_ProcessTCPPacket+0x59a>
    127c:	79 cf       	rjmp	.-270    	; 0x1170 <TCP_ProcessTCPPacket+0x48c>
    127e:	7e cf       	rjmp	.-260    	; 0x117c <TCP_ProcessTCPPacket+0x498>

00001280 <TCP_TCPTask>:
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    1280:	2f 92       	push	r2
    1282:	3f 92       	push	r3
    1284:	4f 92       	push	r4
    1286:	5f 92       	push	r5
    1288:	6f 92       	push	r6
    128a:	7f 92       	push	r7
    128c:	8f 92       	push	r8
    128e:	9f 92       	push	r9
    1290:	af 92       	push	r10
    1292:	bf 92       	push	r11
    1294:	cf 92       	push	r12
    1296:	df 92       	push	r13
    1298:	ef 92       	push	r14
    129a:	ff 92       	push	r15
    129c:	0f 93       	push	r16
    129e:	1f 93       	push	r17
    12a0:	df 93       	push	r29
    12a2:	cf 93       	push	r28
    12a4:	00 d0       	rcall	.+0      	; 0x12a6 <TCP_TCPTask+0x26>
    12a6:	00 d0       	rcall	.+0      	; 0x12a8 <TCP_TCPTask+0x28>
    12a8:	00 d0       	rcall	.+0      	; 0x12aa <TCP_TCPTask+0x2a>
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
    12ae:	9e 83       	std	Y+6, r25	; 0x06
    12b0:	8d 83       	std	Y+5, r24	; 0x05
    12b2:	95 ec       	ldi	r25, 0xC5	; 197
    12b4:	c9 2e       	mov	r12, r25
    12b6:	9d e0       	ldi	r25, 0x0D	; 13
    12b8:	d9 2e       	mov	r13, r25
    12ba:	00 e0       	ldi	r16, 0x00	; 0
    12bc:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    12be:	86 e1       	ldi	r24, 0x16	; 22
    12c0:	e8 2e       	mov	r14, r24
    12c2:	82 e0       	ldi	r24, 0x02	; 2
    12c4:	f8 2e       	mov	r15, r24
    12c6:	1c c0       	rjmp	.+56     	; 0x1300 <TCP_TCPTask+0x80>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    12c8:	80 91 09 14 	lds	r24, 0x1409
    12cc:	81 30       	cpi	r24, 0x01	; 1
    12ce:	79 f4       	brne	.+30     	; 0x12ee <TCP_TCPTask+0x6e>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    12d0:	0e 9d       	mul	r16, r14
    12d2:	b0 01       	movw	r22, r0
    12d4:	0f 9d       	mul	r16, r15
    12d6:	70 0d       	add	r23, r0
    12d8:	1e 9d       	mul	r17, r14
    12da:	70 0d       	add	r23, r0
    12dc:	11 24       	eor	r1, r1
    12de:	6b 52       	subi	r22, 0x2B	; 43
    12e0:	72 4f       	sbci	r23, 0xF2	; 242
    12e2:	e0 91 0a 14 	lds	r30, 0x140A
    12e6:	f0 91 0b 14 	lds	r31, 0x140B
    12ea:	c6 01       	movw	r24, r12
    12ec:	09 95       	icall
    12ee:	0f 5f       	subi	r16, 0xFF	; 255
    12f0:	1f 4f       	sbci	r17, 0xFF	; 255
    12f2:	26 e1       	ldi	r18, 0x16	; 22
    12f4:	32 e0       	ldi	r19, 0x02	; 2
    12f6:	c2 0e       	add	r12, r18
    12f8:	d3 1e       	adc	r13, r19
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    12fa:	03 30       	cpi	r16, 0x03	; 3
    12fc:	11 05       	cpc	r17, r1
    12fe:	59 f0       	breq	.+22     	; 0x1316 <TCP_TCPTask+0x96>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1300:	20 91 07 14 	lds	r18, 0x1407
    1304:	30 91 08 14 	lds	r19, 0x1408
    1308:	d6 01       	movw	r26, r12
    130a:	8d 91       	ld	r24, X+
    130c:	9c 91       	ld	r25, X
    130e:	28 17       	cp	r18, r24
    1310:	39 07       	cpc	r19, r25
    1312:	69 f7       	brne	.-38     	; 0x12ee <TCP_TCPTask+0x6e>
    1314:	d9 cf       	rjmp	.-78     	; 0x12c8 <TCP_TCPTask+0x48>

	/* Get pointer to the output frame info struct for convenience */
	Ethernet_Frame_Info_t* FrameOUT = &RNDISInterfaceInfo->State.FrameOUT;

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameInBuffer)
    1316:	ed 81       	ldd	r30, Y+5	; 0x05
    1318:	fe 81       	ldd	r31, Y+6	; 0x06
    131a:	e8 5a       	subi	r30, 0xA8	; 168
    131c:	f3 4f       	sbci	r31, 0xF3	; 243
    131e:	80 81       	ld	r24, Z
    1320:	e8 55       	subi	r30, 0x58	; 88
    1322:	fc 40       	sbci	r31, 0x0C	; 12
    1324:	fe 83       	std	Y+6, r31	; 0x06
    1326:	ed 83       	std	Y+5, r30	; 0x05
    1328:	88 23       	and	r24, r24
    132a:	09 f0       	breq	.+2      	; 0x132e <TCP_TCPTask+0xae>
    132c:	24 c1       	rjmp	.+584    	; 0x1576 <TCP_TCPTask+0x2f6>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    132e:	80 91 d7 0f 	lds	r24, 0x0FD7
    1332:	88 23       	and	r24, r24
    1334:	39 f0       	breq	.+14     	; 0x1344 <TCP_TCPTask+0xc4>
    1336:	80 91 d8 0f 	lds	r24, 0x0FD8
    133a:	88 23       	and	r24, r24
    133c:	19 f0       	breq	.+6      	; 0x1344 <TCP_TCPTask+0xc4>
    133e:	1c 82       	std	Y+4, r1	; 0x04
    1340:	1b 82       	std	Y+3, r1	; 0x03
    1342:	1b c0       	rjmp	.+54     	; 0x137a <TCP_TCPTask+0xfa>
    1344:	80 91 ed 11 	lds	r24, 0x11ED
    1348:	88 23       	and	r24, r24
    134a:	49 f0       	breq	.+18     	; 0x135e <TCP_TCPTask+0xde>
    134c:	80 91 ee 11 	lds	r24, 0x11EE
    1350:	88 23       	and	r24, r24
    1352:	29 f0       	breq	.+10     	; 0x135e <TCP_TCPTask+0xde>
    1354:	21 e0       	ldi	r18, 0x01	; 1
    1356:	30 e0       	ldi	r19, 0x00	; 0
    1358:	3c 83       	std	Y+4, r19	; 0x04
    135a:	2b 83       	std	Y+3, r18	; 0x03
    135c:	0e c0       	rjmp	.+28     	; 0x137a <TCP_TCPTask+0xfa>
    135e:	80 91 03 14 	lds	r24, 0x1403
    1362:	88 23       	and	r24, r24
    1364:	09 f4       	brne	.+2      	; 0x1368 <TCP_TCPTask+0xe8>
    1366:	07 c1       	rjmp	.+526    	; 0x1576 <TCP_TCPTask+0x2f6>
    1368:	80 91 04 14 	lds	r24, 0x1404
    136c:	88 23       	and	r24, r24
    136e:	09 f4       	brne	.+2      	; 0x1372 <TCP_TCPTask+0xf2>
    1370:	02 c1       	rjmp	.+516    	; 0x1576 <TCP_TCPTask+0x2f6>
    1372:	82 e0       	ldi	r24, 0x02	; 2
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	9c 83       	std	Y+4, r25	; 0x04
    1378:	8b 83       	std	Y+3, r24	; 0x03
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
    137a:	ad 81       	ldd	r26, Y+5	; 0x05
    137c:	be 81       	ldd	r27, Y+6	; 0x06
    137e:	a6 58       	subi	r26, 0x86	; 134
    1380:	b9 4f       	sbci	r27, 0xF9	; 249
    1382:	ba 83       	std	Y+2, r27	; 0x02
    1384:	a9 83       	std	Y+1, r26	; 0x01
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
    1386:	ad 80       	ldd	r10, Y+5	; 0x05
    1388:	be 80       	ldd	r11, Y+6	; 0x06
    138a:	e8 e8       	ldi	r30, 0x88	; 136
    138c:	f6 e0       	ldi	r31, 0x06	; 6
    138e:	ae 0e       	add	r10, r30
    1390:	bf 1e       	adc	r11, r31
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
    1392:	cd 80       	ldd	r12, Y+5	; 0x05
    1394:	de 80       	ldd	r13, Y+6	; 0x06
    1396:	2c e9       	ldi	r18, 0x9C	; 156
    1398:	36 e0       	ldi	r19, 0x06	; 6
    139a:	c2 0e       	add	r12, r18
    139c:	d3 1e       	adc	r13, r19
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    139e:	86 e1       	ldi	r24, 0x16	; 22
    13a0:	92 e0       	ldi	r25, 0x02	; 2
    13a2:	ab 81       	ldd	r26, Y+3	; 0x03
    13a4:	bc 81       	ldd	r27, Y+4	; 0x04
    13a6:	a8 9f       	mul	r26, r24
    13a8:	a0 01       	movw	r20, r0
    13aa:	a9 9f       	mul	r26, r25
    13ac:	50 0d       	add	r21, r0
    13ae:	b8 9f       	mul	r27, r24
    13b0:	50 0d       	add	r21, r0
    13b2:	11 24       	eor	r1, r1
    13b4:	05 ec       	ldi	r16, 0xC5	; 197
    13b6:	80 2e       	mov	r8, r16
    13b8:	0d e0       	ldi	r16, 0x0D	; 13
    13ba:	90 2e       	mov	r9, r16
    13bc:	84 0e       	add	r8, r20
    13be:	95 1e       	adc	r9, r21
    13c0:	f4 01       	movw	r30, r8
    13c2:	60 88       	ldd	r6, Z+16	; 0x10
    13c4:	71 88       	ldd	r7, Z+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    13c6:	80 81       	ld	r24, Z
    13c8:	91 81       	ldd	r25, Z+1	; 0x01
    13ca:	d6 01       	movw	r26, r12
    13cc:	11 96       	adiw	r26, 0x01	; 1
    13ce:	9c 93       	st	X, r25
    13d0:	8e 93       	st	-X, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    13d2:	8b e0       	ldi	r24, 0x0B	; 11
    13d4:	91 e0       	ldi	r25, 0x01	; 1
    13d6:	2b 81       	ldd	r18, Y+3	; 0x03
    13d8:	3c 81       	ldd	r19, Y+4	; 0x04
    13da:	28 9f       	mul	r18, r24
    13dc:	f0 01       	movw	r30, r0
    13de:	29 9f       	mul	r18, r25
    13e0:	f0 0d       	add	r31, r0
    13e2:	38 9f       	mul	r19, r24
    13e4:	f0 0d       	add	r31, r0
    13e6:	11 24       	eor	r1, r1
    13e8:	ee 0f       	add	r30, r30
    13ea:	ff 1f       	adc	r31, r31
    13ec:	e9 53       	subi	r30, 0x39	; 57
    13ee:	f2 4f       	sbci	r31, 0xF2	; 242
    13f0:	80 81       	ld	r24, Z
    13f2:	91 81       	ldd	r25, Z+1	; 0x01
    13f4:	13 96       	adiw	r26, 0x03	; 3
    13f6:	9c 93       	st	X, r25
    13f8:	8e 93       	st	-X, r24
    13fa:	12 97       	sbiw	r26, 0x02	; 2
    13fc:	f4 01       	movw	r30, r8
    13fe:	3c 96       	adiw	r30, 0x0c	; 12
    1400:	d4 01       	movw	r26, r8
    1402:	1c 96       	adiw	r26, 0x0c	; 12
    1404:	3c 91       	ld	r19, X
    1406:	1c 97       	sbiw	r26, 0x0c	; 12
    1408:	21 81       	ldd	r18, Z+1	; 0x01
    140a:	92 81       	ldd	r25, Z+2	; 0x02
    140c:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    140e:	f6 01       	movw	r30, r12
    1410:	84 83       	std	Z+4, r24	; 0x04
    1412:	95 83       	std	Z+5, r25	; 0x05
    1414:	26 83       	std	Z+6, r18	; 0x06
    1416:	37 83       	std	Z+7, r19	; 0x07
    1418:	f4 01       	movw	r30, r8
    141a:	38 96       	adiw	r30, 0x08	; 8
    141c:	18 96       	adiw	r26, 0x08	; 8
    141e:	3c 91       	ld	r19, X
    1420:	21 81       	ldd	r18, Z+1	; 0x01
    1422:	92 81       	ldd	r25, Z+2	; 0x02
    1424:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    1426:	f6 01       	movw	r30, r12
    1428:	80 87       	std	Z+8, r24	; 0x08
    142a:	91 87       	std	Z+9, r25	; 0x09
    142c:	22 87       	std	Z+10, r18	; 0x0a
    142e:	33 87       	std	Z+11, r19	; 0x0b

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;
    1430:	82 e0       	ldi	r24, 0x02	; 2
    1432:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    1434:	97 87       	std	Z+15, r25	; 0x0f
    1436:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    1438:	80 e1       	ldi	r24, 0x10	; 16
    143a:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
    143c:	13 8a       	std	Z+19, r1	; 0x13
    143e:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
    1440:	11 8a       	std	Z+17, r1	; 0x11
    1442:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
    1444:	80 e5       	ldi	r24, 0x50	; 80
    1446:	84 87       	std	Z+12, r24	; 0x0c

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    1448:	2d 81       	ldd	r18, Y+5	; 0x05
    144a:	3e 81       	ldd	r19, Y+6	; 0x06
    144c:	20 55       	subi	r18, 0x50	; 80
    144e:	39 4f       	sbci	r19, 0xF9	; 249
    1450:	49 52       	subi	r20, 0x29	; 41
    1452:	52 4f       	sbci	r21, 0xF2	; 242
    1454:	c9 01       	movw	r24, r18
    1456:	ba 01       	movw	r22, r20
    1458:	a3 01       	movw	r20, r6
    145a:	0e 94 c2 16 	call	0x2d84	; 0x2d84 <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    145e:	c3 01       	movw	r24, r6
    1460:	a0 e0       	ldi	r26, 0x00	; 0
    1462:	b0 e0       	ldi	r27, 0x00	; 0
    1464:	f4 01       	movw	r30, r8
    1466:	24 85       	ldd	r18, Z+12	; 0x0c
    1468:	35 85       	ldd	r19, Z+13	; 0x0d
    146a:	46 85       	ldd	r20, Z+14	; 0x0e
    146c:	57 85       	ldd	r21, Z+15	; 0x0f
    146e:	82 0f       	add	r24, r18
    1470:	93 1f       	adc	r25, r19
    1472:	a4 1f       	adc	r26, r20
    1474:	b5 1f       	adc	r27, r21
    1476:	84 87       	std	Z+12, r24	; 0x0c
    1478:	95 87       	std	Z+13, r25	; 0x0d
    147a:	a6 87       	std	Z+14, r26	; 0x0e
    147c:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    147e:	24 e1       	ldi	r18, 0x14	; 20
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	62 0e       	add	r6, r18
    1484:	73 1e       	adc	r7, r19
    1486:	20 90 77 0d 	lds	r2, 0x0D77
    148a:	30 90 78 0d 	lds	r3, 0x0D78
    148e:	40 90 79 0d 	lds	r4, 0x0D79
    1492:	50 90 7a 0d 	lds	r5, 0x0D7A
    1496:	04 81       	ldd	r16, Z+4	; 0x04
    1498:	15 81       	ldd	r17, Z+5	; 0x05
    149a:	26 81       	ldd	r18, Z+6	; 0x06
    149c:	37 81       	ldd	r19, Z+7	; 0x07
    149e:	c6 01       	movw	r24, r12
    14a0:	b2 01       	movw	r22, r4
    14a2:	a1 01       	movw	r20, r2
    14a4:	73 01       	movw	r14, r6
    14a6:	fc d9       	rcall	.-3080   	; 0x8a0 <TCP_Checksum16>
    14a8:	d6 01       	movw	r26, r12
    14aa:	51 96       	adiw	r26, 0x11	; 17
    14ac:	9c 93       	st	X, r25
    14ae:	8e 93       	st	-X, r24
    14b0:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    14b2:	83 01       	movw	r16, r6
    14b4:	0c 5e       	subi	r16, 0xEC	; 236
    14b6:	1f 4f       	sbci	r17, 0xFF	; 255
    14b8:	f5 01       	movw	r30, r10
    14ba:	12 83       	std	Z+2, r17	; 0x02
    14bc:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    14be:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    14c0:	85 e4       	ldi	r24, 0x45	; 69
    14c2:	80 83       	st	Z, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    14c4:	16 82       	std	Z+6, r1	; 0x06
    14c6:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    14c8:	15 82       	std	Z+5, r1	; 0x05
    14ca:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    14cc:	13 86       	std	Z+11, r1	; 0x0b
    14ce:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    14d0:	86 e0       	ldi	r24, 0x06	; 6
    14d2:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    14d4:	80 e8       	ldi	r24, 0x80	; 128
    14d6:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    14d8:	d5 01       	movw	r26, r10
    14da:	1c 96       	adiw	r26, 0x0c	; 12
    14dc:	2d 92       	st	X+, r2
    14de:	3d 92       	st	X+, r3
    14e0:	4d 92       	st	X+, r4
    14e2:	5c 92       	st	X, r5
    14e4:	1f 97       	sbiw	r26, 0x0f	; 15
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    14e6:	f4 01       	movw	r30, r8
    14e8:	84 81       	ldd	r24, Z+4	; 0x04
    14ea:	95 81       	ldd	r25, Z+5	; 0x05
    14ec:	a6 81       	ldd	r26, Z+6	; 0x06
    14ee:	b7 81       	ldd	r27, Z+7	; 0x07
    14f0:	f5 01       	movw	r30, r10
    14f2:	80 8b       	std	Z+16, r24	; 0x10
    14f4:	91 8b       	std	Z+17, r25	; 0x11
    14f6:	a2 8b       	std	Z+18, r26	; 0x12
    14f8:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    14fa:	c5 01       	movw	r24, r10
    14fc:	64 e1       	ldi	r22, 0x14	; 20
    14fe:	70 e0       	ldi	r23, 0x00	; 0
    1500:	53 d8       	rcall	.-3930   	; 0x5a8 <Ethernet_Checksum16>
    1502:	d5 01       	movw	r26, r10
    1504:	1b 96       	adiw	r26, 0x0b	; 11
    1506:	9c 93       	st	X, r25
    1508:	8e 93       	st	-X, r24
    150a:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    150c:	a9 81       	ldd	r26, Y+1	; 0x01
    150e:	ba 81       	ldd	r27, Y+2	; 0x02
    1510:	16 96       	adiw	r26, 0x06	; 6
    1512:	e1 e7       	ldi	r30, 0x71	; 113
    1514:	fd e0       	ldi	r31, 0x0D	; 13
    1516:	86 e0       	ldi	r24, 0x06	; 6
    1518:	01 90       	ld	r0, Z+
    151a:	0d 92       	st	X+, r0
    151c:	81 50       	subi	r24, 0x01	; 1
    151e:	e1 f7       	brne	.-8      	; 0x1518 <TCP_TCPTask+0x298>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    1520:	a9 81       	ldd	r26, Y+1	; 0x01
    1522:	ba 81       	ldd	r27, Y+2	; 0x02
    1524:	e9 e8       	ldi	r30, 0x89	; 137
    1526:	fd e0       	ldi	r31, 0x0D	; 13
    1528:	86 e0       	ldi	r24, 0x06	; 6
    152a:	01 90       	ld	r0, Z+
    152c:	0d 92       	st	X+, r0
    152e:	81 50       	subi	r24, 0x01	; 1
    1530:	e1 f7       	brne	.-8      	; 0x152a <TCP_TCPTask+0x2aa>
    1532:	88 e0       	ldi	r24, 0x08	; 8
    1534:	90 e0       	ldi	r25, 0x00	; 0
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    1536:	e9 81       	ldd	r30, Y+1	; 0x01
    1538:	fa 81       	ldd	r31, Y+2	; 0x02
    153a:	95 87       	std	Z+13, r25	; 0x0d
    153c:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
    153e:	2d 81       	ldd	r18, Y+5	; 0x05
    1540:	3e 81       	ldd	r19, Y+6	; 0x06
    1542:	2a 5a       	subi	r18, 0xAA	; 170
    1544:	33 4f       	sbci	r19, 0xF3	; 243
    1546:	02 5f       	subi	r16, 0xF2	; 242
    1548:	1f 4f       	sbci	r17, 0xFF	; 255
    154a:	d9 01       	movw	r26, r18
    154c:	0d 93       	st	X+, r16
    154e:	1d 93       	st	X+, r17
    1550:	be 83       	std	Y+6, r27	; 0x06
    1552:	ad 83       	std	Y+5, r26	; 0x05
			FrameOUT->FrameInBuffer         = true;
    1554:	fd 01       	movw	r30, r26
    1556:	81 e0       	ldi	r24, 0x01	; 1
    1558:	80 83       	st	Z, r24

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    155a:	86 e1       	ldi	r24, 0x16	; 22
    155c:	92 e0       	ldi	r25, 0x02	; 2
    155e:	2b 81       	ldd	r18, Y+3	; 0x03
    1560:	3c 81       	ldd	r19, Y+4	; 0x04
    1562:	28 9f       	mul	r18, r24
    1564:	f0 01       	movw	r30, r0
    1566:	29 9f       	mul	r18, r25
    1568:	f0 0d       	add	r31, r0
    156a:	38 9f       	mul	r19, r24
    156c:	f0 0d       	add	r31, r0
    156e:	11 24       	eor	r1, r1
    1570:	e8 52       	subi	r30, 0x28	; 40
    1572:	f0 4f       	sbci	r31, 0xF0	; 240
    1574:	10 82       	st	Z, r1

			break;
		}
	}
}
    1576:	26 96       	adiw	r28, 0x06	; 6
    1578:	0f b6       	in	r0, 0x3f	; 63
    157a:	f8 94       	cli
    157c:	de bf       	out	0x3e, r29	; 62
    157e:	0f be       	out	0x3f, r0	; 63
    1580:	cd bf       	out	0x3d, r28	; 61
    1582:	cf 91       	pop	r28
    1584:	df 91       	pop	r29
    1586:	1f 91       	pop	r17
    1588:	0f 91       	pop	r16
    158a:	ff 90       	pop	r15
    158c:	ef 90       	pop	r14
    158e:	df 90       	pop	r13
    1590:	cf 90       	pop	r12
    1592:	bf 90       	pop	r11
    1594:	af 90       	pop	r10
    1596:	9f 90       	pop	r9
    1598:	8f 90       	pop	r8
    159a:	7f 90       	pop	r7
    159c:	6f 90       	pop	r6
    159e:	5f 90       	pop	r5
    15a0:	4f 90       	pop	r4
    15a2:	3f 90       	pop	r3
    15a4:	2f 90       	pop	r2
    15a6:	08 95       	ret

000015a8 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    15a8:	ef 92       	push	r14
    15aa:	ff 92       	push	r15
    15ac:	0f 93       	push	r16
    15ae:	1f 93       	push	r17
    15b0:	cf 93       	push	r28
    15b2:	df 93       	push	r29
    15b4:	7c 01       	movw	r14, r24
    15b6:	eb 01       	movw	r28, r22
    15b8:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    15ba:	cb 01       	movw	r24, r22
    15bc:	a0 d8       	rcall	.-3776   	; 0x6fe <DecodeUDPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    15be:	8a 81       	ldd	r24, Y+2	; 0x02
    15c0:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    15c2:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    15c4:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    15c6:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    15c8:	83 34       	cpi	r24, 0x43	; 67
    15ca:	91 05       	cpc	r25, r1
    15cc:	e9 f4       	brne	.+58     	; 0x1608 <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    15ce:	be 01       	movw	r22, r28
    15d0:	68 5f       	subi	r22, 0xF8	; 248
    15d2:	7f 4f       	sbci	r23, 0xFF	; 255
    15d4:	a8 01       	movw	r20, r16
    15d6:	48 5f       	subi	r20, 0xF8	; 248
    15d8:	5f 4f       	sbci	r21, 0xFF	; 255
    15da:	c7 01       	movw	r24, r14
    15dc:	1f d0       	rcall	.+62     	; 0x161c <DHCP_ProcessDHCPPacket>
    15de:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    15e0:	18 16       	cp	r1, r24
    15e2:	19 06       	cpc	r1, r25
    15e4:	8c f4       	brge	.+34     	; 0x1608 <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    15e6:	8a 81       	ldd	r24, Y+2	; 0x02
    15e8:	9b 81       	ldd	r25, Y+3	; 0x03
    15ea:	f8 01       	movw	r30, r16
    15ec:	91 83       	std	Z+1, r25	; 0x01
    15ee:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    15f0:	88 81       	ld	r24, Y
    15f2:	99 81       	ldd	r25, Y+1	; 0x01
    15f4:	93 83       	std	Z+3, r25	; 0x03
    15f6:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    15f8:	17 82       	std	Z+7, r1	; 0x07
    15fa:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    15fc:	c9 01       	movw	r24, r18
    15fe:	08 96       	adiw	r24, 0x08	; 8
    1600:	94 83       	std	Z+4, r25	; 0x04
    1602:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1604:	9c 01       	movw	r18, r24
    1606:	02 c0       	rjmp	.+4      	; 0x160c <UDP_ProcessUDPPacket+0x64>
    1608:	20 e0       	ldi	r18, 0x00	; 0
    160a:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    160c:	c9 01       	movw	r24, r18
    160e:	df 91       	pop	r29
    1610:	cf 91       	pop	r28
    1612:	1f 91       	pop	r17
    1614:	0f 91       	pop	r16
    1616:	ff 90       	pop	r15
    1618:	ef 90       	pop	r14
    161a:	08 95       	ret

0000161c <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    161c:	8f 92       	push	r8
    161e:	9f 92       	push	r9
    1620:	af 92       	push	r10
    1622:	bf 92       	push	r11
    1624:	cf 92       	push	r12
    1626:	df 92       	push	r13
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	8b 01       	movw	r16, r22
    1636:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    1638:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    163a:	80 ef       	ldi	r24, 0xF0	; 240
    163c:	88 2e       	mov	r8, r24
    163e:	91 2c       	mov	r9, r1
    1640:	86 0e       	add	r8, r22
    1642:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1644:	cb 01       	movw	r24, r22
    1646:	5c d8       	rcall	.-3912   	; 0x700 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    1648:	80 ef       	ldi	r24, 0xF0	; 240
    164a:	fe 01       	movw	r30, r28
    164c:	11 92       	st	Z+, r1
    164e:	8a 95       	dec	r24
    1650:	e9 f7       	brne	.-6      	; 0x164c <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1652:	f8 01       	movw	r30, r16
    1654:	81 81       	ldd	r24, Z+1	; 0x01
    1656:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1658:	82 e0       	ldi	r24, 0x02	; 2
    165a:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    165c:	82 81       	ldd	r24, Z+2	; 0x02
    165e:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    1660:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    1662:	84 81       	ldd	r24, Z+4	; 0x04
    1664:	95 81       	ldd	r25, Z+5	; 0x05
    1666:	a6 81       	ldd	r26, Z+6	; 0x06
    1668:	b7 81       	ldd	r27, Z+7	; 0x07
    166a:	8c 83       	std	Y+4, r24	; 0x04
    166c:	9d 83       	std	Y+5, r25	; 0x05
    166e:	ae 83       	std	Y+6, r26	; 0x06
    1670:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    1672:	19 86       	std	Y+9, r1	; 0x09
    1674:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    1676:	82 85       	ldd	r24, Z+10	; 0x0a
    1678:	93 85       	ldd	r25, Z+11	; 0x0b
    167a:	9b 87       	std	Y+11, r25	; 0x0b
    167c:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    167e:	c0 90 85 0d 	lds	r12, 0x0D85
    1682:	d0 90 86 0d 	lds	r13, 0x0D86
    1686:	e0 90 87 0d 	lds	r14, 0x0D87
    168a:	f0 90 88 0d 	lds	r15, 0x0D88
    168e:	c8 8a       	std	Y+16, r12	; 0x10
    1690:	d9 8a       	std	Y+17, r13	; 0x11
    1692:	ea 8a       	std	Y+18, r14	; 0x12
    1694:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    1696:	04 5e       	subi	r16, 0xE4	; 228
    1698:	1f 4f       	sbci	r17, 0xFF	; 255
    169a:	ce 01       	movw	r24, r28
    169c:	4c 96       	adiw	r24, 0x1c	; 28
    169e:	b8 01       	movw	r22, r16
    16a0:	46 e0       	ldi	r20, 0x06	; 6
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	0e 94 cb 16 	call	0x2d96	; 0x2d96 <memmove>
				} Data;

				Data.DWord = DWord;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[3];
    16a8:	83 e6       	ldi	r24, 0x63	; 99
    16aa:	93 e5       	ldi	r25, 0x53	; 83
    16ac:	a2 e8       	ldi	r26, 0x82	; 130
    16ae:	b3 e6       	ldi	r27, 0x63	; 99
				Data.Bytes[3] = Temp;
    16b0:	b3 e6       	ldi	r27, 0x63	; 99

				Temp = Data.Bytes[1];
    16b2:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    16b4:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    16b6:	a2 2f       	mov	r26, r18
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    16b8:	c4 51       	subi	r28, 0x14	; 20
    16ba:	df 4f       	sbci	r29, 0xFF	; 255
    16bc:	88 83       	st	Y, r24
    16be:	99 83       	std	Y+1, r25	; 0x01
    16c0:	aa 83       	std	Y+2, r26	; 0x02
    16c2:	bb 83       	std	Y+3, r27	; 0x03
    16c4:	cc 5e       	subi	r28, 0xEC	; 236
    16c6:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    16c8:	f5 01       	movw	r30, r10
    16ca:	c4 86       	std	Z+12, r12	; 0x0c
    16cc:	d5 86       	std	Z+13, r13	; 0x0d
    16ce:	e6 86       	std	Z+14, r14	; 0x0e
    16d0:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    16d2:	80 91 77 0d 	lds	r24, 0x0D77
    16d6:	90 91 78 0d 	lds	r25, 0x0D78
    16da:	a0 91 79 0d 	lds	r26, 0x0D79
    16de:	b0 91 7a 0d 	lds	r27, 0x0D7A
    16e2:	80 8b       	std	Z+16, r24	; 0x10
    16e4:	91 8b       	std	Z+17, r25	; 0x11
    16e6:	a2 8b       	std	Z+18, r26	; 0x12
    16e8:	b3 8b       	std	Z+19, r27	; 0x13
    16ea:	5b c0       	rjmp	.+182    	; 0x17a2 <DHCP_ProcessDHCPPacket+0x186>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    16ec:	85 33       	cpi	r24, 0x35	; 53
    16ee:	09 f0       	breq	.+2      	; 0x16f2 <DHCP_ProcessDHCPPacket+0xd6>
    16f0:	4d c0       	rjmp	.+154    	; 0x178c <DHCP_ProcessDHCPPacket+0x170>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    16f2:	94 01       	movw	r18, r8
    16f4:	2e 5f       	subi	r18, 0xFE	; 254
    16f6:	3f 4f       	sbci	r19, 0xFF	; 255
    16f8:	f4 01       	movw	r30, r8
    16fa:	82 81       	ldd	r24, Z+2	; 0x02
    16fc:	81 30       	cpi	r24, 0x01	; 1
    16fe:	19 f0       	breq	.+6      	; 0x1706 <DHCP_ProcessDHCPPacket+0xea>
    1700:	83 30       	cpi	r24, 0x03	; 3
    1702:	09 f0       	breq	.+2      	; 0x1706 <DHCP_ProcessDHCPPacket+0xea>
    1704:	48 c0       	rjmp	.+144    	; 0x1796 <DHCP_ProcessDHCPPacket+0x17a>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    1706:	fe 01       	movw	r30, r28
    1708:	e0 51       	subi	r30, 0x10	; 16
    170a:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    170c:	df 01       	movw	r26, r30
    170e:	85 e3       	ldi	r24, 0x35	; 53
    1710:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	81 83       	std	Z+1, r24	; 0x01
    1716:	ed 01       	movw	r28, r26
    1718:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    171a:	f9 01       	movw	r30, r18
    171c:	80 81       	ld	r24, Z
    171e:	81 30       	cpi	r24, 0x01	; 1
    1720:	11 f0       	breq	.+4      	; 0x1726 <DHCP_ProcessDHCPPacket+0x10a>
    1722:	85 e0       	ldi	r24, 0x05	; 5
    1724:	01 c0       	rjmp	.+2      	; 0x1728 <DHCP_ProcessDHCPPacket+0x10c>
    1726:	82 e0       	ldi	r24, 0x02	; 2
    1728:	11 96       	adiw	r26, 0x01	; 1
    172a:	8c 93       	st	X, r24
    172c:	fe 01       	movw	r30, r28
    172e:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	89 83       	std	Y+1, r24	; 0x01
    1734:	cf 01       	movw	r24, r30
    1736:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    1738:	34 e0       	ldi	r19, 0x04	; 4
    173a:	31 83       	std	Z+1, r19	; 0x01
    173c:	dc 01       	movw	r26, r24
    173e:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1740:	2f ef       	ldi	r18, 0xFF	; 255
    1742:	fc 01       	movw	r30, r24
    1744:	21 83       	std	Z+1, r18	; 0x01
    1746:	fd 01       	movw	r30, r26
    1748:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    174a:	11 96       	adiw	r26, 0x01	; 1
    174c:	2c 93       	st	X, r18
    174e:	df 01       	movw	r26, r30
    1750:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1752:	21 83       	std	Z+1, r18	; 0x01
    1754:	fd 01       	movw	r30, r26
    1756:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    1758:	11 96       	adiw	r26, 0x01	; 1
    175a:	1c 92       	st	X, r1
    175c:	df 01       	movw	r26, r30
    175e:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1760:	86 e3       	ldi	r24, 0x36	; 54
    1762:	81 83       	std	Z+1, r24	; 0x01
    1764:	fd 01       	movw	r30, r26
    1766:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    1768:	11 96       	adiw	r26, 0x01	; 1
    176a:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    176c:	80 91 77 0d 	lds	r24, 0x0D77
    1770:	90 91 78 0d 	lds	r25, 0x0D78
    1774:	a0 91 79 0d 	lds	r26, 0x0D79
    1778:	b0 91 7a 0d 	lds	r27, 0x0D7A
    177c:	81 83       	std	Z+1, r24	; 0x01
    177e:	92 83       	std	Z+2, r25	; 0x02
    1780:	a3 83       	std	Z+3, r26	; 0x03
    1782:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1784:	25 83       	std	Z+5, r18	; 0x05
    1786:	20 e0       	ldi	r18, 0x00	; 0
    1788:	31 e0       	ldi	r19, 0x01	; 1
    178a:	12 c0       	rjmp	.+36     	; 0x17b0 <DHCP_ProcessDHCPPacket+0x194>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    178c:	88 23       	and	r24, r24
    178e:	19 f4       	brne	.+6      	; 0x1796 <DHCP_ProcessDHCPPacket+0x17a>
    1790:	81 e0       	ldi	r24, 0x01	; 1
    1792:	90 e0       	ldi	r25, 0x00	; 0
    1794:	04 c0       	rjmp	.+8      	; 0x179e <DHCP_ProcessDHCPPacket+0x182>
    1796:	f4 01       	movw	r30, r8
    1798:	81 81       	ldd	r24, Z+1	; 0x01
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	02 96       	adiw	r24, 0x02	; 2
    179e:	88 0e       	add	r8, r24
    17a0:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    17a2:	f4 01       	movw	r30, r8
    17a4:	80 81       	ld	r24, Z
    17a6:	8f 3f       	cpi	r24, 0xFF	; 255
    17a8:	09 f0       	breq	.+2      	; 0x17ac <DHCP_ProcessDHCPPacket+0x190>
    17aa:	a0 cf       	rjmp	.-192    	; 0x16ec <DHCP_ProcessDHCPPacket+0xd0>
    17ac:	20 e0       	ldi	r18, 0x00	; 0
    17ae:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    17b0:	c9 01       	movw	r24, r18
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	1f 91       	pop	r17
    17b8:	0f 91       	pop	r16
    17ba:	ff 90       	pop	r15
    17bc:	ef 90       	pop	r14
    17be:	df 90       	pop	r13
    17c0:	cf 90       	pop	r12
    17c2:	bf 90       	pop	r11
    17c4:	af 90       	pop	r10
    17c6:	9f 90       	pop	r9
    17c8:	8f 90       	pop	r8
    17ca:	08 95       	ret

000017cc <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    17cc:	ef 92       	push	r14
    17ce:	ff 92       	push	r15
    17d0:	0f 93       	push	r16
    17d2:	1f 93       	push	r17
    17d4:	cf 93       	push	r28
    17d6:	df 93       	push	r29
    17d8:	18 2f       	mov	r17, r24
    17da:	09 2f       	mov	r16, r25
    17dc:	f6 2e       	mov	r15, r22
    17de:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    17e0:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    17e4:	c1 2f       	mov	r28, r17
    17e6:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    17e8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ea:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    17ec:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    17ee:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    17f0:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    17f2:	80 50       	subi	r24, 0x00	; 0
    17f4:	98 40       	sbci	r25, 0x08	; 8
    17f6:	09 f0       	breq	.+2      	; 0x17fa <ARP_ProcessARPPacket+0x2e>
    17f8:	5e c0       	rjmp	.+188    	; 0x18b6 <ARP_ProcessARPPacket+0xea>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    17fa:	8e 81       	ldd	r24, Y+6	; 0x06
    17fc:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    17fe:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1800:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1802:	92 2f       	mov	r25, r18
    1804:	01 97       	sbiw	r24, 0x01	; 1
    1806:	09 f0       	breq	.+2      	; 0x180a <ARP_ProcessARPPacket+0x3e>
    1808:	56 c0       	rjmp	.+172    	; 0x18b6 <ARP_ProcessARPPacket+0xea>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    180a:	ce 01       	movw	r24, r28
    180c:	48 96       	adiw	r24, 0x18	; 24
    180e:	67 e7       	ldi	r22, 0x77	; 119
    1810:	7d e0       	ldi	r23, 0x0D	; 13
    1812:	44 e0       	ldi	r20, 0x04	; 4
    1814:	50 e0       	ldi	r21, 0x00	; 0
    1816:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	59 f0       	breq	.+22     	; 0x1834 <ARP_ProcessARPPacket+0x68>
    181e:	ce 01       	movw	r24, r28
    1820:	42 96       	adiw	r24, 0x12	; 18
    1822:	61 e7       	ldi	r22, 0x71	; 113
    1824:	7d e0       	ldi	r23, 0x0D	; 13
    1826:	46 e0       	ldi	r20, 0x06	; 6
    1828:	50 e0       	ldi	r21, 0x00	; 0
    182a:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
    182e:	00 97       	sbiw	r24, 0x00	; 0
    1830:	09 f0       	breq	.+2      	; 0x1834 <ARP_ProcessARPPacket+0x68>
    1832:	41 c0       	rjmp	.+130    	; 0x18b6 <ARP_ProcessARPPacket+0xea>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1834:	ef 2d       	mov	r30, r15
    1836:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1838:	88 81       	ld	r24, Y
    183a:	99 81       	ldd	r25, Y+1	; 0x01
    183c:	91 83       	std	Z+1, r25	; 0x01
    183e:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1840:	8a 81       	ldd	r24, Y+2	; 0x02
    1842:	9b 81       	ldd	r25, Y+3	; 0x03
    1844:	93 83       	std	Z+3, r25	; 0x03
    1846:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1848:	8c 81       	ldd	r24, Y+4	; 0x04
    184a:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    184c:	8d 81       	ldd	r24, Y+5	; 0x05
    184e:	85 83       	std	Z+5, r24	; 0x05
    1850:	80 e0       	ldi	r24, 0x00	; 0
    1852:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1854:	97 83       	std	Z+7, r25	; 0x07
    1856:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    1858:	9f 01       	movw	r18, r30
    185a:	2e 5e       	subi	r18, 0xEE	; 238
    185c:	3f 4f       	sbci	r19, 0xFF	; 255
    185e:	ae 01       	movw	r20, r28
    1860:	48 5f       	subi	r20, 0xF8	; 248
    1862:	5f 4f       	sbci	r21, 0xFF	; 255
    1864:	86 e0       	ldi	r24, 0x06	; 6
    1866:	da 01       	movw	r26, r20
    1868:	0d 90       	ld	r0, X+
    186a:	ad 01       	movw	r20, r26
    186c:	d9 01       	movw	r26, r18
    186e:	0d 92       	st	X+, r0
    1870:	9d 01       	movw	r18, r26
    1872:	81 50       	subi	r24, 0x01	; 1
    1874:	c1 f7       	brne	.-16     	; 0x1866 <ARP_ProcessARPPacket+0x9a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1876:	8e 85       	ldd	r24, Y+14	; 0x0e
    1878:	9f 85       	ldd	r25, Y+15	; 0x0f
    187a:	a8 89       	ldd	r26, Y+16	; 0x10
    187c:	b9 89       	ldd	r27, Y+17	; 0x11
    187e:	80 8f       	std	Z+24, r24	; 0x18
    1880:	91 8f       	std	Z+25, r25	; 0x19
    1882:	a2 8f       	std	Z+26, r26	; 0x1a
    1884:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1886:	ef 01       	movw	r28, r30
    1888:	28 96       	adiw	r28, 0x08	; 8
    188a:	a1 e7       	ldi	r26, 0x71	; 113
    188c:	bd e0       	ldi	r27, 0x0D	; 13
    188e:	86 e0       	ldi	r24, 0x06	; 6
    1890:	0d 90       	ld	r0, X+
    1892:	09 92       	st	Y+, r0
    1894:	81 50       	subi	r24, 0x01	; 1
    1896:	e1 f7       	brne	.-8      	; 0x1890 <ARP_ProcessARPPacket+0xc4>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1898:	80 91 77 0d 	lds	r24, 0x0D77
    189c:	90 91 78 0d 	lds	r25, 0x0D78
    18a0:	a0 91 79 0d 	lds	r26, 0x0D79
    18a4:	b0 91 7a 0d 	lds	r27, 0x0D7A
    18a8:	86 87       	std	Z+14, r24	; 0x0e
    18aa:	97 87       	std	Z+15, r25	; 0x0f
    18ac:	a0 8b       	std	Z+16, r26	; 0x10
    18ae:	b1 8b       	std	Z+17, r27	; 0x11
    18b0:	2c e1       	ldi	r18, 0x1C	; 28
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	02 c0       	rjmp	.+4      	; 0x18ba <ARP_ProcessARPPacket+0xee>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    18b6:	20 e0       	ldi	r18, 0x00	; 0
    18b8:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    18ba:	c9 01       	movw	r24, r18
    18bc:	df 91       	pop	r29
    18be:	cf 91       	pop	r28
    18c0:	1f 91       	pop	r17
    18c2:	0f 91       	pop	r16
    18c4:	ff 90       	pop	r15
    18c6:	ef 90       	pop	r14
    18c8:	08 95       	ret

000018ca <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    18ca:	af 92       	push	r10
    18cc:	bf 92       	push	r11
    18ce:	df 92       	push	r13
    18d0:	ef 92       	push	r14
    18d2:	ff 92       	push	r15
    18d4:	0f 93       	push	r16
    18d6:	1f 93       	push	r17
    18d8:	cf 93       	push	r28
    18da:	df 93       	push	r29
    18dc:	5c 01       	movw	r10, r24
    18de:	7b 01       	movw	r14, r22
    18e0:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    18e2:	cb 01       	movw	r24, r22
    18e4:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    18e8:	f7 01       	movw	r30, r14
    18ea:	d0 80       	ld	r13, Z
    18ec:	ff e0       	ldi	r31, 0x0F	; 15
    18ee:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    18f0:	87 01       	movw	r16, r14
    18f2:	00 5f       	subi	r16, 0xF0	; 240
    18f4:	1f 4f       	sbci	r17, 0xFF	; 255
    18f6:	c8 01       	movw	r24, r16
    18f8:	67 e7       	ldi	r22, 0x77	; 119
    18fa:	7d e0       	ldi	r23, 0x0D	; 13
    18fc:	44 e0       	ldi	r20, 0x04	; 4
    18fe:	50 e0       	ldi	r21, 0x00	; 0
    1900:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
    1904:	00 97       	sbiw	r24, 0x00	; 0
    1906:	49 f0       	breq	.+18     	; 0x191a <IP_ProcessIPPacket+0x50>
    1908:	c8 01       	movw	r24, r16
    190a:	61 e8       	ldi	r22, 0x81	; 129
    190c:	7d e0       	ldi	r23, 0x0D	; 13
    190e:	44 e0       	ldi	r20, 0x04	; 4
    1910:	50 e0       	ldi	r21, 0x00	; 0
    1912:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <memcmp>
    1916:	00 97       	sbiw	r24, 0x00	; 0
    1918:	71 f4       	brne	.+28     	; 0x1936 <IP_ProcessIPPacket+0x6c>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    191a:	6d 2d       	mov	r22, r13
    191c:	70 e0       	ldi	r23, 0x00	; 0
    191e:	66 0f       	add	r22, r22
    1920:	77 1f       	adc	r23, r23
    1922:	66 0f       	add	r22, r22
    1924:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1926:	f7 01       	movw	r30, r14
    1928:	81 85       	ldd	r24, Z+9	; 0x09
    192a:	86 30       	cpi	r24, 0x06	; 6
    192c:	81 f0       	breq	.+32     	; 0x194e <IP_ProcessIPPacket+0x84>
    192e:	81 31       	cpi	r24, 0x11	; 17
    1930:	b1 f0       	breq	.+44     	; 0x195e <IP_ProcessIPPacket+0x94>
    1932:	81 30       	cpi	r24, 0x01	; 1
    1934:	19 f0       	breq	.+6      	; 0x193c <IP_ProcessIPPacket+0x72>
    1936:	20 e0       	ldi	r18, 0x00	; 0
    1938:	30 e0       	ldi	r19, 0x00	; 0
    193a:	47 c0       	rjmp	.+142    	; 0x19ca <IP_ProcessIPPacket+0x100>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    193c:	6e 0d       	add	r22, r14
    193e:	7f 1d       	adc	r23, r15
    1940:	ae 01       	movw	r20, r28
    1942:	4c 5e       	subi	r20, 0xEC	; 236
    1944:	5f 4f       	sbci	r21, 0xFF	; 255
    1946:	c5 01       	movw	r24, r10
    1948:	0e 94 81 03 	call	0x702	; 0x702 <ICMP_ProcessICMPPacket>
    194c:	0f c0       	rjmp	.+30     	; 0x196c <IP_ProcessIPPacket+0xa2>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    194e:	6e 0d       	add	r22, r14
    1950:	7f 1d       	adc	r23, r15
    1952:	ae 01       	movw	r20, r28
    1954:	4c 5e       	subi	r20, 0xEC	; 236
    1956:	5f 4f       	sbci	r21, 0xFF	; 255
    1958:	c7 01       	movw	r24, r14
    195a:	c4 d9       	rcall	.-3192   	; 0xce4 <TCP_ProcessTCPPacket>
    195c:	07 c0       	rjmp	.+14     	; 0x196c <IP_ProcessIPPacket+0xa2>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    195e:	6e 0d       	add	r22, r14
    1960:	7f 1d       	adc	r23, r15
    1962:	ae 01       	movw	r20, r28
    1964:	4c 5e       	subi	r20, 0xEC	; 236
    1966:	5f 4f       	sbci	r21, 0xFF	; 255
    1968:	c7 01       	movw	r24, r14
    196a:	1e de       	rcall	.-964    	; 0x15a8 <UDP_ProcessUDPPacket>
    196c:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    196e:	18 16       	cp	r1, r24
    1970:	19 06       	cpc	r1, r25
    1972:	5c f5       	brge	.+86     	; 0x19ca <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1974:	8c 01       	movw	r16, r24
    1976:	0c 5e       	subi	r16, 0xEC	; 236
    1978:	1f 4f       	sbci	r17, 0xFF	; 255
    197a:	1a 83       	std	Y+2, r17	; 0x02
    197c:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    197e:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1980:	85 e4       	ldi	r24, 0x45	; 69
    1982:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1984:	1e 82       	std	Y+6, r1	; 0x06
    1986:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1988:	1d 82       	std	Y+5, r1	; 0x05
    198a:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    198c:	1b 86       	std	Y+11, r1	; 0x0b
    198e:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1990:	f7 01       	movw	r30, r14
    1992:	81 85       	ldd	r24, Z+9	; 0x09
    1994:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1996:	80 e8       	ldi	r24, 0x80	; 128
    1998:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    199a:	80 89       	ldd	r24, Z+16	; 0x10
    199c:	91 89       	ldd	r25, Z+17	; 0x11
    199e:	a2 89       	ldd	r26, Z+18	; 0x12
    19a0:	b3 89       	ldd	r27, Z+19	; 0x13
    19a2:	8c 87       	std	Y+12, r24	; 0x0c
    19a4:	9d 87       	std	Y+13, r25	; 0x0d
    19a6:	ae 87       	std	Y+14, r26	; 0x0e
    19a8:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    19aa:	84 85       	ldd	r24, Z+12	; 0x0c
    19ac:	95 85       	ldd	r25, Z+13	; 0x0d
    19ae:	a6 85       	ldd	r26, Z+14	; 0x0e
    19b0:	b7 85       	ldd	r27, Z+15	; 0x0f
    19b2:	88 8b       	std	Y+16, r24	; 0x10
    19b4:	99 8b       	std	Y+17, r25	; 0x11
    19b6:	aa 8b       	std	Y+18, r26	; 0x12
    19b8:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    19ba:	ce 01       	movw	r24, r28
    19bc:	64 e1       	ldi	r22, 0x14	; 20
    19be:	70 e0       	ldi	r23, 0x00	; 0
    19c0:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <Ethernet_Checksum16>
    19c4:	9b 87       	std	Y+11, r25	; 0x0b
    19c6:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    19c8:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    19ca:	c9 01       	movw	r24, r18
    19cc:	df 91       	pop	r29
    19ce:	cf 91       	pop	r28
    19d0:	1f 91       	pop	r17
    19d2:	0f 91       	pop	r16
    19d4:	ff 90       	pop	r15
    19d6:	ef 90       	pop	r14
    19d8:	df 90       	pop	r13
    19da:	bf 90       	pop	r11
    19dc:	af 90       	pop	r10
    19de:	08 95       	ret

000019e0 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    19e0:	db 01       	movw	r26, r22
    19e2:	0d 90       	ld	r0, X+
    19e4:	00 20       	and	r0, r0
    19e6:	e9 f7       	brne	.-6      	; 0x19e2 <IsHTTPCommand+0x2>
    19e8:	11 97       	sbiw	r26, 0x01	; 1
    19ea:	a6 1b       	sub	r26, r22
    19ec:	b7 0b       	sbc	r27, r23
    19ee:	ad 01       	movw	r20, r26
    19f0:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <strncmp>
    19f4:	9c 01       	movw	r18, r24
    19f6:	80 e0       	ldi	r24, 0x00	; 0
    19f8:	23 2b       	or	r18, r19
    19fa:	09 f4       	brne	.+2      	; 0x19fe <IsHTTPCommand+0x1e>
    19fc:	81 e0       	ldi	r24, 0x01	; 1
}
    19fe:	08 95       	ret

00001a00 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1a00:	af 92       	push	r10
    1a02:	bf 92       	push	r11
    1a04:	cf 92       	push	r12
    1a06:	df 92       	push	r13
    1a08:	ef 92       	push	r14
    1a0a:	ff 92       	push	r15
    1a0c:	0f 93       	push	r16
    1a0e:	1f 93       	push	r17
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	5c 01       	movw	r10, r24
    1a16:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1a18:	8b 01       	movw	r16, r22
    1a1a:	0e 5f       	subi	r16, 0xFE	; 254
    1a1c:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1a1e:	33 e0       	ldi	r19, 0x03	; 3
    1a20:	c3 2e       	mov	r12, r19
    1a22:	32 e0       	ldi	r19, 0x02	; 2
    1a24:	d3 2e       	mov	r13, r19
    1a26:	c6 0e       	add	r12, r22
    1a28:	d7 1e       	adc	r13, r23
    1a2a:	f6 01       	movw	r30, r12
    1a2c:	80 81       	ld	r24, Z
    1a2e:	88 23       	and	r24, r24
    1a30:	09 f4       	brne	.+2      	; 0x1a34 <Webserver_ApplicationCallback+0x34>
    1a32:	66 c0       	rjmp	.+204    	; 0x1b00 <Webserver_ApplicationCallback+0x100>
    1a34:	22 e0       	ldi	r18, 0x02	; 2
    1a36:	e2 2e       	mov	r14, r18
    1a38:	f2 2e       	mov	r15, r18
    1a3a:	e6 0e       	add	r14, r22
    1a3c:	f7 1e       	adc	r15, r23
    1a3e:	f7 01       	movw	r30, r14
    1a40:	80 81       	ld	r24, Z
    1a42:	88 23       	and	r24, r24
    1a44:	09 f0       	breq	.+2      	; 0x1a48 <Webserver_ApplicationCallback+0x48>
    1a46:	a7 c0       	rjmp	.+334    	; 0x1b96 <Webserver_ApplicationCallback+0x196>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1a48:	c8 01       	movw	r24, r16
    1a4a:	6f e8       	ldi	r22, 0x8F	; 143
    1a4c:	7d e0       	ldi	r23, 0x0D	; 13
    1a4e:	c8 df       	rcall	.-112    	; 0x19e0 <IsHTTPCommand>
    1a50:	88 23       	and	r24, r24
    1a52:	f9 f0       	breq	.+62     	; 0x1a92 <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1a54:	c8 01       	movw	r24, r16
    1a56:	63 e9       	ldi	r22, 0x93	; 147
    1a58:	7d e0       	ldi	r23, 0x0D	; 13
    1a5a:	c2 df       	rcall	.-124    	; 0x19e0 <IsHTTPCommand>
    1a5c:	88 23       	and	r24, r24
    1a5e:	49 f1       	breq	.+82     	; 0x1ab2 <Webserver_ApplicationCallback+0xb2>
			{
				PageBlock = 0;
    1a60:	10 92 c4 0d 	sts	0x0DC4, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1a64:	c8 01       	movw	r24, r16
    1a66:	60 e3       	ldi	r22, 0x30	; 48
    1a68:	71 e0       	ldi	r23, 0x01	; 1
    1a6a:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1a6e:	81 e0       	ldi	r24, 0x01	; 1
    1a70:	f7 01       	movw	r30, r14
    1a72:	80 83       	st	Z, r24
    1a74:	f8 01       	movw	r30, r16
    1a76:	01 90       	ld	r0, Z+
    1a78:	00 20       	and	r0, r0
    1a7a:	e9 f7       	brne	.-6      	; 0x1a76 <Webserver_ApplicationCallback+0x76>
    1a7c:	31 97       	sbiw	r30, 0x01	; 1
    1a7e:	e0 1b       	sub	r30, r16
    1a80:	f1 0b       	sbc	r31, r17
    1a82:	f9 83       	std	Y+1, r31	; 0x01
    1a84:	e8 83       	st	Y, r30
    1a86:	f6 01       	movw	r30, r12
    1a88:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1a8a:	cc 5f       	subi	r28, 0xFC	; 252
    1a8c:	dd 4f       	sbci	r29, 0xFD	; 253
    1a8e:	88 83       	st	Y, r24
    1a90:	82 c0       	rjmp	.+260    	; 0x1b96 <Webserver_ApplicationCallback+0x196>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1a92:	c8 01       	movw	r24, r16
    1a94:	6a e9       	ldi	r22, 0x9A	; 154
    1a96:	7d e0       	ldi	r23, 0x0D	; 13
    1a98:	a3 df       	rcall	.-186    	; 0x19e0 <IsHTTPCommand>
    1a9a:	88 23       	and	r24, r24
    1a9c:	11 f1       	breq	.+68     	; 0x1ae2 <Webserver_ApplicationCallback+0xe2>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1a9e:	c8 01       	movw	r24, r16
    1aa0:	6f e9       	ldi	r22, 0x9F	; 159
    1aa2:	7d e0       	ldi	r23, 0x0D	; 13
    1aa4:	9d df       	rcall	.-198    	; 0x19e0 <IsHTTPCommand>
    1aa6:	88 23       	and	r24, r24
    1aa8:	21 f0       	breq	.+8      	; 0x1ab2 <Webserver_ApplicationCallback+0xb2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1aaa:	c8 01       	movw	r24, r16
    1aac:	60 e3       	ldi	r22, 0x30	; 48
    1aae:	71 e0       	ldi	r23, 0x01	; 1
    1ab0:	03 c0       	rjmp	.+6      	; 0x1ab8 <Webserver_ApplicationCallback+0xb8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1ab2:	c8 01       	movw	r24, r16
    1ab4:	64 e8       	ldi	r22, 0x84	; 132
    1ab6:	71 e0       	ldi	r23, 0x01	; 1
    1ab8:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1abc:	81 e0       	ldi	r24, 0x01	; 1
    1abe:	f7 01       	movw	r30, r14
    1ac0:	80 83       	st	Z, r24
    1ac2:	f8 01       	movw	r30, r16
    1ac4:	01 90       	ld	r0, Z+
    1ac6:	00 20       	and	r0, r0
    1ac8:	e9 f7       	brne	.-6      	; 0x1ac4 <Webserver_ApplicationCallback+0xc4>
    1aca:	31 97       	sbiw	r30, 0x01	; 1
    1acc:	e0 1b       	sub	r30, r16
    1ace:	f1 0b       	sbc	r31, r17
    1ad0:	f9 83       	std	Y+1, r31	; 0x01
    1ad2:	e8 83       	st	Y, r30
    1ad4:	f6 01       	movw	r30, r12
    1ad6:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1ad8:	85 e1       	ldi	r24, 0x15	; 21
    1ada:	92 e0       	ldi	r25, 0x02	; 2
    1adc:	a8 0e       	add	r10, r24
    1ade:	b9 1e       	adc	r11, r25
    1ae0:	57 c0       	rjmp	.+174    	; 0x1b90 <Webserver_ApplicationCallback+0x190>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1ae2:	c8 01       	movw	r24, r16
    1ae4:	67 ea       	ldi	r22, 0xA7	; 167
    1ae6:	7d e0       	ldi	r23, 0x0D	; 13
    1ae8:	7b df       	rcall	.-266    	; 0x19e0 <IsHTTPCommand>
    1aea:	88 23       	and	r24, r24
    1aec:	21 f0       	breq	.+8      	; 0x1af6 <Webserver_ApplicationCallback+0xf6>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	f7 01       	movw	r30, r14
    1af2:	80 83       	st	Z, r24
    1af4:	ef cf       	rjmp	.-34     	; 0x1ad4 <Webserver_ApplicationCallback+0xd4>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1af6:	f6 01       	movw	r30, r12
    1af8:	10 82       	st	Z, r1
    1afa:	19 82       	std	Y+1, r1	; 0x01
    1afc:	18 82       	st	Y, r1
    1afe:	4b c0       	rjmp	.+150    	; 0x1b96 <Webserver_ApplicationCallback+0x196>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1b00:	cc 5f       	subi	r28, 0xFC	; 252
    1b02:	dd 4f       	sbci	r29, 0xFD	; 253
    1b04:	88 81       	ld	r24, Y
    1b06:	c4 50       	subi	r28, 0x04	; 4
    1b08:	d2 40       	sbci	r29, 0x02	; 2
    1b0a:	88 23       	and	r24, r24
    1b0c:	09 f4       	brne	.+2      	; 0x1b10 <Webserver_ApplicationCallback+0x110>
    1b0e:	43 c0       	rjmp	.+134    	; 0x1b96 <Webserver_ApplicationCallback+0x196>
    1b10:	ce 5f       	subi	r28, 0xFE	; 254
    1b12:	dd 4f       	sbci	r29, 0xFD	; 253
    1b14:	88 81       	ld	r24, Y
    1b16:	c2 50       	subi	r28, 0x02	; 2
    1b18:	d2 40       	sbci	r29, 0x02	; 2
    1b1a:	88 23       	and	r24, r24
    1b1c:	e1 f1       	breq	.+120    	; 0x1b96 <Webserver_ApplicationCallback+0x196>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1b1e:	80 91 c4 0d 	lds	r24, 0x0DC4
    1b22:	c8 2e       	mov	r12, r24
    1b24:	dd 24       	eor	r13, r13
    1b26:	d6 94       	lsr	r13
    1b28:	dc 2c       	mov	r13, r12
    1b2a:	cc 24       	eor	r12, r12
    1b2c:	d7 94       	ror	r13
    1b2e:	c7 94       	ror	r12
    1b30:	86 ec       	ldi	r24, 0xC6	; 198
    1b32:	91 e0       	ldi	r25, 0x01	; 1
    1b34:	c8 0e       	add	r12, r24
    1b36:	d9 1e       	adc	r13, r25
    1b38:	c6 01       	movw	r24, r12
    1b3a:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1b3e:	7c 01       	movw	r14, r24
    1b40:	91 e8       	ldi	r25, 0x81	; 129
    1b42:	e9 16       	cp	r14, r25
    1b44:	f1 04       	cpc	r15, r1
    1b46:	18 f0       	brcs	.+6      	; 0x1b4e <Webserver_ApplicationCallback+0x14e>
    1b48:	80 e8       	ldi	r24, 0x80	; 128
    1b4a:	e8 2e       	mov	r14, r24
    1b4c:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1b4e:	c8 01       	movw	r24, r16
    1b50:	b6 01       	movw	r22, r12
    1b52:	a7 01       	movw	r20, r14
    1b54:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1b58:	ce 5f       	subi	r28, 0xFE	; 254
    1b5a:	dd 4f       	sbci	r29, 0xFD	; 253
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	88 83       	st	Y, r24
    1b60:	c2 50       	subi	r28, 0x02	; 2
    1b62:	d2 40       	sbci	r29, 0x02	; 2
    1b64:	f9 82       	std	Y+1, r15	; 0x01
    1b66:	e8 82       	st	Y, r14
    1b68:	cd 5f       	subi	r28, 0xFD	; 253
    1b6a:	dd 4f       	sbci	r29, 0xFD	; 253
    1b6c:	88 83       	st	Y, r24
    1b6e:	c3 50       	subi	r28, 0x03	; 3
    1b70:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1b72:	80 91 c4 0d 	lds	r24, 0x0DC4
    1b76:	8f 5f       	subi	r24, 0xFF	; 255
    1b78:	80 93 c4 0d 	sts	0x0DC4, r24
    1b7c:	81 50       	subi	r24, 0x01	; 1
    1b7e:	83 30       	cpi	r24, 0x03	; 3
    1b80:	51 f4       	brne	.+20     	; 0x1b96 <Webserver_ApplicationCallback+0x196>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1b82:	cc 5f       	subi	r28, 0xFC	; 252
    1b84:	dd 4f       	sbci	r29, 0xFD	; 253
    1b86:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1b88:	e5 e1       	ldi	r30, 0x15	; 21
    1b8a:	f2 e0       	ldi	r31, 0x02	; 2
    1b8c:	ae 0e       	add	r10, r30
    1b8e:	bf 1e       	adc	r11, r31
    1b90:	87 e0       	ldi	r24, 0x07	; 7
    1b92:	f5 01       	movw	r30, r10
    1b94:	80 83       	st	Z, r24
		}
	}
}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	ff 90       	pop	r15
    1ba0:	ef 90       	pop	r14
    1ba2:	df 90       	pop	r13
    1ba4:	cf 90       	pop	r12
    1ba6:	bf 90       	pop	r11
    1ba8:	af 90       	pop	r10
    1baa:	08 95       	ret

00001bac <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1bac:	80 e0       	ldi	r24, 0x00	; 0
    1bae:	90 e5       	ldi	r25, 0x50	; 80
    1bb0:	61 e0       	ldi	r22, 0x01	; 1
    1bb2:	40 e0       	ldi	r20, 0x00	; 0
    1bb4:	5d e0       	ldi	r21, 0x0D	; 13
    1bb6:	0c 94 d0 03 	jmp	0x7a0	; 0x7a0 <TCP_SetPortState>

00001bba <Endpoint_ConfigureEndpoint_Prv>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1bba:	80 93 e9 00 	sts	0x00E9, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1bbe:	80 91 eb 00 	lds	r24, 0x00EB
    1bc2:	81 60       	ori	r24, 0x01	; 1
    1bc4:	80 93 eb 00 	sts	0x00EB, r24
                                    const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
    1bc8:	10 92 ed 00 	sts	0x00ED, r1
	UECFG0X = UECFG0XData;
    1bcc:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
    1bd0:	40 93 ed 00 	sts	0x00ED, r20
			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1bd4:	80 91 ee 00 	lds	r24, 0x00EE

	return Endpoint_IsConfigured();
}
    1bd8:	88 1f       	adc	r24, r24
    1bda:	88 27       	eor	r24, r24
    1bdc:	88 1f       	adc	r24, r24
    1bde:	08 95       	ret

00001be0 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1be0:	80 91 11 14 	lds	r24, 0x1411
    1be4:	88 23       	and	r24, r24
    1be6:	9c f4       	brge	.+38     	; 0x1c0e <Endpoint_ClearStatusStage+0x2e>
    1be8:	04 c0       	rjmp	.+8      	; 0x1bf2 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1bea:	80 91 10 14 	lds	r24, 0x1410
    1bee:	88 23       	and	r24, r24
    1bf0:	b9 f0       	breq	.+46     	; 0x1c20 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1bf2:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1bf6:	82 ff       	sbrs	r24, 2
    1bf8:	f8 cf       	rjmp	.-16     	; 0x1bea <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1bfa:	80 91 e8 00 	lds	r24, 0x00E8
    1bfe:	8b 77       	andi	r24, 0x7B	; 123
    1c00:	80 93 e8 00 	sts	0x00E8, r24
    1c04:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c06:	80 91 10 14 	lds	r24, 0x1410
    1c0a:	88 23       	and	r24, r24
    1c0c:	49 f0       	breq	.+18     	; 0x1c20 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1c0e:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1c12:	80 ff       	sbrs	r24, 0
    1c14:	f8 cf       	rjmp	.-16     	; 0x1c06 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1c16:	80 91 e8 00 	lds	r24, 0x00E8
    1c1a:	8e 77       	andi	r24, 0x7E	; 126
    1c1c:	80 93 e8 00 	sts	0x00E8, r24
    1c20:	08 95       	ret

00001c22 <Endpoint_WaitUntilReady>:
			/** Returns the current USB frame number, when in device mode. Every millisecond the USB bus is active (i.e. enumerated to a host)
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1c22:	40 91 e4 00 	lds	r20, 0x00E4
    1c26:	50 91 e5 00 	lds	r21, 0x00E5
    1c2a:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    1c2c:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    1c30:	80 ff       	sbrs	r24, 0
    1c32:	05 c0       	rjmp	.+10     	; 0x1c3e <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1c34:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    1c38:	80 ff       	sbrs	r24, 0
    1c3a:	05 c0       	rjmp	.+10     	; 0x1c46 <Endpoint_WaitUntilReady+0x24>
    1c3c:	22 c0       	rjmp	.+68     	; 0x1c82 <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1c3e:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1c42:	82 fd       	sbrc	r24, 2
    1c44:	1e c0       	rjmp	.+60     	; 0x1c82 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1c46:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1c4a:	88 23       	and	r24, r24
    1c4c:	11 f4       	brne	.+4      	; 0x1c52 <Endpoint_WaitUntilReady+0x30>
    1c4e:	82 e0       	ldi	r24, 0x02	; 2
    1c50:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1c52:	85 30       	cpi	r24, 0x05	; 5
    1c54:	11 f4       	brne	.+4      	; 0x1c5a <Endpoint_WaitUntilReady+0x38>
    1c56:	83 e0       	ldi	r24, 0x03	; 3
    1c58:	08 95       	ret
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1c5a:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1c5e:	85 ff       	sbrs	r24, 5
    1c60:	02 c0       	rjmp	.+4      	; 0x1c66 <Endpoint_WaitUntilReady+0x44>
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	08 95       	ret
    1c66:	80 91 e4 00 	lds	r24, 0x00E4
    1c6a:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1c6e:	84 17       	cp	r24, r20
    1c70:	95 07       	cpc	r25, r21
    1c72:	e1 f2       	breq	.-72     	; 0x1c2c <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1c74:	22 23       	and	r18, r18
    1c76:	11 f4       	brne	.+4      	; 0x1c7c <Endpoint_WaitUntilReady+0x5a>
    1c78:	84 e0       	ldi	r24, 0x04	; 4
    1c7a:	08 95       	ret
    1c7c:	21 50       	subi	r18, 0x01	; 1
    1c7e:	ac 01       	movw	r20, r24
    1c80:	d5 cf       	rjmp	.-86     	; 0x1c2c <Endpoint_WaitUntilReady+0xa>
    1c82:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1c84:	08 95       	ret

00001c86 <USB_ResetInterface>:
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1c86:	55 d0       	rcall	.+170    	; 0x1d32 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1c88:	5c d0       	rcall	.+184    	; 0x1d42 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
    1c8a:	80 91 d8 00 	lds	r24, 0x00D8

				USBCON = (Temp & ~(1 << USBE));
    1c8e:	98 2f       	mov	r25, r24
    1c90:	9f 77       	andi	r25, 0x7F	; 127
    1c92:	90 93 d8 00 	sts	0x00D8, r25
				USBCON = (Temp |  (1 << USBE));
    1c96:	80 68       	ori	r24, 0x80	; 128
    1c98:	80 93 d8 00 	sts	0x00D8, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    1c9c:	8c e0       	ldi	r24, 0x0C	; 12
    1c9e:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    1ca0:	89 b5       	in	r24, 0x29	; 41
    1ca2:	82 60       	ori	r24, 0x02	; 2
    1ca4:	89 bd       	out	0x29, r24	; 41
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
    1ca6:	09 b4       	in	r0, 0x29	; 41
    1ca8:	00 fe       	sbrs	r0, 0
    1caa:	fd cf       	rjmp	.-6      	; 0x1ca6 <USB_ResetInterface+0x20>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1cac:	80 91 d8 00 	lds	r24, 0x00D8
    1cb0:	8f 7d       	andi	r24, 0xDF	; 223
    1cb2:	80 93 d8 00 	sts	0x00D8, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1cb6:	80 91 d7 00 	lds	r24, 0x00D7
    1cba:	80 68       	ori	r24, 0x80	; 128
    1cbc:	80 93 d7 00 	sts	0x00D7, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
    1cc0:	10 92 10 14 	sts	0x1410, r1
	USB_ConfigurationNumber  = 0;
    1cc4:	10 92 0e 14 	sts	0x140E, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
    1cc8:	10 92 0d 14 	sts	0x140D, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
    1ccc:	10 92 0c 14 	sts	0x140C, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1cd0:	80 91 e0 00 	lds	r24, 0x00E0
    1cd4:	8b 7f       	andi	r24, 0xFB	; 251
    1cd6:	80 93 e0 00 	sts	0x00E0, r24
	if (USB_Options & USB_DEVICE_OPT_LOWSPEED)
	  USB_Device_SetLowSpeed();
	else
	  USB_Device_SetFullSpeed();

	USB_INT_Enable(USB_INT_VBUS);
    1cda:	80 91 d8 00 	lds	r24, 0x00D8
    1cde:	81 60       	ori	r24, 0x01	; 1
    1ce0:	80 93 d8 00 	sts	0x00D8, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    1ce4:	80 e0       	ldi	r24, 0x00	; 0
    1ce6:	60 e0       	ldi	r22, 0x00	; 0
    1ce8:	42 e0       	ldi	r20, 0x02	; 2
    1cea:	67 df       	rcall	.-306    	; 0x1bba <Endpoint_ConfigureEndpoint_Prv>

	Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
							   ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
							   ENDPOINT_BANK_SINGLE);

	USB_INT_Clear(USB_INT_SUSPI);
    1cec:	80 91 e1 00 	lds	r24, 0x00E1
    1cf0:	8e 7f       	andi	r24, 0xFE	; 254
    1cf2:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_SUSPI);
    1cf6:	80 91 e2 00 	lds	r24, 0x00E2
    1cfa:	81 60       	ori	r24, 0x01	; 1
    1cfc:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Enable(USB_INT_EORSTI);
    1d00:	80 91 e2 00 	lds	r24, 0x00E2
    1d04:	88 60       	ori	r24, 0x08	; 8
    1d06:	80 93 e2 00 	sts	0x00E2, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1d0a:	80 91 e0 00 	lds	r24, 0x00E0
    1d0e:	8e 7f       	andi	r24, 0xFE	; 254
    1d10:	80 93 e0 00 	sts	0x00E0, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    1d14:	80 91 d8 00 	lds	r24, 0x00D8
    1d18:	80 61       	ori	r24, 0x10	; 16
    1d1a:	80 93 d8 00 	sts	0x00D8, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1d1e:	08 95       	ret

00001d20 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    1d20:	e7 ed       	ldi	r30, 0xD7	; 215
    1d22:	f0 e0       	ldi	r31, 0x00	; 0
    1d24:	80 81       	ld	r24, Z
    1d26:	81 60       	ori	r24, 0x01	; 1
    1d28:	80 83       	st	Z, r24
	{
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	80 93 0f 14 	sts	0x140F, r24

	USB_ResetInterface();
}
    1d30:	aa cf       	rjmp	.-172    	; 0x1c86 <USB_ResetInterface>

00001d32 <USB_INT_DisableAllInterrupts>:
#include "USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1d32:	e8 ed       	ldi	r30, 0xD8	; 216
    1d34:	f0 e0       	ldi	r31, 0x00	; 0
    1d36:	80 81       	ld	r24, Z
    1d38:	8c 7f       	andi	r24, 0xFC	; 252
    1d3a:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1d3c:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1d40:	08 95       	ret

00001d42 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT  = 0;
    1d42:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
    1d46:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1d4a:	08 95       	ret

00001d4c <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1d4c:	1f 92       	push	r1
    1d4e:	0f 92       	push	r0
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	0f 92       	push	r0
    1d54:	0b b6       	in	r0, 0x3b	; 59
    1d56:	0f 92       	push	r0
    1d58:	11 24       	eor	r1, r1
    1d5a:	2f 93       	push	r18
    1d5c:	3f 93       	push	r19
    1d5e:	4f 93       	push	r20
    1d60:	5f 93       	push	r21
    1d62:	6f 93       	push	r22
    1d64:	7f 93       	push	r23
    1d66:	8f 93       	push	r24
    1d68:	9f 93       	push	r25
    1d6a:	af 93       	push	r26
    1d6c:	bf 93       	push	r27
    1d6e:	ef 93       	push	r30
    1d70:	ff 93       	push	r31
	#if defined(USB_CAN_BE_DEVICE)
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUS) && USB_INT_IsEnabled(USB_INT_VBUS))
    1d72:	80 91 da 00 	lds	r24, 0x00DA
    1d76:	80 ff       	sbrs	r24, 0
    1d78:	17 c0       	rjmp	.+46     	; 0x1da8 <__vector_10+0x5c>
    1d7a:	80 91 d8 00 	lds	r24, 0x00D8
    1d7e:	80 ff       	sbrs	r24, 0
    1d80:	13 c0       	rjmp	.+38     	; 0x1da8 <__vector_10+0x5c>
	{
		USB_INT_Clear(USB_INT_VBUS);
    1d82:	80 91 da 00 	lds	r24, 0x00DA
    1d86:	8e 7f       	andi	r24, 0xFE	; 254
    1d88:	80 93 da 00 	sts	0x00DA, r24
				 *  \note This function is not available on some AVR models which do not support hardware VBUS monitoring.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1d8c:	80 91 d9 00 	lds	r24, 0x00D9

		if (USB_VBUS_GetStatus())
    1d90:	80 ff       	sbrs	r24, 0
    1d92:	06 c0       	rjmp	.+12     	; 0x1da0 <__vector_10+0x54>
		{
			USB_DeviceState = DEVICE_STATE_Powered;
    1d94:	81 e0       	ldi	r24, 0x01	; 1
    1d96:	80 93 10 14 	sts	0x1410, r24
			EVENT_USB_Device_Connect();
    1d9a:	0e 94 30 02 	call	0x460	; 0x460 <EVENT_USB_Device_Connect>
    1d9e:	04 c0       	rjmp	.+8      	; 0x1da8 <__vector_10+0x5c>
		}
		else
		{
			USB_DeviceState = DEVICE_STATE_Unattached;
    1da0:	10 92 10 14 	sts	0x1410, r1
			EVENT_USB_Device_Disconnect();
    1da4:	0e 94 35 02 	call	0x46a	; 0x46a <EVENT_USB_Device_Disconnect>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1da8:	80 91 e1 00 	lds	r24, 0x00E1
    1dac:	80 ff       	sbrs	r24, 0
    1dae:	1d c0       	rjmp	.+58     	; 0x1dea <__vector_10+0x9e>
    1db0:	80 91 e2 00 	lds	r24, 0x00E2
    1db4:	80 ff       	sbrs	r24, 0
    1db6:	19 c0       	rjmp	.+50     	; 0x1dea <__vector_10+0x9e>
	{
		USB_INT_Clear(USB_INT_SUSPI);
    1db8:	80 91 e1 00 	lds	r24, 0x00E1
    1dbc:	8e 7f       	andi	r24, 0xFE	; 254
    1dbe:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPI);
    1dc2:	80 91 e2 00 	lds	r24, 0x00E2
    1dc6:	8e 7f       	andi	r24, 0xFE	; 254
    1dc8:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
    1dcc:	80 91 e2 00 	lds	r24, 0x00E2
    1dd0:	80 61       	ori	r24, 0x10	; 16
    1dd2:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    1dd6:	80 91 d8 00 	lds	r24, 0x00D8
    1dda:	80 62       	ori	r24, 0x20	; 32
    1ddc:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    1de0:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1de2:	85 e0       	ldi	r24, 0x05	; 5
    1de4:	80 93 10 14 	sts	0x1410, r24
		EVENT_USB_Device_Suspend();
    1de8:	e8 d1       	rcall	.+976    	; 0x21ba <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1dea:	80 91 e1 00 	lds	r24, 0x00E1
    1dee:	84 ff       	sbrs	r24, 4
    1df0:	2e c0       	rjmp	.+92     	; 0x1e4e <__vector_10+0x102>
    1df2:	80 91 e2 00 	lds	r24, 0x00E2
    1df6:	84 ff       	sbrs	r24, 4
    1df8:	2a c0       	rjmp	.+84     	; 0x1e4e <__vector_10+0x102>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    1dfa:	8c e0       	ldi	r24, 0x0C	; 12
    1dfc:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    1dfe:	89 b5       	in	r24, 0x29	; 41
    1e00:	82 60       	ori	r24, 0x02	; 2
    1e02:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1e04:	09 b4       	in	r0, 0x29	; 41
    1e06:	00 fe       	sbrs	r0, 0
    1e08:	fd cf       	rjmp	.-6      	; 0x1e04 <__vector_10+0xb8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1e0a:	80 91 d8 00 	lds	r24, 0x00D8
    1e0e:	8f 7d       	andi	r24, 0xDF	; 223
    1e10:	80 93 d8 00 	sts	0x00D8, r24
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUPI);
    1e14:	80 91 e1 00 	lds	r24, 0x00E1
    1e18:	8f 7e       	andi	r24, 0xEF	; 239
    1e1a:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUPI);
    1e1e:	80 91 e2 00 	lds	r24, 0x00E2
    1e22:	8f 7e       	andi	r24, 0xEF	; 239
    1e24:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPI);
    1e28:	80 91 e2 00 	lds	r24, 0x00E2
    1e2c:	81 60       	ori	r24, 0x01	; 1
    1e2e:	80 93 e2 00 	sts	0x00E2, r24

		if (USB_ConfigurationNumber)
    1e32:	80 91 0e 14 	lds	r24, 0x140E
    1e36:	88 23       	and	r24, r24
    1e38:	31 f4       	brne	.+12     	; 0x1e46 <__vector_10+0xfa>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1e3a:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1e3e:	87 fd       	sbrc	r24, 7
    1e40:	02 c0       	rjmp	.+4      	; 0x1e46 <__vector_10+0xfa>
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	01 c0       	rjmp	.+2      	; 0x1e48 <__vector_10+0xfc>
    1e46:	84 e0       	ldi	r24, 0x04	; 4
    1e48:	80 93 10 14 	sts	0x1410, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1e4c:	b6 d1       	rcall	.+876    	; 0x21ba <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1e4e:	80 91 e1 00 	lds	r24, 0x00E1
    1e52:	83 ff       	sbrs	r24, 3
    1e54:	22 c0       	rjmp	.+68     	; 0x1e9a <__vector_10+0x14e>
    1e56:	80 91 e2 00 	lds	r24, 0x00E2
    1e5a:	83 ff       	sbrs	r24, 3
    1e5c:	1e c0       	rjmp	.+60     	; 0x1e9a <__vector_10+0x14e>
	{
		USB_INT_Clear(USB_INT_EORSTI);
    1e5e:	80 91 e1 00 	lds	r24, 0x00E1
    1e62:	87 7f       	andi	r24, 0xF7	; 247
    1e64:	80 93 e1 00 	sts	0x00E1, r24

		USB_DeviceState         = DEVICE_STATE_Default;
    1e68:	82 e0       	ldi	r24, 0x02	; 2
    1e6a:	80 93 10 14 	sts	0x1410, r24
		USB_ConfigurationNumber = 0;
    1e6e:	10 92 0e 14 	sts	0x140E, r1

		USB_INT_Clear(USB_INT_SUSPI);
    1e72:	80 91 e1 00 	lds	r24, 0x00E1
    1e76:	8e 7f       	andi	r24, 0xFE	; 254
    1e78:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPI);
    1e7c:	80 91 e2 00 	lds	r24, 0x00E2
    1e80:	8e 7f       	andi	r24, 0xFE	; 254
    1e82:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUPI);
    1e86:	80 91 e2 00 	lds	r24, 0x00E2
    1e8a:	80 61       	ori	r24, 0x10	; 16
    1e8c:	80 93 e2 00 	sts	0x00E2, r24
    1e90:	80 e0       	ldi	r24, 0x00	; 0
    1e92:	60 e0       	ldi	r22, 0x00	; 0
    1e94:	42 e0       	ldi	r20, 0x02	; 2
    1e96:	91 de       	rcall	.-734    	; 0x1bba <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1e98:	90 d1       	rcall	.+800    	; 0x21ba <USB_Event_Stub>
	}

	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1e9a:	80 91 e1 00 	lds	r24, 0x00E1
    1e9e:	82 ff       	sbrs	r24, 2
    1ea0:	0a c0       	rjmp	.+20     	; 0x1eb6 <__vector_10+0x16a>
    1ea2:	80 91 e2 00 	lds	r24, 0x00E2
    1ea6:	82 ff       	sbrs	r24, 2
    1ea8:	06 c0       	rjmp	.+12     	; 0x1eb6 <__vector_10+0x16a>
	{
		USB_INT_Clear(USB_INT_SOFI);
    1eaa:	80 91 e1 00 	lds	r24, 0x00E1
    1eae:	8b 7f       	andi	r24, 0xFB	; 251
    1eb0:	80 93 e1 00 	sts	0x00E1, r24

		EVENT_USB_Device_StartOfFrame();
    1eb4:	82 d1       	rcall	.+772    	; 0x21ba <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1eb6:	ff 91       	pop	r31
    1eb8:	ef 91       	pop	r30
    1eba:	bf 91       	pop	r27
    1ebc:	af 91       	pop	r26
    1ebe:	9f 91       	pop	r25
    1ec0:	8f 91       	pop	r24
    1ec2:	7f 91       	pop	r23
    1ec4:	6f 91       	pop	r22
    1ec6:	5f 91       	pop	r21
    1ec8:	4f 91       	pop	r20
    1eca:	3f 91       	pop	r19
    1ecc:	2f 91       	pop	r18
    1ece:	0f 90       	pop	r0
    1ed0:	0b be       	out	0x3b, r0	; 59
    1ed2:	0f 90       	pop	r0
    1ed4:	0f be       	out	0x3f, r0	; 63
    1ed6:	0f 90       	pop	r0
    1ed8:	1f 90       	pop	r1
    1eda:	18 95       	reti

00001edc <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1edc:	0f 93       	push	r16
    1ede:	1f 93       	push	r17
    1ee0:	df 93       	push	r29
    1ee2:	cf 93       	push	r28
    1ee4:	cd b7       	in	r28, 0x3d	; 61
    1ee6:	de b7       	in	r29, 0x3e	; 62
    1ee8:	ac 97       	sbiw	r28, 0x2c	; 44
    1eea:	0f b6       	in	r0, 0x3f	; 63
    1eec:	f8 94       	cli
    1eee:	de bf       	out	0x3e, r29	; 62
    1ef0:	0f be       	out	0x3f, r0	; 63
    1ef2:	cd bf       	out	0x3d, r28	; 61
    1ef4:	e1 e1       	ldi	r30, 0x11	; 17
    1ef6:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    1ef8:	80 91 f1 00 	lds	r24, 0x00F1
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
    1efc:	81 93       	st	Z+, r24

void USB_Device_ProcessControlRequest(void)
{
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1efe:	24 e1       	ldi	r18, 0x14	; 20
    1f00:	e9 31       	cpi	r30, 0x19	; 25
    1f02:	f2 07       	cpc	r31, r18
    1f04:	c9 f7       	brne	.-14     	; 0x1ef8 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_Byte();

	EVENT_USB_Device_ControlRequest();
    1f06:	0e 94 3a 02 	call	0x474	; 0x474 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1f0a:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    1f0e:	83 ff       	sbrs	r24, 3
    1f10:	3b c1       	rjmp	.+630    	; 0x2188 <__stack+0x89>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1f12:	80 91 11 14 	lds	r24, 0x1411

		switch (USB_ControlRequest.bRequest)
    1f16:	30 91 12 14 	lds	r19, 0x1412
    1f1a:	35 30       	cpi	r19, 0x05	; 5
    1f1c:	09 f4       	brne	.+2      	; 0x1f20 <USB_Device_ProcessControlRequest+0x44>
    1f1e:	87 c0       	rjmp	.+270    	; 0x202e <USB_Device_ProcessControlRequest+0x152>
    1f20:	36 30       	cpi	r19, 0x06	; 6
    1f22:	40 f4       	brcc	.+16     	; 0x1f34 <USB_Device_ProcessControlRequest+0x58>
    1f24:	31 30       	cpi	r19, 0x01	; 1
    1f26:	c9 f1       	breq	.+114    	; 0x1f9a <USB_Device_ProcessControlRequest+0xbe>
    1f28:	31 30       	cpi	r19, 0x01	; 1
    1f2a:	70 f0       	brcs	.+28     	; 0x1f48 <USB_Device_ProcessControlRequest+0x6c>
    1f2c:	33 30       	cpi	r19, 0x03	; 3
    1f2e:	09 f0       	breq	.+2      	; 0x1f32 <USB_Device_ProcessControlRequest+0x56>
    1f30:	2b c1       	rjmp	.+598    	; 0x2188 <__stack+0x89>
    1f32:	33 c0       	rjmp	.+102    	; 0x1f9a <USB_Device_ProcessControlRequest+0xbe>
    1f34:	38 30       	cpi	r19, 0x08	; 8
    1f36:	09 f4       	brne	.+2      	; 0x1f3a <USB_Device_ProcessControlRequest+0x5e>
    1f38:	f8 c0       	rjmp	.+496    	; 0x212a <__stack+0x2b>
    1f3a:	39 30       	cpi	r19, 0x09	; 9
    1f3c:	09 f4       	brne	.+2      	; 0x1f40 <USB_Device_ProcessControlRequest+0x64>
    1f3e:	07 c1       	rjmp	.+526    	; 0x214e <__stack+0x4f>
    1f40:	36 30       	cpi	r19, 0x06	; 6
    1f42:	09 f0       	breq	.+2      	; 0x1f46 <USB_Device_ProcessControlRequest+0x6a>
    1f44:	21 c1       	rjmp	.+578    	; 0x2188 <__stack+0x89>
    1f46:	99 c0       	rjmp	.+306    	; 0x207a <USB_Device_ProcessControlRequest+0x19e>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1f48:	80 38       	cpi	r24, 0x80	; 128
    1f4a:	21 f0       	breq	.+8      	; 0x1f54 <USB_Device_ProcessControlRequest+0x78>
    1f4c:	82 38       	cpi	r24, 0x82	; 130
    1f4e:	09 f0       	breq	.+2      	; 0x1f52 <USB_Device_ProcessControlRequest+0x76>
    1f50:	1b c1       	rjmp	.+566    	; 0x2188 <__stack+0x89>
    1f52:	08 c0       	rjmp	.+16     	; 0x1f64 <USB_Device_ProcessControlRequest+0x88>
    1f54:	90 91 0c 14 	lds	r25, 0x140C
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
    1f58:	80 91 0d 14 	lds	r24, 0x140D
    1f5c:	88 23       	and	r24, r24
    1f5e:	99 f0       	breq	.+38     	; 0x1f86 <USB_Device_ProcessControlRequest+0xaa>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1f60:	92 60       	ori	r25, 0x02	; 2
    1f62:	11 c0       	rjmp	.+34     	; 0x1f86 <USB_Device_ProcessControlRequest+0xaa>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1f64:	80 91 15 14 	lds	r24, 0x1415
    1f68:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1f6a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1f6e:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    1f72:	90 e0       	ldi	r25, 0x00	; 0
    1f74:	25 e0       	ldi	r18, 0x05	; 5
    1f76:	96 95       	lsr	r25
    1f78:	87 95       	ror	r24
    1f7a:	2a 95       	dec	r18
    1f7c:	e1 f7       	brne	.-8      	; 0x1f76 <USB_Device_ProcessControlRequest+0x9a>
    1f7e:	98 2f       	mov	r25, r24
    1f80:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1f82:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1f86:	80 91 e8 00 	lds	r24, 0x00E8
    1f8a:	87 7f       	andi	r24, 0xF7	; 247
    1f8c:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    1f90:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Word >> 8);
    1f94:	10 92 f1 00 	sts	0x00F1, r1
    1f98:	d3 c0       	rjmp	.+422    	; 0x2140 <__stack+0x41>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1f9a:	88 23       	and	r24, r24
    1f9c:	19 f0       	breq	.+6      	; 0x1fa4 <USB_Device_ProcessControlRequest+0xc8>
    1f9e:	82 30       	cpi	r24, 0x02	; 2
    1fa0:	09 f0       	breq	.+2      	; 0x1fa4 <USB_Device_ProcessControlRequest+0xc8>
    1fa2:	f2 c0       	rjmp	.+484    	; 0x2188 <__stack+0x89>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	8f 71       	andi	r24, 0x1F	; 31
    1fa8:	90 70       	andi	r25, 0x00	; 0
    1faa:	00 97       	sbiw	r24, 0x00	; 0
    1fac:	21 f0       	breq	.+8      	; 0x1fb6 <USB_Device_ProcessControlRequest+0xda>
    1fae:	02 97       	sbiw	r24, 0x02	; 2
    1fb0:	09 f0       	breq	.+2      	; 0x1fb4 <USB_Device_ProcessControlRequest+0xd8>
    1fb2:	ea c0       	rjmp	.+468    	; 0x2188 <__stack+0x89>
    1fb4:	0c c0       	rjmp	.+24     	; 0x1fce <USB_Device_ProcessControlRequest+0xf2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1fb6:	80 91 13 14 	lds	r24, 0x1413
    1fba:	81 30       	cpi	r24, 0x01	; 1
    1fbc:	09 f0       	breq	.+2      	; 0x1fc0 <USB_Device_ProcessControlRequest+0xe4>
    1fbe:	e4 c0       	rjmp	.+456    	; 0x2188 <__stack+0x89>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1fc0:	10 92 0d 14 	sts	0x140D, r1
    1fc4:	33 30       	cpi	r19, 0x03	; 3
    1fc6:	69 f5       	brne	.+90     	; 0x2022 <USB_Device_ProcessControlRequest+0x146>
    1fc8:	80 93 0d 14 	sts	0x140D, r24
    1fcc:	2a c0       	rjmp	.+84     	; 0x2022 <USB_Device_ProcessControlRequest+0x146>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1fce:	80 91 13 14 	lds	r24, 0x1413
    1fd2:	88 23       	and	r24, r24
    1fd4:	31 f5       	brne	.+76     	; 0x2022 <USB_Device_ProcessControlRequest+0x146>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1fd6:	20 91 15 14 	lds	r18, 0x1415
    1fda:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    1fdc:	09 f4       	brne	.+2      	; 0x1fe0 <USB_Device_ProcessControlRequest+0x104>
    1fde:	d4 c0       	rjmp	.+424    	; 0x2188 <__stack+0x89>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1fe0:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    1fe4:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    1fe8:	80 ff       	sbrs	r24, 0
    1fea:	1b c0       	rjmp	.+54     	; 0x2022 <USB_Device_ProcessControlRequest+0x146>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1fec:	33 30       	cpi	r19, 0x03	; 3
    1fee:	21 f4       	brne	.+8      	; 0x1ff8 <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    1ff0:	80 91 eb 00 	lds	r24, 0x00EB
    1ff4:	80 62       	ori	r24, 0x20	; 32
    1ff6:	13 c0       	rjmp	.+38     	; 0x201e <USB_Device_ProcessControlRequest+0x142>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    1ff8:	80 91 eb 00 	lds	r24, 0x00EB
    1ffc:	80 61       	ori	r24, 0x10	; 16
    1ffe:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	90 e0       	ldi	r25, 0x00	; 0
    2006:	02 c0       	rjmp	.+4      	; 0x200c <USB_Device_ProcessControlRequest+0x130>
    2008:	88 0f       	add	r24, r24
    200a:	99 1f       	adc	r25, r25
    200c:	2a 95       	dec	r18
    200e:	e2 f7       	brpl	.-8      	; 0x2008 <USB_Device_ProcessControlRequest+0x12c>
    2010:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    2014:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2018:	80 91 eb 00 	lds	r24, 0x00EB
    201c:	88 60       	ori	r24, 0x08	; 8
    201e:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2022:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2026:	80 91 e8 00 	lds	r24, 0x00E8
    202a:	87 7f       	andi	r24, 0xF7	; 247
    202c:	8c c0       	rjmp	.+280    	; 0x2146 <__stack+0x47>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    202e:	88 23       	and	r24, r24
    2030:	09 f0       	breq	.+2      	; 0x2034 <USB_Device_ProcessControlRequest+0x158>
    2032:	aa c0       	rjmp	.+340    	; 0x2188 <__stack+0x89>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2034:	10 91 13 14 	lds	r17, 0x1413
    2038:	1f 77       	andi	r17, 0x7F	; 127

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    203a:	0f b7       	in	r16, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    203c:	f8 94       	cli
    203e:	80 91 e8 00 	lds	r24, 0x00E8
    2042:	87 7f       	andi	r24, 0xF7	; 247
    2044:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_ClearSETUP();

		Endpoint_ClearStatusStage();
    2048:	cb dd       	rcall	.-1130   	; 0x1be0 <Endpoint_ClearStatusStage>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    204a:	80 91 e8 00 	lds	r24, 0x00E8

		while (!(Endpoint_IsINReady()));
    204e:	80 ff       	sbrs	r24, 0
    2050:	fc cf       	rjmp	.-8      	; 0x204a <USB_Device_ProcessControlRequest+0x16e>

		USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2052:	11 23       	and	r17, r17
    2054:	11 f4       	brne	.+4      	; 0x205a <USB_Device_ProcessControlRequest+0x17e>
    2056:	82 e0       	ldi	r24, 0x02	; 2
    2058:	01 c0       	rjmp	.+2      	; 0x205c <USB_Device_ProcessControlRequest+0x180>
    205a:	83 e0       	ldi	r24, 0x03	; 3
    205c:	80 93 10 14 	sts	0x1410, r24
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR  = ((UDADDR & (1 << ADDEN)) | (Address & 0x7F));
    2060:	80 91 e3 00 	lds	r24, 0x00E3
    2064:	80 78       	andi	r24, 0x80	; 128
    2066:	18 2b       	or	r17, r24
    2068:	10 93 e3 00 	sts	0x00E3, r17
				UDADDR |= (1 << ADDEN);
    206c:	80 91 e3 00 	lds	r24, 0x00E3
    2070:	80 68       	ori	r24, 0x80	; 128
    2072:	80 93 e3 00 	sts	0x00E3, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    2076:	0f bf       	out	0x3f, r16	; 63
    __asm__ volatile ("" ::: "memory");
    2078:	87 c0       	rjmp	.+270    	; 0x2188 <__stack+0x89>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    207a:	80 58       	subi	r24, 0x80	; 128
    207c:	82 30       	cpi	r24, 0x02	; 2
    207e:	08 f0       	brcs	.+2      	; 0x2082 <USB_Device_ProcessControlRequest+0x1a6>
    2080:	83 c0       	rjmp	.+262    	; 0x2188 <__stack+0x89>
	#if !defined(USE_FLASH_DESCRIPTORS) && !defined(USE_EEPROM_DESCRIPTORS) && !defined(USE_RAM_DESCRIPTORS)
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2082:	80 91 13 14 	lds	r24, 0x1413
    2086:	90 91 14 14 	lds	r25, 0x1414
    208a:	23 e0       	ldi	r18, 0x03	; 3
    208c:	8c 3d       	cpi	r24, 0xDC	; 220
    208e:	92 07       	cpc	r25, r18
    2090:	99 f5       	brne	.+102    	; 0x20f8 <USB_Device_ProcessControlRequest+0x21c>
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    2092:	7f b7       	in	r23, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2094:	f8 94       	cli
    2096:	de 01       	movw	r26, r28
    2098:	15 96       	adiw	r26, 0x05	; 5
    209a:	6e e0       	ldi	r22, 0x0E	; 14
    209c:	40 e0       	ldi	r20, 0x00	; 0
    209e:	50 e0       	ldi	r21, 0x00	; 0
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
		{
			uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    20a0:	11 e2       	ldi	r17, 0x21	; 33
    20a2:	e6 2f       	mov	r30, r22
    20a4:	f0 e0       	ldi	r31, 0x00	; 0
    20a6:	10 93 57 00 	sts	0x0057, r17
    20aa:	84 91       	lpm	r24, Z+

			if (SerialCharNum & 0x01)
    20ac:	40 ff       	sbrs	r20, 0
    20ae:	03 c0       	rjmp	.+6      	; 0x20b6 <USB_Device_ProcessControlRequest+0x1da>
			{
				SerialByte >>= 4;
    20b0:	82 95       	swap	r24
    20b2:	8f 70       	andi	r24, 0x0F	; 15
				SigReadAddress++;
    20b4:	6f 5f       	subi	r22, 0xFF	; 255
			}

			SerialByte &= 0x0F;
    20b6:	8f 70       	andi	r24, 0x0F	; 15
    20b8:	28 2f       	mov	r18, r24
    20ba:	30 e0       	ldi	r19, 0x00	; 0

			SignatureDescriptor.UnicodeString[SerialCharNum] = (SerialByte >= 10) ?
    20bc:	8a 30       	cpi	r24, 0x0A	; 10
    20be:	18 f0       	brcs	.+6      	; 0x20c6 <USB_Device_ProcessControlRequest+0x1ea>
    20c0:	c9 01       	movw	r24, r18
    20c2:	c7 96       	adiw	r24, 0x37	; 55
    20c4:	02 c0       	rjmp	.+4      	; 0x20ca <USB_Device_ProcessControlRequest+0x1ee>
    20c6:	c9 01       	movw	r24, r18
    20c8:	c0 96       	adiw	r24, 0x30	; 48
    20ca:	8d 93       	st	X+, r24
    20cc:	9d 93       	st	X+, r25
    20ce:	4f 5f       	subi	r20, 0xFF	; 255
    20d0:	5f 4f       	sbci	r21, 0xFF	; 255

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		uint8_t SigReadAddress = 0x0E;

		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
    20d2:	44 31       	cpi	r20, 0x14	; 20
    20d4:	51 05       	cpc	r21, r1
    20d6:	29 f7       	brne	.-54     	; 0x20a2 <USB_Device_ProcessControlRequest+0x1c6>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    20d8:	7f bf       	out	0x3f, r23	; 63
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);
    20da:	8a e2       	ldi	r24, 0x2A	; 42
    20dc:	8b 83       	std	Y+3, r24	; 0x03
	{
		USB_Descriptor_Header_t Header;
		wchar_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    20de:	83 e0       	ldi	r24, 0x03	; 3
    20e0:	8c 83       	std	Y+4, r24	; 0x04
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    20e2:	80 91 e8 00 	lds	r24, 0x00E8
    20e6:	87 7f       	andi	r24, 0xF7	; 247
    20e8:	80 93 e8 00 	sts	0x00E8, r24
		}
	}

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    20ec:	ce 01       	movw	r24, r28
    20ee:	03 96       	adiw	r24, 0x03	; 3
    20f0:	6a e2       	ldi	r22, 0x2A	; 42
    20f2:	70 e0       	ldi	r23, 0x00	; 0
    20f4:	63 d0       	rcall	.+198    	; 0x21bc <Endpoint_Write_Control_Stream_LE>
    20f6:	13 c0       	rjmp	.+38     	; 0x211e <__stack+0x1f>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    20f8:	60 91 15 14 	lds	r22, 0x1415
    20fc:	ae 01       	movw	r20, r28
    20fe:	4f 5f       	subi	r20, 0xFF	; 255
    2100:	5f 4f       	sbci	r21, 0xFF	; 255
    2102:	0e 94 a6 02 	call	0x54c	; 0x54c <CALLBACK_USB_GetDescriptor>
    2106:	bc 01       	movw	r22, r24
    2108:	00 97       	sbiw	r24, 0x00	; 0
    210a:	09 f4       	brne	.+2      	; 0x210e <__stack+0xf>
    210c:	3d c0       	rjmp	.+122    	; 0x2188 <__stack+0x89>
    210e:	80 91 e8 00 	lds	r24, 0x00E8
    2112:	87 7f       	andi	r24, 0xF7	; 247
    2114:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2118:	89 81       	ldd	r24, Y+1	; 0x01
    211a:	9a 81       	ldd	r25, Y+2	; 0x02
    211c:	ad d0       	rcall	.+346    	; 0x2278 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    211e:	80 91 e8 00 	lds	r24, 0x00E8
    2122:	8b 77       	andi	r24, 0x7B	; 123
    2124:	80 93 e8 00 	sts	0x00E8, r24
    2128:	2f c0       	rjmp	.+94     	; 0x2188 <__stack+0x89>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    212a:	80 38       	cpi	r24, 0x80	; 128
    212c:	69 f5       	brne	.+90     	; 0x2188 <__stack+0x89>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    212e:	80 91 e8 00 	lds	r24, 0x00E8
    2132:	87 7f       	andi	r24, 0xF7	; 247
    2134:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
    2138:	80 91 0e 14 	lds	r24, 0x140E
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    213c:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2140:	80 91 e8 00 	lds	r24, 0x00E8
    2144:	8e 77       	andi	r24, 0x7E	; 126
    2146:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    214a:	4a dd       	rcall	.-1388   	; 0x1be0 <Endpoint_ClearStatusStage>
    214c:	1d c0       	rjmp	.+58     	; 0x2188 <__stack+0x89>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    214e:	88 23       	and	r24, r24
    2150:	d9 f4       	brne	.+54     	; 0x2188 <__stack+0x89>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2152:	90 91 13 14 	lds	r25, 0x1413
    2156:	92 30       	cpi	r25, 0x02	; 2
    2158:	b8 f4       	brcc	.+46     	; 0x2188 <__stack+0x89>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    215a:	80 91 e8 00 	lds	r24, 0x00E8
    215e:	87 7f       	andi	r24, 0xF7	; 247
    2160:	80 93 e8 00 	sts	0x00E8, r24
	}
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2164:	90 93 0e 14 	sts	0x140E, r25

	Endpoint_ClearStatusStage();
    2168:	3b dd       	rcall	.-1418   	; 0x1be0 <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
    216a:	80 91 0e 14 	lds	r24, 0x140E
    216e:	88 23       	and	r24, r24
    2170:	31 f4       	brne	.+12     	; 0x217e <__stack+0x7f>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2172:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2176:	87 fd       	sbrc	r24, 7
    2178:	02 c0       	rjmp	.+4      	; 0x217e <__stack+0x7f>
    217a:	81 e0       	ldi	r24, 0x01	; 1
    217c:	01 c0       	rjmp	.+2      	; 0x2180 <__stack+0x81>
    217e:	84 e0       	ldi	r24, 0x04	; 4
    2180:	80 93 10 14 	sts	0x1410, r24

	EVENT_USB_Device_ConfigurationChanged();
    2184:	0e 94 3e 02 	call	0x47c	; 0x47c <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2188:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    218c:	83 ff       	sbrs	r24, 3
    218e:	0a c0       	rjmp	.+20     	; 0x21a4 <__stack+0xa5>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2190:	80 91 eb 00 	lds	r24, 0x00EB
    2194:	80 62       	ori	r24, 0x20	; 32
    2196:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    219a:	80 91 e8 00 	lds	r24, 0x00E8
    219e:	87 7f       	andi	r24, 0xF7	; 247
    21a0:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    21a4:	ac 96       	adiw	r28, 0x2c	; 44
    21a6:	0f b6       	in	r0, 0x3f	; 63
    21a8:	f8 94       	cli
    21aa:	de bf       	out	0x3e, r29	; 62
    21ac:	0f be       	out	0x3f, r0	; 63
    21ae:	cd bf       	out	0x3d, r28	; 61
    21b0:	cf 91       	pop	r28
    21b2:	df 91       	pop	r29
    21b4:	1f 91       	pop	r17
    21b6:	0f 91       	pop	r16
    21b8:	08 95       	ret

000021ba <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    21ba:	08 95       	ret

000021bc <Endpoint_Write_Control_Stream_LE>:
    21bc:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    21be:	40 91 17 14 	lds	r20, 0x1417
    21c2:	50 91 18 14 	lds	r21, 0x1418
    21c6:	46 17       	cp	r20, r22
    21c8:	57 07       	cpc	r21, r23
    21ca:	18 f4       	brcc	.+6      	; 0x21d2 <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    21cc:	f9 01       	movw	r30, r18
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	3d c0       	rjmp	.+122    	; 0x224c <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    21d2:	61 15       	cp	r22, r1
    21d4:	71 05       	cpc	r23, r1
    21d6:	11 f0       	breq	.+4      	; 0x21dc <Endpoint_Write_Control_Stream_LE+0x20>
    21d8:	ab 01       	movw	r20, r22
    21da:	f8 cf       	rjmp	.-16     	; 0x21cc <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    21dc:	80 91 e8 00 	lds	r24, 0x00E8
    21e0:	8e 77       	andi	r24, 0x7E	; 126
    21e2:	80 93 e8 00 	sts	0x00E8, r24
    21e6:	40 e0       	ldi	r20, 0x00	; 0
    21e8:	50 e0       	ldi	r21, 0x00	; 0
    21ea:	f0 cf       	rjmp	.-32     	; 0x21cc <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    21ec:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    21f0:	88 23       	and	r24, r24
    21f2:	f1 f1       	breq	.+124    	; 0x2270 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    21f4:	85 30       	cpi	r24, 0x05	; 5
    21f6:	f1 f1       	breq	.+124    	; 0x2274 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    21f8:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    21fc:	83 ff       	sbrs	r24, 3
    21fe:	02 c0       	rjmp	.+4      	; 0x2204 <Endpoint_Write_Control_Stream_LE+0x48>
    2200:	81 e0       	ldi	r24, 0x01	; 1
    2202:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2204:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2208:	82 fd       	sbrc	r24, 2
    220a:	2c c0       	rjmp	.+88     	; 0x2264 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    220c:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    2210:	80 ff       	sbrs	r24, 0
    2212:	1c c0       	rjmp	.+56     	; 0x224c <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2214:	20 91 f2 00 	lds	r18, 0x00F2
    2218:	30 91 f3 00 	lds	r19, 0x00F3
    221c:	07 c0       	rjmp	.+14     	; 0x222c <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    221e:	81 91       	ld	r24, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    2220:	80 93 f1 00 	sts	0x00F1, r24
				Length--;
    2224:	41 50       	subi	r20, 0x01	; 1
    2226:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    2228:	2f 5f       	subi	r18, 0xFF	; 255
    222a:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    222c:	41 15       	cp	r20, r1
    222e:	51 05       	cpc	r21, r1
    2230:	19 f0       	breq	.+6      	; 0x2238 <Endpoint_Write_Control_Stream_LE+0x7c>
    2232:	28 30       	cpi	r18, 0x08	; 8
    2234:	31 05       	cpc	r19, r1
    2236:	98 f3       	brcs	.-26     	; 0x221e <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	28 30       	cpi	r18, 0x08	; 8
    223c:	31 05       	cpc	r19, r1
    223e:	09 f4       	brne	.+2      	; 0x2242 <Endpoint_Write_Control_Stream_LE+0x86>
    2240:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2242:	80 91 e8 00 	lds	r24, 0x00E8
    2246:	8e 77       	andi	r24, 0x7E	; 126
    2248:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    224c:	41 15       	cp	r20, r1
    224e:	51 05       	cpc	r21, r1
    2250:	69 f6       	brne	.-102    	; 0x21ec <Endpoint_Write_Control_Stream_LE+0x30>
    2252:	99 23       	and	r25, r25
    2254:	59 f6       	brne	.-106    	; 0x21ec <Endpoint_Write_Control_Stream_LE+0x30>
    2256:	06 c0       	rjmp	.+12     	; 0x2264 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2258:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    225c:	88 23       	and	r24, r24
    225e:	41 f0       	breq	.+16     	; 0x2270 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2260:	85 30       	cpi	r24, 0x05	; 5
    2262:	41 f0       	breq	.+16     	; 0x2274 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2264:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2268:	82 ff       	sbrs	r24, 2
    226a:	f6 cf       	rjmp	.-20     	; 0x2258 <Endpoint_Write_Control_Stream_LE+0x9c>
    226c:	80 e0       	ldi	r24, 0x00	; 0
    226e:	08 95       	ret
    2270:	82 e0       	ldi	r24, 0x02	; 2
    2272:	08 95       	ret
    2274:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2276:	08 95       	ret

00002278 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
    2278:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    227a:	40 91 17 14 	lds	r20, 0x1417
    227e:	50 91 18 14 	lds	r21, 0x1418
    2282:	46 17       	cp	r20, r22
    2284:	57 07       	cpc	r21, r23
    2286:	10 f4       	brcc	.+4      	; 0x228c <Endpoint_Write_Control_PStream_LE+0x14>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2288:	60 e0       	ldi	r22, 0x00	; 0
    228a:	40 c0       	rjmp	.+128    	; 0x230c <Endpoint_Write_Control_PStream_LE+0x94>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    228c:	61 15       	cp	r22, r1
    228e:	71 05       	cpc	r23, r1
    2290:	11 f0       	breq	.+4      	; 0x2296 <Endpoint_Write_Control_PStream_LE+0x1e>
    2292:	ab 01       	movw	r20, r22
    2294:	f9 cf       	rjmp	.-14     	; 0x2288 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2296:	80 91 e8 00 	lds	r24, 0x00E8
    229a:	8e 77       	andi	r24, 0x7E	; 126
    229c:	80 93 e8 00 	sts	0x00E8, r24
    22a0:	40 e0       	ldi	r20, 0x00	; 0
    22a2:	50 e0       	ldi	r21, 0x00	; 0
    22a4:	f1 cf       	rjmp	.-30     	; 0x2288 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    22a6:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    22aa:	88 23       	and	r24, r24
    22ac:	09 f4       	brne	.+2      	; 0x22b0 <Endpoint_Write_Control_PStream_LE+0x38>
    22ae:	40 c0       	rjmp	.+128    	; 0x2330 <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    22b0:	85 30       	cpi	r24, 0x05	; 5
    22b2:	09 f4       	brne	.+2      	; 0x22b6 <Endpoint_Write_Control_PStream_LE+0x3e>
    22b4:	3f c0       	rjmp	.+126    	; 0x2334 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    22b6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    22ba:	83 ff       	sbrs	r24, 3
    22bc:	02 c0       	rjmp	.+4      	; 0x22c2 <Endpoint_Write_Control_PStream_LE+0x4a>
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    22c2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    22c6:	82 fd       	sbrc	r24, 2
    22c8:	2d c0       	rjmp	.+90     	; 0x2324 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    22ca:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    22ce:	80 ff       	sbrs	r24, 0
    22d0:	1d c0       	rjmp	.+58     	; 0x230c <Endpoint_Write_Control_PStream_LE+0x94>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    22d2:	80 91 f2 00 	lds	r24, 0x00F2
    22d6:	90 91 f3 00 	lds	r25, 0x00F3
    22da:	09 c0       	rjmp	.+18     	; 0x22ee <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    22dc:	f9 01       	movw	r30, r18
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    22de:	2f 5f       	subi	r18, 0xFF	; 255
    22e0:	3f 4f       	sbci	r19, 0xFF	; 255
    22e2:	e4 91       	lpm	r30, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    22e4:	e0 93 f1 00 	sts	0x00F1, r30
				Length--;
    22e8:	41 50       	subi	r20, 0x01	; 1
    22ea:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    22ec:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    22ee:	41 15       	cp	r20, r1
    22f0:	51 05       	cpc	r21, r1
    22f2:	19 f0       	breq	.+6      	; 0x22fa <Endpoint_Write_Control_PStream_LE+0x82>
    22f4:	88 30       	cpi	r24, 0x08	; 8
    22f6:	91 05       	cpc	r25, r1
    22f8:	88 f3       	brcs	.-30     	; 0x22dc <Endpoint_Write_Control_PStream_LE+0x64>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    22fa:	60 e0       	ldi	r22, 0x00	; 0
    22fc:	08 97       	sbiw	r24, 0x08	; 8
    22fe:	09 f4       	brne	.+2      	; 0x2302 <Endpoint_Write_Control_PStream_LE+0x8a>
    2300:	61 e0       	ldi	r22, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2302:	80 91 e8 00 	lds	r24, 0x00E8
    2306:	8e 77       	andi	r24, 0x7E	; 126
    2308:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    230c:	41 15       	cp	r20, r1
    230e:	51 05       	cpc	r21, r1
    2310:	51 f6       	brne	.-108    	; 0x22a6 <Endpoint_Write_Control_PStream_LE+0x2e>
    2312:	66 23       	and	r22, r22
    2314:	41 f6       	brne	.-112    	; 0x22a6 <Endpoint_Write_Control_PStream_LE+0x2e>
    2316:	06 c0       	rjmp	.+12     	; 0x2324 <Endpoint_Write_Control_PStream_LE+0xac>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2318:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    231c:	88 23       	and	r24, r24
    231e:	41 f0       	breq	.+16     	; 0x2330 <Endpoint_Write_Control_PStream_LE+0xb8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2320:	85 30       	cpi	r24, 0x05	; 5
    2322:	41 f0       	breq	.+16     	; 0x2334 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2324:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2328:	82 ff       	sbrs	r24, 2
    232a:	f6 cf       	rjmp	.-20     	; 0x2318 <Endpoint_Write_Control_PStream_LE+0xa0>
    232c:	80 e0       	ldi	r24, 0x00	; 0
    232e:	08 95       	ret
    2330:	82 e0       	ldi	r24, 0x02	; 2
    2332:	08 95       	ret
    2334:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2336:	08 95       	ret

00002338 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
    2338:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    233a:	61 15       	cp	r22, r1
    233c:	71 05       	cpc	r23, r1
    233e:	29 f4       	brne	.+10     	; 0x234a <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2340:	80 91 e8 00 	lds	r24, 0x00E8
    2344:	8b 77       	andi	r24, 0x7B	; 123
    2346:	80 93 e8 00 	sts	0x00E8, r24
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    234a:	f9 01       	movw	r30, r18
    234c:	22 c0       	rjmp	.+68     	; 0x2392 <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    234e:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2352:	88 23       	and	r24, r24
    2354:	71 f1       	breq	.+92     	; 0x23b2 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2356:	85 30       	cpi	r24, 0x05	; 5
    2358:	71 f1       	breq	.+92     	; 0x23b6 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    235a:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    235e:	83 ff       	sbrs	r24, 3
    2360:	02 c0       	rjmp	.+4      	; 0x2366 <Endpoint_Read_Control_Stream_LE+0x2e>
    2362:	81 e0       	ldi	r24, 0x01	; 1
    2364:	08 95       	ret
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2366:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    236a:	82 ff       	sbrs	r24, 2
    236c:	f0 cf       	rjmp	.-32     	; 0x234e <Endpoint_Read_Control_Stream_LE+0x16>
    236e:	06 c0       	rjmp	.+12     	; 0x237c <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    2370:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2374:	81 93       	st	Z+, r24
				Length--;
    2376:	61 50       	subi	r22, 0x01	; 1
    2378:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    237a:	31 f0       	breq	.+12     	; 0x2388 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    237c:	80 91 f2 00 	lds	r24, 0x00F2
    2380:	90 91 f3 00 	lds	r25, 0x00F3
    2384:	89 2b       	or	r24, r25
    2386:	a1 f7       	brne	.-24     	; 0x2370 <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2388:	80 91 e8 00 	lds	r24, 0x00E8
    238c:	8b 77       	andi	r24, 0x7B	; 123
    238e:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    2392:	61 15       	cp	r22, r1
    2394:	71 05       	cpc	r23, r1
    2396:	d9 f6       	brne	.-74     	; 0x234e <Endpoint_Read_Control_Stream_LE+0x16>
    2398:	06 c0       	rjmp	.+12     	; 0x23a6 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    239a:	80 91 10 14 	lds	r24, 0x1410

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    239e:	88 23       	and	r24, r24
    23a0:	41 f0       	breq	.+16     	; 0x23b2 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    23a2:	85 30       	cpi	r24, 0x05	; 5
    23a4:	41 f0       	breq	.+16     	; 0x23b6 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    23a6:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    23aa:	80 ff       	sbrs	r24, 0
    23ac:	f6 cf       	rjmp	.-20     	; 0x239a <Endpoint_Read_Control_Stream_LE+0x62>
    23ae:	80 e0       	ldi	r24, 0x00	; 0
    23b0:	08 95       	ret
    23b2:	82 e0       	ldi	r24, 0x02	; 2
    23b4:	08 95       	ret
    23b6:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    23b8:	08 95       	ret

000023ba <Endpoint_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    23ba:	df 92       	push	r13
    23bc:	ef 92       	push	r14
    23be:	ff 92       	push	r15
    23c0:	0f 93       	push	r16
    23c2:	1f 93       	push	r17
    23c4:	cf 93       	push	r28
    23c6:	df 93       	push	r29
    23c8:	18 2f       	mov	r17, r24
    23ca:	09 2f       	mov	r16, r25
    23cc:	eb 01       	movw	r28, r22
    23ce:	7a 01       	movw	r14, r20
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    23d0:	28 dc       	rcall	.-1968   	; 0x1c22 <Endpoint_WaitUntilReady>
    23d2:	d8 2e       	mov	r13, r24
    23d4:	88 23       	and	r24, r24
    23d6:	19 f5       	brne	.+70     	; 0x241e <Endpoint_Read_Stream_LE+0x64>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    23d8:	81 2f       	mov	r24, r17
    23da:	90 2f       	mov	r25, r16
    23dc:	9c 01       	movw	r18, r24
    23de:	89 01       	movw	r16, r18
    23e0:	1c c0       	rjmp	.+56     	; 0x241a <Endpoint_Read_Stream_LE+0x60>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    23e2:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    23e6:	85 fd       	sbrc	r24, 5
    23e8:	12 c0       	rjmp	.+36     	; 0x240e <Endpoint_Read_Stream_LE+0x54>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    23ea:	80 91 e8 00 	lds	r24, 0x00E8
    23ee:	8b 77       	andi	r24, 0x7B	; 123
    23f0:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    23f4:	e1 14       	cp	r14, r1
    23f6:	f1 04       	cpc	r15, r1
    23f8:	31 f0       	breq	.+12     	; 0x2406 <Endpoint_Read_Stream_LE+0x4c>
    23fa:	f7 01       	movw	r30, r14
    23fc:	09 95       	icall
    23fe:	81 30       	cpi	r24, 0x01	; 1
    2400:	11 f4       	brne	.+4      	; 0x2406 <Endpoint_Read_Stream_LE+0x4c>
    2402:	85 e0       	ldi	r24, 0x05	; 5
    2404:	0d c0       	rjmp	.+26     	; 0x2420 <Endpoint_Read_Stream_LE+0x66>
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2406:	0d dc       	rcall	.-2022   	; 0x1c22 <Endpoint_WaitUntilReady>
    2408:	88 23       	and	r24, r24
    240a:	39 f0       	breq	.+14     	; 0x241a <Endpoint_Read_Stream_LE+0x60>
    240c:	09 c0       	rjmp	.+18     	; 0x2420 <Endpoint_Read_Stream_LE+0x66>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    240e:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2412:	f8 01       	movw	r30, r16
    2414:	81 93       	st	Z+, r24
    2416:	8f 01       	movw	r16, r30
			Length--;
    2418:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    241a:	20 97       	sbiw	r28, 0x00	; 0
    241c:	11 f7       	brne	.-60     	; 0x23e2 <Endpoint_Read_Stream_LE+0x28>
    241e:	8d 2d       	mov	r24, r13
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2420:	df 91       	pop	r29
    2422:	cf 91       	pop	r28
    2424:	1f 91       	pop	r17
    2426:	0f 91       	pop	r16
    2428:	ff 90       	pop	r15
    242a:	ef 90       	pop	r14
    242c:	df 90       	pop	r13
    242e:	08 95       	ret

00002430 <Endpoint_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
    2430:	df 92       	push	r13
    2432:	ef 92       	push	r14
    2434:	ff 92       	push	r15
    2436:	0f 93       	push	r16
    2438:	1f 93       	push	r17
    243a:	cf 93       	push	r28
    243c:	df 93       	push	r29
    243e:	18 2f       	mov	r17, r24
    2440:	09 2f       	mov	r16, r25
    2442:	eb 01       	movw	r28, r22
    2444:	7a 01       	movw	r14, r20
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2446:	ed db       	rcall	.-2086   	; 0x1c22 <Endpoint_WaitUntilReady>
    2448:	d8 2e       	mov	r13, r24
    244a:	88 23       	and	r24, r24
    244c:	19 f5       	brne	.+70     	; 0x2494 <Endpoint_Write_Stream_LE+0x64>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer,
                            uint16_t Length
                            __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    244e:	81 2f       	mov	r24, r17
    2450:	90 2f       	mov	r25, r16
    2452:	9c 01       	movw	r18, r24
    2454:	89 01       	movw	r16, r18
    2456:	1c c0       	rjmp	.+56     	; 0x2490 <Endpoint_Write_Stream_LE+0x60>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2458:	80 91 e8 00 	lds	r24, 0x00E8
	}
	#endif

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    245c:	85 fd       	sbrc	r24, 5
    245e:	12 c0       	rjmp	.+36     	; 0x2484 <Endpoint_Write_Stream_LE+0x54>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2460:	80 91 e8 00 	lds	r24, 0x00E8
    2464:	8e 77       	andi	r24, 0x7E	; 126
    2466:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
    246a:	e1 14       	cp	r14, r1
    246c:	f1 04       	cpc	r15, r1
    246e:	31 f0       	breq	.+12     	; 0x247c <Endpoint_Write_Stream_LE+0x4c>
    2470:	f7 01       	movw	r30, r14
    2472:	09 95       	icall
    2474:	81 30       	cpi	r24, 0x01	; 1
    2476:	11 f4       	brne	.+4      	; 0x247c <Endpoint_Write_Stream_LE+0x4c>
    2478:	85 e0       	ldi	r24, 0x05	; 5
    247a:	0d c0       	rjmp	.+26     	; 0x2496 <Endpoint_Write_Stream_LE+0x66>
			  return ENDPOINT_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    247c:	d2 db       	rcall	.-2140   	; 0x1c22 <Endpoint_WaitUntilReady>
    247e:	88 23       	and	r24, r24
    2480:	39 f0       	breq	.+14     	; 0x2490 <Endpoint_Write_Stream_LE+0x60>
    2482:	09 c0       	rjmp	.+18     	; 0x2496 <Endpoint_Write_Stream_LE+0x66>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2484:	f8 01       	movw	r30, r16
    2486:	81 91       	ld	r24, Z+
    2488:	8f 01       	movw	r16, r30
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    248a:	80 93 f1 00 	sts	0x00F1, r24
			Length--;
    248e:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);
		}
	}
	#endif

	while (Length)
    2490:	20 97       	sbiw	r28, 0x00	; 0
    2492:	11 f7       	brne	.-60     	; 0x2458 <Endpoint_Write_Stream_LE+0x28>
    2494:	8d 2d       	mov	r24, r13
			Length--;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2496:	df 91       	pop	r29
    2498:	cf 91       	pop	r28
    249a:	1f 91       	pop	r17
    249c:	0f 91       	pop	r16
    249e:	ff 90       	pop	r15
    24a0:	ef 90       	pop	r14
    24a2:	df 90       	pop	r13
    24a4:	08 95       	ret

000024a6 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    24a6:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    24a8:	80 91 10 14 	lds	r24, 0x1410
    24ac:	88 23       	and	r24, r24
    24ae:	61 f0       	breq	.+24     	; 0x24c8 <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    24b0:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24b4:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    24b8:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    24bc:	83 ff       	sbrs	r24, 3
    24be:	01 c0       	rjmp	.+2      	; 0x24c2 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    24c0:	0d dd       	rcall	.-1510   	; 0x1edc <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    24c2:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24c4:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    24c8:	1f 91       	pop	r17
    24ca:	08 95       	ret

000024cc <RNDIS_Device_USBTask>:

	return true;
}

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    24cc:	ef 92       	push	r14
    24ce:	ff 92       	push	r15
    24d0:	0f 93       	push	r16
    24d2:	1f 93       	push	r17
    24d4:	df 93       	push	r29
    24d6:	cf 93       	push	r28
    24d8:	cd b7       	in	r28, 0x3d	; 61
    24da:	de b7       	in	r29, 0x3e	; 62
    24dc:	ac 97       	sbiw	r28, 0x2c	; 44
    24de:	0f b6       	in	r0, 0x3f	; 63
    24e0:	f8 94       	cli
    24e2:	de bf       	out	0x3e, r29	; 62
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	cd bf       	out	0x3d, r28	; 61
    24e8:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    24ea:	80 91 10 14 	lds	r24, 0x1410
    24ee:	84 30       	cpi	r24, 0x04	; 4
    24f0:	09 f0       	breq	.+2      	; 0x24f4 <RNDIS_Device_USBTask+0x28>
    24f2:	d4 c0       	rjmp	.+424    	; 0x269c <RNDIS_Device_USBTask+0x1d0>
	  return;

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    24f4:	d8 01       	movw	r26, r16
    24f6:	19 96       	adiw	r26, 0x09	; 9
    24f8:	8c 91       	ld	r24, X
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24fa:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    24fe:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2502:	80 ff       	sbrs	r24, 0
    2504:	23 c0       	rjmp	.+70     	; 0x254c <RNDIS_Device_USBTask+0x80>
    2506:	0b 56       	subi	r16, 0x6B	; 107
    2508:	1f 4f       	sbci	r17, 0xFF	; 255
    250a:	f8 01       	movw	r30, r16
    250c:	80 81       	ld	r24, Z
    250e:	05 59       	subi	r16, 0x95	; 149
    2510:	10 40       	sbci	r17, 0x00	; 0
    2512:	88 23       	and	r24, r24
    2514:	d9 f0       	breq	.+54     	; 0x254c <RNDIS_Device_USBTask+0x80>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = 0,
				.wIndex        = 0,
				.wLength       = 0,
			};
    2516:	de 01       	movw	r26, r28
    2518:	11 96       	adiw	r26, 0x01	; 1
    251a:	ed ea       	ldi	r30, 0xAD	; 173
    251c:	fd e0       	ldi	r31, 0x0D	; 13
    251e:	88 e0       	ldi	r24, 0x08	; 8
    2520:	01 90       	ld	r0, Z+
    2522:	0d 92       	st	X+, r0
    2524:	81 50       	subi	r24, 0x01	; 1
    2526:	e1 f7       	brne	.-8      	; 0x2520 <RNDIS_Device_USBTask+0x54>

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NO_STREAM_CALLBACK);
    2528:	ce 01       	movw	r24, r28
    252a:	01 96       	adiw	r24, 0x01	; 1
    252c:	68 e0       	ldi	r22, 0x08	; 8
    252e:	70 e0       	ldi	r23, 0x00	; 0
    2530:	40 e0       	ldi	r20, 0x00	; 0
    2532:	50 e0       	ldi	r21, 0x00	; 0
    2534:	7d df       	rcall	.-262    	; 0x2430 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2536:	80 91 e8 00 	lds	r24, 0x00E8
    253a:	8e 77       	andi	r24, 0x7E	; 126
    253c:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2540:	0b 56       	subi	r16, 0x6B	; 107
    2542:	1f 4f       	sbci	r17, 0xFF	; 255
    2544:	d8 01       	movw	r26, r16
    2546:	1c 92       	st	X, r1
    2548:	05 59       	subi	r16, 0x95	; 149
    254a:	10 40       	sbci	r17, 0x00	; 0
	}

	if ((RNDISInterfaceInfo->State.CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
    254c:	0a 56       	subi	r16, 0x6A	; 106
    254e:	1f 4f       	sbci	r17, 0xFF	; 255
    2550:	f8 01       	movw	r30, r16
    2552:	80 81       	ld	r24, Z
    2554:	06 59       	subi	r16, 0x96	; 150
    2556:	10 40       	sbci	r17, 0x00	; 0
    2558:	82 30       	cpi	r24, 0x02	; 2
    255a:	09 f0       	breq	.+2      	; 0x255e <RNDIS_Device_USBTask+0x92>
    255c:	9f c0       	rjmp	.+318    	; 0x269c <RNDIS_Device_USBTask+0x1d0>
    255e:	f8 01       	movw	r30, r16
    2560:	81 8d       	ldd	r24, Z+25	; 0x19
    2562:	92 8d       	ldd	r25, Z+26	; 0x1a
    2564:	a3 8d       	ldd	r26, Z+27	; 0x1b
    2566:	b4 8d       	ldd	r27, Z+28	; 0x1c
    2568:	00 97       	sbiw	r24, 0x00	; 0
    256a:	a1 05       	cpc	r26, r1
    256c:	b1 05       	cpc	r27, r1
    256e:	09 f0       	breq	.+2      	; 0x2572 <RNDIS_Device_USBTask+0xa6>
    2570:	95 c0       	rjmp	.+298    	; 0x269c <RNDIS_Device_USBTask+0x1d0>
	{
		RNDIS_Packet_Message_t RNDISPacketHeader;

		Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    2572:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2574:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2578:	80 91 e8 00 	lds	r24, 0x00E8

		if (Endpoint_IsOUTReceived() && !(RNDISInterfaceInfo->State.FrameIN.FrameInBuffer))
    257c:	82 ff       	sbrs	r24, 2
    257e:	3b c0       	rjmp	.+118    	; 0x25f6 <RNDIS_Device_USBTask+0x12a>
    2580:	99 e7       	ldi	r25, 0x79	; 121
    2582:	e9 2e       	mov	r14, r25
    2584:	96 e0       	ldi	r25, 0x06	; 6
    2586:	f9 2e       	mov	r15, r25
    2588:	e0 0e       	add	r14, r16
    258a:	f1 1e       	adc	r15, r17
    258c:	d7 01       	movw	r26, r14
    258e:	8c 91       	ld	r24, X
    2590:	88 23       	and	r24, r24
    2592:	89 f5       	brne	.+98     	; 0x25f6 <RNDIS_Device_USBTask+0x12a>
		{
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NO_STREAM_CALLBACK);
    2594:	ce 01       	movw	r24, r28
    2596:	01 96       	adiw	r24, 0x01	; 1
    2598:	6c e2       	ldi	r22, 0x2C	; 44
    259a:	70 e0       	ldi	r23, 0x00	; 0
    259c:	40 e0       	ldi	r20, 0x00	; 0
    259e:	50 e0       	ldi	r21, 0x00	; 0
    25a0:	0c df       	rcall	.-488    	; 0x23ba <Endpoint_Read_Stream_LE>

			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
    25a2:	2d 85       	ldd	r18, Y+13	; 0x0d
    25a4:	3e 85       	ldd	r19, Y+14	; 0x0e
    25a6:	4f 85       	ldd	r20, Y+15	; 0x0f
    25a8:	58 89       	ldd	r21, Y+16	; 0x10
    25aa:	2d 3d       	cpi	r18, 0xDD	; 221
    25ac:	b5 e0       	ldi	r27, 0x05	; 5
    25ae:	3b 07       	cpc	r19, r27
    25b0:	b0 e0       	ldi	r27, 0x00	; 0
    25b2:	4b 07       	cpc	r20, r27
    25b4:	b0 e0       	ldi	r27, 0x00	; 0
    25b6:	5b 07       	cpc	r21, r27
    25b8:	30 f0       	brcs	.+12     	; 0x25c6 <RNDIS_Device_USBTask+0xfa>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    25ba:	80 91 eb 00 	lds	r24, 0x00EB
    25be:	80 62       	ori	r24, 0x20	; 32
    25c0:	80 93 eb 00 	sts	0x00EB, r24
    25c4:	6b c0       	rjmp	.+214    	; 0x269c <RNDIS_Device_USBTask+0x1d0>
			{
				Endpoint_StallTransaction();
				return;
			}

			Endpoint_Read_Stream_LE(RNDISInterfaceInfo->State.FrameIN.FrameData, RNDISPacketHeader.DataLength, NO_STREAM_CALLBACK);
    25c6:	c8 01       	movw	r24, r16
    25c8:	85 56       	subi	r24, 0x65	; 101
    25ca:	9f 4f       	sbci	r25, 0xFF	; 255
    25cc:	b9 01       	movw	r22, r18
    25ce:	40 e0       	ldi	r20, 0x00	; 0
    25d0:	50 e0       	ldi	r21, 0x00	; 0
    25d2:	f3 de       	rcall	.-538    	; 0x23ba <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    25d4:	80 91 e8 00 	lds	r24, 0x00E8
    25d8:	8b 77       	andi	r24, 0x7B	; 123
    25da:	80 93 e8 00 	sts	0x00E8, r24

			Endpoint_ClearOUT();

			RNDISInterfaceInfo->State.FrameIN.FrameLength = RNDISPacketHeader.DataLength;
    25de:	09 58       	subi	r16, 0x89	; 137
    25e0:	19 4f       	sbci	r17, 0xF9	; 249
    25e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    25e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    25e6:	f8 01       	movw	r30, r16
    25e8:	91 83       	std	Z+1, r25	; 0x01
    25ea:	80 83       	st	Z, r24
    25ec:	07 57       	subi	r16, 0x77	; 119
    25ee:	16 40       	sbci	r17, 0x06	; 6

			RNDISInterfaceInfo->State.FrameIN.FrameInBuffer = true;
    25f0:	81 e0       	ldi	r24, 0x01	; 1
    25f2:	d7 01       	movw	r26, r14
    25f4:	8c 93       	st	X, r24
		}

		Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    25f6:	f8 01       	movw	r30, r16
    25f8:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25fa:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    25fe:	80 91 e8 00 	lds	r24, 0x00E8

		if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.FrameOUT.FrameInBuffer)
    2602:	80 ff       	sbrs	r24, 0
    2604:	4b c0       	rjmp	.+150    	; 0x269c <RNDIS_Device_USBTask+0x1d0>
    2606:	88 e5       	ldi	r24, 0x58	; 88
    2608:	e8 2e       	mov	r14, r24
    260a:	8c e0       	ldi	r24, 0x0C	; 12
    260c:	f8 2e       	mov	r15, r24
    260e:	e0 0e       	add	r14, r16
    2610:	f1 1e       	adc	r15, r17
    2612:	d7 01       	movw	r26, r14
    2614:	8c 91       	ld	r24, X
    2616:	88 23       	and	r24, r24
    2618:	09 f4       	brne	.+2      	; 0x261c <RNDIS_Device_USBTask+0x150>
    261a:	40 c0       	rjmp	.+128    	; 0x269c <RNDIS_Device_USBTask+0x1d0>
		{
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    261c:	fe 01       	movw	r30, r28
    261e:	31 96       	adiw	r30, 0x01	; 1
    2620:	8c e2       	ldi	r24, 0x2C	; 44
    2622:	df 01       	movw	r26, r30
    2624:	1d 92       	st	X+, r1
    2626:	8a 95       	dec	r24
    2628:	e9 f7       	brne	.-6      	; 0x2624 <RNDIS_Device_USBTask+0x158>

			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	90 e0       	ldi	r25, 0x00	; 0
    262e:	a0 e0       	ldi	r26, 0x00	; 0
    2630:	b0 e0       	ldi	r27, 0x00	; 0
    2632:	89 83       	std	Y+1, r24	; 0x01
    2634:	9a 83       	std	Y+2, r25	; 0x02
    2636:	ab 83       	std	Y+3, r26	; 0x03
    2638:	bc 83       	std	Y+4, r27	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + RNDISInterfaceInfo->State.FrameOUT.FrameLength);
    263a:	0a 5a       	subi	r16, 0xAA	; 170
    263c:	13 4f       	sbci	r17, 0xF3	; 243
    263e:	d8 01       	movw	r26, r16
    2640:	8d 91       	ld	r24, X+
    2642:	9c 91       	ld	r25, X
    2644:	8c 96       	adiw	r24, 0x2c	; 44
    2646:	9c 01       	movw	r18, r24
    2648:	40 e0       	ldi	r20, 0x00	; 0
    264a:	50 e0       	ldi	r21, 0x00	; 0
    264c:	8c 97       	sbiw	r24, 0x2c	; 44
    264e:	2d 83       	std	Y+5, r18	; 0x05
    2650:	3e 83       	std	Y+6, r19	; 0x06
    2652:	4f 83       	std	Y+7, r20	; 0x07
    2654:	58 87       	std	Y+8, r21	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2656:	24 e2       	ldi	r18, 0x24	; 36
    2658:	30 e0       	ldi	r19, 0x00	; 0
    265a:	40 e0       	ldi	r20, 0x00	; 0
    265c:	50 e0       	ldi	r21, 0x00	; 0
    265e:	29 87       	std	Y+9, r18	; 0x09
    2660:	3a 87       	std	Y+10, r19	; 0x0a
    2662:	4b 87       	std	Y+11, r20	; 0x0b
    2664:	5c 87       	std	Y+12, r21	; 0x0c
			RNDISPacketHeader.DataLength    = RNDISInterfaceInfo->State.FrameOUT.FrameLength;
    2666:	a0 e0       	ldi	r26, 0x00	; 0
    2668:	b0 e0       	ldi	r27, 0x00	; 0
    266a:	8d 87       	std	Y+13, r24	; 0x0d
    266c:	9e 87       	std	Y+14, r25	; 0x0e
    266e:	af 87       	std	Y+15, r26	; 0x0f
    2670:	b8 8b       	std	Y+16, r27	; 0x10

			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NO_STREAM_CALLBACK);
    2672:	cf 01       	movw	r24, r30
    2674:	6c e2       	ldi	r22, 0x2C	; 44
    2676:	70 e0       	ldi	r23, 0x00	; 0
    2678:	40 e0       	ldi	r20, 0x00	; 0
    267a:	50 e0       	ldi	r21, 0x00	; 0
    267c:	d9 de       	rcall	.-590    	; 0x2430 <Endpoint_Write_Stream_LE>
			Endpoint_Write_Stream_LE(RNDISInterfaceInfo->State.FrameOUT.FrameData, RNDISPacketHeader.DataLength, NO_STREAM_CALLBACK);
    267e:	6d 85       	ldd	r22, Y+13	; 0x0d
    2680:	7e 85       	ldd	r23, Y+14	; 0x0e
    2682:	c8 01       	movw	r24, r16
    2684:	8c 5d       	subi	r24, 0xDC	; 220
    2686:	95 40       	sbci	r25, 0x05	; 5
    2688:	40 e0       	ldi	r20, 0x00	; 0
    268a:	50 e0       	ldi	r21, 0x00	; 0
    268c:	d1 de       	rcall	.-606    	; 0x2430 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    268e:	80 91 e8 00 	lds	r24, 0x00E8
    2692:	8e 77       	andi	r24, 0x7E	; 126
    2694:	80 93 e8 00 	sts	0x00E8, r24
			Endpoint_ClearIN();

			RNDISInterfaceInfo->State.FrameOUT.FrameInBuffer = false;
    2698:	f7 01       	movw	r30, r14
    269a:	10 82       	st	Z, r1
		}
	}
}
    269c:	ac 96       	adiw	r28, 0x2c	; 44
    269e:	0f b6       	in	r0, 0x3f	; 63
    26a0:	f8 94       	cli
    26a2:	de bf       	out	0x3e, r29	; 62
    26a4:	0f be       	out	0x3f, r0	; 63
    26a6:	cd bf       	out	0x3d, r28	; 61
    26a8:	cf 91       	pop	r28
    26aa:	df 91       	pop	r29
    26ac:	1f 91       	pop	r17
    26ae:	0f 91       	pop	r16
    26b0:	ff 90       	pop	r15
    26b2:	ef 90       	pop	r14
    26b4:	08 95       	ret

000026b6 <RNDIS_Device_ConfigureEndpoints>:
			break;
	}
}

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    26b6:	1f 93       	push	r17
    26b8:	cf 93       	push	r28
    26ba:	df 93       	push	r29
    26bc:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    26be:	45 96       	adiw	r24, 0x15	; 21
    26c0:	fc 01       	movw	r30, r24
    26c2:	84 e4       	ldi	r24, 0x44	; 68
    26c4:	9c e0       	ldi	r25, 0x0C	; 12
    26c6:	df 01       	movw	r26, r30
    26c8:	9c 01       	movw	r18, r24
    26ca:	1d 92       	st	X+, r1
    26cc:	21 50       	subi	r18, 0x01	; 1
    26ce:	30 40       	sbci	r19, 0x00	; 0
    26d0:	e1 f7       	brne	.-8      	; 0x26ca <RNDIS_Device_ConfigureEndpoints+0x14>
    26d2:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	18 17       	cp	r17, r24
    26d8:	29 f4       	brne	.+10     	; 0x26e4 <RNDIS_Device_ConfigureEndpoints+0x2e>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    26da:	ea 81       	ldd	r30, Y+2	; 0x02
    26dc:	fb 81       	ldd	r31, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    26de:	8c 81       	ldd	r24, Y+4	; 0x04
    26e0:	62 e0       	ldi	r22, 0x02	; 2
    26e2:	10 c0       	rjmp	.+32     	; 0x2704 <RNDIS_Device_ConfigureEndpoints+0x4e>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    26e4:	8d 81       	ldd	r24, Y+5	; 0x05
    26e6:	18 17       	cp	r17, r24
    26e8:	31 f4       	brne	.+12     	; 0x26f6 <RNDIS_Device_ConfigureEndpoints+0x40>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    26ea:	ee 81       	ldd	r30, Y+6	; 0x06
    26ec:	ff 81       	ldd	r31, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    26ee:	88 85       	ldd	r24, Y+8	; 0x08
    26f0:	62 e0       	ldi	r22, 0x02	; 2
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	08 c0       	rjmp	.+16     	; 0x2706 <RNDIS_Device_ConfigureEndpoints+0x50>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    26f6:	89 85       	ldd	r24, Y+9	; 0x09
    26f8:	18 17       	cp	r17, r24
    26fa:	09 f5       	brne	.+66     	; 0x273e <RNDIS_Device_ConfigureEndpoints+0x88>
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    26fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    26fe:	fb 85       	ldd	r31, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    2700:	8c 85       	ldd	r24, Y+12	; 0x0c
    2702:	63 e0       	ldi	r22, 0x03	; 3
    2704:	31 e0       	ldi	r19, 0x01	; 1
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    2706:	88 23       	and	r24, r24
    2708:	11 f4       	brne	.+4      	; 0x270e <RNDIS_Device_ConfigureEndpoints+0x58>
    270a:	40 e0       	ldi	r20, 0x00	; 0
    270c:	01 c0       	rjmp	.+2      	; 0x2710 <RNDIS_Device_ConfigureEndpoints+0x5a>
    270e:	44 e0       	ldi	r20, 0x04	; 4
    2710:	20 e0       	ldi	r18, 0x00	; 0
    2712:	88 e0       	ldi	r24, 0x08	; 8
    2714:	90 e0       	ldi	r25, 0x00	; 0
    2716:	03 c0       	rjmp	.+6      	; 0x271e <RNDIS_Device_ConfigureEndpoints+0x68>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    2718:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    271a:	88 0f       	add	r24, r24
    271c:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    271e:	8e 17       	cp	r24, r30
    2720:	9f 07       	cpc	r25, r31
    2722:	d0 f3       	brcs	.-12     	; 0x2718 <RNDIS_Device_ConfigureEndpoints+0x62>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    2724:	62 95       	swap	r22
    2726:	66 0f       	add	r22, r22
    2728:	66 0f       	add	r22, r22
    272a:	60 7c       	andi	r22, 0xC0	; 192
    272c:	63 2b       	or	r22, r19
    272e:	42 60       	ori	r20, 0x02	; 2
    2730:	22 95       	swap	r18
    2732:	20 7f       	andi	r18, 0xF0	; 240
    2734:	42 2b       	or	r20, r18
    2736:	81 2f       	mov	r24, r17
    2738:	40 da       	rcall	.-2944   	; 0x1bba <Endpoint_ConfigureEndpoint_Prv>
    273a:	88 23       	and	r24, r24
    273c:	21 f0       	breq	.+8      	; 0x2746 <RNDIS_Device_ConfigureEndpoints+0x90>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    273e:	1f 5f       	subi	r17, 0xFF	; 255
    2740:	17 30       	cpi	r17, 0x07	; 7
    2742:	41 f6       	brne	.-112    	; 0x26d4 <RNDIS_Device_ConfigureEndpoints+0x1e>
    2744:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    2746:	df 91       	pop	r29
    2748:	cf 91       	pop	r28
    274a:	1f 91       	pop	r17
    274c:	08 95       	ret

0000274e <RNDIS_Device_ProcessControlRequest>:
		OID_802_3_XMIT_ONE_COLLISION,
		OID_802_3_XMIT_MORE_COLLISIONS,
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    274e:	ef 92       	push	r14
    2750:	ff 92       	push	r15
    2752:	0f 93       	push	r16
    2754:	1f 93       	push	r17
    2756:	cf 93       	push	r28
    2758:	df 93       	push	r29
    275a:	ec 01       	movw	r28, r24
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    275c:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    2760:	83 ff       	sbrs	r24, 3
    2762:	b9 c2       	rjmp	.+1394   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    2764:	88 81       	ld	r24, Y
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	20 91 15 14 	lds	r18, 0x1415
    276c:	30 91 16 14 	lds	r19, 0x1416
    2770:	28 17       	cp	r18, r24
    2772:	39 07       	cpc	r19, r25
    2774:	09 f0       	breq	.+2      	; 0x2778 <RNDIS_Device_ProcessControlRequest+0x2a>
    2776:	af c2       	rjmp	.+1374   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
	  return;

	switch (USB_ControlRequest.bRequest)
    2778:	80 91 12 14 	lds	r24, 0x1412
    277c:	88 23       	and	r24, r24
    277e:	21 f0       	breq	.+8      	; 0x2788 <RNDIS_Device_ProcessControlRequest+0x3a>
    2780:	81 30       	cpi	r24, 0x01	; 1
    2782:	09 f0       	breq	.+2      	; 0x2786 <RNDIS_Device_ProcessControlRequest+0x38>
    2784:	a8 c2       	rjmp	.+1360   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
    2786:	57 c2       	rjmp	.+1198   	; 0x2c36 <RNDIS_Device_ProcessControlRequest+0x4e8>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    2788:	80 91 11 14 	lds	r24, 0x1411
    278c:	81 32       	cpi	r24, 0x21	; 33
    278e:	09 f0       	breq	.+2      	; 0x2792 <RNDIS_Device_ProcessControlRequest+0x44>
    2790:	a2 c2       	rjmp	.+1348   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2792:	80 91 e8 00 	lds	r24, 0x00E8
    2796:	87 7f       	andi	r24, 0xF7	; 247
    2798:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    279c:	8e 01       	movw	r16, r28
    279e:	0b 5e       	subi	r16, 0xEB	; 235
    27a0:	1f 4f       	sbci	r17, 0xFF	; 255
    27a2:	60 91 17 14 	lds	r22, 0x1417
    27a6:	70 91 18 14 	lds	r23, 0x1418
    27aa:	c8 01       	movw	r24, r16
    27ac:	c5 dd       	rcall	.-1142   	; 0x2338 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    27ae:	80 91 e8 00 	lds	r24, 0x00E8
    27b2:	8e 77       	andi	r24, 0x7E	; 126
    27b4:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (MessageHeader->MessageType)
    27b8:	8d 89       	ldd	r24, Y+21	; 0x15
    27ba:	9e 89       	ldd	r25, Y+22	; 0x16
    27bc:	af 89       	ldd	r26, Y+23	; 0x17
    27be:	b8 8d       	ldd	r27, Y+24	; 0x18
    27c0:	84 30       	cpi	r24, 0x04	; 4
    27c2:	91 05       	cpc	r25, r1
    27c4:	a1 05       	cpc	r26, r1
    27c6:	b1 05       	cpc	r27, r1
    27c8:	09 f4       	brne	.+2      	; 0x27cc <RNDIS_Device_ProcessControlRequest+0x7e>
    27ca:	77 c0       	rjmp	.+238    	; 0x28ba <RNDIS_Device_ProcessControlRequest+0x16c>
    27cc:	85 30       	cpi	r24, 0x05	; 5
    27ce:	91 05       	cpc	r25, r1
    27d0:	a1 05       	cpc	r26, r1
    27d2:	b1 05       	cpc	r27, r1
    27d4:	58 f4       	brcc	.+22     	; 0x27ec <RNDIS_Device_ProcessControlRequest+0x9e>
    27d6:	82 30       	cpi	r24, 0x02	; 2
    27d8:	91 05       	cpc	r25, r1
    27da:	a1 05       	cpc	r26, r1
    27dc:	b1 05       	cpc	r27, r1
    27de:	c1 f0       	breq	.+48     	; 0x2810 <RNDIS_Device_ProcessControlRequest+0xc2>
    27e0:	03 97       	sbiw	r24, 0x03	; 3
    27e2:	a1 05       	cpc	r26, r1
    27e4:	b1 05       	cpc	r27, r1
    27e6:	09 f0       	breq	.+2      	; 0x27ea <RNDIS_Device_ProcessControlRequest+0x9c>
    27e8:	76 c2       	rjmp	.+1260   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
    27ea:	5d c0       	rjmp	.+186    	; 0x28a6 <RNDIS_Device_ProcessControlRequest+0x158>
    27ec:	86 30       	cpi	r24, 0x06	; 6
    27ee:	91 05       	cpc	r25, r1
    27f0:	a1 05       	cpc	r26, r1
    27f2:	b1 05       	cpc	r27, r1
    27f4:	09 f4       	brne	.+2      	; 0x27f8 <RNDIS_Device_ProcessControlRequest+0xaa>
    27f6:	e7 c1       	rjmp	.+974    	; 0x2bc6 <RNDIS_Device_ProcessControlRequest+0x478>
    27f8:	86 30       	cpi	r24, 0x06	; 6
    27fa:	91 05       	cpc	r25, r1
    27fc:	a1 05       	cpc	r26, r1
    27fe:	b1 05       	cpc	r27, r1
    2800:	08 f4       	brcc	.+2      	; 0x2804 <RNDIS_Device_ProcessControlRequest+0xb6>
    2802:	96 c1       	rjmp	.+812    	; 0x2b30 <RNDIS_Device_ProcessControlRequest+0x3e2>
    2804:	08 97       	sbiw	r24, 0x08	; 8
    2806:	a1 05       	cpc	r26, r1
    2808:	b1 05       	cpc	r27, r1
    280a:	09 f0       	breq	.+2      	; 0x280e <RNDIS_Device_ProcessControlRequest+0xc0>
    280c:	64 c2       	rjmp	.+1224   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
    280e:	f7 c1       	rjmp	.+1006   	; 0x2bfe <RNDIS_Device_ProcessControlRequest+0x4b0>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2810:	cb 56       	subi	r28, 0x6B	; 107
    2812:	df 4f       	sbci	r29, 0xFF	; 255
    2814:	21 e0       	ldi	r18, 0x01	; 1
    2816:	28 83       	st	Y, r18
    2818:	c5 59       	subi	r28, 0x95	; 149
    281a:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
    281c:	82 e0       	ldi	r24, 0x02	; 2
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	a0 e0       	ldi	r26, 0x00	; 0
    2822:	b0 e8       	ldi	r27, 0x80	; 128
    2824:	8d 8b       	std	Y+21, r24	; 0x15
    2826:	9e 8b       	std	Y+22, r25	; 0x16
    2828:	af 8b       	std	Y+23, r26	; 0x17
    282a:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
    282c:	84 e3       	ldi	r24, 0x34	; 52
    282e:	90 e0       	ldi	r25, 0x00	; 0
    2830:	a0 e0       	ldi	r26, 0x00	; 0
    2832:	b0 e0       	ldi	r27, 0x00	; 0
    2834:	f8 01       	movw	r30, r16
    2836:	84 83       	std	Z+4, r24	; 0x04
    2838:	95 83       	std	Z+5, r25	; 0x05
    283a:	a6 83       	std	Z+6, r26	; 0x06
    283c:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
    283e:	14 86       	std	Z+12, r1	; 0x0c
    2840:	15 86       	std	Z+13, r1	; 0x0d
    2842:	16 86       	std	Z+14, r1	; 0x0e
    2844:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
    2846:	81 e0       	ldi	r24, 0x01	; 1
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	a0 e0       	ldi	r26, 0x00	; 0
    284c:	b0 e0       	ldi	r27, 0x00	; 0
    284e:	80 8b       	std	Z+16, r24	; 0x10
    2850:	91 8b       	std	Z+17, r25	; 0x11
    2852:	a2 8b       	std	Z+18, r26	; 0x12
    2854:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
    2856:	14 8a       	std	Z+20, r1	; 0x14
    2858:	15 8a       	std	Z+21, r1	; 0x15
    285a:	16 8a       	std	Z+22, r1	; 0x16
    285c:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
    285e:	80 8f       	std	Z+24, r24	; 0x18
    2860:	91 8f       	std	Z+25, r25	; 0x19
    2862:	a2 8f       	std	Z+26, r26	; 0x1a
    2864:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
    2866:	14 8e       	std	Z+28, r1	; 0x1c
    2868:	15 8e       	std	Z+29, r1	; 0x1d
    286a:	16 8e       	std	Z+30, r1	; 0x1e
    286c:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
    286e:	80 a3       	std	Z+32, r24	; 0x20
    2870:	91 a3       	std	Z+33, r25	; 0x21
    2872:	a2 a3       	std	Z+34, r26	; 0x22
    2874:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    2876:	88 e0       	ldi	r24, 0x08	; 8
    2878:	96 e0       	ldi	r25, 0x06	; 6
    287a:	a0 e0       	ldi	r26, 0x00	; 0
    287c:	b0 e0       	ldi	r27, 0x00	; 0
    287e:	84 a3       	std	Z+36, r24	; 0x24
    2880:	95 a3       	std	Z+37, r25	; 0x25
    2882:	a6 a3       	std	Z+38, r26	; 0x26
    2884:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
    2886:	10 a6       	std	Z+40, r1	; 0x28
    2888:	11 a6       	std	Z+41, r1	; 0x29
    288a:	12 a6       	std	Z+42, r1	; 0x2a
    288c:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset          = 0;
    288e:	14 a6       	std	Z+44, r1	; 0x2c
    2890:	15 a6       	std	Z+45, r1	; 0x2d
    2892:	16 a6       	std	Z+46, r1	; 0x2e
    2894:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize            = 0;
    2896:	10 aa       	std	Z+48, r1	; 0x30
    2898:	11 aa       	std	Z+49, r1	; 0x31
    289a:	12 aa       	std	Z+50, r1	; 0x32
    289c:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState = RNDIS_Initialized;
    289e:	ca 56       	subi	r28, 0x6A	; 106
    28a0:	df 4f       	sbci	r29, 0xFF	; 255
    28a2:	28 83       	st	Y, r18
    28a4:	18 c2       	rjmp	.+1072   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>

			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady = false;
    28a6:	cb 56       	subi	r28, 0x6B	; 107
    28a8:	df 4f       	sbci	r29, 0xFF	; 255
    28aa:	19 92       	st	Y+, r1
			MessageHeader->MessageLength = 0;
    28ac:	f8 01       	movw	r30, r16
    28ae:	14 82       	std	Z+4, r1	; 0x04
    28b0:	15 82       	std	Z+5, r1	; 0x05
    28b2:	16 82       	std	Z+6, r1	; 0x06
    28b4:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState = RNDIS_Uninitialized;
    28b6:	18 82       	st	Y, r1
    28b8:	0e c2       	rjmp	.+1052   	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>

			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    28ba:	cb 56       	subi	r28, 0x6B	; 107
    28bc:	df 4f       	sbci	r29, 0xFF	; 255
    28be:	81 e0       	ldi	r24, 0x01	; 1
    28c0:	88 83       	st	Y, r24
    28c2:	c5 59       	subi	r28, 0x95	; 149
    28c4:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid      = QUERY_Message->Oid;
    28c6:	f8 01       	movw	r30, r16
    28c8:	24 85       	ldd	r18, Z+12	; 0x0c
    28ca:	35 85       	ldd	r19, Z+13	; 0x0d
    28cc:	46 85       	ldd	r20, Z+14	; 0x0e
    28ce:	57 85       	ldd	r21, Z+15	; 0x0f

			void*     QueryData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                    QUERY_Message->InformationBufferOffset];
			void*     ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    28d0:	6d e2       	ldi	r22, 0x2D	; 45
    28d2:	e6 2e       	mov	r14, r22
    28d4:	f1 2c       	mov	r15, r1
    28d6:	ec 0e       	add	r14, r28
    28d8:	fd 1e       	adc	r15, r29
			uint16_t  ResponseSize;

			QUERY_Response->MessageType   = REMOTE_NDIS_QUERY_CMPLT;
    28da:	84 e0       	ldi	r24, 0x04	; 4
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	a0 e0       	ldi	r26, 0x00	; 0
    28e0:	b0 e8       	ldi	r27, 0x80	; 128
    28e2:	8d 8b       	std	Y+21, r24	; 0x15
    28e4:	9e 8b       	std	Y+22, r25	; 0x16
    28e6:	af 8b       	std	Y+23, r26	; 0x17
    28e8:	b8 8f       	std	Y+24, r27	; 0x18
			QUERY_Response->MessageLength = sizeof(RNDIS_Query_Complete_t);
    28ea:	88 e1       	ldi	r24, 0x18	; 24
    28ec:	90 e0       	ldi	r25, 0x00	; 0
    28ee:	a0 e0       	ldi	r26, 0x00	; 0
    28f0:	b0 e0       	ldi	r27, 0x00	; 0
    28f2:	84 83       	std	Z+4, r24	; 0x04
    28f4:	95 83       	std	Z+5, r25	; 0x05
    28f6:	a6 83       	std	Z+6, r26	; 0x06
    28f8:	b7 83       	std	Z+7, r27	; 0x07
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    28fa:	2e 30       	cpi	r18, 0x0E	; 14
    28fc:	f1 e0       	ldi	r31, 0x01	; 1
    28fe:	3f 07       	cpc	r19, r31
    2900:	f1 e0       	ldi	r31, 0x01	; 1
    2902:	4f 07       	cpc	r20, r31
    2904:	f0 e0       	ldi	r31, 0x00	; 0
    2906:	5f 07       	cpc	r21, r31
    2908:	09 f4       	brne	.+2      	; 0x290c <RNDIS_Device_ProcessControlRequest+0x1be>
    290a:	e7 c0       	rjmp	.+462    	; 0x2ada <RNDIS_Device_ProcessControlRequest+0x38c>
    290c:	2f 30       	cpi	r18, 0x0F	; 15
    290e:	61 e0       	ldi	r22, 0x01	; 1
    2910:	36 07       	cpc	r19, r22
    2912:	61 e0       	ldi	r22, 0x01	; 1
    2914:	46 07       	cpc	r20, r22
    2916:	60 e0       	ldi	r22, 0x00	; 0
    2918:	56 07       	cpc	r21, r22
    291a:	08 f0       	brcs	.+2      	; 0x291e <RNDIS_Device_ProcessControlRequest+0x1d0>
    291c:	58 c0       	rjmp	.+176    	; 0x29ce <RNDIS_Device_ProcessControlRequest+0x280>
    291e:	26 30       	cpi	r18, 0x06	; 6
    2920:	81 e0       	ldi	r24, 0x01	; 1
    2922:	38 07       	cpc	r19, r24
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	48 07       	cpc	r20, r24
    2928:	80 e0       	ldi	r24, 0x00	; 0
    292a:	58 07       	cpc	r21, r24
    292c:	09 f4       	brne	.+2      	; 0x2930 <RNDIS_Device_ProcessControlRequest+0x1e2>
    292e:	ae c0       	rjmp	.+348    	; 0x2a8c <RNDIS_Device_ProcessControlRequest+0x33e>
    2930:	27 30       	cpi	r18, 0x07	; 7
    2932:	e1 e0       	ldi	r30, 0x01	; 1
    2934:	3e 07       	cpc	r19, r30
    2936:	e1 e0       	ldi	r30, 0x01	; 1
    2938:	4e 07       	cpc	r20, r30
    293a:	e0 e0       	ldi	r30, 0x00	; 0
    293c:	5e 07       	cpc	r21, r30
    293e:	f8 f4       	brcc	.+62     	; 0x297e <RNDIS_Device_ProcessControlRequest+0x230>
    2940:	22 30       	cpi	r18, 0x02	; 2
    2942:	f1 e0       	ldi	r31, 0x01	; 1
    2944:	3f 07       	cpc	r19, r31
    2946:	f1 e0       	ldi	r31, 0x01	; 1
    2948:	4f 07       	cpc	r20, r31
    294a:	f0 e0       	ldi	r31, 0x00	; 0
    294c:	5f 07       	cpc	r21, r31
    294e:	09 f4       	brne	.+2      	; 0x2952 <RNDIS_Device_ProcessControlRequest+0x204>
    2950:	cd c0       	rjmp	.+410    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x39e>
    2952:	23 30       	cpi	r18, 0x03	; 3
    2954:	61 e0       	ldi	r22, 0x01	; 1
    2956:	36 07       	cpc	r19, r22
    2958:	61 e0       	ldi	r22, 0x01	; 1
    295a:	46 07       	cpc	r20, r22
    295c:	60 e0       	ldi	r22, 0x00	; 0
    295e:	56 07       	cpc	r21, r22
    2960:	38 f4       	brcc	.+14     	; 0x2970 <RNDIS_Device_ProcessControlRequest+0x222>
    2962:	21 50       	subi	r18, 0x01	; 1
    2964:	31 40       	sbci	r19, 0x01	; 1
    2966:	41 40       	sbci	r20, 0x01	; 1
    2968:	50 40       	sbci	r21, 0x00	; 0
    296a:	09 f0       	breq	.+2      	; 0x296e <RNDIS_Device_ProcessControlRequest+0x220>
    296c:	cf c0       	rjmp	.+414    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    296e:	80 c0       	rjmp	.+256    	; 0x2a70 <RNDIS_Device_ProcessControlRequest+0x322>
    2970:	25 50       	subi	r18, 0x05	; 5
    2972:	31 40       	sbci	r19, 0x01	; 1
    2974:	41 40       	sbci	r20, 0x01	; 1
    2976:	50 40       	sbci	r21, 0x00	; 0
    2978:	08 f0       	brcs	.+2      	; 0x297c <RNDIS_Device_ProcessControlRequest+0x22e>
    297a:	c8 c0       	rjmp	.+400    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    297c:	b7 c0       	rjmp	.+366    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x39e>
    297e:	2c 30       	cpi	r18, 0x0C	; 12
    2980:	f1 e0       	ldi	r31, 0x01	; 1
    2982:	3f 07       	cpc	r19, r31
    2984:	f1 e0       	ldi	r31, 0x01	; 1
    2986:	4f 07       	cpc	r20, r31
    2988:	f0 e0       	ldi	r31, 0x00	; 0
    298a:	5f 07       	cpc	r21, r31
    298c:	80 f4       	brcc	.+32     	; 0x29ae <RNDIS_Device_ProcessControlRequest+0x260>
    298e:	2a 30       	cpi	r18, 0x0A	; 10
    2990:	61 e0       	ldi	r22, 0x01	; 1
    2992:	36 07       	cpc	r19, r22
    2994:	61 e0       	ldi	r22, 0x01	; 1
    2996:	46 07       	cpc	r20, r22
    2998:	60 e0       	ldi	r22, 0x00	; 0
    299a:	56 07       	cpc	r21, r22
    299c:	08 f0       	brcs	.+2      	; 0x29a0 <RNDIS_Device_ProcessControlRequest+0x252>
    299e:	76 c0       	rjmp	.+236    	; 0x2a8c <RNDIS_Device_ProcessControlRequest+0x33e>
    29a0:	27 50       	subi	r18, 0x07	; 7
    29a2:	31 40       	sbci	r19, 0x01	; 1
    29a4:	41 40       	sbci	r20, 0x01	; 1
    29a6:	50 40       	sbci	r21, 0x00	; 0
    29a8:	09 f0       	breq	.+2      	; 0x29ac <RNDIS_Device_ProcessControlRequest+0x25e>
    29aa:	b0 c0       	rjmp	.+352    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    29ac:	81 c0       	rjmp	.+258    	; 0x2ab0 <RNDIS_Device_ProcessControlRequest+0x362>
    29ae:	2c 30       	cpi	r18, 0x0C	; 12
    29b0:	e1 e0       	ldi	r30, 0x01	; 1
    29b2:	3e 07       	cpc	r19, r30
    29b4:	e1 e0       	ldi	r30, 0x01	; 1
    29b6:	4e 07       	cpc	r20, r30
    29b8:	e0 e0       	ldi	r30, 0x00	; 0
    29ba:	5e 07       	cpc	r21, r30
    29bc:	09 f4       	brne	.+2      	; 0x29c0 <RNDIS_Device_ProcessControlRequest+0x272>
    29be:	61 c0       	rjmp	.+194    	; 0x2a82 <RNDIS_Device_ProcessControlRequest+0x334>
    29c0:	2d 50       	subi	r18, 0x0D	; 13
    29c2:	31 40       	sbci	r19, 0x01	; 1
    29c4:	41 40       	sbci	r20, 0x01	; 1
    29c6:	50 40       	sbci	r21, 0x00	; 0
    29c8:	09 f0       	breq	.+2      	; 0x29cc <RNDIS_Device_ProcessControlRequest+0x27e>
    29ca:	a0 c0       	rjmp	.+320    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    29cc:	64 c0       	rjmp	.+200    	; 0x2a96 <RNDIS_Device_ProcessControlRequest+0x348>
    29ce:	26 30       	cpi	r18, 0x06	; 6
    29d0:	61 e0       	ldi	r22, 0x01	; 1
    29d2:	36 07       	cpc	r19, r22
    29d4:	62 e0       	ldi	r22, 0x02	; 2
    29d6:	46 07       	cpc	r20, r22
    29d8:	60 e0       	ldi	r22, 0x00	; 0
    29da:	56 07       	cpc	r21, r22
    29dc:	10 f5       	brcc	.+68     	; 0x2a22 <RNDIS_Device_ProcessControlRequest+0x2d4>
    29de:	21 30       	cpi	r18, 0x01	; 1
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	38 07       	cpc	r19, r24
    29e4:	82 e0       	ldi	r24, 0x02	; 2
    29e6:	48 07       	cpc	r20, r24
    29e8:	80 e0       	ldi	r24, 0x00	; 0
    29ea:	58 07       	cpc	r21, r24
    29ec:	08 f0       	brcs	.+2      	; 0x29f0 <RNDIS_Device_ProcessControlRequest+0x2a2>
    29ee:	7e c0       	rjmp	.+252    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x39e>
    29f0:	24 31       	cpi	r18, 0x14	; 20
    29f2:	e1 e0       	ldi	r30, 0x01	; 1
    29f4:	3e 07       	cpc	r19, r30
    29f6:	e1 e0       	ldi	r30, 0x01	; 1
    29f8:	4e 07       	cpc	r20, r30
    29fa:	e0 e0       	ldi	r30, 0x00	; 0
    29fc:	5e 07       	cpc	r21, r30
    29fe:	09 f4       	brne	.+2      	; 0x2a02 <RNDIS_Device_ProcessControlRequest+0x2b4>
    2a00:	75 c0       	rjmp	.+234    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x39e>
    2a02:	22 30       	cpi	r18, 0x02	; 2
    2a04:	f2 e0       	ldi	r31, 0x02	; 2
    2a06:	3f 07       	cpc	r19, r31
    2a08:	f1 e0       	ldi	r31, 0x01	; 1
    2a0a:	4f 07       	cpc	r20, r31
    2a0c:	f0 e0       	ldi	r31, 0x00	; 0
    2a0e:	5f 07       	cpc	r21, r31
    2a10:	09 f4       	brne	.+2      	; 0x2a14 <RNDIS_Device_ProcessControlRequest+0x2c6>
    2a12:	6c c0       	rjmp	.+216    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x39e>
    2a14:	21 51       	subi	r18, 0x11	; 17
    2a16:	31 40       	sbci	r19, 0x01	; 1
    2a18:	41 40       	sbci	r20, 0x01	; 1
    2a1a:	50 40       	sbci	r21, 0x00	; 0
    2a1c:	09 f0       	breq	.+2      	; 0x2a20 <RNDIS_Device_ProcessControlRequest+0x2d2>
    2a1e:	76 c0       	rjmp	.+236    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    2a20:	6a c0       	rjmp	.+212    	; 0x2af6 <RNDIS_Device_ProcessControlRequest+0x3a8>
    2a22:	24 30       	cpi	r18, 0x04	; 4
    2a24:	81 e0       	ldi	r24, 0x01	; 1
    2a26:	38 07       	cpc	r19, r24
    2a28:	81 e0       	ldi	r24, 0x01	; 1
    2a2a:	48 07       	cpc	r20, r24
    2a2c:	81 e0       	ldi	r24, 0x01	; 1
    2a2e:	58 07       	cpc	r21, r24
    2a30:	09 f4       	brne	.+2      	; 0x2a34 <RNDIS_Device_ProcessControlRequest+0x2e6>
    2a32:	4e c0       	rjmp	.+156    	; 0x2ad0 <RNDIS_Device_ProcessControlRequest+0x382>
    2a34:	25 30       	cpi	r18, 0x05	; 5
    2a36:	e1 e0       	ldi	r30, 0x01	; 1
    2a38:	3e 07       	cpc	r19, r30
    2a3a:	e1 e0       	ldi	r30, 0x01	; 1
    2a3c:	4e 07       	cpc	r20, r30
    2a3e:	e1 e0       	ldi	r30, 0x01	; 1
    2a40:	5e 07       	cpc	r21, r30
    2a42:	58 f4       	brcc	.+22     	; 0x2a5a <RNDIS_Device_ProcessControlRequest+0x30c>
    2a44:	21 50       	subi	r18, 0x01	; 1
    2a46:	31 40       	sbci	r19, 0x01	; 1
    2a48:	41 40       	sbci	r20, 0x01	; 1
    2a4a:	51 40       	sbci	r21, 0x01	; 1
    2a4c:	22 30       	cpi	r18, 0x02	; 2
    2a4e:	31 05       	cpc	r19, r1
    2a50:	41 05       	cpc	r20, r1
    2a52:	51 05       	cpc	r21, r1
    2a54:	08 f0       	brcs	.+2      	; 0x2a58 <RNDIS_Device_ProcessControlRequest+0x30a>
    2a56:	5a c0       	rjmp	.+180    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    2a58:	30 c0       	rjmp	.+96     	; 0x2aba <RNDIS_Device_ProcessControlRequest+0x36c>
    2a5a:	21 50       	subi	r18, 0x01	; 1
    2a5c:	31 40       	sbci	r19, 0x01	; 1
    2a5e:	42 40       	sbci	r20, 0x02	; 2
    2a60:	51 40       	sbci	r21, 0x01	; 1
    2a62:	23 30       	cpi	r18, 0x03	; 3
    2a64:	31 05       	cpc	r19, r1
    2a66:	41 05       	cpc	r20, r1
    2a68:	51 05       	cpc	r21, r1
    2a6a:	08 f0       	brcs	.+2      	; 0x2a6e <RNDIS_Device_ProcessControlRequest+0x320>
    2a6c:	4f c0       	rjmp	.+158    	; 0x2b0c <RNDIS_Device_ProcessControlRequest+0x3be>
    2a6e:	3e c0       	rjmp	.+124    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x39e>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2a70:	c7 01       	movw	r24, r14
    2a72:	66 eb       	ldi	r22, 0xB6	; 182
    2a74:	73 e0       	ldi	r23, 0x03	; 3
    2a76:	4c e6       	ldi	r20, 0x6C	; 108
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	4f d1       	rcall	.+670    	; 0x2d1a <memcpy_P>
    2a7c:	cc e6       	ldi	r28, 0x6C	; 108
    2a7e:	d0 e0       	ldi	r29, 0x00	; 0
    2a80:	0a c1       	rjmp	.+532    	; 0x2c96 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
    2a82:	8f ef       	ldi	r24, 0xFF	; 255
    2a84:	9f ef       	ldi	r25, 0xFF	; 255
    2a86:	af ef       	ldi	r26, 0xFF	; 255
    2a88:	b0 e0       	ldi	r27, 0x00	; 0
    2a8a:	39 c0       	rjmp	.+114    	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x3b0>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
    2a8c:	8c ed       	ldi	r24, 0xDC	; 220
    2a8e:	95 e0       	ldi	r25, 0x05	; 5
    2a90:	a0 e0       	ldi	r26, 0x00	; 0
    2a92:	b0 e0       	ldi	r27, 0x00	; 0
    2a94:	34 c0       	rjmp	.+104    	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x3b0>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2a96:	6d 85       	ldd	r22, Y+13	; 0x0d
    2a98:	7e 85       	ldd	r23, Y+14	; 0x0e
    2a9a:	fb 01       	movw	r30, r22
    2a9c:	ef 01       	movw	r28, r30
    2a9e:	09 90       	ld	r0, Y+
    2aa0:	00 20       	and	r0, r0
    2aa2:	e9 f7       	brne	.-6      	; 0x2a9e <RNDIS_Device_ProcessControlRequest+0x350>
    2aa4:	ce 1b       	sub	r28, r30
    2aa6:	df 0b       	sbc	r29, r31

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2aa8:	c7 01       	movw	r24, r14
    2aaa:	ae 01       	movw	r20, r28
    2aac:	6b d1       	rcall	.+726    	; 0x2d84 <memcpy>
    2aae:	f3 c0       	rjmp	.+486    	; 0x2c96 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
    2ab0:	80 ea       	ldi	r24, 0xA0	; 160
    2ab2:	96 e8       	ldi	r25, 0x86	; 134
    2ab4:	a1 e0       	ldi	r26, 0x01	; 1
    2ab6:	b0 e0       	ldi	r27, 0x00	; 0
    2ab8:	22 c0       	rjmp	.+68     	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x3b0>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    2aba:	d7 01       	movw	r26, r14
    2abc:	fe 01       	movw	r30, r28
    2abe:	3f 96       	adiw	r30, 0x0f	; 15
    2ac0:	86 e0       	ldi	r24, 0x06	; 6
    2ac2:	01 90       	ld	r0, Z+
    2ac4:	0d 92       	st	X+, r0
    2ac6:	81 50       	subi	r24, 0x01	; 1
    2ac8:	e1 f7       	brne	.-8      	; 0x2ac2 <RNDIS_Device_ProcessControlRequest+0x374>
    2aca:	c6 e0       	ldi	r28, 0x06	; 6
    2acc:	d0 e0       	ldi	r29, 0x00	; 0
    2ace:	e3 c0       	rjmp	.+454    	; 0x2c96 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
    2ad0:	81 e0       	ldi	r24, 0x01	; 1
    2ad2:	90 e0       	ldi	r25, 0x00	; 0
    2ad4:	a0 e0       	ldi	r26, 0x00	; 0
    2ad6:	b0 e0       	ldi	r27, 0x00	; 0
    2ad8:	12 c0       	rjmp	.+36     	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x3b0>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = RNDISInterfaceInfo->State.CurrPacketFilter;
    2ada:	c9 56       	subi	r28, 0x69	; 105
    2adc:	df 4f       	sbci	r29, 0xFF	; 255
    2ade:	88 81       	ld	r24, Y
    2ae0:	99 81       	ldd	r25, Y+1	; 0x01
    2ae2:	aa 81       	ldd	r26, Y+2	; 0x02
    2ae4:	bb 81       	ldd	r27, Y+3	; 0x03
    2ae6:	c7 59       	subi	r28, 0x97	; 151
    2ae8:	d0 40       	sbci	r29, 0x00	; 0
    2aea:	09 c0       	rjmp	.+18     	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x3b0>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
    2aec:	1d a6       	std	Y+45, r1	; 0x2d
    2aee:	1e a6       	std	Y+46, r1	; 0x2e
    2af0:	1f a6       	std	Y+47, r1	; 0x2f
    2af2:	18 aa       	std	Y+48, r1	; 0x30
    2af4:	08 c0       	rjmp	.+16     	; 0x2b06 <RNDIS_Device_ProcessControlRequest+0x3b8>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    2af6:	8c e5       	ldi	r24, 0x5C	; 92
    2af8:	96 e0       	ldi	r25, 0x06	; 6
    2afa:	a0 e0       	ldi	r26, 0x00	; 0
    2afc:	b0 e0       	ldi	r27, 0x00	; 0
    2afe:	8d a7       	std	Y+45, r24	; 0x2d
    2b00:	9e a7       	std	Y+46, r25	; 0x2e
    2b02:	af a7       	std	Y+47, r26	; 0x2f
    2b04:	b8 ab       	std	Y+48, r27	; 0x30
    2b06:	c4 e0       	ldi	r28, 0x04	; 4
    2b08:	d0 e0       	ldi	r29, 0x00	; 0
    2b0a:	c5 c0       	rjmp	.+394    	; 0x2c96 <RNDIS_Device_ProcessControlRequest+0x548>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    2b0c:	8b eb       	ldi	r24, 0xBB	; 187
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	a0 e0       	ldi	r26, 0x00	; 0
    2b12:	b0 ec       	ldi	r27, 0xC0	; 192
    2b14:	f8 01       	movw	r30, r16
    2b16:	84 87       	std	Z+12, r24	; 0x0c
    2b18:	95 87       	std	Z+13, r25	; 0x0d
    2b1a:	a6 87       	std	Z+14, r26	; 0x0e
    2b1c:	b7 87       	std	Z+15, r27	; 0x0f

				QUERY_Response->InformationBufferLength = 0;
    2b1e:	10 8a       	std	Z+16, r1	; 0x10
    2b20:	11 8a       	std	Z+17, r1	; 0x11
    2b22:	12 8a       	std	Z+18, r1	; 0x12
    2b24:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = 0;
    2b26:	14 8a       	std	Z+20, r1	; 0x14
    2b28:	15 8a       	std	Z+21, r1	; 0x15
    2b2a:	16 8a       	std	Z+22, r1	; 0x16
    2b2c:	17 8a       	std	Z+23, r1	; 0x17
    2b2e:	d3 c0       	rjmp	.+422    	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2b30:	cb 56       	subi	r28, 0x6B	; 107
    2b32:	df 4f       	sbci	r29, 0xFF	; 255
    2b34:	81 e0       	ldi	r24, 0x01	; 1
    2b36:	88 83       	st	Y, r24
    2b38:	c5 59       	subi	r28, 0x95	; 149
    2b3a:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
    2b3c:	f8 01       	movw	r30, r16
    2b3e:	24 85       	ldd	r18, Z+12	; 0x0c
    2b40:	35 85       	ldd	r19, Z+13	; 0x0d
    2b42:	46 85       	ldd	r20, Z+14	; 0x0e
    2b44:	57 85       	ldd	r21, Z+15	; 0x0f

			SET_Response->MessageType   = REMOTE_NDIS_SET_CMPLT;
    2b46:	85 e0       	ldi	r24, 0x05	; 5
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	a0 e0       	ldi	r26, 0x00	; 0
    2b4c:	b0 e8       	ldi	r27, 0x80	; 128
    2b4e:	8d 8b       	std	Y+21, r24	; 0x15
    2b50:	9e 8b       	std	Y+22, r25	; 0x16
    2b52:	af 8b       	std	Y+23, r26	; 0x17
    2b54:	b8 8f       	std	Y+24, r27	; 0x18
			SET_Response->MessageLength = sizeof(RNDIS_Set_Complete_t);
    2b56:	80 e1       	ldi	r24, 0x10	; 16
    2b58:	90 e0       	ldi	r25, 0x00	; 0
    2b5a:	a0 e0       	ldi	r26, 0x00	; 0
    2b5c:	b0 e0       	ldi	r27, 0x00	; 0
    2b5e:	84 83       	std	Z+4, r24	; 0x04
    2b60:	95 83       	std	Z+5, r25	; 0x05
    2b62:	a6 83       	std	Z+6, r26	; 0x06
    2b64:	b7 83       	std	Z+7, r27	; 0x07
			SET_Response->RequestId     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              SET_Message->InformationBufferOffset];
    2b66:	84 89       	ldd	r24, Z+20	; 0x14
    2b68:	95 89       	ldd	r25, Z+21	; 0x15
    2b6a:	a6 89       	ldd	r26, Z+22	; 0x16
    2b6c:	b7 89       	ldd	r27, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2b6e:	2e 30       	cpi	r18, 0x0E	; 14
    2b70:	f1 e0       	ldi	r31, 0x01	; 1
    2b72:	3f 07       	cpc	r19, r31
    2b74:	f1 e0       	ldi	r31, 0x01	; 1
    2b76:	4f 07       	cpc	r20, r31
    2b78:	f0 e0       	ldi	r31, 0x00	; 0
    2b7a:	5f 07       	cpc	r21, r31
    2b7c:	51 f0       	breq	.+20     	; 0x2b92 <RNDIS_Device_ProcessControlRequest+0x444>
    2b7e:	23 50       	subi	r18, 0x03	; 3
    2b80:	31 40       	sbci	r19, 0x01	; 1
    2b82:	41 40       	sbci	r20, 0x01	; 1
    2b84:	51 40       	sbci	r21, 0x01	; 1
    2b86:	a9 f0       	breq	.+42     	; 0x2bb2 <RNDIS_Device_ProcessControlRequest+0x464>
    2b88:	8b eb       	ldi	r24, 0xBB	; 187
    2b8a:	90 e0       	ldi	r25, 0x00	; 0
    2b8c:	a0 e0       	ldi	r26, 0x00	; 0
    2b8e:	b0 ec       	ldi	r27, 0xC0	; 192
    2b90:	14 c0       	rjmp	.+40     	; 0x2bba <RNDIS_Device_ProcessControlRequest+0x46c>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = *((uint32_t*)SetData);
    2b92:	fe 01       	movw	r30, r28
    2b94:	e8 0f       	add	r30, r24
    2b96:	f9 1f       	adc	r31, r25
    2b98:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b9a:	96 8d       	ldd	r25, Z+30	; 0x1e
    2b9c:	a7 8d       	ldd	r26, Z+31	; 0x1f
    2b9e:	b0 a1       	ldd	r27, Z+32	; 0x20
    2ba0:	c9 56       	subi	r28, 0x69	; 105
    2ba2:	df 4f       	sbci	r29, 0xFF	; 255
    2ba4:	88 83       	st	Y, r24
    2ba6:	99 83       	std	Y+1, r25	; 0x01
    2ba8:	aa 83       	std	Y+2, r26	; 0x02
    2baa:	bb 83       	std	Y+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState = ((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    2bac:	fe 01       	movw	r30, r28
    2bae:	82 e0       	ldi	r24, 0x02	; 2
    2bb0:	82 93       	st	-Z, r24
    2bb2:	80 e0       	ldi	r24, 0x00	; 0
    2bb4:	90 e0       	ldi	r25, 0x00	; 0
    2bb6:	a0 e0       	ldi	r26, 0x00	; 0
    2bb8:	b0 e0       	ldi	r27, 0x00	; 0
			SET_Response->RequestId     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              SET_Message->InformationBufferOffset];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    2bba:	f8 01       	movw	r30, r16
    2bbc:	84 87       	std	Z+12, r24	; 0x0c
    2bbe:	95 87       	std	Z+13, r25	; 0x0d
    2bc0:	a6 87       	std	Z+14, r26	; 0x0e
    2bc2:	b7 87       	std	Z+15, r27	; 0x0f
    2bc4:	88 c0       	rjmp	.+272    	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
			                                                   SET_Message->InformationBufferLength) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2bc6:	cb 56       	subi	r28, 0x6B	; 107
    2bc8:	df 4f       	sbci	r29, 0xFF	; 255
    2bca:	81 e0       	ldi	r24, 0x01	; 1
    2bcc:	88 83       	st	Y, r24
    2bce:	c5 59       	subi	r28, 0x95	; 149
    2bd0:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType     = REMOTE_NDIS_RESET_CMPLT;
    2bd2:	86 e0       	ldi	r24, 0x06	; 6
    2bd4:	90 e0       	ldi	r25, 0x00	; 0
    2bd6:	a0 e0       	ldi	r26, 0x00	; 0
    2bd8:	b0 e8       	ldi	r27, 0x80	; 128
    2bda:	8d 8b       	std	Y+21, r24	; 0x15
    2bdc:	9e 8b       	std	Y+22, r25	; 0x16
    2bde:	af 8b       	std	Y+23, r26	; 0x17
    2be0:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength   = sizeof(RNDIS_Reset_Complete_t);
    2be2:	80 e1       	ldi	r24, 0x10	; 16
    2be4:	90 e0       	ldi	r25, 0x00	; 0
    2be6:	a0 e0       	ldi	r26, 0x00	; 0
    2be8:	b0 e0       	ldi	r27, 0x00	; 0
    2bea:	f8 01       	movw	r30, r16
    2bec:	84 83       	std	Z+4, r24	; 0x04
    2bee:	95 83       	std	Z+5, r25	; 0x05
    2bf0:	a6 83       	std	Z+6, r26	; 0x06
    2bf2:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
    2bf4:	10 86       	std	Z+8, r1	; 0x08
    2bf6:	11 86       	std	Z+9, r1	; 0x09
    2bf8:	12 86       	std	Z+10, r1	; 0x0a
    2bfa:	13 86       	std	Z+11, r1	; 0x0b
    2bfc:	17 c0       	rjmp	.+46     	; 0x2c2c <RNDIS_Device_ProcessControlRequest+0x4de>
			RESET_Response->AddressingReset = 0;

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2bfe:	cb 56       	subi	r28, 0x6B	; 107
    2c00:	df 4f       	sbci	r29, 0xFF	; 255
    2c02:	81 e0       	ldi	r24, 0x01	; 1
    2c04:	88 83       	st	Y, r24
    2c06:	c5 59       	subi	r28, 0x95	; 149
    2c08:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType   = REMOTE_NDIS_KEEPALIVE_CMPLT;
    2c0a:	88 e0       	ldi	r24, 0x08	; 8
    2c0c:	90 e0       	ldi	r25, 0x00	; 0
    2c0e:	a0 e0       	ldi	r26, 0x00	; 0
    2c10:	b0 e8       	ldi	r27, 0x80	; 128
    2c12:	8d 8b       	std	Y+21, r24	; 0x15
    2c14:	9e 8b       	std	Y+22, r25	; 0x16
    2c16:	af 8b       	std	Y+23, r26	; 0x17
    2c18:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength = sizeof(RNDIS_KeepAlive_Complete_t);
    2c1a:	80 e1       	ldi	r24, 0x10	; 16
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	a0 e0       	ldi	r26, 0x00	; 0
    2c20:	b0 e0       	ldi	r27, 0x00	; 0
    2c22:	f8 01       	movw	r30, r16
    2c24:	84 83       	std	Z+4, r24	; 0x04
    2c26:	95 83       	std	Z+5, r25	; 0x05
    2c28:	a6 83       	std	Z+6, r26	; 0x06
    2c2a:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId     = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
    2c2c:	14 86       	std	Z+12, r1	; 0x0c
    2c2e:	15 86       	std	Z+13, r1	; 0x0d
    2c30:	16 86       	std	Z+14, r1	; 0x0e
    2c32:	17 86       	std	Z+15, r1	; 0x0f
    2c34:	50 c0       	rjmp	.+160    	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2c36:	80 91 11 14 	lds	r24, 0x1411
    2c3a:	81 3a       	cpi	r24, 0xA1	; 161
    2c3c:	09 f0       	breq	.+2      	; 0x2c40 <RNDIS_Device_ProcessControlRequest+0x4f2>
    2c3e:	4b c0       	rjmp	.+150    	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    2c40:	8e 01       	movw	r16, r28
    2c42:	0b 5e       	subi	r16, 0xEB	; 235
    2c44:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    2c46:	f8 01       	movw	r30, r16
    2c48:	84 81       	ldd	r24, Z+4	; 0x04
    2c4a:	95 81       	ldd	r25, Z+5	; 0x05
    2c4c:	a6 81       	ldd	r26, Z+6	; 0x06
    2c4e:	b7 81       	ldd	r27, Z+7	; 0x07
    2c50:	00 97       	sbiw	r24, 0x00	; 0
    2c52:	a1 05       	cpc	r26, r1
    2c54:	b1 05       	cpc	r27, r1
    2c56:	49 f4       	brne	.+18     	; 0x2c6a <RNDIS_Device_ProcessControlRequest+0x51c>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    2c58:	1d 8a       	std	Y+21, r1	; 0x15
					MessageHeader->MessageLength = 1;
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	a0 e0       	ldi	r26, 0x00	; 0
    2c60:	b0 e0       	ldi	r27, 0x00	; 0
    2c62:	84 83       	std	Z+4, r24	; 0x04
    2c64:	95 83       	std	Z+5, r25	; 0x05
    2c66:	a6 83       	std	Z+6, r26	; 0x06
    2c68:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2c6a:	80 91 e8 00 	lds	r24, 0x00E8
    2c6e:	87 7f       	andi	r24, 0xF7	; 247
    2c70:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, MessageHeader->MessageLength);
    2c74:	f8 01       	movw	r30, r16
    2c76:	64 81       	ldd	r22, Z+4	; 0x04
    2c78:	75 81       	ldd	r23, Z+5	; 0x05
    2c7a:	ce 01       	movw	r24, r28
    2c7c:	45 96       	adiw	r24, 0x15	; 21
    2c7e:	9e da       	rcall	.-2756   	; 0x21bc <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2c80:	80 91 e8 00 	lds	r24, 0x00E8
    2c84:	8b 77       	andi	r24, 0x7B	; 123
    2c86:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = 0;
    2c8a:	f8 01       	movw	r30, r16
    2c8c:	14 82       	std	Z+4, r1	; 0x04
    2c8e:	15 82       	std	Z+5, r1	; 0x05
    2c90:	16 82       	std	Z+6, r1	; 0x06
    2c92:	17 82       	std	Z+7, r1	; 0x07
    2c94:	20 c0       	rjmp	.+64     	; 0x2cd6 <RNDIS_Device_ProcessControlRequest+0x588>
			QUERY_Response->MessageLength = sizeof(RNDIS_Query_Complete_t);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
    2c96:	f8 01       	movw	r30, r16
    2c98:	14 86       	std	Z+12, r1	; 0x0c
    2c9a:	15 86       	std	Z+13, r1	; 0x0d
    2c9c:	16 86       	std	Z+14, r1	; 0x0e
    2c9e:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength          += ResponseSize;
    2ca0:	ce 01       	movw	r24, r28
    2ca2:	a0 e0       	ldi	r26, 0x00	; 0
    2ca4:	b0 e0       	ldi	r27, 0x00	; 0
    2ca6:	24 81       	ldd	r18, Z+4	; 0x04
    2ca8:	35 81       	ldd	r19, Z+5	; 0x05
    2caa:	46 81       	ldd	r20, Z+6	; 0x06
    2cac:	57 81       	ldd	r21, Z+7	; 0x07
    2cae:	28 0f       	add	r18, r24
    2cb0:	39 1f       	adc	r19, r25
    2cb2:	4a 1f       	adc	r20, r26
    2cb4:	5b 1f       	adc	r21, r27
    2cb6:	24 83       	std	Z+4, r18	; 0x04
    2cb8:	35 83       	std	Z+5, r19	; 0x05
    2cba:	46 83       	std	Z+6, r20	; 0x06
    2cbc:	57 83       	std	Z+7, r21	; 0x07

				QUERY_Response->InformationBufferLength = ResponseSize;
    2cbe:	80 8b       	std	Z+16, r24	; 0x10
    2cc0:	91 8b       	std	Z+17, r25	; 0x11
    2cc2:	a2 8b       	std	Z+18, r26	; 0x12
    2cc4:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    2cc6:	80 e1       	ldi	r24, 0x10	; 16
    2cc8:	90 e0       	ldi	r25, 0x00	; 0
    2cca:	a0 e0       	ldi	r26, 0x00	; 0
    2ccc:	b0 e0       	ldi	r27, 0x00	; 0
    2cce:	84 8b       	std	Z+20, r24	; 0x14
    2cd0:	95 8b       	std	Z+21, r25	; 0x15
    2cd2:	a6 8b       	std	Z+22, r26	; 0x16
    2cd4:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = 0;
			}

			break;
	}
}
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	1f 91       	pop	r17
    2cdc:	0f 91       	pop	r16
    2cde:	ff 90       	pop	r15
    2ce0:	ef 90       	pop	r14
    2ce2:	08 95       	ret

00002ce4 <SerialStream_TxByte>:

FILE USARTStream = FDEV_SETUP_STREAM(SerialStream_TxByte, SerialStream_RxByte, _FDEV_SETUP_RW);

static int SerialStream_TxByte(char DataByte,
                               FILE *Stream)
{
    2ce4:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_TxByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_TxByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2ce6:	80 91 c8 00 	lds	r24, 0x00C8
    2cea:	85 ff       	sbrs	r24, 5
    2cec:	fc cf       	rjmp	.-8      	; 0x2ce6 <SerialStream_TxByte+0x2>
				UDR1 = DataByte;
    2cee:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_TxByte(DataByte);
	return 0;
}
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
    2cf4:	90 e0       	ldi	r25, 0x00	; 0
    2cf6:	08 95       	ret

00002cf8 <SerialStream_RxByte>:
			 *  \return Boolean true if a character has been received, false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2cf8:	80 91 c8 00 	lds	r24, 0x00C8

static int SerialStream_RxByte(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2cfc:	87 fd       	sbrc	r24, 7
    2cfe:	03 c0       	rjmp	.+6      	; 0x2d06 <SerialStream_RxByte+0xe>
    2d00:	2e ef       	ldi	r18, 0xFE	; 254
    2d02:	3f ef       	ldi	r19, 0xFF	; 255
    2d04:	08 c0       	rjmp	.+16     	; 0x2d16 <SerialStream_RxByte+0x1e>
			 *  \return Byte received from the USART.
			 */
			static inline char Serial_RxByte(void) ATTR_ALWAYS_INLINE;
			static inline char Serial_RxByte(void)
			{
				while (!(UCSR1A & (1 << RXC1)));
    2d06:	80 91 c8 00 	lds	r24, 0x00C8
    2d0a:	87 ff       	sbrs	r24, 7
    2d0c:	fc cf       	rjmp	.-8      	; 0x2d06 <SerialStream_RxByte+0xe>
				return UDR1;
    2d0e:	80 91 ce 00 	lds	r24, 0x00CE
	  return _FDEV_EOF;

	return Serial_RxByte();
    2d12:	28 2f       	mov	r18, r24
    2d14:	30 e0       	ldi	r19, 0x00	; 0
}
    2d16:	c9 01       	movw	r24, r18
    2d18:	08 95       	ret

00002d1a <memcpy_P>:
    2d1a:	fb 01       	movw	r30, r22
    2d1c:	dc 01       	movw	r26, r24
    2d1e:	02 c0       	rjmp	.+4      	; 0x2d24 <memcpy_P+0xa>
    2d20:	05 90       	lpm	r0, Z+
    2d22:	0d 92       	st	X+, r0
    2d24:	41 50       	subi	r20, 0x01	; 1
    2d26:	50 40       	sbci	r21, 0x00	; 0
    2d28:	d8 f7       	brcc	.-10     	; 0x2d20 <memcpy_P+0x6>
    2d2a:	08 95       	ret

00002d2c <strcpy_P>:
    2d2c:	fb 01       	movw	r30, r22
    2d2e:	dc 01       	movw	r26, r24
    2d30:	05 90       	lpm	r0, Z+
    2d32:	0d 92       	st	X+, r0
    2d34:	00 20       	and	r0, r0
    2d36:	e1 f7       	brne	.-8      	; 0x2d30 <strcpy_P+0x4>
    2d38:	08 95       	ret

00002d3a <strlen_P>:
    2d3a:	fc 01       	movw	r30, r24
    2d3c:	05 90       	lpm	r0, Z+
    2d3e:	00 20       	and	r0, r0
    2d40:	e9 f7       	brne	.-6      	; 0x2d3c <strlen_P+0x2>
    2d42:	80 95       	com	r24
    2d44:	90 95       	com	r25
    2d46:	8e 0f       	add	r24, r30
    2d48:	9f 1f       	adc	r25, r31
    2d4a:	08 95       	ret

00002d4c <strncpy_P>:
    2d4c:	fb 01       	movw	r30, r22
    2d4e:	dc 01       	movw	r26, r24
    2d50:	41 50       	subi	r20, 0x01	; 1
    2d52:	50 40       	sbci	r21, 0x00	; 0
    2d54:	48 f0       	brcs	.+18     	; 0x2d68 <strncpy_P+0x1c>
    2d56:	05 90       	lpm	r0, Z+
    2d58:	0d 92       	st	X+, r0
    2d5a:	00 20       	and	r0, r0
    2d5c:	c9 f7       	brne	.-14     	; 0x2d50 <strncpy_P+0x4>
    2d5e:	01 c0       	rjmp	.+2      	; 0x2d62 <strncpy_P+0x16>
    2d60:	1d 92       	st	X+, r1
    2d62:	41 50       	subi	r20, 0x01	; 1
    2d64:	50 40       	sbci	r21, 0x00	; 0
    2d66:	e0 f7       	brcc	.-8      	; 0x2d60 <strncpy_P+0x14>
    2d68:	08 95       	ret

00002d6a <memcmp>:
    2d6a:	fb 01       	movw	r30, r22
    2d6c:	dc 01       	movw	r26, r24
    2d6e:	04 c0       	rjmp	.+8      	; 0x2d78 <memcmp+0xe>
    2d70:	8d 91       	ld	r24, X+
    2d72:	01 90       	ld	r0, Z+
    2d74:	80 19       	sub	r24, r0
    2d76:	21 f4       	brne	.+8      	; 0x2d80 <memcmp+0x16>
    2d78:	41 50       	subi	r20, 0x01	; 1
    2d7a:	50 40       	sbci	r21, 0x00	; 0
    2d7c:	c8 f7       	brcc	.-14     	; 0x2d70 <memcmp+0x6>
    2d7e:	88 1b       	sub	r24, r24
    2d80:	99 0b       	sbc	r25, r25
    2d82:	08 95       	ret

00002d84 <memcpy>:
    2d84:	fb 01       	movw	r30, r22
    2d86:	dc 01       	movw	r26, r24
    2d88:	02 c0       	rjmp	.+4      	; 0x2d8e <memcpy+0xa>
    2d8a:	01 90       	ld	r0, Z+
    2d8c:	0d 92       	st	X+, r0
    2d8e:	41 50       	subi	r20, 0x01	; 1
    2d90:	50 40       	sbci	r21, 0x00	; 0
    2d92:	d8 f7       	brcc	.-10     	; 0x2d8a <memcpy+0x6>
    2d94:	08 95       	ret

00002d96 <memmove>:
    2d96:	68 17       	cp	r22, r24
    2d98:	79 07       	cpc	r23, r25
    2d9a:	68 f4       	brcc	.+26     	; 0x2db6 <memmove+0x20>
    2d9c:	fb 01       	movw	r30, r22
    2d9e:	dc 01       	movw	r26, r24
    2da0:	e4 0f       	add	r30, r20
    2da2:	f5 1f       	adc	r31, r21
    2da4:	a4 0f       	add	r26, r20
    2da6:	b5 1f       	adc	r27, r21
    2da8:	02 c0       	rjmp	.+4      	; 0x2dae <memmove+0x18>
    2daa:	02 90       	ld	r0, -Z
    2dac:	0e 92       	st	-X, r0
    2dae:	41 50       	subi	r20, 0x01	; 1
    2db0:	50 40       	sbci	r21, 0x00	; 0
    2db2:	d8 f7       	brcc	.-10     	; 0x2daa <memmove+0x14>
    2db4:	08 95       	ret
    2db6:	e6 cf       	rjmp	.-52     	; 0x2d84 <memcpy>

00002db8 <strncmp>:
    2db8:	fb 01       	movw	r30, r22
    2dba:	dc 01       	movw	r26, r24
    2dbc:	41 50       	subi	r20, 0x01	; 1
    2dbe:	50 40       	sbci	r21, 0x00	; 0
    2dc0:	30 f0       	brcs	.+12     	; 0x2dce <strncmp+0x16>
    2dc2:	8d 91       	ld	r24, X+
    2dc4:	01 90       	ld	r0, Z+
    2dc6:	80 19       	sub	r24, r0
    2dc8:	19 f4       	brne	.+6      	; 0x2dd0 <strncmp+0x18>
    2dca:	00 20       	and	r0, r0
    2dcc:	b9 f7       	brne	.-18     	; 0x2dbc <strncmp+0x4>
    2dce:	88 1b       	sub	r24, r24
    2dd0:	99 0b       	sbc	r25, r25
    2dd2:	08 95       	ret

00002dd4 <_exit>:
    2dd4:	f8 94       	cli

00002dd6 <__stop_program>:
    2dd6:	ff cf       	rjmp	.-2      	; 0x2dd6 <__stop_program>
